{"version":3,"mappings":"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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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","names":["l","n","p","f","a","b","c","d","e","g","h","k","w","m","C","x","exports","q","r","t","u","v","y","z","A","B","D","E","F","G","H","I","J","K","M","N","O","P","Q","R","S","T","U","module","require$$0","aa","ca","require$$1","La","Na","Oa","Ma","Pa","yf","Af","zf","Bf","Cf","Df","Ef","Ff","Gf","Hf","Jf","If","Kf","bd","Lf","Mf","Nf","Of","Pf","uf","of","Qf","Rf","Wc","Cb","ue","Db","Sf","Tf","Uf","Vf","Wf","Xf","Yf","Zf","$f","ag","bg","Ra","cg","dg","eg","fg","gg","hg","ig","jg","ac","fc","kg","lg","mg","ng","og","pg","qg","rg","sg","tg","ug","oc","vg","wg","xg","yg","zg","Ag","Bg","Cg","Dg","Eg","Fg","Gg","Hg","Ig","Jg","Kg","ua","Lg","Mg","Ng","Og","Pg","Qg","Rg","Sg","Tg","Ug","Vg","Wg","Xg","Yg","Zg","$g","ah","bh","ch","dh","eh","Cc","fh","gh","hh","ih","jh","kh","nh","Vb","L","lh","mh","oh","Ie","ph","qh","rh","sh","th","uh","vh","wh","xh","ya","Ha","yh","zh","Ah","va","wa","eb","Ka","Bh","Ch","Dh","Eh","Fh","Gh","Hh","Ih","lb","Jh","Kh","Lh","Mh","Nh","Oh","Ph","Qh","Rh","Sh","Th","Uh","Vh","Wh","He","Xh","Yh","Zh","$h","ai","bi","ci","di","ei","fi","gi","hi","ii","ji","ki","li","mi","ni","oi","pi","qi","ri","si","ti","ui","vi","wi","xi","yi","zi","Ai","Bi","Ci","Di","yc","Ei","Fi","Gi","Hi","Ii","Ji","Ki","Li","Mi","Ni","Oi","Pi","Qi","Ri","Si","Ti","Ui","Vi","Wi","Xi","Yi","Zi","$i","aj","bj","cj","dj","ej","fj","gj","hj","ij","jj","kj","lj","mj","nj","oj","pj","listener","Listener","callback","callbackThis","stack","hasBuffer","regex","strings.createRegExp","LineFeedCounter","text","searcher","searchStart","character","__awaiter","this","thisArg","_arguments","generator","lineWithoutLF","lineLength","line","embeddedLanguageData","lineState","pos","groupMatching","forceEvaluation","pos0","stackLen0","groupLen0","state","matches","matched","action","rule","enteringEmbeddedLanguage","groupEntry","rules","monarchCommon.findRules","monarchCommon.createError","restOfLine","monarchCommon.isFuzzyAction","monarchCommon.isIAction","result","monarchCommon.substituteMatches","nextState","monarchCommon.log","computeNewStateForEmbeddedLanguage","languageId","hasEOL","MonarchLineStateFactory","offsetDelta","tokensCollector","totalLen","i","tokenType","monarchCommon.isString","rest","bracket","findBracket","monarchCommon.sanitize","token","lineWithoutLFLength","EmbeddedLanguageData","NullState","languages.TokenizationRegistry","tokenizationSupport","MonarchTokenizer","__decorate","__param","IConfigurationService","lexer","monarchCommon.fixCase","brackets","adopt","value","resolve","reject","fulfilled","step","rejected","_a","ttPolicy","Colorizer","themeService","languageService","domNode","options","theme","mimeType","render","str","trustedhtml","err","languageIdCodec","tabSize","strings.startsWithUTF8BOM","lines","strings.splitLines","_fakeColorize","TokenizationRegistry","_colorize","mightContainNonBasicASCII","mightContainRTL","tokens","isBasicASCII","ViewLineRenderingData","containsRTL","renderViewLine","RenderLineInput","model","lineNumber","content","inflatedTokens","execute","_actualColorize","status","html","length","lineTokens","LineTokens","renderResult","tokenizeResult","BrowserFeatures","platform.isNative","browser.isStandalone","browser.isSafari","createKeybinding","keybinding","OS","firstPart","chordPart","ChordKeybinding","createSimpleKeybinding","ctrlCmd","winCtrl","ctrlKey","shiftKey","altKey","metaKey","keyCode","SimpleKeybinding","other","parts","illegalArgument","ResolvedKeybindingPart","kbLabel","kbAriaLabel","ResolvedKeybinding","extractKeyCode","char","KeyCodeUtils","browser.isFirefox","platform.isMacintosh","browser.isWebKit","EVENT_KEY_CODE_MAP","ctrlKeyMod","altKeyMod","shiftKeyMod","metaKeyMod","StandardKeyboardEvent","source","key","hasDifferentOriginAncestorFlag","sameOriginWindowChainCache","getParentWindowIfSameOrigin","location","parentLocation","IframeUtils","parent","childWindow","ancestorWindow","top","left","windowChain","windowChainEl","boundingRect","StandardMouseEvent","iframeOffsets","StandardWheelEvent","deltaX","deltaY","e1","e2","ev","platform.isWindows","_toConsumableArray","arr","arr2","hasOwnProperty","setPrototypeOf","isFrozen","getPrototypeOf","getOwnPropertyDescriptor","freeze","seal","create","_ref","apply","construct","fun","thisValue","args","Func","colorRegistry","ColorRegistry","platform.Registry","Extensions","migrateColorDefaults","o","registerColor","id","defaults","description","needsTransparency","deprecationMessage","foreground","nls.localize","errorForeground","transparent","iconForeground","focusBorder","contrastBorder","activeContrastBorder","Color","textLinkForeground","textLinkActiveForeground","camelToDashes","prop","cssValue","position","CursorColumns","lastLineFeedIndex","dataToCopy","storedMetadata","ClipboardEventUtils","clipboardData","Mimes","metadata","TextAreaWrapper","Disposable","_actual","dom.createEventEmitter","lineTextBeforeSelection","textBeforeSelection","lineFeedOffset1","tabOffset1","desiredVisibleBeforeCharCount","startModelPosition","modelSelection","visibleBeforeCharCount","distanceToModelLineStart","hiddenLineTextBefore","widthOfHiddenTextBefore","measureText","lineTextAfterSelection","lineFeedOffset2","textAfterSelection","tabOffset2","desiredVisibleAfterCharCount","startIndex","canUseZeroSizeTextarea","renderData","ta","tac","applyFontInfo","Margin","LineNumbersOverlay","fontInfo","container","regularDomNode","res","_normalizeIndentationFromWhitespace","indentSize","insertSpaces","spacesCnt","tabsCnt","normalizeIndentation","firstNonWhitespaceIndex","strings.firstNonWhitespaceIndex","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","chr","CursorConfiguration","modelOptions","configuration","languageConfigurationService","layoutInfo","surroundingPairs","pair","electricChars","context","column","scopedLineTokens","createScopedLineTokens","electricCharacterSupport","autoCloseConfig","autoCloseBeforeSet","visibleColumn","minColumn","maxColumn","CursorState","modelState","viewState","PartialModelCursorState","PartialViewCursorState","selection","Selection","SingleCursorState","Range","modelSelections","states","len","selectionStart","selectionStartLeftoverVisibleColumns","leftoverVisibleColumns","inSelectionMode","Position","EditOperationResult","type","commands","opts","isQuote","ColumnSelection","config","fromLineNumber","fromVisibleColumn","toLineNumber","toVisibleColumn","lineCount","reversed","isRTL","isLTR","startColumn","endColumn","visibleStartColumn","visibleEndColumn","prevColumnSelectData","toViewVisualColumn","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","isPaged","linesCount","toViewLineNumber","isCursorMoveArgs","pasteOnNewLine","typeSelection","keepPosition","increasedIndent","normalIndent","actualIndentation","ir","offset","oldEndColumn","selections","TypeOperations","isDoingComposition","autoIndentFails","autoClosedCharacters","prevEditOperationType","autoClosingPairClose","ReplaceCommand","opType","getTypingOperation","shouldPushStackElementBetween","ReplaceCommandWithoutChangingPosition","TypeWithAutoClosingCommand","ReplaceCommandWithOffsetCursorState","openCharacter","insertOpenCharacter","closeCharacter","helper","range","CompositionOutcome","deletedText","deletedSelectionStart","deletedSelectionEnd","insertedText","insertedSelectionStart","insertedSelectionEnd","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","EditorContextKeys","RawContextKey","CORE_WEIGHT","CoreEditorCommand","EditorCommand","accessor","editor","viewModel","EditorScroll_","isEditorScrollArgs","arg","types.isObject","scrollArg","types.isString","types.isUndefined","types.isNumber","types.isBoolean","parse","direction","unit","revealCursor","RevealLine_","isRevealLineArgs","reveaLineArg","EditorOrNativeTextInputCommand","target","focusedEditor","ICodeEditorService","activeElement","activeEditor","CoreNavigationCommands","BaseMoveToCommand","CursorMoveCommands","registerEditorCommand","ColumnSelectCommand","primary","validatedPosition","validatedViewPosition","fromViewLineNumber","fromViewVisualColumn","ColumnSelectUpCommand","ColumnSelectDownCommand","CursorMoveImpl","CursorMove_","parsed","cursors","CursorMoveBasedCommand","dynamicArgs","newState","newModelPosition","newViewPosition","lastAddedCursorIndex","newStates","HomeCommand","LineStartCommand","cursor","EndCommand","LineEndCommand","TopCommand","BottomCommand","EditorScrollImpl","desiredScrollTop","desiredVisibleViewRange","visibleViewRange","visibleModelRange","desiredTopModelLineNumber","viewPosition","noOfLines","deltaLines","scrollbarShadowColor","scrollbarSliderBackgroundColor","scrollbarSliderBackground","collector","scrollbarSliderHoverBackgroundColor","scrollbarSliderActiveBackgroundColor","scrollbarSliderActiveBackground","DecorationToRender","startLineNumber","endLineNumber","className","DedupOverlay","DynamicViewOverlay","visibleStartLineNumber","visibleEndLineNumber","decorations","output","lineIndex","edit","closeChar","autoClosingPairsCandidates","openChar","closeCharIndex","openCharIndex","indices","eventsCollector","edits","cursorStateComputer","autoClosingIndices","autoClosedCharactersRanges","autoClosedEnclosingRanges","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","match","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","Token","toLength","SmallImmutableSet","TextAstNode","smallTextTokens1Line","regexp","curOffset","colCount","isEditStackElement","element","SingleModelEditStackElement","MultiModelEditStackElement","EditStack","undoRedoService","lastElement","beforeCursorState","newElement","eol","editStackElement","getModelEOL","editOperations","inverseEditOperations","afterCursorState","textChanges","op","index","SpacesDiffResult","spacesDiff","aLength","bLength","aCharCode","bCharCode","aSpacesCnt","aTabsCount","j","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineText","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","MAX_ALLOWED_TAB_SIZE_GUESS","spacesDiffCount","tmp","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","lenJ","charCode","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","node","setNodeColor","color","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeStickiness","_setNodeStickiness","stickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","start","end","versionId","absoluteStart","absoluteEnd","cachedVersionId","SENTINEL","IntervalTree","filterOwnerId","filterOutValidation","intervalSearch","search","ownerId","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","rbTreeDelete","initialNode","delta","nodeStart","nodeEnd","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","noOverlapReplace","nodeAcceptEdit","normalizeDelta","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","deltaColumn","nodeMaxEnd","resultLen","editDelta","include","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","leftRotate","rightRotate","zAbsoluteStart","zAbsoluteEnd","intervalCompare","leftest","resetSentinel","yWasRed","computeMaxEnd","maxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","TreeNode","piece","righttest","calculateSize","calculateLF","tree","rbDelete","recomputeTreeMetadata","newSizeLeft","newLFLeft","lf_delta","updateTreeMetadata","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","LineStarts","lineStarts","cr","lf","crlf","createLineStartsFast","readonly","rLength","createLineStarts","Piece","bufferIndex","lineFeedCnt","StringBuffer","buffer","PieceTreeSnapshot","BOM","PieceTreeSearchCache","limit","nodePos","nodePosition","hasInvalidVal","newArr","entry","PieceTreeBase","chunks","eolNormalized","lastNode","averageBufferSize","min","max","tempChunk","tempChunkLen","newEOL","leftLen","lfCnt","originalOffset","out","lineStartOffset","startPosition","endPosition","startOffset","ret","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","matchingNode","targetOffset","startCursor","endCursor","searchData","captureMatches","limitResultCount","startOffsetInBuffer","searchText","offsetInBuffer","retStartColumn","retEndColumn","createFindMatch","searchRange","Searcher","currentNode","lineBreakCnt","nextLineStartOffset","deltaOffset","wordSeparators","searchString","searchStringLen","lastMatchIndex","isValidMatch","FindMatch","insertPosInBuffer","remainder","nodeStartOffset","nodesToDel","newRightPiece","newStart","previousPos","newPieces","tmpNode","pieces","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","next","secondNode","prev","nPiece","low","high","mid","midStop","midStart","endOffset","previousCharOffset","nodes","lastChar","splitText","endIndex","endPos","newPiece","cache","prevAccumulatedValue","accumulatedValue","originalLineNumber","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","size_delta","newLength","originalStartOffset","newStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","nextNode","leftRet","prevNode","PieceTreeTextBuffer","containsUnusualLineTerminators","Emitter","preserveBOM","lineEnding","lineContent","fromOffset","toOffset","strings.isHighSurrogate","strings.lastNonWhitespaceIndex","validText","bufferEOL","operations","validatedRange","eolCount","firstLineLength","lastLineLength","hasTouchingRanges","count","rangeEnd","nextRangeStart","canReduceOperations","reverseRanges","computeUndoEdits","recordTrimAutoWhitespace","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","TextChange","mightContainUnusualLineTerminators","contentChanges","trimAutoWhitespaceLineNumbers","prevContent","ApplyEditsResult","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","countEOL","contentChangeRange","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","defaultEOL","totalEOLCount","totalCRCount","oldFullModelRange","SearchParams","isRegex","matchCase","editRange","eolPreference","iconRegistry","IconRegistry","registerIcon","getIconRegistry","initialize","icon","Codicon","iconsSchemaId","schemaRegistry","JSONExtensions","delayer","RunOnceScheduler","widgetClose","localize","ThemeIcon","decorators","desc","paramIndex","decorator","DIFF_LINES_PADDING","DiffEntry","originalLineStart","originalLineEnd","modifiedLineStart","modifiedLineEnd","Diff","entries","diffReviewInsertIcon","diffReviewRemoveIcon","diffReviewCloseIcon","DiffReview","diffEditor","_languageService","createFastDomNode","ActionBar","Action","DomScrollableElement","dom.addStandardDisposableListener","row","dom.findParentWithClass","currentIndex","jumpToLineNumber","current","width","height","lineChanges","originalModel","modifiedModel","originalLineCount","modifiedLineCount","diffs","diffsLength","lineChange","originalStart","originalEnd","modifiedStart","modifiedEnd","originalEqualAbove","modifiedEqualAbove","minOriginal","minModified","prevLineChange","fromOriginal","fromModified","originalEqualBelow","modifiedEqualBelow","maxOriginal","maxModified","nextLineChange","toOriginal","toModified","actions","copyLineAction","diff","lineFeed","showContextMenu","isDeletion","currentLineNumberOffset","dom.getDomNodePagePosition","pad","lineHeight","_visibility","marginDomNode","lineNumberOffset","newTop","acc","IClipboardService","createDecorator","IProgressService","Progress","item","IEditorProgressService","VisualEditorState","_contextMenuService","_clipboardService","diffDiagonalFillColor","diffDiagonalFill","group","UndoRedoGroup","UndoRedoSource","resourceLabel","getResourceLabel","strResource","ResourceStackElement","formatRule","isForShadowDom","style","computeStyles","styleMap","styles","newDefaultEOL","trimAutoWhitespace","EDITOR_MODEL_DEFAULTS","total","highlight","highlights","newStyles","QuickInputController","CombinedSpliceable","spliceables","deleteCount","elements","ListError","user","message","groupIntersect","groups","intersection","shift","much","consolidate","previousGroup","size","concat","RangeMap","items","before","after","middle","newSize","groupCount","newCount","removeFromParent","RowCache","renderers","templateId","$","templateData","cachedRows","cachedRow","renderer","DefaultOptions","ElementsDragAndDropData","ExternalElementsDragAndDropData","NativeDragAndDropData","dataTransfer","file","equalsDragFeedback","f1","f2","equals","ListViewAccessibilityProvider","accessibilityProvider","_","ListView","virtualDelegate","_b","_c","_d","_e","_f","_g","_h","_j","_k","Delayer","DisposableStore","Gesture","Scrollable","cb","scheduleAtNextAnimationFrame","SmoothScrollableElement","addDisposableListener","TouchEventType","getContentWidth","previousRenderRange","deleteRange","removeRange","rowsToDispose","rows","previousRestRange","previousRenderedRestRange","previousUnrenderedRestRanges","inserted","deleted","renderRange","renderedRestRange","updateRange","removeRanges","unrenderedRestRanges","insertRanges","beforeElement","scrollWidth","scrollDimensions","getContentHeight","renderTop","renderHeight","renderLeft","updateItemsInDOM","rangesToInsert","rangesToRemove","rangesToUpdate","role","checked","update","uri","event","isFirefox","scrollTop","reuseAnimation","Event","DomEmitter","browserEvent","DataTransfers","label","dragImage","StaticDND","feedback","distinct","toDisposable","disposableTimeout","dragData","viewTop","getTopLeftOffset","animate","upperLimit","scrollableElement","rawIndex","inSmoothScrolling","anchorElementIndex","anchorElementTopDelta","heightDiff","didChange","unrenderRanges","renderRanges","afterIndex","beforeRow","deltaScrollTop","newScrollTop","ranges","lastRange","nextToLastItem","dispose","memoize","TraitRenderer","trait","renderedElementIndex","el","rendered","insertCount","renderedElement","indexes","Trait","_trait","sortedIndexes","hasTrait","first","numericSort","sortedResult","toRender","disjunction","binarySearch","SelectionTrait","setAriaSelected","TraitSpliceable","view","identityProvider","pastElementsWithTrait","elementsWithTrait","isInputElement","isMonacoEditor","isButton","KeyboardController","list","optionsUpdate","TypeNavigationMode","TypeNavigationControllerState","DefaultKeyboardNavigationDelegate","TypeNavigationController","keyboardNavigationLabelProvider","keyboardNavigationEventFilter","delegate","suffix","defaultStyles","Table","defaultOpts","Toggle","Widget","classes","CSSIcon","keyboardEvent","newIsChecked","NLS_CASE_SENSITIVE_TOGGLE_LABEL","NLS_WHOLE_WORD_TOGGLE_LABEL","NLS_REGEX_TOGGLE_LABEL","CaseSensitiveToggle","WholeWordsToggle","RegexToggle","NLS_DEFAULT_LABEL","FindInput","contextViewProvider","_showOptionButtons","appendCaseSensitiveLabel","appendWholeWordsLabel","appendRegexLabel","history","flexibleHeight","flexibleWidth","flexibleMaxHeight","HistoryInputBox","viaKeyboard","newIndex","dom.EventHelper","toggle","dom.addDisposableListener","enabled","toggleStyles","inputBoxStyles","TreeMouseEventTarget","TreeError","WeakMapper","fn","isFilterResult","obj","getVisibleState","visibility","isCollapsibleStateUpdate","IndexTreeModel","rootElement","EventBufferer","MicrotaskDelay","toInsert","Iterable","identity","toInsertIterable","recurseLevels","parentNode","LcsDiff","locationPrefix","recurseSplice","lastStartO","lastStartM","change","treeListElementsToInsert","nodesToInsertIterator","revealed","onDidCreateNode","lastIndex","lastHadChildren","visibleChildStartIndex","child","nodesToInsert","insertedVisibleChildrenCount","renderNodeCount","deletedNodes","splice","diffIdentityProvider","deletedVisibleChildrenCount","visible","visibleDeleteCount","listIndex","onDidDeleteNode","visit","currentlyHasChildren","collapsible","collapsed","recursive","onlyVisibleChildIndex","previousRenderNodeCount","deep","treeElement","parentVisibility","treeListElements","childElements","childRevealed","childNodes","visibleChildrenCount","resultStartLength","hasVisibleDescendants","visibleChildIndex","indexTreeNode","tail2","SetMap","values","TreeElementsDragAndDropData","data","asTreeDragAndDropData","TreeNodeListDragAndDrop","modelProvider","dnd","originalEvent","targetNode","targetIndex","raw","didChangeAutoExpandNode","ref","accept","effect","parentRef","parentIndex","asListOptions","ComposedTreeDelegate","RenderIndentGuides","EventCollection","onDidChange","_elements","TreeRenderer","onDidChangeCollapseState","activeNodes","clamp","shouldRenderIndentGuides","disposables","append","indent","twistie","contents","twistieRendered","vs","UnthemedProductIconTheme","contribution","definition","VS_LIGHT_THEME_NAME","VS_DARK_THEME_NAME","HC_BLACK_THEME_NAME","HC_LIGHT_THEME_NAME","Registry","themingRegistry","ThemingExtensions","StandaloneTheme","name","standaloneThemeData","base","isBuiltinTheme","colors","baseData","getBuiltinRules","colorId","useDefault","ColorScheme","encodedTokensColors","editorForeground","editorBackground","TokenTheme","modifiers","modelLanguage","TokenMetadata","fontStyle","themeName","builtinTheme","vs_dark","hc_black","hc_light","newBuiltInTheme","themeData","StandaloneThemeService","iconsStyleSheet","getIconsStyleSheet","addMatchMediaChangeListener","dom.isInShadowDOM","dom.createStyleSheet","styleElement","colorMapOverride","desiredTheme","wantsHighContrast","isHighContrast","newThemeName","isDark","autoDetectHighContrast","cssRules","hasRule","ruleCollector","colorVariables","asCssVariableName","colorMap","generateTokensCSSForColorMap","IStandaloneThemeService","seen","outgoing","CyclicDependencyError","graph","printChild","dur","Trace","causedCreation","DoubleResourceMap","ResourceMap","resource","owner","ownerMap","confirmation","StandaloneResourcePropertiesService","StandaloneTelemetryService","eventName","StandaloneWorkspaceContextService","URI","WorkspaceFolder","updateConfigurationService","configurationService","isDiffEditor","StandaloneConfigurationService","toUpdate","isEditorConfigurationKey","isDiffEditorConfigurationKey","StandaloneBulkEditService","_modelService","firstLine","firstLF","doCreateModel","modelService","languageSelection","domElement","override","StandaloneServices","StandaloneEditor","onDidCreateEditor","onDidCreateDiffEditor","getEditors","getDiffEditors","createDiffEditor","StandaloneDiffEditor","createDiffNavigator","DiffNavigator","createModel","language","ILanguageService","createTextModel","IModelService","setModelLanguage","setModelMarkers","markers","IMarkerService","removeAllMarkers","getModelMarkers","filter","register","ModesRegistry","getLanguages","getEncodedLanguageId","onLanguage","disposable","encounteredLanguageId","__defProp","__getOwnPropDesc","__getOwnPropNames","__hasOwnProp","__copyProps","to","from","except","editorLightBulbForegroundColor","editorLightBulbAutoFixForegroundColor","editorLightBulbAutoFixForeground","editorBackgroundColor","__classPrivateFieldSet","receiver","kind","__classPrivateFieldGet","_CodeActionUi_disposed","CodeActionUi","_editor","quickFixActionId","preferredFixActionId","instantiationService","MutableDisposable","Lazy","CodeActionMenu","trigger","widget","LightBulbWidget","codeLensHeight","fontSize","fontFeaturesVar","fontFamily","newStyle","title","UILabelProvider","matchIndentInNode","Tokenizer","nextLine","src","itemContents","endEarly","rawLine","blankLine","lineBreaks","cap","block","lastToken","errMsg","_proto","_this2","cutSrc","maskedSrc","keepPrevChar","prevChar","links","repeatString","extTokenizer","mangle","tempSrc","tempStart","getStartIndex","smartypants","_createClass","Lexer","inline","Renderer","_code","infostring","escaped","lang","escape","quote","_html","level","slugger","body","ordered","header","errorCodiconSelector","errorIconForeground","warningIconForeground","problemsWarningIconForeground","warningCodiconSelector","infoCodiconSelector","infoIconForeground","normalizeDriveLetter","path","isWindowsOS","isWindows","hasDriveLetter","builder","s","caseOps","nextChCode","chCode","replaceString","matchIndex","nextNextChCode","CONTEXT_FIND_WIDGET_VISIBLE","CONTEXT_FIND_INPUT_FOCUSED","CONTEXT_REPLACE_INPUT_FOCUSED","ToggleCaseSensitiveKeybinding","ToggleWholeWordKeybinding","ToggleRegexKeybinding","ToggleSearchScopeKeybinding","TogglePreserveCaseKeybinding","FIND_IDS","MATCHES_LIMIT","RESEARCH_DELAY","FindModelBoundToEditorModel","TimeoutTimer","FindDecorations","findScope","moveCursor","newFindScope","findScopes","findMatches","editorSelection","currentMatchesPosition","matchAfterSelection","findFirstInSorted","matchesPosition","isUsingLineStops","isRecursed","nextMatchRange","prevMatchRange","prevMatch","nextMatch","forceMove","parseReplaceString","ReplacePattern","replacePattern","command","searchRanges","scope","searchRegex","mod","modelText","fullModelRange","resultText","preserveCase","ReplaceCommandThatPreservesSelection","replaceStrings","ReplaceAllCommand","FindOptionsWidget","keybindingService","inputActiveOptionBorderColor","inputActiveOptionBorder","inputActiveOptionForegroundColor","inputActiveOptionForeground","inputActiveOptionBackgroundColor","inputActiveOptionBackground","somethingChanged","dom.EventType","actionId","kb","inputStyles","registerThemingParticipant","widgetBackground","editorWidgetBackground","widgetForeground","editorWidgetForeground","widgetShadowColor","widgetShadow","hcBorder","effectiveOptionValue","FindReplaceState","matchesCount","currentMatch","changeEvent","updateHistory","oldEffectiveIsRegex","oldEffectiveWholeWords","oldEffectiveMatchCase","oldEffectivePreserveCase","newSearchScope","existingSearchScope","showHistoryKeybindingHint","findSelectionIcon","findCollapsedIcon","findExpandedIcon","findReplaceIcon","findReplaceAllIcon","findPreviousMatchIcon","findNextMatchIcon","NLS_FIND_INPUT_LABEL","NLS_FIND_INPUT_PLACEHOLDER","NLS_PREVIOUS_MATCH_BTN_LABEL","NLS_NEXT_MATCH_BTN_LABEL","NLS_TOGGLE_SELECTION_FIND_TITLE","NLS_CLOSE_BTN_LABEL","NLS_REPLACE_INPUT_LABEL","NLS_REPLACE_INPUT_PLACEHOLDER","NLS_REPLACE_BTN_LABEL","NLS_REPLACE_ALL_BTN_LABEL","NLS_TOGGLE_REPLACE_MODE_BTN_LABEL","NLS_MATCHES_COUNT_LIMIT_TITLE","NLS_MATCHES_LOCATION","NLS_NO_RESULTS","FIND_WIDGET_INITIAL_WIDTH","PART_WIDTH","FIND_INPUT_AREA_WIDTH","MAX_MATCHES_COUNT_WIDTH","FIND_INPUT_AREA_HEIGHT","ctrlEnterReplaceAllWarningPromptedKey","FindWidgetViewZone","afterLineNumber","stopPropagationForMultiLineUpwards","textarea","isMultiline","stopPropagationForMultiLineDownwards","FindWidget","codeEditor","controller","contextKeyService","storageService","notificationService","addExtraSpaceOnTop","globalBufferTerm","dom.trackFocus","dom.getTotalWidth","showRedOutline","onUnexpectedError","strings.format","alertFn","ariaLabel","isSelection","isChecked","findInputIsNonEmpty","canReplace","isSelectionMultipleLine","adjustEditorScrollTop","editorCoords","startCoords","startLeft","startTop","leftOfFindWidget","dom.getTopLeftOffset","endCoords","focusTheEditor","targetScrollTop","viewZone","adjustScroll","newHeight","scrollAdjustment","inputBackground","inputForeground","inputBorder","inputValidationInfoBackground","inputValidationInfoForeground","inputValidationInfoBorder","inputValidationWarningBackground","inputValidationWarningForeground","inputValidationWarningBorder","inputValidationErrorBackground","inputValidationErrorForeground","inputValidationErrorBorder","dom.isInDOM","editorWidth","minimapWidth","collapsedFindWidget","reducedFindWidget","narrowFindWidget","findInputWidth","totalheight","totalHeight","toolbarHoverBackgroundColor","focusOutline","SEARCH_STRING_MAX_LENGTH","getSelectionSearchString","seedSearchStringFromSelection","seedSearchStringFromNonEmptySelection","wordAtPosition","CommonFindController","clipboardService","shouldRestartFind","StartFindWithArgsAction","EditorAction","foldingArgumentsConstraint","_foldingController","foldingModel","levels","lineNumbers","setCollapseStateLevelsUp","setCollapseStateLevelsDown","UnFoldRecursivelyAction","FoldingAction","CONTEXT_FOLDING_ENABLED","KeyChord","_args","FoldAction","foldingCollapsedIcon","foldingManualExpandedIcon","foldingManualCollapsedIcon","BaseGhostTextWidgetModel","md","documentation","MarkdownString","sourceText","movingLineNumber","movingLineText","AbstractCopyLinesAction","endCursorState","finalSelection","linesDeleted","TrimTrailingWhitespaceAction","_accessor","TrimTrailingWhitespaceCommand","DeleteLinesAction","ops","cursorState","EditOperation","mergedOperations","previousOperation","IndentLinesAction","OutdentLinesAction","CoreEditingCommands","InsertLineBeforeAction","InsertLineAfterAction","AbstractDeleteAllToBoundaryAction","primaryCursor","rangesToDelete","effectiveRanges","nextRange","DeleteAllLeftAction","endPrimaryCursor","deletedLines","newStartLine","deleteFromLine","deleteFromColumn","DeleteAllRightAction","sel","JoinLinesAction","reducedSelections","lastSelection","previousValue","currentValue","lineOffset","columnDeltaOffset","selectionEndPositionOffset","trimmedLinesContent","lineText","firstNonWhitespaceIdx","insertSpace","lineTextWithoutIndent","deleteSelection","resultSelection","TransposeAction","chars","AbstractCaseAction","textEdits","word","wordRange","UpperCaseAction","LowerCaseAction","BackwardsCompatibleRegExp","_pattern","_flags","TitleCaseAction","titleBoundary","SnakeCaseAction","caseBoundary","singleLetters","KebabCaseAction","underscoreBoundary","registerEditorAction","CopyLinesUpAction","CopyLinesDownAction","DuplicateSelectionAction","MoveLinesUpAction","MoveLinesDownAction","SortLinesAscendingAction","SortLinesDescendingAction","DeleteDuplicateLinesAction","CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE","DECORATION_CLASS_NAME","LinkedEditingContribution","languageFeaturesService","languageFeatureDebounceService","forceRefresh","isEnabled","rangeUpdateScheduler","triggerRangeUpdate","rangeSyncScheduler","triggerRangeSync","MultiCursorSession","findController","isDisconnectedFromFindController","wholeWord","rejects","provider","newName","rename","registry","skeleton","RenameSkeleton","loc","CancellationToken","RenameController","_instaService","_notificationService","_bulkEditService","_progressService","_logService","_configService","_languageFeaturesService","CancellationTokenSource","IdleValue","RenameInputField","EditorStateCancellationTokenSource","turnOnMessage","AccessibilityHelpNLS","ToggleTabFocusModeAction"],"sources":["../../node_modules/react/cjs/react.production.min.js","../../node_modules/scheduler/cjs/scheduler.production.min.js","../../node_modules/scheduler/index.js","../../node_modules/react-dom/cjs/react-dom.production.min.js","../../node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js","../../node_modules/monaco-editor/esm/vs/base/common/errors.js","../../node_modules/monaco-editor/esm/vs/base/common/event.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../../node_modules/monaco-editor/esm/vs/base/common/buffer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","../../node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js","../../node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/colorizer.js","../../node_modules/monaco-editor/esm/vs/base/browser/canIUse.js","../../node_modules/monaco-editor/esm/vs/base/common/keybindings.js","../../node_modules/monaco-editor/esm/vs/base/browser/keyboardEvent.js","../../node_modules/monaco-editor/esm/vs/base/browser/iframe.js","../../node_modules/monaco-editor/esm/vs/base/browser/mouseEvent.js","../../node_modules/monaco-editor/esm/vs/base/browser/dompurify/dompurify.js","../../node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/browser/editorDom.js","../../node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseTarget.js","../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaState.js","../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js","../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaHandler.js","../../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../../node_modules/monaco-editor/esm/vs/editor/common/cursorCommon.js","../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../../node_modules/monaco-editor/esm/vs/editor/browser/coreCommands.js","../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/editorScrollbar/editorScrollbar.js","../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/glyphMargin/glyphMargin.js","../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js","../../node_modules/monaco-editor/esm/vs/editor/browser/widget/codeEditorWidget.js","../../node_modules/monaco-editor/esm/vs/base/common/htmlContent.js","../../node_modules/monaco-editor/esm/vs/platform/theme/common/iconRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/browser/widget/diffReview.js","../../node_modules/monaco-editor/esm/vs/editor/browser/widget/inlineDiffMargin.js","../../node_modules/monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js","../../node_modules/monaco-editor/esm/vs/platform/progress/common/progress.js","../../node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditorWidget.js","../../node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/contextview/contextview.js","../../node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextViewService.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/menu/menu.js","../../node_modules/monaco-editor/esm/vs/platform/theme/common/styler.js","../../node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","../../node_modules/monaco-editor/esm/vs/base/browser/formattedTextRenderer.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/highlightedlabel/highlightedLabel.js","../../node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInput.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/splice.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/list.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/rangeMap.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/rowCache.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/listView.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/listWidget.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/table/tableWidget.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/toggle/toggle.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInputToggles.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/tree.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js","../../node_modules/monaco-editor/esm/vs/base/common/collections.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/abstractTree.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/common/themes.js","../../node_modules/monaco-editor/esm/vs/platform/theme/browser/iconsStyleSheet.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneThemeService.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/common/standaloneTheme.js","../../node_modules/monaco-editor/esm/vs/platform/accessibility/browser/accessibilityService.js","../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/graph.js","../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js","../../node_modules/monaco-editor/esm/vs/platform/markers/common/markerService.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditor.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneEditor.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneLanguages.js","../../node_modules/monaco-editor/esm/vs/basic-languages/_.contribution.js","../../node_modules/monaco-editor/esm/vs/language/css/monaco.contribution.js","../../node_modules/monaco-editor/esm/vs/language/html/monaco.contribution.js","../../node_modules/monaco-editor/esm/vs/language/json/monaco.contribution.js","../../node_modules/monaco-editor/esm/vs/language/typescript/monaco.contribution.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/lightBulbWidget.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionUi.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensController.js","../../node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js","../../node_modules/monaco-editor/esm/vs/base/common/marked/marked.js","../../node_modules/monaco-editor/esm/vs/platform/severityIcon/common/severityIcon.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js","../../node_modules/monaco-editor/esm/vs/editor/browser/dnd.js","../../node_modules/monaco-editor/esm/vs/base/common/labels.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/lineCommentCommand.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replacePattern.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findModel.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findOptionsWidget.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findState.js","../../node_modules/monaco-editor/esm/vs/platform/history/browser/historyWidgetKeybindingHint.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findController.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/fontZoom/browser/fontZoom.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/utils.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostText.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/symbolIcons/browser/symbolIcons.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetDetails.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/copyLinesCommand.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/moveLinesCommand.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/sortLinesCommand.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/linkedEditing/browser/linkedEditing.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/browser/multicursor.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/rename.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp.js"],"sourcesContent":["/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var l=Symbol.for(\"react.element\"),n=Symbol.for(\"react.portal\"),p=Symbol.for(\"react.fragment\"),q=Symbol.for(\"react.strict_mode\"),r=Symbol.for(\"react.profiler\"),t=Symbol.for(\"react.provider\"),u=Symbol.for(\"react.context\"),v=Symbol.for(\"react.forward_ref\"),w=Symbol.for(\"react.suspense\"),x=Symbol.for(\"react.memo\"),y=Symbol.for(\"react.lazy\"),z=Symbol.iterator;function A(a){if(null===a||\"object\"!==typeof a)return null;a=z&&a[z]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}\nvar B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};\nE.prototype.setState=function(a,b){if(\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a)throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");this.updater.enqueueSetState(this,a,b,\"setState\")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;\nH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=\"\"+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\nfunction N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={\"=\":\"=0\",\":\":\"=2\"};return\"$\"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return\"object\"===typeof a&&null!==a&&null!=a.key?escape(\"\"+a.key):b.toString(36)}\nfunction R(a,b,e,d,c){var k=typeof a;if(\"undefined\"===k||\"boolean\"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case \"string\":case \"number\":h=!0;break;case \"object\":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=\"\"===d?\".\"+Q(h,0):d,I(c)?(e=\"\",null!=a&&(e=a.replace(P,\"$&/\")+\"/\"),R(c,b,e,\"\",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?\"\":(\"\"+c.key).replace(P,\"$&/\")+\"/\")+a)),b.push(c)),1;h=0;d=\"\"===d?\".\":d+\":\";if(I(a))for(var g=0;g<a.length;g++){k=\na[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),\"function\"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if(\"object\"===k)throw b=String(a),Error(\"Objects are not valid as a React child (found: \"+(\"[object Object]\"===b?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":b)+\"). If you meant to render a collection of children, use an array instead.\");return h}\nfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,\"\",\"\",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}\nvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error(\"React.Children.only expected to receive a single React element child.\");return a}};exports.Component=E;exports.Fragment=p;\nexports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;\nexports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \"+a+\".\");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=\"\"+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\nfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};\nexports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=function(){throw Error(\"act(...) is not supported in production builds of React.\");};\nexports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};\nexports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};\nexports.useTransition=function(){return U.current.useTransition()};exports.version=\"18.2.0\";\n","/**\n * @license React\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}\nfunction g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if(\"object\"===typeof performance&&\"function\"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D=\"function\"===typeof setTimeout?setTimeout:null,E=\"function\"===typeof clearTimeout?clearTimeout:null,F=\"undefined\"!==typeof setImmediate?setImmediate:null;\n\"undefined\"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t)}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else{var b=h(t);null!==b&&K(H,b.startTime-a)}}\nfunction J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if(\"function\"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();\"function\"===typeof e?v.callback=e:v===h(r)&&k(r);G(b)}else k(r);v=h(r)}if(null!==v)var w=!0;else{var m=h(t);null!==m&&K(H,m.startTime-b);w=!1}return w}finally{v=null,y=c,z=!1}}var N=!1,O=null,L=-1,P=5,Q=-1;\nfunction M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a)}finally{b?S():(N=!1,O=null)}}else N=!1}var S;if(\"function\"===typeof F)S=function(){F(R)};else if(\"undefined\"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null)}}else S=function(){D(R,0)};function I(a){O=a;N||(N=!0,S())}function K(a,b){L=D(function(){a(exports.unstable_now())},b)}\nexports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J))};\nexports.unstable_forceFrameRate=function(a){0>a||125<a?console.error(\"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"):P=0<a?Math.floor(1E3/a):5};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y}var c=y;y=b;try{return a()}finally{y=c}};exports.unstable_pauseExecution=function(){};\nexports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=y;y=a;try{return b()}finally{y=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();\"object\"===typeof c&&null!==c?(c=c.delay,c=\"number\"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};\nexports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c}}};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/scheduler.production.min.js');\n} else {\n  module.exports = require('./cjs/scheduler.development.js');\n}\n","/**\n * @license React\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\n'use strict';var aa=require(\"react\"),ca=require(\"scheduler\");function p(a){for(var b=\"https://reactjs.org/docs/error-decoder.html?invariant=\"+a,c=1;c<arguments.length;c++)b+=\"&args[]=\"+encodeURIComponent(arguments[c]);return\"Minified React error #\"+a+\"; visit \"+b+\" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+\"Capture\",b)}\nfunction ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a])}\nvar ia=!(\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,la=\n{},ma={};function oa(a){if(ja.call(ma,a))return!0;if(ja.call(la,a))return!1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return!1}function pa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case \"function\":case \"symbol\":return!0;case \"boolean\":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return\"data-\"!==a&&\"aria-\"!==a;default:return!1}}\nfunction qa(a,b,c,d){if(null===b||\"undefined\"===typeof b||pa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var z={};\n\"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style\".split(\" \").forEach(function(a){z[a]=new v(a,0,!1,a,null,!1,!1)});[[\"acceptCharset\",\"accept-charset\"],[\"className\",\"class\"],[\"htmlFor\",\"for\"],[\"httpEquiv\",\"http-equiv\"]].forEach(function(a){var b=a[0];z[b]=new v(b,1,!1,a[1],null,!1,!1)});[\"contentEditable\",\"draggable\",\"spellCheck\",\"value\"].forEach(function(a){z[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});\n[\"autoReverse\",\"externalResourcesRequired\",\"focusable\",\"preserveAlpha\"].forEach(function(a){z[a]=new v(a,2,!1,a,null,!1,!1)});\"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope\".split(\" \").forEach(function(a){z[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});\n[\"checked\",\"multiple\",\"muted\",\"selected\"].forEach(function(a){z[a]=new v(a,3,!0,a,null,!1,!1)});[\"capture\",\"download\"].forEach(function(a){z[a]=new v(a,4,!1,a,null,!1,!1)});[\"cols\",\"rows\",\"size\",\"span\"].forEach(function(a){z[a]=new v(a,6,!1,a,null,!1,!1)});[\"rowSpan\",\"start\"].forEach(function(a){z[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra=/[\\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}\n\"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height\".split(\" \").forEach(function(a){var b=a.replace(ra,\nsa);z[b]=new v(b,1,!1,a,null,!1,!1)});\"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type\".split(\" \").forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,\"http://www.w3.org/1999/xlink\",!1,!1)});[\"xml:base\",\"xml:lang\",\"xml:space\"].forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,\"http://www.w3.org/XML/1998/namespace\",!1,!1)});[\"tabIndex\",\"crossOrigin\"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});\nz.xlinkHref=new v(\"xlinkHref\",1,!1,\"xlink:href\",\"http://www.w3.org/1999/xlink\",!0,!1);[\"src\",\"href\",\"action\",\"formAction\"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});\nfunction ta(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||\"o\"!==b[0]&&\"O\"!==b[0]||\"n\"!==b[1]&&\"N\"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,\"\"+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:\"\":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?\"\":\"\"+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}\nvar ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for(\"react.element\"),wa=Symbol.for(\"react.portal\"),ya=Symbol.for(\"react.fragment\"),za=Symbol.for(\"react.strict_mode\"),Aa=Symbol.for(\"react.profiler\"),Ba=Symbol.for(\"react.provider\"),Ca=Symbol.for(\"react.context\"),Da=Symbol.for(\"react.forward_ref\"),Ea=Symbol.for(\"react.suspense\"),Fa=Symbol.for(\"react.suspense_list\"),Ga=Symbol.for(\"react.memo\"),Ha=Symbol.for(\"react.lazy\");Symbol.for(\"react.scope\");Symbol.for(\"react.debug_trace_mode\");\nvar Ia=Symbol.for(\"react.offscreen\");Symbol.for(\"react.legacy_hidden\");Symbol.for(\"react.cache\");Symbol.for(\"react.tracing_marker\");var Ja=Symbol.iterator;function Ka(a){if(null===a||\"object\"!==typeof a)return null;a=Ja&&a[Ja]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}var A=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);La=b&&b[1]||\"\"}return\"\\n\"+La+a}var Na=!1;\nfunction Oa(a,b){if(!a||Na)return\"\";Na=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,\"props\",{set:function(){throw Error();}}),\"object\"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&\"string\"===typeof l.stack){for(var e=l.stack.split(\"\\n\"),\nf=d.stack.split(\"\\n\"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k=\"\\n\"+e[g].replace(\" at new \",\" at \");a.displayName&&k.includes(\"<anonymous>\")&&(k=k.replace(\"<anonymous>\",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:\"\")?Ma(a):\"\"}\nfunction Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma(\"Lazy\");case 13:return Ma(\"Suspense\");case 19:return Ma(\"SuspenseList\");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return\"\"}}\nfunction Qa(a){if(null==a)return null;if(\"function\"===typeof a)return a.displayName||a.name||null;if(\"string\"===typeof a)return a;switch(a){case ya:return\"Fragment\";case wa:return\"Portal\";case Aa:return\"Profiler\";case za:return\"StrictMode\";case Ea:return\"Suspense\";case Fa:return\"SuspenseList\"}if(\"object\"===typeof a)switch(a.$$typeof){case Ca:return(a.displayName||\"Context\")+\".Consumer\";case Ba:return(a._context.displayName||\"Context\")+\".Provider\";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||\nb.name||\"\",a=\"\"!==a?\"ForwardRef(\"+a+\")\":\"ForwardRef\");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||\"Memo\";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}\nfunction Ra(a){var b=a.type;switch(a.tag){case 24:return\"Cache\";case 9:return(b.displayName||\"Context\")+\".Consumer\";case 10:return(b._context.displayName||\"Context\")+\".Provider\";case 18:return\"DehydratedFragment\";case 11:return a=b.render,a=a.displayName||a.name||\"\",b.displayName||(\"\"!==a?\"ForwardRef(\"+a+\")\":\"ForwardRef\");case 7:return\"Fragment\";case 5:return b;case 4:return\"Portal\";case 3:return\"Root\";case 6:return\"Text\";case 16:return Qa(b);case 8:return b===za?\"StrictMode\":\"Mode\";case 22:return\"Offscreen\";\ncase 12:return\"Profiler\";case 21:return\"Scope\";case 13:return\"Suspense\";case 19:return\"SuspenseList\";case 25:return\"TracingMarker\";case 1:case 0:case 17:case 2:case 14:case 15:if(\"function\"===typeof b)return b.displayName||b.name||null;if(\"string\"===typeof b)return b}return null}function Sa(a){switch(typeof a){case \"boolean\":case \"number\":case \"string\":case \"undefined\":return a;case \"object\":return a;default:return\"\"}}\nfunction Ta(a){var b=a.type;return(a=a.nodeName)&&\"input\"===a.toLowerCase()&&(\"checkbox\"===b||\"radio\"===b)}\nfunction Ua(a){var b=Ta(a)?\"checked\":\"value\",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=\"\"+a[b];if(!a.hasOwnProperty(b)&&\"undefined\"!==typeof c&&\"function\"===typeof c.get&&\"function\"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=\"\"+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=\"\"+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d=\"\";a&&(d=Ta(a)?a.checked?\"true\":\"false\":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||(\"undefined\"!==typeof document?document:void 0);if(\"undefined\"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}\nfunction Ya(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?\"\":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:\"checkbox\"===b.type||\"radio\"===b.type?null!=b.checked:null!=b.value}}function ab(a,b){b=b.checked;null!=b&&ta(a,\"checked\",b,!1)}\nfunction bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if(\"number\"===d){if(0===c&&\"\"===a.value||a.value!=c)a.value=\"\"+c}else a.value!==\"\"+c&&(a.value=\"\"+c);else if(\"submit\"===d||\"reset\"===d){a.removeAttribute(\"value\");return}b.hasOwnProperty(\"value\")?cb(a,b.type,c):b.hasOwnProperty(\"defaultValue\")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction db(a,b,c){if(b.hasOwnProperty(\"value\")||b.hasOwnProperty(\"defaultValue\")){var d=b.type;if(!(\"submit\"!==d&&\"reset\"!==d||void 0!==b.value&&null!==b.value))return;b=\"\"+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;\"\"!==c&&(a.name=\"\");a.defaultChecked=!!a._wrapperState.initialChecked;\"\"!==c&&(a.name=c)}\nfunction cb(a,b,c){if(\"number\"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=\"\"+a._wrapperState.initialValue:a.defaultValue!==\"\"+c&&(a.defaultValue=\"\"+c)}var eb=Array.isArray;\nfunction fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b[\"$\"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty(\"$\"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=\"\"+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:\"\"+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(eb(c)){if(1<c.length)throw Error(p(93));c=c[0]}b=c}null==b&&(b=\"\");c=b}a._wrapperState={initialValue:Sa(c)}}\nfunction ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=\"\"+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=\"\"+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&\"\"!==b&&null!==b&&(a.value=b)}function kb(a){switch(a){case \"svg\":return\"http://www.w3.org/2000/svg\";case \"math\":return\"http://www.w3.org/1998/Math/MathML\";default:return\"http://www.w3.org/1999/xhtml\"}}\nfunction lb(a,b){return null==a||\"http://www.w3.org/1999/xhtml\"===a?kb(b):\"http://www.w3.org/2000/svg\"===a&&\"foreignObject\"===b?\"http://www.w3.org/1999/xhtml\":a}\nvar mb,nb=function(a){return\"undefined\"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(\"http://www.w3.org/2000/svg\"!==a.namespaceURI||\"innerHTML\"in a)a.innerHTML=b;else{mb=mb||document.createElement(\"div\");mb.innerHTML=\"<svg>\"+b.valueOf().toString()+\"</svg>\";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,\nzoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=[\"Webkit\",\"ms\",\"Moz\",\"O\"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a]})});function rb(a,b,c){return null==b||\"boolean\"===typeof b||\"\"===b?\"\":c||\"number\"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(\"\"+b).trim():b+\"px\"}\nfunction sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf(\"--\"),e=rb(c,b[c],d);\"float\"===c&&(c=\"cssFloat\");d?a.setProperty(c,e):a[c]=e}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if(\"object\"!==typeof b.dangerouslySetInnerHTML||!(\"__html\"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&\"object\"!==typeof b.style)throw Error(p(62));}}\nfunction vb(a,b){if(-1===a.indexOf(\"-\"))return\"string\"===typeof b.is;switch(a){case \"annotation-xml\":case \"color-profile\":case \"font-face\":case \"font-face-src\":case \"font-face-uri\":case \"font-face-format\":case \"font-face-name\":case \"missing-glyph\":return!1;default:return!0}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;\nfunction Bb(a){if(a=Cb(a)){if(\"function\"!==typeof yb)throw Error(p(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(){}var Ib=!1;function Jb(a,b,c){if(Ib)return a(b,c);Ib=!0;try{return Gb(a,b,c)}finally{if(Ib=!1,null!==zb||null!==Ab)Hb(),Fb()}}\nfunction Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case \"onClick\":case \"onClickCapture\":case \"onDoubleClick\":case \"onDoubleClickCapture\":case \"onMouseDown\":case \"onMouseDownCapture\":case \"onMouseMove\":case \"onMouseMoveCapture\":case \"onMouseUp\":case \"onMouseUpCapture\":case \"onMouseEnter\":(d=!d.disabled)||(a=a.type,d=!(\"button\"===a||\"input\"===a||\"select\"===a||\"textarea\"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&\"function\"!==\ntypeof c)throw Error(p(231,b,typeof c));return c}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,\"passive\",{get:function(){Lb=!0}});window.addEventListener(\"test\",Mb,Mb);window.removeEventListener(\"test\",Mb,Mb)}catch(a){Lb=!1}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0;Pb=a}};function Tb(a,b,c,d,e,f,g,h,k){Ob=!1;Pb=null;Nb.apply(Sb,arguments)}\nfunction Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=!1;Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=l)}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p(188));}\nfunction Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling}return null}\nvar ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&\"function\"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128))}catch(b){}}\nvar oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;\nfunction tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;\ndefault:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)))}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}\nfunction wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}\nfunction Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc=\"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit\".split(\" \");\nfunction Sc(a,b){switch(a){case \"focusin\":case \"focusout\":Lc=null;break;case \"dragenter\":case \"dragleave\":Mc=null;break;case \"mouseover\":case \"mouseout\":Nc=null;break;case \"pointerover\":case \"pointerout\":Oc.delete(b.pointerId);break;case \"gotpointercapture\":case \"lostpointercapture\":Pc.delete(b.pointerId)}}\nfunction Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}\nfunction Uc(a,b,c,d,e){switch(b){case \"focusin\":return Lc=Tc(Lc,a,b,c,d,e),!0;case \"dragenter\":return Mc=Tc(Mc,a,b,c,d,e),!0;case \"mouseover\":return Nc=Tc(Nc,a,b,c,d,e),!0;case \"pointerover\":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return!0;case \"gotpointercapture\":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}\nfunction Xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,!1;b.shift()}return!0}function Zc(a,b,c){Xc(a)&&c.delete(b)}function $c(){Jc=!1;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc)}\nfunction ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}\nfunction bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;\nfunction ed(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=1,fd(a,b,c,d)}finally{C=e,cd.transition=f}}function gd(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=4,fd(a,b,c,d)}finally{C=e,cd.transition=f}}\nfunction fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else hd(a,b,d,null,c)}}var id=null;\nfunction Yc(a,b,c,d){id=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);id=a;return null}\nfunction jd(a){switch(a){case \"cancel\":case \"click\":case \"close\":case \"contextmenu\":case \"copy\":case \"cut\":case \"auxclick\":case \"dblclick\":case \"dragend\":case \"dragstart\":case \"drop\":case \"focusin\":case \"focusout\":case \"input\":case \"invalid\":case \"keydown\":case \"keypress\":case \"keyup\":case \"mousedown\":case \"mouseup\":case \"paste\":case \"pause\":case \"play\":case \"pointercancel\":case \"pointerdown\":case \"pointerup\":case \"ratechange\":case \"reset\":case \"resize\":case \"seeked\":case \"submit\":case \"touchcancel\":case \"touchend\":case \"touchstart\":case \"volumechange\":case \"change\":case \"selectionchange\":case \"textInput\":case \"compositionstart\":case \"compositionend\":case \"compositionupdate\":case \"beforeblur\":case \"afterblur\":case \"beforeinput\":case \"blur\":case \"fullscreenchange\":case \"focus\":case \"hashchange\":case \"popstate\":case \"select\":case \"selectstart\":return 1;case \"drag\":case \"dragenter\":case \"dragexit\":case \"dragleave\":case \"dragover\":case \"mousemove\":case \"mouseout\":case \"mouseover\":case \"pointermove\":case \"pointerout\":case \"pointerover\":case \"scroll\":case \"toggle\":case \"touchmove\":case \"wheel\":case \"mouseenter\":case \"mouseleave\":case \"pointerenter\":case \"pointerleave\":return 4;\ncase \"message\":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e=\"value\"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}\nfunction od(a){var b=a.keyCode;\"charCode\"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}\nfunction rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():\"unknown\"!==typeof a.returnValue&&\n(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():\"unknown\"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}\nvar sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if(\"movementX\"in\na)return a.movementX;a!==yd&&(yd&&\"mousemove\"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return\"movementY\"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(a){return\"clipboardData\"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:\"Escape\",\nSpacebar:\" \",Left:\"ArrowLeft\",Up:\"ArrowUp\",Right:\"ArrowRight\",Down:\"ArrowDown\",Del:\"Delete\",Win:\"OS\",Menu:\"ContextMenu\",Apps:\"ContextMenu\",Scroll:\"ScrollLock\",MozPrintableKey:\"Unidentified\"},Nd={8:\"Backspace\",9:\"Tab\",12:\"Clear\",13:\"Enter\",16:\"Shift\",17:\"Control\",18:\"Alt\",19:\"Pause\",20:\"CapsLock\",27:\"Escape\",32:\" \",33:\"PageUp\",34:\"PageDown\",35:\"End\",36:\"Home\",37:\"ArrowLeft\",38:\"ArrowUp\",39:\"ArrowRight\",40:\"ArrowDown\",45:\"Insert\",46:\"Delete\",112:\"F1\",113:\"F2\",114:\"F3\",115:\"F4\",116:\"F5\",117:\"F6\",118:\"F7\",\n119:\"F8\",120:\"F9\",121:\"F10\",122:\"F11\",123:\"F12\",144:\"NumLock\",145:\"ScrollLock\",224:\"Meta\"},Od={Alt:\"altKey\",Control:\"ctrlKey\",Meta:\"metaKey\",Shift:\"shiftKey\"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}\nvar Qd=A({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if(\"Unidentified\"!==b)return b}return\"keypress\"===a.type?(a=od(a),13===a?\"Enter\":String.fromCharCode(a)):\"keydown\"===a.type||\"keyup\"===a.type?Nd[a.keyCode]||\"Unidentified\":\"\"},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return\"keypress\"===a.type?od(a):0},keyCode:function(a){return\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0},which:function(a){return\"keypress\"===\na.type?od(a):\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(a){return\"deltaX\"in a?a.deltaX:\"wheelDeltaX\"in a?-a.wheelDeltaX:0},\ndeltaY:function(a){return\"deltaY\"in a?a.deltaY:\"wheelDeltaY\"in a?-a.wheelDeltaY:\"wheelDelta\"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&\"CompositionEvent\"in window,be=null;ia&&\"documentMode\"in document&&(be=document.documentMode);var ce=ia&&\"TextEvent\"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;\nfunction ge(a,b){switch(a){case \"keyup\":return-1!==$d.indexOf(b.keyCode);case \"keydown\":return 229!==b.keyCode;case \"keypress\":case \"mousedown\":case \"focusout\":return!0;default:return!1}}function he(a){a=a.detail;return\"object\"===typeof a&&\"data\"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case \"compositionend\":return he(b);case \"keypress\":if(32!==b.which)return null;fe=!0;return ee;case \"textInput\":return a=b.data,a===ee&&fe?null:a;default:return null}}\nfunction ke(a,b){if(ie)return\"compositionend\"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case \"paste\":return null;case \"keypress\":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case \"compositionend\":return de&&\"ko\"!==b.locale?null:b.data;default:return null}}\nvar le={color:!0,date:!0,datetime:!0,\"datetime-local\":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return\"input\"===b?!!le[a.type]:\"textarea\"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,\"onChange\");0<b.length&&(c=new td(\"onChange\",\"change\",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}\nfunction ve(a,b){if(\"change\"===a)return b}var we=!1;if(ia){var xe;if(ia){var ye=\"oninput\"in document;if(!ye){var ze=document.createElement(\"div\");ze.setAttribute(\"oninput\",\"return;\");ye=\"function\"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent(\"onpropertychange\",Be),qe=pe=null)}function Be(a){if(\"value\"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b)}}\nfunction Ce(a,b,c){\"focusin\"===a?(Ae(),pe=b,qe=c,pe.attachEvent(\"onpropertychange\",Be)):\"focusout\"===a&&Ae()}function De(a){if(\"selectionchange\"===a||\"keyup\"===a||\"keydown\"===a)return te(qe)}function Ee(a,b){if(\"click\"===a)return te(b)}function Fe(a,b){if(\"input\"===a||\"change\"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He=\"function\"===typeof Object.is?Object.is:Ge;\nfunction Ie(a,b){if(He(a,b))return!0;if(\"object\"!==typeof a||null===a||\"object\"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return!1}return!0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Je(c)}}function Le(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Le(a,b.parentNode):\"contains\"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}\nfunction Me(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c=\"string\"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&(\"input\"===b&&(\"text\"===a.type||\"search\"===a.type||\"tel\"===a.type||\"url\"===a.type||\"password\"===a.type)||\"textarea\"===b||\"true\"===a.contentEditable)}\nfunction Oe(a){var b=Me(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),\"selectionStart\"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,\nd);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});\"function\"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}\nvar Pe=ia&&\"documentMode\"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;\nfunction Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,\"selectionStart\"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe(Re,\"onSelect\"),0<d.length&&(b=new td(\"onSelect\",\"select\",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}\nfunction Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c[\"Webkit\"+a]=\"webkit\"+b;c[\"Moz\"+a]=\"moz\"+b;return c}var We={animationend:Ve(\"Animation\",\"AnimationEnd\"),animationiteration:Ve(\"Animation\",\"AnimationIteration\"),animationstart:Ve(\"Animation\",\"AnimationStart\"),transitionend:Ve(\"Transition\",\"TransitionEnd\")},Xe={},Ye={};\nia&&(Ye=document.createElement(\"div\").style,\"AnimationEvent\"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),\"TransitionEvent\"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe[a]=b[c];return a}var $e=Ze(\"animationend\"),af=Ze(\"animationiteration\"),bf=Ze(\"animationstart\"),cf=Ze(\"transitionend\"),df=new Map,ef=\"abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel\".split(\" \");\nfunction ff(a,b){df.set(a,b);fa(b,[a])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,\"on\"+kf)}ff($e,\"onAnimationEnd\");ff(af,\"onAnimationIteration\");ff(bf,\"onAnimationStart\");ff(\"dblclick\",\"onDoubleClick\");ff(\"focusin\",\"onFocus\");ff(\"focusout\",\"onBlur\");ff(cf,\"onTransitionEnd\");ha(\"onMouseEnter\",[\"mouseout\",\"mouseover\"]);ha(\"onMouseLeave\",[\"mouseout\",\"mouseover\"]);ha(\"onPointerEnter\",[\"pointerout\",\"pointerover\"]);\nha(\"onPointerLeave\",[\"pointerout\",\"pointerover\"]);fa(\"onChange\",\"change click focusin focusout input keydown keyup selectionchange\".split(\" \"));fa(\"onSelect\",\"focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange\".split(\" \"));fa(\"onBeforeInput\",[\"compositionend\",\"keypress\",\"textInput\",\"paste\"]);fa(\"onCompositionEnd\",\"compositionend focusout keydown keypress keyup mousedown\".split(\" \"));fa(\"onCompositionStart\",\"compositionstart focusout keydown keypress keyup mousedown\".split(\" \"));\nfa(\"onCompositionUpdate\",\"compositionupdate focusout keydown keypress keyup mousedown\".split(\" \"));var lf=\"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting\".split(\" \"),mf=new Set(\"cancel close invalid load scroll toggle\".split(\" \").concat(lf));\nfunction nf(a,b,c){var d=a.type||\"unknown-event\";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null}\nfunction se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a;}\nfunction D(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+\"__bubble\";c.has(d)||(pf(b,a,2,!1),c.add(d))}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b)}var rf=\"_reactListening\"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0;da.forEach(function(b){\"selectionchange\"!==b&&(mf.has(b)||qf(b,!1,a),qf(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=!0,qf(\"selectionchange\",!1,b))}}\nfunction pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd}c=e.bind(null,b,c,a);e=void 0;!Lb||\"touchstart\"!==b&&\"touchmove\"!==b&&\"wheel\"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}\nfunction hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Jb(function(){var d=f,e=xb(c),g=[];\na:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case \"keypress\":if(0===od(c))break a;case \"keydown\":case \"keyup\":k=Rd;break;case \"focusin\":n=\"focus\";k=Fd;break;case \"focusout\":n=\"blur\";k=Fd;break;case \"beforeblur\":case \"afterblur\":k=Fd;break;case \"click\":if(2===c.button)break a;case \"auxclick\":case \"dblclick\":case \"mousedown\":case \"mousemove\":case \"mouseup\":case \"mouseout\":case \"mouseover\":case \"contextmenu\":k=Bd;break;case \"drag\":case \"dragend\":case \"dragenter\":case \"dragexit\":case \"dragleave\":case \"dragover\":case \"dragstart\":case \"drop\":k=\nDd;break;case \"touchcancel\":case \"touchend\":case \"touchmove\":case \"touchstart\":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case \"scroll\":k=vd;break;case \"wheel\":k=Zd;break;case \"copy\":case \"cut\":case \"paste\":k=Jd;break;case \"gotpointercapture\":case \"lostpointercapture\":case \"pointercancel\":case \"pointerdown\":case \"pointermove\":case \"pointerout\":case \"pointerover\":case \"pointerup\":k=Td}var t=0!==(b&4),J=!t&&\"scroll\"===a,x=t?null!==h?h+\"Capture\":null:h;t=[];for(var w=d,u;null!==\nw;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}))}}if(0===(b&7)){a:{h=\"mouseover\"===a||\"pointerover\"===a;k=\"mouseout\"===a||\"pointerout\"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==\nn&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null}else k=null,n=d;if(k!==n){t=Bd;F=\"onMouseLeave\";x=\"onMouseEnter\";w=\"mouse\";if(\"pointerout\"===a||\"pointerover\"===a)t=Td,F=\"onPointerLeave\",x=\"onPointerEnter\",w=\"pointer\";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+\"leave\",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+\"enter\",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=\nvf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x)}t=null}else t=null;null!==k&&wf(g,h,k,t,!1);null!==n&&null!==J&&wf(g,J,n,t,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if(\"select\"===k||\"input\"===k&&\"file\"===h.type)var na=ve;else if(me(h))if(we)na=Fe;else{na=De;var xa=Ce}else(k=h.nodeName)&&\"input\"===k.toLowerCase()&&(\"checkbox\"===h.type||\"radio\"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);\"focusout\"===a&&(xa=h._wrapperState)&&\nxa.controlled&&\"number\"===h.type&&cb(h,\"number\",h.value)}xa=d?ue(d):window;switch(a){case \"focusin\":if(me(xa)||\"true\"===xa.contentEditable)Qe=xa,Re=d,Se=null;break;case \"focusout\":Se=Re=Qe=null;break;case \"mousedown\":Te=!0;break;case \"contextmenu\":case \"mouseup\":case \"dragend\":Te=!1;Ue(g,c,e);break;case \"selectionchange\":if(Pe)break;case \"keydown\":case \"keyup\":Ue(g,c,e)}var $a;if(ae)b:{switch(a){case \"compositionstart\":var ba=\"onCompositionStart\";break b;case \"compositionend\":ba=\"onCompositionEnd\";\nbreak b;case \"compositionupdate\":ba=\"onCompositionUpdate\";break b}ba=void 0}else ie?ge(a,c)&&(ba=\"onCompositionEnd\"):\"keydown\"===a&&229===c.keyCode&&(ba=\"onCompositionStart\");ba&&(de&&\"ko\"!==c.locale&&(ie||\"onCompositionStart\"!==ba?\"onCompositionEnd\"===ba&&ie&&($a=nd()):(kd=e,ld=\"value\"in kd?kd.value:kd.textContent,ie=!0)),xa=oe(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce?je(a,c):ke(a,c))d=oe(d,\"onBeforeInput\"),\n0<d.length&&(e=new Ld(\"onBeforeInput\",\"beforeinput\",null,c,e),g.push({event:e,listeners:d}),e.data=$a)}se(g,b)})}function tf(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+\"Capture\",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}var xf=/\\r\\n?/g,yf=/\\u0000|\\uFFFD/g;function zf(a){return(\"string\"===typeof a?a:\"\"+a).replace(xf,\"\\n\").replace(yf,\"\")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p(425));}function Bf(){}\nvar Cf=null,Df=null;function Ef(a,b){return\"textarea\"===a||\"noscript\"===a||\"string\"===typeof b.children||\"number\"===typeof b.children||\"object\"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}\nvar Ff=\"function\"===typeof setTimeout?setTimeout:void 0,Gf=\"function\"===typeof clearTimeout?clearTimeout:void 0,Hf=\"function\"===typeof Promise?Promise:void 0,Jf=\"function\"===typeof queueMicrotask?queueMicrotask:\"undefined\"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;})}\nfunction Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,\"/$\"===c){if(0===d){a.removeChild(e);bd(b);return}d--}else\"$\"!==c&&\"$?\"!==c&&\"$!\"!==c||d++;c=e}while(c);bd(b)}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if(\"$\"===b||\"$!\"===b||\"$?\"===b)break;if(\"/$\"===b)return null}}return a}\nfunction Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(\"$\"===c||\"$!\"===c||\"$?\"===c){if(0===b)return a;b--}else\"/$\"===c&&b++}a=a.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of=\"__reactFiber$\"+Nf,Pf=\"__reactProps$\"+Nf,uf=\"__reactContainer$\"+Nf,of=\"__reactEvents$\"+Nf,Qf=\"__reactListeners$\"+Nf,Rf=\"__reactHandles$\"+Nf;\nfunction Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[Of]||a[uf];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return{current:a}}\nfunction E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(a,b){Tf++;Sf[Tf]=a.current;a.current=b}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}\nfunction Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E(Wf);E(H)}function ag(a,b,c){if(H.current!==Vf)throw Error(p(168));G(H,b);G(Wf,c)}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if(\"function\"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Ra(a)||\"Unknown\",e));return A({},c,d)}\nfunction cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H.current;G(H,a);G(Wf,Wf.current);return!0}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf);G(Wf,c)}var eg=null,fg=!1,gg=!1;function hg(a){null===eg?eg=[a]:eg.push(a)}function ig(a){fg=!0;hg(a)}\nfunction jg(){if(!gg&&null!==eg){gg=!0;var a=0,b=C;try{var c=eg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C=b,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg=\"\";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b}\nfunction ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a}else rg=1<<f|c<<e|d,sg=a}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0))}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;\nfunction Ag(a,b){var c=Bg(5,null,null,0);c.elementType=\"DELETED\";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}\nfunction Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),!0):!1;case 6:return b=\"\"===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=\nnull,!0):!1;default:return!1}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=!1;xg=a}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a}\nfunction Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b=\"head\"!==b&&\"body\"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling)}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(\"/$\"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--}else\"$\"!==c&&\"$!\"!==c&&\"$?\"!==c||b++}a=a.nextSibling}yg=\nnull}}else yg=xg?Lf(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling)}function Ig(){yg=xg=null;I=!1}function Jg(a){null===zg?zg=[a]:zg.push(a)}var Kg=ua.ReactCurrentBatchConfig;function Lg(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var Mg=Uf(null),Ng=null,Og=null,Pg=null;function Qg(){Pg=Og=Ng=null}function Rg(a){var b=Mg.current;E(Mg);a._currentValue=b}\nfunction Sg(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}function Tg(a,b){Ng=a;Pg=Og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(Ug=!0),a.firstContext=null)}\nfunction Vg(a){var b=a._currentValue;if(Pg!==a)if(a={context:a,memoizedValue:b,next:null},null===Og){if(null===Ng)throw Error(p(308));Og=a;Ng.dependencies={lanes:0,firstContext:a}}else Og=Og.next=a;return b}var Wg=null;function Xg(a){null===Wg?Wg=[a]:Wg.push(a)}function Yg(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,Xg(b)):(c.next=e.next,e.next=c);b.interleaved=c;return Zg(a,d)}\nfunction Zg(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var $g=!1;function ah(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}\nfunction bh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function ch(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}\nfunction dh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return Zg(a,c)}e=d.interleaved;null===e?(b.next=b,Xg(d)):(b.next=e.next,e.next=b);d.interleaved=b;return Zg(a,c)}function eh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}\nfunction fh(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction gh(a,b,c,d){var e=a.updateQueue;$g=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k))}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,\nnext:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if(\"function\"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r=\"function\"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A({},q,r);break a;case 2:$g=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h))}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;\nh=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);hh|=g;a.lanes=g;a.memoizedState=q}}\nfunction ih(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if(\"function\"!==typeof e)throw Error(p(191,e));e.call(d)}}}var jh=(new aa.Component).refs;function kh(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar nh={isMounted:function(a){return(a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=L(),d=\nlh(a),e=ch(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=dh(a,e,d);null!==b&&(mh(b,a,d,c),eh(b,a,d))}};function oh(a,b,c,d,e,f,g){a=a.stateNode;return\"function\"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):!0}\nfunction ph(a,b,c){var d=!1,e=Vf;var f=b.contextType;\"object\"===typeof f&&null!==f?f=Vg(f):(e=Zf(b)?Xf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=nh;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction qh(a,b,c,d){a=b.state;\"function\"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);\"function\"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&nh.enqueueReplaceState(b,b.state,null)}\nfunction rh(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=jh;ah(a);var f=b.contextType;\"object\"===typeof f&&null!==f?e.context=Vg(f):(f=Zf(b)?Xf:H.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;\"function\"===typeof f&&(kh(a,b,f,c),e.state=a.memoizedState);\"function\"===typeof b.getDerivedStateFromProps||\"function\"===typeof e.getSnapshotBeforeUpdate||\"function\"!==typeof e.UNSAFE_componentWillMount&&\"function\"!==typeof e.componentWillMount||(b=e.state,\n\"function\"===typeof e.componentWillMount&&e.componentWillMount(),\"function\"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&nh.enqueueReplaceState(e,e.state,null),gh(a,c,e,d),e.state=a.memoizedState);\"function\"===typeof e.componentDidMount&&(a.flags|=4194308)}\nfunction sh(a,b,c){a=c.ref;if(null!==a&&\"function\"!==typeof a&&\"object\"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode}if(!d)throw Error(p(147,a));var e=d,f=\"\"+a;if(null!==b&&null!==b.ref&&\"function\"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;b===jh&&(b=e.refs={});null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if(\"string\"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}\nfunction th(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,\"[object Object]\"===a?\"object with keys {\"+Object.keys(b).join(\", \")+\"}\":a));}function uh(a){var b=a._init;return b(a._payload)}\nfunction vh(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=wh(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&\nnull===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=xh(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||\"object\"===typeof f&&null!==f&&f.$$typeof===Ha&&uh(f)===b.type))return d=e(b,c.props),d.ref=sh(a,b,c),d.return=a,d;d=yh(c.type,c.key,c.props,null,a.mode,d);d.ref=sh(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||\nb.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=zh(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ah(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if(\"string\"===typeof b&&\"\"!==b||\"number\"===typeof b)return b=xh(\"\"+b,a.mode,c),b.return=a,b;if(\"object\"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=yh(b.type,b.key,b.props,null,a.mode,c),\nc.ref=sh(a,null,b),c.return=a,c;case wa:return b=zh(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Ah(b,a.mode,c,null),b.return=a,b;th(a,b)}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if(\"string\"===typeof c&&\"\"!==c||\"number\"===typeof c)return null!==e?null:h(a,b,\"\"+c,d);if(\"object\"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,\nb,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);th(a,c)}return null}function y(a,b,c,d,e){if(\"string\"===typeof d&&\"\"!==d||\"number\"===typeof d)return a=a.get(c)||null,h(b,a,\"\"+d,e);if(\"object\"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);th(b,d)}return null}\nfunction n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x}if(w===h.length)return c(e,u),I&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===\nx.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if(\"function\"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x}if(n.done)return c(e,\nm),I&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function J(a,d,f,h){\"object\"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if(\"object\"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=\nf.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||\"object\"===typeof k&&null!==k&&k.$$typeof===Ha&&uh(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=sh(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===ya?(d=Ah(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=yh(f.type,f.key,f.props,null,a.mode,h),h.ref=sh(a,d,f),h.return=a,a=h)}return g(a);case wa:a:{for(l=f.key;null!==\nd;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=zh(f,a.mode,h);d.return=a;a=d}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);th(a,f)}return\"string\"===typeof f&&\"\"!==f||\"number\"===typeof f?(f=\"\"+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):\n(c(a,d),d=xh(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Bh=vh(!0),Ch=vh(!1),Dh={},Eh=Uf(Dh),Fh=Uf(Dh),Gh=Uf(Dh);function Hh(a){if(a===Dh)throw Error(p(174));return a}function Ih(a,b){G(Gh,b);G(Fh,a);G(Eh,Dh);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,\"\");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a)}E(Eh);G(Eh,b)}function Jh(){E(Eh);E(Fh);E(Gh)}\nfunction Kh(a){Hh(Gh.current);var b=Hh(Eh.current);var c=lb(b,a.type);b!==c&&(G(Fh,a),G(Eh,c))}function Lh(a){Fh.current===a&&(E(Eh),E(Fh))}var M=Uf(0);\nfunction Mh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||\"$?\"===c.data||\"$!\"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var Nh=[];\nfunction Oh(){for(var a=0;a<Nh.length;a++)Nh[a]._workInProgressVersionPrimary=null;Nh.length=0}var Ph=ua.ReactCurrentDispatcher,Qh=ua.ReactCurrentBatchConfig,Rh=0,N=null,O=null,P=null,Sh=!1,Th=!1,Uh=0,Vh=0;function Q(){throw Error(p(321));}function Wh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}\nfunction Xh(a,b,c,d,e,f){Rh=f;N=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Ph.current=null===a||null===a.memoizedState?Yh:Zh;a=c(d,e);if(Th){f=0;do{Th=!1;Uh=0;if(25<=f)throw Error(p(301));f+=1;P=O=null;b.updateQueue=null;Ph.current=$h;a=c(d,e)}while(Th)}Ph.current=ai;b=null!==O&&null!==O.next;Rh=0;P=O=N=null;Sh=!1;if(b)throw Error(p(300));return a}function bi(){var a=0!==Uh;Uh=0;return a}\nfunction ci(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P?N.memoizedState=P=a:P=P.next=a;return P}function di(){if(null===O){var a=N.alternate;a=null!==a?a.memoizedState:null}else a=O.next;var b=null===P?N.memoizedState:P.next;if(null!==b)P=b,O=a;else{if(null===a)throw Error(p(310));O=a;a={memoizedState:O.memoizedState,baseState:O.baseState,baseQueue:O.baseQueue,queue:O.queue,next:null};null===P?N.memoizedState=P=a:P=P.next=a}return P}\nfunction ei(a,b){return\"function\"===typeof b?b(a):b}\nfunction fi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=O,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Rh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,\neagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;N.lanes|=m;hh|=m}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(Ug=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,N.lanes|=f,hh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}\nfunction gi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(Ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function hi(){}\nfunction ii(a,b){var c=N,d=di(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,Ug=!0);d=d.queue;ji(ki.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==P&&P.memoizedState.tag&1){c.flags|=2048;li(9,mi.bind(null,c,d,e,b),void 0,null);if(null===R)throw Error(p(349));0!==(Rh&30)||ni(c,b,e)}return e}function ni(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}\nfunction mi(a,b,c,d){b.value=c;b.getSnapshot=d;oi(b)&&pi(a)}function ki(a,b,c){return c(function(){oi(b)&&pi(a)})}function oi(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!He(a,c)}catch(d){return!0}}function pi(a){var b=Zg(a,1);null!==b&&mh(b,a,1,-1)}\nfunction qi(a){var b=ci();\"function\"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ei,lastRenderedState:a};b.queue=a;a=a.dispatch=ri.bind(null,N,a);return[b.memoizedState,a]}\nfunction li(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function si(){return di().memoizedState}function ti(a,b,c,d){var e=ci();N.flags|=a;e.memoizedState=li(1|b,c,void 0,void 0===d?null:d)}\nfunction ui(a,b,c,d){var e=di();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&Wh(d,g.deps)){e.memoizedState=li(b,c,f,d);return}}N.flags|=a;e.memoizedState=li(1|b,c,f,d)}function vi(a,b){return ti(8390656,8,a,b)}function ji(a,b){return ui(2048,8,a,b)}function wi(a,b){return ui(4,2,a,b)}function xi(a,b){return ui(4,4,a,b)}\nfunction yi(a,b){if(\"function\"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function zi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ui(4,4,yi.bind(null,b,a),c)}function Ai(){}function Bi(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}\nfunction Ci(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Di(a,b,c){if(0===(Rh&21))return a.baseState&&(a.baseState=!1,Ug=!0),a.memoizedState=c;He(c,b)||(c=yc(),N.lanes|=c,hh|=c,a.baseState=!0);return b}function Ei(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Qh.transition;Qh.transition={};try{a(!1),b()}finally{C=c,Qh.transition=d}}function Fi(){return di().memoizedState}\nfunction Gi(a,b,c){var d=lh(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,c);else if(c=Yg(a,b,c,d),null!==c){var e=L();mh(c,a,d,e);Ji(c,b,d)}}\nfunction ri(a,b,c){var d=lh(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,e);else{var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,Xg(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=Yg(a,b,e,d);null!==c&&(e=L(),mh(c,a,d,e),Ji(c,b,d))}}\nfunction Hi(a){var b=a.alternate;return a===N||null!==b&&b===N}function Ii(a,b){Th=Sh=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function Ji(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}\nvar ai={readContext:Vg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useInsertionEffect:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useDeferredValue:Q,useTransition:Q,useMutableSource:Q,useSyncExternalStore:Q,useId:Q,unstable_isNewReconciler:!1},Yh={readContext:Vg,useCallback:function(a,b){ci().memoizedState=[a,void 0===b?null:b];return a},useContext:Vg,useEffect:vi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ti(4194308,\n4,yi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ti(4194308,4,a,b)},useInsertionEffect:function(a,b){return ti(4,2,a,b)},useMemo:function(a,b){var c=ci();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=ci();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=Gi.bind(null,N,a);return[d.memoizedState,a]},useRef:function(a){var b=\nci();a={current:a};return b.memoizedState=a},useState:qi,useDebugValue:Ai,useDeferredValue:function(a){return ci().memoizedState=a},useTransition:function(){var a=qi(!1),b=a[0];a=Ei.bind(null,a[1]);ci().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=N,e=ci();if(I){if(void 0===c)throw Error(p(407));c=c()}else{c=b();if(null===R)throw Error(p(349));0!==(Rh&30)||ni(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;vi(ki.bind(null,d,\nf,a),[a]);d.flags|=2048;li(9,mi.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=ci(),b=R.identifierPrefix;if(I){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=\":\"+b+\"R\"+c;c=Uh++;0<c&&(b+=\"H\"+c.toString(32));b+=\":\"}else c=Vh++,b=\":\"+b+\"r\"+c.toString(32)+\":\";return a.memoizedState=b},unstable_isNewReconciler:!1},Zh={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:fi,useRef:si,useState:function(){return fi(ei)},\nuseDebugValue:Ai,useDeferredValue:function(a){var b=di();return Di(b,O.memoizedState,a)},useTransition:function(){var a=fi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1},$h={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:gi,useRef:si,useState:function(){return gi(ei)},useDebugValue:Ai,useDeferredValue:function(a){var b=di();return null===\nO?b.memoizedState=a:Di(b,O.memoizedState,a)},useTransition:function(){var a=gi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1};function Ki(a,b){try{var c=\"\",d=b;do c+=Pa(d),d=d.return;while(d);var e=c}catch(f){e=\"\\nError generating stack: \"+f.message+\"\\n\"+f.stack}return{value:a,source:b,stack:e,digest:null}}function Li(a,b,c){return{value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}\nfunction Mi(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Ni=\"function\"===typeof WeakMap?WeakMap:Map;function Oi(a,b,c){c=ch(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Pi||(Pi=!0,Qi=d);Mi(a,b)};return c}\nfunction Ri(a,b,c){c=ch(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if(\"function\"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Mi(a,b)}}var f=a.stateNode;null!==f&&\"function\"===typeof f.componentDidCatch&&(c.callback=function(){Mi(a,b);\"function\"!==typeof d&&(null===Si?Si=new Set([this]):Si.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:\"\"})});return c}\nfunction Ti(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Ni;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ui.bind(null,a,b,c),b.then(a,a))}function Vi(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}\nfunction Wi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=ch(-1,1),b.tag=2,dh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Xi=ua.ReactCurrentOwner,Ug=!1;function Yi(a,b,c,d){b.child=null===a?Ch(b,null,c,d):Bh(b,a.child,c,d)}\nfunction Zi(a,b,c,d,e){c=c.render;var f=b.ref;Tg(b,e);d=Xh(a,b,c,d,f,e);c=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&c&&vg(b);b.flags|=1;Yi(a,b,d,e);return b.child}\nfunction aj(a,b,c,d,e){if(null===a){var f=c.type;if(\"function\"===typeof f&&!bj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,cj(a,b,f,d,e);a=yh(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return $i(a,b,e)}b.flags|=1;a=wh(f,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction cj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(Ug=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(Ug=!0);else return b.lanes=a.lanes,$i(a,b,e)}return dj(a,b,c,d,e)}\nfunction ej(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if(\"hidden\"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(fj,gj),gj|=c;else{if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(fj,gj),gj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G(fj,gj);gj|=d}else null!==\nf?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(fj,gj),gj|=d;Yi(a,b,e,c);return b.child}function hj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function dj(a,b,c,d,e){var f=Zf(c)?Xf:H.current;f=Yf(b,f);Tg(b,e);c=Xh(a,b,c,d,f,e);d=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&d&&vg(b);b.flags|=1;Yi(a,b,c,e);return b.child}\nfunction ij(a,b,c,d,e){if(Zf(c)){var f=!0;cg(b)}else f=!1;Tg(b,e);if(null===b.stateNode)jj(a,b),ph(b,c,d),rh(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;\"object\"===typeof l&&null!==l?l=Vg(l):(l=Zf(c)?Xf:H.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q=\"function\"===typeof m||\"function\"===typeof g.getSnapshotBeforeUpdate;q||\"function\"!==typeof g.UNSAFE_componentWillReceiveProps&&\"function\"!==typeof g.componentWillReceiveProps||\n(h!==d||k!==l)&&qh(b,g,d,l);$g=!1;var r=b.memoizedState;g.state=r;gh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||$g?(\"function\"===typeof m&&(kh(b,c,m,d),k=b.memoizedState),(h=$g||oh(b,c,h,d,r,k,l))?(q||\"function\"!==typeof g.UNSAFE_componentWillMount&&\"function\"!==typeof g.componentWillMount||(\"function\"===typeof g.componentWillMount&&g.componentWillMount(),\"function\"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),\"function\"===typeof g.componentDidMount&&(b.flags|=4194308)):\n(\"function\"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):(\"function\"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;bh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Lg(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;\"object\"===typeof k&&null!==k?k=Vg(k):(k=Zf(c)?Xf:H.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m=\"function\"===typeof y||\"function\"===typeof g.getSnapshotBeforeUpdate)||\n\"function\"!==typeof g.UNSAFE_componentWillReceiveProps&&\"function\"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&qh(b,g,d,k);$g=!1;r=b.memoizedState;g.state=r;gh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||$g?(\"function\"===typeof y&&(kh(b,c,y,d),n=b.memoizedState),(l=$g||oh(b,c,l,d,r,n,k)||!1)?(m||\"function\"!==typeof g.UNSAFE_componentWillUpdate&&\"function\"!==typeof g.componentWillUpdate||(\"function\"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),\"function\"===typeof g.UNSAFE_componentWillUpdate&&\ng.UNSAFE_componentWillUpdate(d,n,k)),\"function\"===typeof g.componentDidUpdate&&(b.flags|=4),\"function\"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):(\"function\"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),\"function\"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):(\"function\"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===\na.memoizedState||(b.flags|=4),\"function\"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1)}return kj(a,b,c,d,f,e)}\nfunction kj(a,b,c,d,e,f){hj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,!1),$i(a,b,f);d=b.stateNode;Xi.current=b;var h=g&&\"function\"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Bh(b,a.child,null,f),b.child=Bh(b,null,h,f)):Yi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,!0);return b.child}function lj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,!1);Ih(a,b.containerInfo)}\nfunction mj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Yi(a,b,c,d);return b.child}var nj={dehydrated:null,treeContext:null,retryLane:0};function oj(a){return{baseLanes:a,cachePool:null,transitions:null}}\nfunction pj(a,b,c){var d=b.pendingProps,e=M.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(M,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:\"$!\"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:\"hidden\",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=\ng):f=qj(g,d,0,null),a=Ah(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=oj(c),b.memoizedState=nj,a):rj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return sj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:\"hidden\",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=wh(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=wh(h,f):(f=Ah(f,g,c,null),f.flags|=2);f.return=\nb;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?oj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=nj;return d}f=a.child;a=f.sibling;d=wh(f,{mode:\"visible\",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}\nfunction rj(a,b){b=qj({mode:\"visible\",children:b},a.mode,0,null);b.return=a;return a.child=b}function tj(a,b,c,d){null!==d&&Jg(d);Bh(b,a.child,null,c);a=rj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}\nfunction sj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Li(Error(p(422))),tj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=qj({mode:\"visible\",children:d.children},e,0,null);f=Ah(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Bh(b,a.child,null,g);b.child.memoizedState=oj(g);b.memoizedState=nj;return f}if(0===(b.mode&1))return tj(a,b,g,null);if(\"$!\"===e.data){d=e.nextSibling&&e.nextSibling.dataset;\nif(d)var h=d.dgst;d=h;f=Error(p(419));d=Li(f,d,void 0);return tj(a,b,g,d)}h=0!==(g&a.childLanes);if(Ug||h){d=R;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0}e=0!==(e&(d.suspendedLanes|g))?0:e;\n0!==e&&e!==f.retryLane&&(f.retryLane=e,Zg(a,e),mh(d,a,e,-1))}uj();d=Li(Error(p(421)));return tj(a,b,g,d)}if(\"$?\"===e.data)return b.flags|=128,b.child=a.child,b=vj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I=!0;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=rj(b,d.children);b.flags|=4096;return b}function wj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);Sg(a.return,b,c)}\nfunction xj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}\nfunction yj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Yi(a,b,d.children,c);d=M.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&wj(a,c,b);else if(19===a.tag)wj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}G(M,d);if(0===(b.mode&1))b.memoizedState=\nnull;else switch(e){case \"forwards\":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Mh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);xj(b,!1,e,c,f);break;case \"backwards\":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Mh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}xj(b,!0,c,null,f);break;case \"together\":xj(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}\nfunction jj(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2)}function $i(a,b,c){null!==a&&(b.dependencies=a.dependencies);hh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=wh(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=wh(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}\nfunction zj(a,b,c){switch(b.tag){case 3:lj(b);Ig();break;case 5:Kh(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:Ih(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(Mg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(M,M.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return pj(a,b,c);G(M,M.current&1);a=$i(a,b,c);return null!==a?a.sibling:null}G(M,M.current&1);break;case 19:d=0!==(c&\nb.childLanes);if(0!==(a.flags&128)){if(d)return yj(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(M,M.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,ej(a,b,c)}return $i(a,b,c)}var Aj,Bj,Cj,Dj;\nAj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Bj=function(){};\nCj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;Hh(Eh.current);var f=null;switch(c){case \"input\":e=Ya(a,e);d=Ya(a,d);f=[];break;case \"select\":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case \"textarea\":e=gb(a,e);d=gb(a,d);f=[];break;default:\"function\"!==typeof e.onClick&&\"function\"===typeof d.onClick&&(a.onclick=Bf)}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if(\"style\"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&\n(c||(c={}),c[g]=\"\")}else\"dangerouslySetInnerHTML\"!==l&&\"children\"!==l&&\"suppressContentEditableWarning\"!==l&&\"suppressHydrationWarning\"!==l&&\"autoFocus\"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if(\"style\"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]=\"\");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,\nc)),c=k;else\"dangerouslySetInnerHTML\"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):\"children\"===l?\"string\"!==typeof k&&\"number\"!==typeof k||(f=f||[]).push(l,\"\"+k):\"suppressContentEditableWarning\"!==l&&\"suppressHydrationWarning\"!==l&&(ea.hasOwnProperty(l)?(null!=k&&\"onScroll\"===l&&D(\"scroll\",a),f||h===k||(f=[])):(f=f||[]).push(l,k))}c&&(f=f||[]).push(\"style\",c);var l=f;if(b.updateQueue=l)b.flags|=4}};Dj=function(a,b,c,d){c!==d&&(b.flags|=4)};\nfunction Ej(a,b){if(!I)switch(a.tailMode){case \"hidden\":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case \"collapsed\":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}\nfunction Fj(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;Jh();E(Wf);E(H);Oh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Gj(zg),zg=null));Bj(a,b);S(b);return null;case 5:Lh(b);var e=Hh(Gh.current);\nc=b.type;if(null!==a&&null!=b.stateNode)Cj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(p(166));S(b);return null}a=Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case \"dialog\":D(\"cancel\",d);D(\"close\",d);break;case \"iframe\":case \"object\":case \"embed\":D(\"load\",d);break;case \"video\":case \"audio\":for(e=0;e<lf.length;e++)D(lf[e],d);break;case \"source\":D(\"error\",d);break;case \"img\":case \"image\":case \"link\":D(\"error\",\nd);D(\"load\",d);break;case \"details\":D(\"toggle\",d);break;case \"input\":Za(d,f);D(\"invalid\",d);break;case \"select\":d._wrapperState={wasMultiple:!!f.multiple};D(\"invalid\",d);break;case \"textarea\":hb(d,f),D(\"invalid\",d)}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];\"children\"===g?\"string\"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=[\"children\",h]):\"number\"===typeof h&&d.textContent!==\"\"+h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,\nh,a),e=[\"children\",\"\"+h]):ea.hasOwnProperty(g)&&null!=h&&\"onScroll\"===g&&D(\"scroll\",d)}switch(c){case \"input\":Va(d);db(d,f,!0);break;case \"textarea\":Va(d);jb(d);break;case \"select\":case \"option\":break;default:\"function\"===typeof f.onClick&&(d.onclick=Bf)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;\"http://www.w3.org/1999/xhtml\"===a&&(a=kb(c));\"http://www.w3.org/1999/xhtml\"===a?\"script\"===c?(a=g.createElement(\"div\"),a.innerHTML=\"<script>\\x3c/script>\",a=a.removeChild(a.firstChild)):\n\"string\"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),\"select\"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;Aj(a,b,!1,!1);b.stateNode=a;a:{g=vb(c,d);switch(c){case \"dialog\":D(\"cancel\",a);D(\"close\",a);e=d;break;case \"iframe\":case \"object\":case \"embed\":D(\"load\",a);e=d;break;case \"video\":case \"audio\":for(e=0;e<lf.length;e++)D(lf[e],a);e=d;break;case \"source\":D(\"error\",a);e=d;break;case \"img\":case \"image\":case \"link\":D(\"error\",\na);D(\"load\",a);e=d;break;case \"details\":D(\"toggle\",a);e=d;break;case \"input\":Za(a,d);e=Ya(a,d);D(\"invalid\",a);break;case \"option\":e=d;break;case \"select\":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D(\"invalid\",a);break;case \"textarea\":hb(a,d);e=gb(a,d);D(\"invalid\",a);break;default:e=d}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];\"style\"===f?sb(a,k):\"dangerouslySetInnerHTML\"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):\"children\"===f?\"string\"===typeof k?(\"textarea\"!==\nc||\"\"!==k)&&ob(a,k):\"number\"===typeof k&&ob(a,\"\"+k):\"suppressContentEditableWarning\"!==f&&\"suppressHydrationWarning\"!==f&&\"autoFocus\"!==f&&(ea.hasOwnProperty(f)?null!=k&&\"onScroll\"===f&&D(\"scroll\",a):null!=k&&ta(a,f,k,g))}switch(c){case \"input\":Va(a);db(a,d,!1);break;case \"textarea\":Va(a);jb(a);break;case \"option\":null!=d.value&&a.setAttribute(\"value\",\"\"+Sa(d.value));break;case \"select\":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,\n!0);break;default:\"function\"===typeof e.onClick&&(a.onclick=Bf)}switch(c){case \"button\":case \"input\":case \"select\":case \"textarea\":d=!!d.autoFocus;break a;case \"img\":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}S(b);return null;case 6:if(a&&null!=b.stateNode)Dj(a,b,a.memoizedProps,d);else{if(\"string\"!==typeof d&&null===b.stateNode)throw Error(p(166));c=Hh(Gh.current);Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=\nxg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d}S(b);return null;case 13:E(M);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=!1;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===\na){if(!f)throw Error(p(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p(317));f[Of]=b}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=!1}else null!==zg&&(Gj(zg),zg=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(M.current&1)?0===T&&(T=3):uj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return Jh(),\nBj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return Rg(b.type._context),S(b),null;case 17:return Zf(b.type)&&$f(),S(b),null;case 19:E(M);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Ej(f,!1);else{if(0!==T||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Mh(a);if(null!==g){b.flags|=128;Ej(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,\ng=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(M,M.current&1|2);return b.child}a=\na.sibling}null!==f.tail&&B()>Hj&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304)}else{if(!d)if(a=Mh(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Ej(f,!0),null===f.tail&&\"hidden\"===f.tailMode&&!g.alternate&&!I)return S(b),null}else 2*B()-f.renderingStartTime>Hj&&1073741824!==c&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=\nb,f.tail=b.sibling,f.renderingStartTime=B(),b.sibling=null,c=M.current,G(M,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Ij(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(gj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}\nfunction Jj(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return Jh(),E(Wf),E(H),Oh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Lh(b),null;case 13:E(M);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));Ig()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(M),null;case 4:return Jh(),null;case 10:return Rg(b.type._context),null;case 22:case 23:return Ij(),\nnull;case 24:return null;default:return null}}var Kj=!1,U=!1,Lj=\"function\"===typeof WeakSet?WeakSet:Set,V=null;function Mj(a,b){var c=a.ref;if(null!==c)if(\"function\"===typeof c)try{c(null)}catch(d){W(a,b,d)}else c.current=null}function Nj(a,b,c){try{c()}catch(d){W(a,b,d)}}var Oj=!1;\nfunction Pj(a,b){Cf=dd;a=Me();if(Ne(a)){if(\"selectionStart\"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=\nq.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode}q=y}c=-1===h||-1===k?null:{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Df={focusedElem:a,selectionRange:c};dd=!1;for(V=b;null!==V;)if(b=V,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V=a;else for(;null!==V;){b=V;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;\ncase 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Lg(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent=\"\":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(F){W(b,b.return,F)}a=b.sibling;if(null!==a){a.return=b.return;V=a;break}V=b.return}n=Oj;Oj=!1;return n}\nfunction Qj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Nj(b,c,f)}e=e.next}while(e!==d)}}function Rj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Sj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}\"function\"===typeof b?b(a):b.current=a}}\nfunction Tj(a){var b=a.alternate;null!==b&&(a.alternate=null,Tj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Uj(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction Vj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Uj(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}\nfunction Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling}\nfunction Xj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Xj(a,b,c),a=a.sibling;null!==a;)Xj(a,b,c),a=a.sibling}var X=null,Yj=!1;function Zj(a,b,c){for(c=c.child;null!==c;)ak(a,b,c),c=c.sibling}\nfunction ak(a,b,c){if(lc&&\"function\"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c)}catch(h){}switch(c.tag){case 5:U||Mj(c,b);case 6:var d=X,e=Yj;X=null;Zj(a,b,c);X=d;Yj=e;null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X,c.stateNode));break;case 4:d=X;e=Yj;X=c.stateNode.containerInfo;Yj=!0;\nZj(a,b,c);X=d;Yj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Nj(c,b,g):0!==(f&4)&&Nj(c,b,g));e=e.next}while(e!==d)}Zj(a,b,c);break;case 1:if(!U&&(Mj(c,b),d=c.stateNode,\"function\"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){W(c,b,h)}Zj(a,b,c);break;case 21:Zj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==\nc.memoizedState,Zj(a,b,c),U=d):Zj(a,b,c);break;default:Zj(a,b,c)}}function bk(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Lj);b.forEach(function(b){var d=ck.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction dk(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Yj=!1;break a;case 3:X=h.stateNode.containerInfo;Yj=!0;break a;case 4:X=h.stateNode.containerInfo;Yj=!0;break a}h=h.return}if(null===X)throw Error(p(160));ak(f,g,e);X=null;Yj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){W(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)ek(b,a),b=b.sibling}\nfunction ek(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:dk(b,a);fk(a);if(d&4){try{Qj(3,a,a.return),Rj(3,a)}catch(t){W(a,a.return,t)}try{Qj(5,a,a.return)}catch(t){W(a,a.return,t)}}break;case 1:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);break;case 5:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,\"\")}catch(t){W(a,a.return,t)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;\na.updateQueue=null;if(null!==k)try{\"input\"===h&&\"radio\"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];\"style\"===m?sb(e,q):\"dangerouslySetInnerHTML\"===m?nb(e,q):\"children\"===m?ob(e,q):ta(e,m,q,l)}switch(h){case \"input\":bb(e,f);break;case \"textarea\":ib(e,f);break;case \"select\":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,\nf.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:\"\",!1))}e[Pf]=f}catch(t){W(a,a.return,t)}}break;case 6:dk(b,a);fk(a);if(d&4){if(null===a.stateNode)throw Error(p(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f}catch(t){W(a,a.return,t)}}break;case 3:dk(b,a);fk(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo)}catch(t){W(a,a.return,t)}break;case 4:dk(b,a);fk(a);break;case 13:dk(b,a);fk(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||\nnull!==e.alternate&&null!==e.alternate.memoizedState||(gk=B()));d&4&&bk(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,dk(b,a),U=l):dk(b,a);fk(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V=a,m=a.child;null!==m;){for(q=V=m;null!==V;){r=V;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Qj(4,r,r.return);break;case 1:Mj(r,r.return);var n=r.stateNode;if(\"function\"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=\nb.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount()}catch(t){W(d,c,t)}}break;case 5:Mj(r,r.return);break;case 22:if(null!==r.memoizedState){hk(q);continue}}null!==y?(y.return=r,V=y):hk(q)}m=m.sibling}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,\"function\"===typeof f.setProperty?f.setProperty(\"display\",\"none\",\"important\"):f.display=\"none\"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty(\"display\")?k.display:null,h.style.display=\nrb(\"display\",g))}catch(t){W(a,a.return,t)}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?\"\":q.memoizedProps}catch(t){W(a,a.return,t)}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling}}break;case 19:dk(b,a);fk(a);d&4&&bk(a);break;case 21:break;default:dk(b,\na),fk(a)}}function fk(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Uj(c)){var d=c;break a}c=c.return}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,\"\"),d.flags&=-33);var f=Vj(a);Xj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Vj(a);Wj(a,h,g);break;default:throw Error(p(161));}}catch(k){W(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function ik(a,b,c){V=a;jk(a,b,c)}\nfunction jk(a,b,c){for(var d=0!==(a.mode&1);null!==V;){var e=V,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Kj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Kj;var l=U;Kj=g;if((U=k)&&!l)for(V=e;null!==V;)g=V,k=g.child,22===g.tag&&null!==g.memoizedState?kk(e):null!==k?(k.return=g,V=k):kk(e);for(;null!==f;)V=f,jk(f,b,c),f=f.sibling;V=e;Kj=h;U=l}lk(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V=f):lk(a,b,c)}}\nfunction lk(a){for(;null!==V;){var b=V;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Rj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:Lg(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&ih(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=\nb.child.stateNode;break;case 1:c=b.child.stateNode}ih(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case \"button\":case \"input\":case \"select\":case \"textarea\":k.autoFocus&&c.focus();break;case \"img\":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;\ndefault:throw Error(p(163));}U||b.flags&512&&Sj(b)}catch(r){W(b,b.return,r)}}if(b===a){V=null;break}c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}function hk(a){for(;null!==V;){var b=V;if(b===a){V=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}\nfunction kk(a){for(;null!==V;){var b=V;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Rj(4,b)}catch(k){W(b,c,k)}break;case 1:var d=b.stateNode;if(\"function\"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){W(b,e,k)}}var f=b.return;try{Sj(b)}catch(k){W(b,f,k)}break;case 5:var g=b.return;try{Sj(b)}catch(k){W(b,g,k)}}}catch(k){W(b,b.return,k)}if(b===a){V=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V=h;break}V=b.return}}\nvar mk=Math.ceil,nk=ua.ReactCurrentDispatcher,ok=ua.ReactCurrentOwner,pk=ua.ReactCurrentBatchConfig,K=0,R=null,Y=null,Z=0,gj=0,fj=Uf(0),T=0,qk=null,hh=0,rk=0,sk=0,tk=null,uk=null,gk=0,Hj=Infinity,vk=null,Pi=!1,Qi=null,Si=null,wk=!1,xk=null,yk=0,zk=0,Ak=null,Bk=-1,Ck=0;function L(){return 0!==(K&6)?B():-1!==Bk?Bk:Bk=B()}\nfunction lh(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==Kg.transition)return 0===Ck&&(Ck=yc()),Ck;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function mh(a,b,c,d){if(50<zk)throw zk=0,Ak=null,Error(p(185));Ac(a,c,d);if(0===(K&2)||a!==R)a===R&&(0===(K&2)&&(rk|=c),4===T&&Dk(a,Z)),Ek(a,d),1===c&&0===K&&0===(b.mode&1)&&(Hj=B()+500,fg&&jg())}\nfunction Ek(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===R?Z:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Fk.bind(null,a)):hg(Fk.bind(null,a)),Jf(function(){0===(K&6)&&jg()}),c=null;else{switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc}c=Gk(c,Hk.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}\nfunction Hk(a,b){Bk=-1;Ck=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(Ik()&&a.callbackNode!==c)return null;var d=uc(a,a===R?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Jk(a,d);else{b=d;var e=K;K|=2;var f=Kk();if(R!==a||Z!==b)vk=null,Hj=B()+500,Lk(a,b);do try{Mk();break}catch(h){Nk(a,h)}while(1);Qg();nk.current=f;K=e;null!==Y?b=0:(R=null,Z=0,b=T)}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Ok(a,e)));if(1===b)throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;if(6===b)Dk(a,d);\nelse{e=a.current.alternate;if(0===(d&30)&&!Pk(e)&&(b=Jk(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Ok(a,f))),1===b))throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Qk(a,uk,vk);break;case 3:Dk(a,d);if((d&130023424)===d&&(b=gk+500-B(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){L();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),b);break}Qk(a,uk,vk);break;case 4:Dk(a,d);if((d&4194240)===\nd)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*mk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),d);break}Qk(a,uk,vk);break;case 5:Qk(a,uk,vk);break;default:throw Error(p(329));}}}Ek(a,B());return a.callbackNode===c?Hk.bind(null,a):null}\nfunction Ok(a,b){var c=tk;a.current.memoizedState.isDehydrated&&(Lk(a,b).flags|=256);a=Jk(a,b);2!==a&&(b=uk,uk=c,null!==b&&Gj(b));return a}function Gj(a){null===uk?uk=a:uk.push.apply(uk,a)}\nfunction Pk(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}\nfunction Dk(a,b){b&=~sk;b&=~rk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d}}function Fk(a){if(0!==(K&6))throw Error(p(327));Ik();var b=uc(a,0);if(0===(b&1))return Ek(a,B()),null;var c=Jk(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Ok(a,d))}if(1===c)throw c=qk,Lk(a,0),Dk(a,b),Ek(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Qk(a,uk,vk);Ek(a,B());return null}\nfunction Rk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Hj=B()+500,fg&&jg())}}function Sk(a){null!==xk&&0===xk.tag&&0===(K&6)&&Ik();var b=K;K|=1;var c=pk.transition,d=C;try{if(pk.transition=null,C=1,a)return a()}finally{C=d,pk.transition=c,K=b,0===(K&6)&&jg()}}function Ij(){gj=fj.current;E(fj)}\nfunction Lk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:Jh();E(Wf);E(H);Oh();break;case 5:Lh(d);break;case 4:Jh();break;case 13:E(M);break;case 19:E(M);break;case 10:Rg(d.type._context);break;case 22:case 23:Ij()}c=c.return}R=a;Y=a=wh(a.current,null);Z=gj=b;T=0;qk=null;sk=rk=hh=0;uk=tk=null;if(null!==Wg){for(b=\n0;b<Wg.length;b++)if(c=Wg[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}Wg=null}return a}\nfunction Nk(a,b){do{var c=Y;try{Qg();Ph.current=ai;if(Sh){for(var d=N.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Sh=!1}Rh=0;P=O=N=null;Th=!1;Uh=0;ok.current=null;if(null===c||null===c.return){T=1;qk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&\"object\"===typeof k&&\"function\"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,\nm.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null)}var y=Vi(g);if(null!==y){y.flags&=-257;Wi(y,g,h,f,b);y.mode&1&&Ti(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t}else n.add(k);break a}else{if(0===(b&1)){Ti(f,l,b);uj();break a}k=Error(p(426))}}else if(I&&h.mode&1){var J=Vi(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Wi(J,g,h,f,b);Jg(Ki(k,h));break a}}f=k=Ki(k,h);4!==T&&(T=2);null===tk?tk=[f]:tk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;\nb&=-b;f.lanes|=b;var x=Oi(f,k,b);fh(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&(\"function\"===typeof w.getDerivedStateFromError||null!==u&&\"function\"===typeof u.componentDidCatch&&(null===Si||!Si.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Ri(f,h,b);fh(f,F);break a}}f=f.return}while(null!==f)}Tk(c)}catch(na){b=na;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function Kk(){var a=nk.current;nk.current=ai;return null===a?ai:a}\nfunction uj(){if(0===T||3===T||2===T)T=4;null===R||0===(hh&268435455)&&0===(rk&268435455)||Dk(R,Z)}function Jk(a,b){var c=K;K|=2;var d=Kk();if(R!==a||Z!==b)vk=null,Lk(a,b);do try{Uk();break}catch(e){Nk(a,e)}while(1);Qg();K=c;nk.current=d;if(null!==Y)throw Error(p(261));R=null;Z=0;return T}function Uk(){for(;null!==Y;)Vk(Y)}function Mk(){for(;null!==Y&&!cc();)Vk(Y)}function Vk(a){var b=Wk(a.alternate,a,gj);a.memoizedProps=a.pendingProps;null===b?Tk(a):Y=b;ok.current=null}\nfunction Tk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Fj(c,b,gj),null!==c){Y=c;return}}else{c=Jj(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===T&&(T=5)}function Qk(a,b,c){var d=C,e=pk.transition;try{pk.transition=null,C=1,Xk(a,b,c,d)}finally{pk.transition=e,C=d}return null}\nfunction Xk(a,b,c,d){do Ik();while(null!==xk);if(0!==(K&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===R&&(Y=R=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||wk||(wk=!0,Gk(hc,function(){Ik();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=pk.transition;pk.transition=null;\nvar g=C;C=1;var h=K;K|=4;ok.current=null;Pj(a,c);ek(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;ik(c,a,e);dc();K=h;C=g;pk.transition=f}else a.current=c;wk&&(wk=!1,xk=a,yk=e);f=a.pendingLanes;0===f&&(Si=null);mc(c.stateNode,d);Ek(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Pi)throw Pi=!1,a=Qi,Qi=null,a;0!==(yk&1)&&0!==a.tag&&Ik();f=a.pendingLanes;0!==(f&1)?a===Ak?zk++:(zk=0,Ak=a):zk=0;jg();return null}\nfunction Ik(){if(null!==xk){var a=Dc(yk),b=pk.transition,c=C;try{pk.transition=null;C=16>a?16:a;if(null===xk)var d=!1;else{a=xk;xk=null;yk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(V=a.current;null!==V;){var f=V,g=f.child;if(0!==(V.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V=l;null!==V;){var m=V;switch(m.tag){case 0:case 11:case 15:Qj(8,m,f)}var q=m.child;if(null!==q)q.return=m,V=q;else for(;null!==V;){m=V;var r=m.sibling,y=m.return;Tj(m);if(m===\nl){V=null;break}if(null!==r){r.return=y;V=r;break}V=y}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J}while(null!==t)}}V=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V=g;else b:for(;null!==V;){f=V;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Qj(9,f,f.return)}var x=f.sibling;if(null!==x){x.return=f.return;V=x;break b}V=f.return}}var w=a.current;for(V=w;null!==V;){g=V;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==\nu)u.return=g,V=u;else b:for(g=w;null!==V;){h=V;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Rj(9,h)}}catch(na){W(h,h.return,na)}if(h===g){V=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V=F;break b}V=h.return}}K=e;jg();if(lc&&\"function\"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a)}catch(na){}d=!0}return d}finally{C=c,pk.transition=b}}return!1}function Yk(a,b,c){b=Ki(c,b);b=Oi(a,b,1);a=dh(a,b,1);b=L();null!==a&&(Ac(a,1,b),Ek(a,b))}\nfunction W(a,b,c){if(3===a.tag)Yk(a,a,c);else for(;null!==b;){if(3===b.tag){Yk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if(\"function\"===typeof b.type.getDerivedStateFromError||\"function\"===typeof d.componentDidCatch&&(null===Si||!Si.has(d))){a=Ki(c,a);a=Ri(b,a,1);b=dh(b,a,1);a=L();null!==b&&(Ac(b,1,a),Ek(b,a));break}}b=b.return}}\nfunction Ui(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=L();a.pingedLanes|=a.suspendedLanes&c;R===a&&(Z&c)===c&&(4===T||3===T&&(Z&130023424)===Z&&500>B()-gk?Lk(a,0):sk|=c);Ek(a,b)}function Zk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=L();a=Zg(a,b);null!==a&&(Ac(a,b,c),Ek(a,c))}function vj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Zk(a,c)}\nfunction ck(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Zk(a,c)}var Wk;\nWk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)Ug=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return Ug=!1,zj(a,b,c);Ug=0!==(a.flags&131072)?!0:!1}else Ug=!1,I&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;jj(a,b);a=b.pendingProps;var e=Yf(b,H.current);Tg(b,c);e=Xh(null,b,d,a,e,c);var f=bi();b.flags|=1;\"object\"===typeof e&&null!==e&&\"function\"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=\nnull,Zf(d)?(f=!0,cg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,ah(b),e.updater=nh,b.stateNode=e,e._reactInternals=b,rh(b,d,a,c),b=kj(null,b,d,!0,f,c)):(b.tag=0,I&&f&&vg(b),Yi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{jj(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=$k(d);a=Lg(d,a);switch(e){case 0:b=dj(null,b,d,a,c);break a;case 1:b=ij(null,b,d,a,c);break a;case 11:b=Zi(null,b,d,a,c);break a;case 14:b=aj(null,b,d,Lg(d.type,a),c);break a}throw Error(p(306,\nd,\"\"));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),dj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),ij(a,b,d,e,c);case 3:a:{lj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;bh(a,b);gh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=\nf,b.memoizedState=f,b.flags&256){e=Ki(Error(p(423)),b);b=mj(a,b,d,c,e);break a}else if(d!==e){e=Ki(Error(p(424)),b);b=mj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I=!0,zg=null,c=Ch(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{Ig();if(d===e){b=$i(a,b,c);break a}Yi(a,b,d,c)}b=b.child}return b;case 5:return Kh(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),\nhj(a,b),Yi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return pj(a,b,c);case 4:return Ih(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Bh(b,null,d,c):Yi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),Zi(a,b,d,e,c);case 7:return Yi(a,b,b.pendingProps,c),b.child;case 8:return Yi(a,b,b.pendingProps.children,c),b.child;case 12:return Yi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;\ng=e.value;G(Mg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=$i(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=ch(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);Sg(f.return,\nc,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);Sg(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}Yi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,d=b.pendingProps.children,Tg(b,c),e=Vg(e),d=d(e),b.flags|=1,Yi(a,b,d,c),\nb.child;case 14:return d=b.type,e=Lg(d,b.pendingProps),e=Lg(d.type,e),aj(a,b,d,e,c);case 15:return cj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),jj(a,b),b.tag=1,Zf(d)?(a=!0,cg(b)):a=!1,Tg(b,c),ph(b,d,e),rh(b,d,e,c),kj(null,b,d,!0,a,c);case 19:return yj(a,b,c);case 22:return ej(a,b,c)}throw Error(p(156,b.tag));};function Gk(a,b){return ac(a,b)}\nfunction al(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function Bg(a,b,c,d){return new al(a,b,c,d)}function bj(a){a=a.prototype;return!(!a||!a.isReactComponent)}\nfunction $k(a){if(\"function\"===typeof a)return bj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}\nfunction wh(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction yh(a,b,c,d,e,f){var g=2;d=a;if(\"function\"===typeof a)bj(a)&&(g=1);else if(\"string\"===typeof a)g=5;else a:switch(a){case ya:return Ah(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return qj(c,e,f,b);default:if(\"object\"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;\nbreak a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,\"\"));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Ah(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function qj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:!1};return a}function xh(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}\nfunction zh(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction bl(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=\nnull}function cl(a,b,c,d,e,f,g,h,k){a=new bl(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};ah(f);return a}function dl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:wa,key:null==d?null:\"\"+d,children:a,containerInfo:b,implementation:c}}\nfunction el(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}\nfunction fl(a,b,c,d,e,f,g,h,k){a=cl(c,d,!0,a,e,f,g,h,k);a.context=el(null);c=a.current;d=L();e=lh(c);f=ch(d,e);f.callback=void 0!==b&&null!==b?b:null;dh(c,f,e);a.current.lanes=e;Ac(a,e,d);Ek(a,d);return a}function gl(a,b,c,d){var e=b.current,f=L(),g=lh(e);c=el(c);null===b.context?b.context=c:b.pendingContext=c;b=ch(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=dh(e,b,g);null!==a&&(mh(a,e,g,f),eh(a,e,g));return g}\nfunction hl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function il(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function jl(a,b){il(a,b);(a=a.alternate)&&il(a,b)}function kl(){return null}var ll=\"function\"===typeof reportError?reportError:function(a){console.error(a)};function ml(a){this._internalRoot=a}\nnl.prototype.render=ml.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));gl(a,b,null,null)};nl.prototype.unmount=ml.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Sk(function(){gl(null,a,null,null)});b[uf]=null}};function nl(a){this._internalRoot=a}\nnl.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a)}};function ol(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function pl(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||\" react-mount-point-unstable \"!==a.nodeValue))}function ql(){}\nfunction rl(a,b,c,d,e){if(e){if(\"function\"===typeof d){var f=d;d=function(){var a=hl(g);f.call(a)}}var g=fl(b,d,a,0,null,!1,!1,\"\",ql);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Sk();return g}for(;e=a.lastChild;)a.removeChild(e);if(\"function\"===typeof d){var h=d;d=function(){var a=hl(k);h.call(a)}}var k=cl(a,0,!1,null,null,!1,!1,\"\",ql);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Sk(function(){gl(b,k,c,d)});return k}\nfunction sl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if(\"function\"===typeof e){var h=e;e=function(){var a=hl(g);h.call(a)}}gl(b,g,a,e)}else g=rl(c,b,a,e,d);return hl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Ek(b,B()),0===(K&6)&&(Hj=B()+500,jg()))}break;case 13:Sk(function(){var b=Zg(a,1);if(null!==b){var c=L();mh(b,a,1,c)}}),jl(a,1)}};\nFc=function(a){if(13===a.tag){var b=Zg(a,134217728);if(null!==b){var c=L();mh(b,a,134217728,c)}jl(a,134217728)}};Gc=function(a){if(13===a.tag){var b=lh(a),c=Zg(a,b);if(null!==c){var d=L();mh(c,a,b,d)}jl(a,b)}};Hc=function(){return C};Ic=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};\nyb=function(a,b,c){switch(b){case \"input\":bb(a,c);b=c.name;if(\"radio\"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll(\"input[name=\"+JSON.stringify(\"\"+b)+'][type=\"radio\"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p(90));Wa(d);bb(d,e)}}}break;case \"textarea\":ib(a,c);break;case \"select\":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Rk;Hb=Sk;\nvar tl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Rk]},ul={findFiberByHostInstance:Wc,bundleType:0,version:\"18.2.0\",rendererPackageName:\"react-dom\"};\nvar vl={bundleType:ul.bundleType,version:ul.version,rendererPackageName:ul.rendererPackageName,rendererConfig:ul.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:ul.findFiberByHostInstance||\nkl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:\"18.2.0-next-9e3b772b8-20220608\"};if(\"undefined\"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var wl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!wl.isDisabled&&wl.supportsFiber)try{kc=wl.inject(vl),lc=wl}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=tl;\nexports.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!ol(b))throw Error(p(200));return dl(a,b,null,c)};exports.createRoot=function(a,b){if(!ol(a))throw Error(p(299));var c=!1,d=\"\",e=ll;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=cl(a,1,!1,null,null,c,!1,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ml(b)};\nexports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if(\"function\"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(\",\");throw Error(p(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a){return Sk(a)};exports.hydrate=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!0,c)};\nexports.hydrateRoot=function(a,b,c){if(!ol(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f=\"\",g=ll;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=fl(b,null,a,1,null!=c?c:null,e,!1,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,\ne);return new nl(b)};exports.render=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!pl(a))throw Error(p(40));return a._reactRootContainer?(Sk(function(){sl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null})}),!0):!1};exports.unstable_batchedUpdates=Rk;\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!pl(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return sl(a,b,c,!1,d)};exports.version=\"18.2.0-next-9e3b772b8-20220608\";\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { USUAL_WORD_SEPARATORS } from '../core/wordHelper.js';\nimport * as arrays from '../../../base/common/arrays.js';\nimport * as objects from '../../../base/common/objects.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\n/**\n * @internal\n * The width of the minimap gutter, in pixels.\n */\nexport const MINIMAP_GUTTER_WIDTH = 8;\n//#endregion\n/**\n * An event describing that the configuration of the editor has changed.\n */\nexport class ConfigurationChangedEvent {\n    /**\n     * @internal\n     */\n    constructor(values) {\n        this._values = values;\n    }\n    hasChanged(id) {\n        return this._values[id];\n    }\n}\n/**\n * @internal\n */\nexport class ComputeOptionsMemory {\n    constructor() {\n        this.stableMinimapLayoutInput = null;\n        this.stableFitMaxMinimapScale = 0;\n        this.stableFitRemainingWidth = 0;\n    }\n}\n/**\n * @internal\n */\nclass BaseEditorOption {\n    constructor(id, name, defaultValue, schema) {\n        this.id = id;\n        this.name = name;\n        this.defaultValue = defaultValue;\n        this.schema = schema;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    compute(env, options, value) {\n        return value;\n    }\n}\nexport class ApplyUpdateResult {\n    constructor(newValue, didChange) {\n        this.newValue = newValue;\n        this.didChange = didChange;\n    }\n}\nfunction applyUpdate(value, update) {\n    if (typeof value !== 'object' || typeof update !== 'object' || !value || !update) {\n        return new ApplyUpdateResult(update, value !== update);\n    }\n    if (Array.isArray(value) || Array.isArray(update)) {\n        const arrayEquals = Array.isArray(value) && Array.isArray(update) && arrays.equals(value, update);\n        return new ApplyUpdateResult(update, !arrayEquals);\n    }\n    let didChange = false;\n    for (const key in update) {\n        if (update.hasOwnProperty(key)) {\n            const result = applyUpdate(value[key], update[key]);\n            if (result.didChange) {\n                value[key] = result.newValue;\n                didChange = true;\n            }\n        }\n    }\n    return new ApplyUpdateResult(value, didChange);\n}\n/**\n * @internal\n */\nclass ComputedEditorOption {\n    constructor(id) {\n        this.schema = undefined;\n        this.id = id;\n        this.name = '_never_';\n        this.defaultValue = undefined;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    validate(input) {\n        return this.defaultValue;\n    }\n}\nclass SimpleEditorOption {\n    constructor(id, name, defaultValue, schema) {\n        this.id = id;\n        this.name = name;\n        this.defaultValue = defaultValue;\n        this.schema = schema;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        return input;\n    }\n    compute(env, options, value) {\n        return value;\n    }\n}\n/**\n * @internal\n */\nexport function boolean(value, defaultValue) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    if (value === 'false') {\n        // treat the string 'false' as false\n        return false;\n    }\n    return Boolean(value);\n}\nclass EditorBooleanOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'boolean';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n    }\n    validate(input) {\n        return boolean(input, this.defaultValue);\n    }\n}\n/**\n * @internal\n */\nexport function clampedInt(value, defaultValue, minimum, maximum) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    let r = parseInt(value, 10);\n    if (isNaN(r)) {\n        return defaultValue;\n    }\n    r = Math.max(minimum, r);\n    r = Math.min(maximum, r);\n    return r | 0;\n}\nclass EditorIntOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, minimum, maximum, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'integer';\n            schema.default = defaultValue;\n            schema.minimum = minimum;\n            schema.maximum = maximum;\n        }\n        super(id, name, defaultValue, schema);\n        this.minimum = minimum;\n        this.maximum = maximum;\n    }\n    static clampedInt(value, defaultValue, minimum, maximum) {\n        return clampedInt(value, defaultValue, minimum, maximum);\n    }\n    validate(input) {\n        return EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);\n    }\n}\nclass EditorFloatOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, validationFn, schema) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'number';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n        this.validationFn = validationFn;\n    }\n    static clamp(n, min, max) {\n        if (n < min) {\n            return min;\n        }\n        if (n > max) {\n            return max;\n        }\n        return n;\n    }\n    static float(value, defaultValue) {\n        if (typeof value === 'number') {\n            return value;\n        }\n        if (typeof value === 'undefined') {\n            return defaultValue;\n        }\n        const r = parseFloat(value);\n        return (isNaN(r) ? defaultValue : r);\n    }\n    validate(input) {\n        return this.validationFn(EditorFloatOption.float(input, this.defaultValue));\n    }\n}\nclass EditorStringOption extends SimpleEditorOption {\n    static string(value, defaultValue) {\n        if (typeof value !== 'string') {\n            return defaultValue;\n        }\n        return value;\n    }\n    constructor(id, name, defaultValue, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n    }\n    validate(input) {\n        return EditorStringOption.string(input, this.defaultValue);\n    }\n}\n/**\n * @internal\n */\nexport function stringSet(value, defaultValue, allowedValues) {\n    if (typeof value !== 'string') {\n        return defaultValue;\n    }\n    if (allowedValues.indexOf(value) === -1) {\n        return defaultValue;\n    }\n    return value;\n}\nclass EditorStringEnumOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, allowedValues, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.enum = allowedValues;\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n        this._allowedValues = allowedValues;\n    }\n    validate(input) {\n        return stringSet(input, this.defaultValue, this._allowedValues);\n    }\n}\nclass EditorEnumOption extends BaseEditorOption {\n    constructor(id, name, defaultValue, defaultStringValue, allowedValues, convert, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.enum = allowedValues;\n            schema.default = defaultStringValue;\n        }\n        super(id, name, defaultValue, schema);\n        this._allowedValues = allowedValues;\n        this._convert = convert;\n    }\n    validate(input) {\n        if (typeof input !== 'string') {\n            return this.defaultValue;\n        }\n        if (this._allowedValues.indexOf(input) === -1) {\n            return this.defaultValue;\n        }\n        return this._convert(input);\n    }\n}\n//#endregion\n//#region autoIndent\nfunction _autoIndentFromString(autoIndent) {\n    switch (autoIndent) {\n        case 'none': return 0 /* EditorAutoIndentStrategy.None */;\n        case 'keep': return 1 /* EditorAutoIndentStrategy.Keep */;\n        case 'brackets': return 2 /* EditorAutoIndentStrategy.Brackets */;\n        case 'advanced': return 3 /* EditorAutoIndentStrategy.Advanced */;\n        case 'full': return 4 /* EditorAutoIndentStrategy.Full */;\n    }\n}\n//#endregion\n//#region accessibilitySupport\nclass EditorAccessibilitySupport extends BaseEditorOption {\n    constructor() {\n        super(2 /* EditorOption.accessibilitySupport */, 'accessibilitySupport', 0 /* AccessibilitySupport.Unknown */, {\n            type: 'string',\n            enum: ['auto', 'on', 'off'],\n            enumDescriptions: [\n                nls.localize('accessibilitySupport.auto', \"The editor will use platform APIs to detect when a Screen Reader is attached.\"),\n                nls.localize('accessibilitySupport.on', \"The editor will be permanently optimized for usage with a Screen Reader. Word wrapping will be disabled.\"),\n                nls.localize('accessibilitySupport.off', \"The editor will never be optimized for usage with a Screen Reader.\"),\n            ],\n            default: 'auto',\n            description: nls.localize('accessibilitySupport', \"Controls whether the editor should run in a mode where it is optimized for screen readers. Setting to on will disable word wrapping.\")\n        });\n    }\n    validate(input) {\n        switch (input) {\n            case 'auto': return 0 /* AccessibilitySupport.Unknown */;\n            case 'off': return 1 /* AccessibilitySupport.Disabled */;\n            case 'on': return 2 /* AccessibilitySupport.Enabled */;\n        }\n        return this.defaultValue;\n    }\n    compute(env, options, value) {\n        if (value === 0 /* AccessibilitySupport.Unknown */) {\n            // The editor reads the `accessibilitySupport` from the environment\n            return env.accessibilitySupport;\n        }\n        return value;\n    }\n}\nclass EditorComments extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            insertSpace: true,\n            ignoreEmptyLines: true,\n        };\n        super(19 /* EditorOption.comments */, 'comments', defaults, {\n            'editor.comments.insertSpace': {\n                type: 'boolean',\n                default: defaults.insertSpace,\n                description: nls.localize('comments.insertSpace', \"Controls whether a space character is inserted when commenting.\")\n            },\n            'editor.comments.ignoreEmptyLines': {\n                type: 'boolean',\n                default: defaults.ignoreEmptyLines,\n                description: nls.localize('comments.ignoreEmptyLines', 'Controls if empty lines should be ignored with toggle, add or remove actions for line comments.')\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            insertSpace: boolean(input.insertSpace, this.defaultValue.insertSpace),\n            ignoreEmptyLines: boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines),\n        };\n    }\n}\nfunction _cursorBlinkingStyleFromString(cursorBlinkingStyle) {\n    switch (cursorBlinkingStyle) {\n        case 'blink': return 1 /* TextEditorCursorBlinkingStyle.Blink */;\n        case 'smooth': return 2 /* TextEditorCursorBlinkingStyle.Smooth */;\n        case 'phase': return 3 /* TextEditorCursorBlinkingStyle.Phase */;\n        case 'expand': return 4 /* TextEditorCursorBlinkingStyle.Expand */;\n        case 'solid': return 5 /* TextEditorCursorBlinkingStyle.Solid */;\n    }\n}\n//#endregion\n//#region cursorStyle\n/**\n * The style in which the editor's cursor should be rendered.\n */\nexport var TextEditorCursorStyle;\n(function (TextEditorCursorStyle) {\n    /**\n     * As a vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Line\"] = 1] = \"Line\";\n    /**\n     * As a block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Block\"] = 2] = \"Block\";\n    /**\n     * As a horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Underline\"] = 3] = \"Underline\";\n    /**\n     * As a thin vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"LineThin\"] = 4] = \"LineThin\";\n    /**\n     * As an outlined block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"BlockOutline\"] = 5] = \"BlockOutline\";\n    /**\n     * As a thin horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));\nfunction _cursorStyleFromString(cursorStyle) {\n    switch (cursorStyle) {\n        case 'line': return TextEditorCursorStyle.Line;\n        case 'block': return TextEditorCursorStyle.Block;\n        case 'underline': return TextEditorCursorStyle.Underline;\n        case 'line-thin': return TextEditorCursorStyle.LineThin;\n        case 'block-outline': return TextEditorCursorStyle.BlockOutline;\n        case 'underline-thin': return TextEditorCursorStyle.UnderlineThin;\n    }\n}\n//#endregion\n//#region editorClassName\nclass EditorClassName extends ComputedEditorOption {\n    constructor() {\n        super(130 /* EditorOption.editorClassName */);\n    }\n    compute(env, options, _) {\n        const classNames = ['monaco-editor'];\n        if (options.get(35 /* EditorOption.extraEditorClassName */)) {\n            classNames.push(options.get(35 /* EditorOption.extraEditorClassName */));\n        }\n        if (env.extraEditorClassName) {\n            classNames.push(env.extraEditorClassName);\n        }\n        if (options.get(68 /* EditorOption.mouseStyle */) === 'default') {\n            classNames.push('mouse-default');\n        }\n        else if (options.get(68 /* EditorOption.mouseStyle */) === 'copy') {\n            classNames.push('mouse-copy');\n        }\n        if (options.get(102 /* EditorOption.showUnused */)) {\n            classNames.push('showUnused');\n        }\n        if (options.get(128 /* EditorOption.showDeprecated */)) {\n            classNames.push('showDeprecated');\n        }\n        return classNames.join(' ');\n    }\n}\n//#endregion\n//#region emptySelectionClipboard\nclass EditorEmptySelectionClipboard extends EditorBooleanOption {\n    constructor() {\n        super(33 /* EditorOption.emptySelectionClipboard */, 'emptySelectionClipboard', true, { description: nls.localize('emptySelectionClipboard', \"Controls whether copying without a selection copies the current line.\") });\n    }\n    compute(env, options, value) {\n        return value && env.emptySelectionClipboard;\n    }\n}\nclass EditorFind extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            cursorMoveOnType: true,\n            seedSearchStringFromSelection: 'always',\n            autoFindInSelection: 'never',\n            globalFindClipboard: false,\n            addExtraSpaceOnTop: true,\n            loop: true\n        };\n        super(37 /* EditorOption.find */, 'find', defaults, {\n            'editor.find.cursorMoveOnType': {\n                type: 'boolean',\n                default: defaults.cursorMoveOnType,\n                description: nls.localize('find.cursorMoveOnType', \"Controls whether the cursor should jump to find matches while typing.\")\n            },\n            'editor.find.seedSearchStringFromSelection': {\n                type: 'string',\n                enum: ['never', 'always', 'selection'],\n                default: defaults.seedSearchStringFromSelection,\n                enumDescriptions: [\n                    nls.localize('editor.find.seedSearchStringFromSelection.never', 'Never seed search string from the editor selection.'),\n                    nls.localize('editor.find.seedSearchStringFromSelection.always', 'Always seed search string from the editor selection, including word at cursor position.'),\n                    nls.localize('editor.find.seedSearchStringFromSelection.selection', 'Only seed search string from the editor selection.')\n                ],\n                description: nls.localize('find.seedSearchStringFromSelection', \"Controls whether the search string in the Find Widget is seeded from the editor selection.\")\n            },\n            'editor.find.autoFindInSelection': {\n                type: 'string',\n                enum: ['never', 'always', 'multiline'],\n                default: defaults.autoFindInSelection,\n                enumDescriptions: [\n                    nls.localize('editor.find.autoFindInSelection.never', 'Never turn on Find in Selection automatically (default).'),\n                    nls.localize('editor.find.autoFindInSelection.always', 'Always turn on Find in Selection automatically.'),\n                    nls.localize('editor.find.autoFindInSelection.multiline', 'Turn on Find in Selection automatically when multiple lines of content are selected.')\n                ],\n                description: nls.localize('find.autoFindInSelection', \"Controls the condition for turning on Find in Selection automatically.\")\n            },\n            'editor.find.globalFindClipboard': {\n                type: 'boolean',\n                default: defaults.globalFindClipboard,\n                description: nls.localize('find.globalFindClipboard', \"Controls whether the Find Widget should read or modify the shared find clipboard on macOS.\"),\n                included: platform.isMacintosh\n            },\n            'editor.find.addExtraSpaceOnTop': {\n                type: 'boolean',\n                default: defaults.addExtraSpaceOnTop,\n                description: nls.localize('find.addExtraSpaceOnTop', \"Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.\")\n            },\n            'editor.find.loop': {\n                type: 'boolean',\n                default: defaults.loop,\n                description: nls.localize('find.loop', \"Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            cursorMoveOnType: boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),\n            seedSearchStringFromSelection: typeof _input.seedSearchStringFromSelection === 'boolean'\n                ? (_input.seedSearchStringFromSelection ? 'always' : 'never')\n                : stringSet(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ['never', 'always', 'selection']),\n            autoFindInSelection: typeof _input.autoFindInSelection === 'boolean'\n                ? (_input.autoFindInSelection ? 'always' : 'never')\n                : stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ['never', 'always', 'multiline']),\n            globalFindClipboard: boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),\n            addExtraSpaceOnTop: boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),\n            loop: boolean(input.loop, this.defaultValue.loop),\n        };\n    }\n}\n//#endregion\n//#region fontLigatures\n/**\n * @internal\n */\nexport class EditorFontLigatures extends BaseEditorOption {\n    constructor() {\n        super(47 /* EditorOption.fontLigatures */, 'fontLigatures', EditorFontLigatures.OFF, {\n            anyOf: [\n                {\n                    type: 'boolean',\n                    description: nls.localize('fontLigatures', \"Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.\"),\n                },\n                {\n                    type: 'string',\n                    description: nls.localize('fontFeatureSettings', \"Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.\")\n                }\n            ],\n            description: nls.localize('fontLigaturesGeneral', \"Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property.\"),\n            default: false\n        });\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            if (input === 'false') {\n                return EditorFontLigatures.OFF;\n            }\n            if (input === 'true') {\n                return EditorFontLigatures.ON;\n            }\n            return input;\n        }\n        if (Boolean(input)) {\n            return EditorFontLigatures.ON;\n        }\n        return EditorFontLigatures.OFF;\n    }\n}\nEditorFontLigatures.OFF = '\"liga\" off, \"calt\" off';\nEditorFontLigatures.ON = '\"liga\" on, \"calt\" on';\n//#endregion\n//#region fontInfo\nclass EditorFontInfo extends ComputedEditorOption {\n    constructor() {\n        super(46 /* EditorOption.fontInfo */);\n    }\n    compute(env, options, _) {\n        return env.fontInfo;\n    }\n}\n//#endregion\n//#region fontSize\nclass EditorFontSize extends SimpleEditorOption {\n    constructor() {\n        super(48 /* EditorOption.fontSize */, 'fontSize', EDITOR_FONT_DEFAULTS.fontSize, {\n            type: 'number',\n            minimum: 6,\n            maximum: 100,\n            default: EDITOR_FONT_DEFAULTS.fontSize,\n            description: nls.localize('fontSize', \"Controls the font size in pixels.\")\n        });\n    }\n    validate(input) {\n        const r = EditorFloatOption.float(input, this.defaultValue);\n        if (r === 0) {\n            return EDITOR_FONT_DEFAULTS.fontSize;\n        }\n        return EditorFloatOption.clamp(r, 6, 100);\n    }\n    compute(env, options, value) {\n        // The final fontSize respects the editor zoom level.\n        // So take the result from env.fontInfo\n        return env.fontInfo.fontSize;\n    }\n}\n//#endregion\n//#region fontWeight\nclass EditorFontWeight extends BaseEditorOption {\n    constructor() {\n        super(49 /* EditorOption.fontWeight */, 'fontWeight', EDITOR_FONT_DEFAULTS.fontWeight, {\n            anyOf: [\n                {\n                    type: 'number',\n                    minimum: EditorFontWeight.MINIMUM_VALUE,\n                    maximum: EditorFontWeight.MAXIMUM_VALUE,\n                    errorMessage: nls.localize('fontWeightErrorMessage', \"Only \\\"normal\\\" and \\\"bold\\\" keywords or numbers between 1 and 1000 are allowed.\")\n                },\n                {\n                    type: 'string',\n                    pattern: '^(normal|bold|1000|[1-9][0-9]{0,2})$'\n                },\n                {\n                    enum: EditorFontWeight.SUGGESTION_VALUES\n                }\n            ],\n            default: EDITOR_FONT_DEFAULTS.fontWeight,\n            description: nls.localize('fontWeight', \"Controls the font weight. Accepts \\\"normal\\\" and \\\"bold\\\" keywords or numbers between 1 and 1000.\")\n        });\n    }\n    validate(input) {\n        if (input === 'normal' || input === 'bold') {\n            return input;\n        }\n        return String(EditorIntOption.clampedInt(input, EDITOR_FONT_DEFAULTS.fontWeight, EditorFontWeight.MINIMUM_VALUE, EditorFontWeight.MAXIMUM_VALUE));\n    }\n}\nEditorFontWeight.SUGGESTION_VALUES = ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900'];\nEditorFontWeight.MINIMUM_VALUE = 1;\nEditorFontWeight.MAXIMUM_VALUE = 1000;\nclass EditorGoToLocation extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            multiple: 'peek',\n            multipleDefinitions: 'peek',\n            multipleTypeDefinitions: 'peek',\n            multipleDeclarations: 'peek',\n            multipleImplementations: 'peek',\n            multipleReferences: 'peek',\n            alternativeDefinitionCommand: 'editor.action.goToReferences',\n            alternativeTypeDefinitionCommand: 'editor.action.goToReferences',\n            alternativeDeclarationCommand: 'editor.action.goToReferences',\n            alternativeImplementationCommand: '',\n            alternativeReferenceCommand: '',\n        };\n        const jsonSubset = {\n            type: 'string',\n            enum: ['peek', 'gotoAndPeek', 'goto'],\n            default: defaults.multiple,\n            enumDescriptions: [\n                nls.localize('editor.gotoLocation.multiple.peek', 'Show peek view of the results (default)'),\n                nls.localize('editor.gotoLocation.multiple.gotoAndPeek', 'Go to the primary result and show a peek view'),\n                nls.localize('editor.gotoLocation.multiple.goto', 'Go to the primary result and enable peek-less navigation to others')\n            ]\n        };\n        const alternativeCommandOptions = ['', 'editor.action.referenceSearch.trigger', 'editor.action.goToReferences', 'editor.action.peekImplementation', 'editor.action.goToImplementation', 'editor.action.peekTypeDefinition', 'editor.action.goToTypeDefinition', 'editor.action.peekDeclaration', 'editor.action.revealDeclaration', 'editor.action.peekDefinition', 'editor.action.revealDefinitionAside', 'editor.action.revealDefinition'];\n        super(53 /* EditorOption.gotoLocation */, 'gotoLocation', defaults, {\n            'editor.gotoLocation.multiple': {\n                deprecationMessage: nls.localize('editor.gotoLocation.multiple.deprecated', \"This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.\"),\n            },\n            'editor.gotoLocation.multipleDefinitions': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleDefinitions', \"Controls the behavior the 'Go to Definition'-command when multiple target locations exist.\") }, jsonSubset),\n            'editor.gotoLocation.multipleTypeDefinitions': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleTypeDefinitions', \"Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.\") }, jsonSubset),\n            'editor.gotoLocation.multipleDeclarations': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleDeclarations', \"Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.\") }, jsonSubset),\n            'editor.gotoLocation.multipleImplementations': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleImplemenattions', \"Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.\") }, jsonSubset),\n            'editor.gotoLocation.multipleReferences': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleReferences', \"Controls the behavior the 'Go to References'-command when multiple target locations exist.\") }, jsonSubset),\n            'editor.gotoLocation.alternativeDefinitionCommand': {\n                type: 'string',\n                default: defaults.alternativeDefinitionCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeDefinitionCommand', \"Alternative command id that is being executed when the result of 'Go to Definition' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeTypeDefinitionCommand': {\n                type: 'string',\n                default: defaults.alternativeTypeDefinitionCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeTypeDefinitionCommand', \"Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeDeclarationCommand': {\n                type: 'string',\n                default: defaults.alternativeDeclarationCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeDeclarationCommand', \"Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeImplementationCommand': {\n                type: 'string',\n                default: defaults.alternativeImplementationCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeImplementationCommand', \"Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeReferenceCommand': {\n                type: 'string',\n                default: defaults.alternativeReferenceCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeReferenceCommand', \"Alternative command id that is being executed when the result of 'Go to Reference' is the current location.\")\n            },\n        });\n    }\n    validate(_input) {\n        var _a, _b, _c, _d, _e;\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            multiple: stringSet(input.multiple, this.defaultValue.multiple, ['peek', 'gotoAndPeek', 'goto']),\n            multipleDefinitions: (_a = input.multipleDefinitions) !== null && _a !== void 0 ? _a : stringSet(input.multipleDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleTypeDefinitions: (_b = input.multipleTypeDefinitions) !== null && _b !== void 0 ? _b : stringSet(input.multipleTypeDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleDeclarations: (_c = input.multipleDeclarations) !== null && _c !== void 0 ? _c : stringSet(input.multipleDeclarations, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleImplementations: (_d = input.multipleImplementations) !== null && _d !== void 0 ? _d : stringSet(input.multipleImplementations, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleReferences: (_e = input.multipleReferences) !== null && _e !== void 0 ? _e : stringSet(input.multipleReferences, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),\n            alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),\n            alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),\n            alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),\n            alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),\n        };\n    }\n}\nclass EditorHover extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            delay: 300,\n            sticky: true,\n            above: true,\n        };\n        super(55 /* EditorOption.hover */, 'hover', defaults, {\n            'editor.hover.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('hover.enabled', \"Controls whether the hover is shown.\")\n            },\n            'editor.hover.delay': {\n                type: 'number',\n                default: defaults.delay,\n                minimum: 0,\n                maximum: 10000,\n                description: nls.localize('hover.delay', \"Controls the delay in milliseconds after which the hover is shown.\")\n            },\n            'editor.hover.sticky': {\n                type: 'boolean',\n                default: defaults.sticky,\n                description: nls.localize('hover.sticky', \"Controls whether the hover should remain visible when mouse is moved over it.\")\n            },\n            'editor.hover.above': {\n                type: 'boolean',\n                default: defaults.above,\n                description: nls.localize('hover.above', \"Prefer showing hovers above the line, if there's space.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 10000),\n            sticky: boolean(input.sticky, this.defaultValue.sticky),\n            above: boolean(input.above, this.defaultValue.above),\n        };\n    }\n}\n/**\n * @internal\n */\nexport class EditorLayoutInfoComputer extends ComputedEditorOption {\n    constructor() {\n        super(133 /* EditorOption.layoutInfo */);\n    }\n    compute(env, options, _) {\n        return EditorLayoutInfoComputer.computeLayout(options, {\n            memory: env.memory,\n            outerWidth: env.outerWidth,\n            outerHeight: env.outerHeight,\n            isDominatedByLongLines: env.isDominatedByLongLines,\n            lineHeight: env.fontInfo.lineHeight,\n            viewLineCount: env.viewLineCount,\n            lineNumbersDigitCount: env.lineNumbersDigitCount,\n            typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,\n            maxDigitWidth: env.fontInfo.maxDigitWidth,\n            pixelRatio: env.pixelRatio\n        });\n    }\n    static computeContainedMinimapLineCount(input) {\n        const typicalViewportLineCount = input.height / input.lineHeight;\n        const extraLinesBeyondLastLine = input.scrollBeyondLastLine ? (typicalViewportLineCount - 1) : 0;\n        const desiredRatio = (input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);\n        const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);\n        return { typicalViewportLineCount, extraLinesBeyondLastLine, desiredRatio, minimapLineCount };\n    }\n    static _computeMinimapLayout(input, memory) {\n        const outerWidth = input.outerWidth;\n        const outerHeight = input.outerHeight;\n        const pixelRatio = input.pixelRatio;\n        if (!input.minimap.enabled) {\n            return {\n                renderMinimap: 0 /* RenderMinimap.None */,\n                minimapLeft: 0,\n                minimapWidth: 0,\n                minimapHeightIsEditorHeight: false,\n                minimapIsSampling: false,\n                minimapScale: 1,\n                minimapLineHeight: 1,\n                minimapCanvasInnerWidth: 0,\n                minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),\n                minimapCanvasOuterWidth: 0,\n                minimapCanvasOuterHeight: outerHeight,\n            };\n        }\n        // Can use memory if only the `viewLineCount` and `remainingWidth` have changed\n        const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;\n        const couldUseMemory = (stableMinimapLayoutInput\n            // && input.outerWidth === lastMinimapLayoutInput.outerWidth !!! INTENTIONAL OMITTED\n            && input.outerHeight === stableMinimapLayoutInput.outerHeight\n            && input.lineHeight === stableMinimapLayoutInput.lineHeight\n            && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth\n            && input.pixelRatio === stableMinimapLayoutInput.pixelRatio\n            && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine\n            && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled\n            && input.minimap.side === stableMinimapLayoutInput.minimap.side\n            && input.minimap.size === stableMinimapLayoutInput.minimap.size\n            && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider\n            && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters\n            && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn\n            && input.minimap.scale === stableMinimapLayoutInput.minimap.scale\n            && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth\n            // && input.viewLineCount === lastMinimapLayoutInput.viewLineCount !!! INTENTIONAL OMITTED\n            // && input.remainingWidth === lastMinimapLayoutInput.remainingWidth !!! INTENTIONAL OMITTED\n            && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping);\n        const lineHeight = input.lineHeight;\n        const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;\n        const scrollBeyondLastLine = input.scrollBeyondLastLine;\n        const minimapRenderCharacters = input.minimap.renderCharacters;\n        let minimapScale = (pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale);\n        const minimapMaxColumn = input.minimap.maxColumn;\n        const minimapSize = input.minimap.size;\n        const minimapSide = input.minimap.side;\n        const verticalScrollbarWidth = input.verticalScrollbarWidth;\n        const viewLineCount = input.viewLineCount;\n        const remainingWidth = input.remainingWidth;\n        const isViewportWrapping = input.isViewportWrapping;\n        const baseCharHeight = minimapRenderCharacters ? 2 : 3;\n        let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);\n        const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;\n        let minimapHeightIsEditorHeight = false;\n        let minimapIsSampling = false;\n        let minimapLineHeight = baseCharHeight * minimapScale;\n        let minimapCharWidth = minimapScale / pixelRatio;\n        let minimapWidthMultiplier = 1;\n        if (minimapSize === 'fill' || minimapSize === 'fit') {\n            const { typicalViewportLineCount, extraLinesBeyondLastLine, desiredRatio, minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n                viewLineCount: viewLineCount,\n                scrollBeyondLastLine: scrollBeyondLastLine,\n                height: outerHeight,\n                lineHeight: lineHeight,\n                pixelRatio: pixelRatio\n            });\n            // ratio is intentionally not part of the layout to avoid the layout changing all the time\n            // when doing sampling\n            const ratio = viewLineCount / minimapLineCount;\n            if (ratio > 1) {\n                minimapHeightIsEditorHeight = true;\n                minimapIsSampling = true;\n                minimapScale = 1;\n                minimapLineHeight = 1;\n                minimapCharWidth = minimapScale / pixelRatio;\n            }\n            else {\n                let fitBecomesFill = false;\n                let maxMinimapScale = minimapScale + 1;\n                if (minimapSize === 'fit') {\n                    const effectiveMinimapHeight = Math.ceil((viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);\n                    if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {\n                        // There is a loop when using `fit` and viewport wrapping:\n                        // - view line count impacts minimap layout\n                        // - minimap layout impacts viewport width\n                        // - viewport width impacts view line count\n                        // To break the loop, once we go to a smaller minimap scale, we try to stick with it.\n                        fitBecomesFill = true;\n                        maxMinimapScale = memory.stableFitMaxMinimapScale;\n                    }\n                    else {\n                        fitBecomesFill = (effectiveMinimapHeight > minimapCanvasInnerHeight);\n                    }\n                }\n                if (minimapSize === 'fill' || fitBecomesFill) {\n                    minimapHeightIsEditorHeight = true;\n                    const configuredMinimapScale = minimapScale;\n                    minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));\n                    if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {\n                        // There is a loop when using `fill` and viewport wrapping:\n                        // - view line count impacts minimap layout\n                        // - minimap layout impacts viewport width\n                        // - viewport width impacts view line count\n                        // To break the loop, once we go to a smaller minimap scale, we try to stick with it.\n                        maxMinimapScale = memory.stableFitMaxMinimapScale;\n                    }\n                    minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));\n                    if (minimapScale > configuredMinimapScale) {\n                        minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);\n                    }\n                    minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;\n                    minimapCanvasInnerHeight = Math.ceil((Math.max(typicalViewportLineCount, viewLineCount + extraLinesBeyondLastLine)) * minimapLineHeight);\n                    if (isViewportWrapping) {\n                        // remember for next time\n                        memory.stableMinimapLayoutInput = input;\n                        memory.stableFitRemainingWidth = remainingWidth;\n                        memory.stableFitMaxMinimapScale = minimapScale;\n                    }\n                    else {\n                        memory.stableMinimapLayoutInput = null;\n                        memory.stableFitRemainingWidth = 0;\n                    }\n                }\n            }\n        }\n        // Given:\n        // (leaving 2px for the cursor to have space after the last character)\n        // viewportColumn = (contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth\n        // minimapWidth = viewportColumn * minimapCharWidth\n        // contentWidth = remainingWidth - minimapWidth\n        // What are good values for contentWidth and minimapWidth ?\n        // minimapWidth = ((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth) * minimapCharWidth\n        // typicalHalfwidthCharacterWidth * minimapWidth = (contentWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // typicalHalfwidthCharacterWidth * minimapWidth = (remainingWidth - minimapWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // (typicalHalfwidthCharacterWidth + minimapCharWidth) * minimapWidth = (remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // minimapWidth = ((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)\n        const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);\n        const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor(((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + MINIMAP_GUTTER_WIDTH);\n        let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);\n        const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;\n        minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);\n        const renderMinimap = (minimapRenderCharacters ? 1 /* RenderMinimap.Text */ : 2 /* RenderMinimap.Blocks */);\n        const minimapLeft = (minimapSide === 'left' ? 0 : (outerWidth - minimapWidth - verticalScrollbarWidth));\n        return {\n            renderMinimap,\n            minimapLeft,\n            minimapWidth,\n            minimapHeightIsEditorHeight,\n            minimapIsSampling,\n            minimapScale,\n            minimapLineHeight,\n            minimapCanvasInnerWidth,\n            minimapCanvasInnerHeight,\n            minimapCanvasOuterWidth,\n            minimapCanvasOuterHeight,\n        };\n    }\n    static computeLayout(options, env) {\n        const outerWidth = env.outerWidth | 0;\n        const outerHeight = env.outerHeight | 0;\n        const lineHeight = env.lineHeight | 0;\n        const lineNumbersDigitCount = env.lineNumbersDigitCount | 0;\n        const typicalHalfwidthCharacterWidth = env.typicalHalfwidthCharacterWidth;\n        const maxDigitWidth = env.maxDigitWidth;\n        const pixelRatio = env.pixelRatio;\n        const viewLineCount = env.viewLineCount;\n        const wordWrapOverride2 = options.get(125 /* EditorOption.wordWrapOverride2 */);\n        const wordWrapOverride1 = (wordWrapOverride2 === 'inherit' ? options.get(124 /* EditorOption.wordWrapOverride1 */) : wordWrapOverride2);\n        const wordWrap = (wordWrapOverride1 === 'inherit' ? options.get(120 /* EditorOption.wordWrap */) : wordWrapOverride1);\n        const wordWrapColumn = options.get(123 /* EditorOption.wordWrapColumn */);\n        const accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        const isDominatedByLongLines = env.isDominatedByLongLines;\n        const showGlyphMargin = options.get(52 /* EditorOption.glyphMargin */);\n        const showLineNumbers = (options.get(62 /* EditorOption.lineNumbers */).renderType !== 0 /* RenderLineNumbersType.Off */);\n        const lineNumbersMinChars = options.get(63 /* EditorOption.lineNumbersMinChars */);\n        const scrollBeyondLastLine = options.get(96 /* EditorOption.scrollBeyondLastLine */);\n        const minimap = options.get(67 /* EditorOption.minimap */);\n        const scrollbar = options.get(94 /* EditorOption.scrollbar */);\n        const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;\n        const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;\n        const scrollbarArrowSize = scrollbar.arrowSize;\n        const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;\n        const rawLineDecorationsWidth = options.get(60 /* EditorOption.lineDecorationsWidth */);\n        const folding = options.get(39 /* EditorOption.folding */);\n        const showFoldingDecoration = options.get(101 /* EditorOption.showFoldingControls */) !== 'never';\n        let lineDecorationsWidth;\n        if (typeof rawLineDecorationsWidth === 'string' && /^\\d+(\\.\\d+)?ch$/.test(rawLineDecorationsWidth)) {\n            const multiple = parseFloat(rawLineDecorationsWidth.substr(0, rawLineDecorationsWidth.length - 2));\n            lineDecorationsWidth = EditorIntOption.clampedInt(multiple * typicalHalfwidthCharacterWidth, 0, 0, 1000);\n        }\n        else {\n            lineDecorationsWidth = EditorIntOption.clampedInt(rawLineDecorationsWidth, 0, 0, 1000);\n        }\n        if (folding && showFoldingDecoration) {\n            lineDecorationsWidth += 16;\n        }\n        let lineNumbersWidth = 0;\n        if (showLineNumbers) {\n            const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);\n            lineNumbersWidth = Math.round(digitCount * maxDigitWidth);\n        }\n        let glyphMarginWidth = 0;\n        if (showGlyphMargin) {\n            glyphMarginWidth = lineHeight;\n        }\n        let glyphMarginLeft = 0;\n        let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;\n        let decorationsLeft = lineNumbersLeft + lineNumbersWidth;\n        let contentLeft = decorationsLeft + lineDecorationsWidth;\n        const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;\n        let isWordWrapMinified = false;\n        let isViewportWrapping = false;\n        let wrappingColumn = -1;\n        if (accessibilitySupport !== 2 /* AccessibilitySupport.Enabled */) {\n            // See https://github.com/microsoft/vscode/issues/27766\n            // Never enable wrapping when a screen reader is attached\n            // because arrow down etc. will not move the cursor in the way\n            // a screen reader expects.\n            if (wordWrapOverride1 === 'inherit' && isDominatedByLongLines) {\n                // Force viewport width wrapping if model is dominated by long lines\n                isWordWrapMinified = true;\n                isViewportWrapping = true;\n            }\n            else if (wordWrap === 'on' || wordWrap === 'bounded') {\n                isViewportWrapping = true;\n            }\n            else if (wordWrap === 'wordWrapColumn') {\n                wrappingColumn = wordWrapColumn;\n            }\n        }\n        const minimapLayout = EditorLayoutInfoComputer._computeMinimapLayout({\n            outerWidth: outerWidth,\n            outerHeight: outerHeight,\n            lineHeight: lineHeight,\n            typicalHalfwidthCharacterWidth: typicalHalfwidthCharacterWidth,\n            pixelRatio: pixelRatio,\n            scrollBeyondLastLine: scrollBeyondLastLine,\n            minimap: minimap,\n            verticalScrollbarWidth: verticalScrollbarWidth,\n            viewLineCount: viewLineCount,\n            remainingWidth: remainingWidth,\n            isViewportWrapping: isViewportWrapping,\n        }, env.memory || new ComputeOptionsMemory());\n        if (minimapLayout.renderMinimap !== 0 /* RenderMinimap.None */ && minimapLayout.minimapLeft === 0) {\n            // the minimap is rendered to the left, so move everything to the right\n            glyphMarginLeft += minimapLayout.minimapWidth;\n            lineNumbersLeft += minimapLayout.minimapWidth;\n            decorationsLeft += minimapLayout.minimapWidth;\n            contentLeft += minimapLayout.minimapWidth;\n        }\n        const contentWidth = remainingWidth - minimapLayout.minimapWidth;\n        // (leaving 2px for the cursor to have space after the last character)\n        const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));\n        const verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);\n        if (isViewportWrapping) {\n            // compute the actual wrappingColumn\n            wrappingColumn = Math.max(1, viewportColumn);\n            if (wordWrap === 'bounded') {\n                wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);\n            }\n        }\n        return {\n            width: outerWidth,\n            height: outerHeight,\n            glyphMarginLeft: glyphMarginLeft,\n            glyphMarginWidth: glyphMarginWidth,\n            lineNumbersLeft: lineNumbersLeft,\n            lineNumbersWidth: lineNumbersWidth,\n            decorationsLeft: decorationsLeft,\n            decorationsWidth: lineDecorationsWidth,\n            contentLeft: contentLeft,\n            contentWidth: contentWidth,\n            minimap: minimapLayout,\n            viewportColumn: viewportColumn,\n            isWordWrapMinified: isWordWrapMinified,\n            isViewportWrapping: isViewportWrapping,\n            wrappingColumn: wrappingColumn,\n            verticalScrollbarWidth: verticalScrollbarWidth,\n            horizontalScrollbarHeight: horizontalScrollbarHeight,\n            overviewRuler: {\n                top: verticalArrowSize,\n                width: verticalScrollbarWidth,\n                height: (outerHeight - 2 * verticalArrowSize),\n                right: 0\n            }\n        };\n    }\n}\nclass EditorLightbulb extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true };\n        super(59 /* EditorOption.lightbulb */, 'lightbulb', defaults, {\n            'editor.lightbulb.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('codeActions', \"Enables the code action lightbulb in the editor.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled)\n        };\n    }\n}\nclass EditorExperimental extends BaseEditorOption {\n    constructor() {\n        const defaults = { stickyScroll: { enabled: false } };\n        super(34 /* EditorOption.experimental */, 'experimental', defaults, {\n            'editor.experimental.stickyScroll.enabled': {\n                type: 'boolean',\n                default: defaults.stickyScroll.enabled,\n                description: nls.localize('editor.experimental.stickyScroll', \"Shows the nested current scopes during the scroll at the top of the editor.\")\n            },\n        });\n    }\n    validate(_input) {\n        var _a;\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            stickyScroll: {\n                enabled: boolean((_a = input.stickyScroll) === null || _a === void 0 ? void 0 : _a.enabled, this.defaultValue.stickyScroll.enabled)\n            }\n        };\n    }\n}\nclass EditorInlayHints extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: 'on', fontSize: 0, fontFamily: '', padding: false };\n        super(129 /* EditorOption.inlayHints */, 'inlayHints', defaults, {\n            'editor.inlayHints.enabled': {\n                type: 'string',\n                default: defaults.enabled,\n                description: nls.localize('inlayHints.enable', \"Enables the inlay hints in the editor.\"),\n                enum: ['on', 'onUnlessPressed', 'offUnlessPressed', 'off'],\n                markdownEnumDescriptions: [\n                    nls.localize('editor.inlayHints.on', \"Inlay hints are enabled\"),\n                    nls.localize('editor.inlayHints.onUnlessPressed', \"Inlay hints are showing by default and hide when holding `Ctrl+Alt`\"),\n                    nls.localize('editor.inlayHints.offUnlessPressed', \"Inlay hints are hidden by default and show when holding `Ctrl+Alt`\"),\n                    nls.localize('editor.inlayHints.off', \"Inlay hints are disabled\"),\n                ],\n            },\n            'editor.inlayHints.fontSize': {\n                type: 'number',\n                default: defaults.fontSize,\n                markdownDescription: nls.localize('inlayHints.fontSize', \"Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.\", '`#editor.fontSize#`', '`5`')\n            },\n            'editor.inlayHints.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                markdownDescription: nls.localize('inlayHints.fontFamily', \"Controls font family of inlay hints in the editor. When set to empty, the {0} is used.\", '`#editor.fontFamily#`')\n            },\n            'editor.inlayHints.padding': {\n                type: 'boolean',\n                default: defaults.padding,\n                description: nls.localize('inlayHints.padding', \"Enables the padding around the inlay hints in the editor.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        if (typeof input.enabled === 'boolean') {\n            input.enabled = input.enabled ? 'on' : 'off';\n        }\n        return {\n            enabled: stringSet(input.enabled, this.defaultValue.enabled, ['on', 'off', 'offUnlessPressed', 'onUnlessPressed']),\n            fontSize: EditorIntOption.clampedInt(input.fontSize, this.defaultValue.fontSize, 0, 100),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),\n            padding: boolean(input.padding, this.defaultValue.padding)\n        };\n    }\n}\n//#endregion\n//#region lineHeight\nclass EditorLineHeight extends EditorFloatOption {\n    constructor() {\n        super(61 /* EditorOption.lineHeight */, 'lineHeight', EDITOR_FONT_DEFAULTS.lineHeight, x => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: nls.localize('lineHeight', \"Controls the line height. \\n - Use 0 to automatically compute the line height from the font size.\\n - Values between 0 and 8 will be used as a multiplier with the font size.\\n - Values greater than or equal to 8 will be used as effective values.\") });\n    }\n    compute(env, options, value) {\n        // The lineHeight is computed from the fontSize if it is 0.\n        // Moreover, the final lineHeight respects the editor zoom level.\n        // So take the result from env.fontInfo\n        return env.fontInfo.lineHeight;\n    }\n}\nclass EditorMinimap extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            size: 'proportional',\n            side: 'right',\n            showSlider: 'mouseover',\n            autohide: false,\n            renderCharacters: true,\n            maxColumn: 120,\n            scale: 1,\n        };\n        super(67 /* EditorOption.minimap */, 'minimap', defaults, {\n            'editor.minimap.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('minimap.enabled', \"Controls whether the minimap is shown.\")\n            },\n            'editor.minimap.autohide': {\n                type: 'boolean',\n                default: defaults.autohide,\n                description: nls.localize('minimap.autohide', \"Controls whether the minimap is hidden automatically.\")\n            },\n            'editor.minimap.size': {\n                type: 'string',\n                enum: ['proportional', 'fill', 'fit'],\n                enumDescriptions: [\n                    nls.localize('minimap.size.proportional', \"The minimap has the same size as the editor contents (and might scroll).\"),\n                    nls.localize('minimap.size.fill', \"The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling).\"),\n                    nls.localize('minimap.size.fit', \"The minimap will shrink as necessary to never be larger than the editor (no scrolling).\"),\n                ],\n                default: defaults.size,\n                description: nls.localize('minimap.size', \"Controls the size of the minimap.\")\n            },\n            'editor.minimap.side': {\n                type: 'string',\n                enum: ['left', 'right'],\n                default: defaults.side,\n                description: nls.localize('minimap.side', \"Controls the side where to render the minimap.\")\n            },\n            'editor.minimap.showSlider': {\n                type: 'string',\n                enum: ['always', 'mouseover'],\n                default: defaults.showSlider,\n                description: nls.localize('minimap.showSlider', \"Controls when the minimap slider is shown.\")\n            },\n            'editor.minimap.scale': {\n                type: 'number',\n                default: defaults.scale,\n                minimum: 1,\n                maximum: 3,\n                enum: [1, 2, 3],\n                description: nls.localize('minimap.scale', \"Scale of content drawn in the minimap: 1, 2 or 3.\")\n            },\n            'editor.minimap.renderCharacters': {\n                type: 'boolean',\n                default: defaults.renderCharacters,\n                description: nls.localize('minimap.renderCharacters', \"Render the actual characters on a line as opposed to color blocks.\")\n            },\n            'editor.minimap.maxColumn': {\n                type: 'number',\n                default: defaults.maxColumn,\n                description: nls.localize('minimap.maxColumn', \"Limit the width of the minimap to render at most a certain number of columns.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            autohide: boolean(input.autohide, this.defaultValue.autohide),\n            size: stringSet(input.size, this.defaultValue.size, ['proportional', 'fill', 'fit']),\n            side: stringSet(input.side, this.defaultValue.side, ['right', 'left']),\n            showSlider: stringSet(input.showSlider, this.defaultValue.showSlider, ['always', 'mouseover']),\n            renderCharacters: boolean(input.renderCharacters, this.defaultValue.renderCharacters),\n            scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),\n            maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 10000),\n        };\n    }\n}\n//#endregion\n//#region multiCursorModifier\nfunction _multiCursorModifierFromString(multiCursorModifier) {\n    if (multiCursorModifier === 'ctrlCmd') {\n        return (platform.isMacintosh ? 'metaKey' : 'ctrlKey');\n    }\n    return 'altKey';\n}\nclass EditorPadding extends BaseEditorOption {\n    constructor() {\n        super(77 /* EditorOption.padding */, 'padding', { top: 0, bottom: 0 }, {\n            'editor.padding.top': {\n                type: 'number',\n                default: 0,\n                minimum: 0,\n                maximum: 1000,\n                description: nls.localize('padding.top', \"Controls the amount of space between the top edge of the editor and the first line.\")\n            },\n            'editor.padding.bottom': {\n                type: 'number',\n                default: 0,\n                minimum: 0,\n                maximum: 1000,\n                description: nls.localize('padding.bottom', \"Controls the amount of space between the bottom edge of the editor and the last line.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            top: EditorIntOption.clampedInt(input.top, 0, 0, 1000),\n            bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1000)\n        };\n    }\n}\nclass EditorParameterHints extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            cycle: false\n        };\n        super(78 /* EditorOption.parameterHints */, 'parameterHints', defaults, {\n            'editor.parameterHints.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('parameterHints.enabled', \"Enables a pop-up that shows parameter documentation and type information as you type.\")\n            },\n            'editor.parameterHints.cycle': {\n                type: 'boolean',\n                default: defaults.cycle,\n                description: nls.localize('parameterHints.cycle', \"Controls whether the parameter hints menu cycles or closes when reaching the end of the list.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            cycle: boolean(input.cycle, this.defaultValue.cycle)\n        };\n    }\n}\n//#endregion\n//#region pixelRatio\nclass EditorPixelRatio extends ComputedEditorOption {\n    constructor() {\n        super(131 /* EditorOption.pixelRatio */);\n    }\n    compute(env, options, _) {\n        return env.pixelRatio;\n    }\n}\nclass EditorQuickSuggestions extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            other: 'on',\n            comments: 'off',\n            strings: 'off'\n        };\n        const types = [\n            { type: 'boolean' },\n            {\n                type: 'string',\n                enum: ['on', 'inline', 'off'],\n                enumDescriptions: [nls.localize('on', \"Quick suggestions show inside the suggest widget\"), nls.localize('inline', \"Quick suggestions show as ghost text\"), nls.localize('off', \"Quick suggestions are disabled\")]\n            }\n        ];\n        super(81 /* EditorOption.quickSuggestions */, 'quickSuggestions', defaults, {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n                strings: {\n                    anyOf: types,\n                    default: defaults.strings,\n                    description: nls.localize('quickSuggestions.strings', \"Enable quick suggestions inside strings.\")\n                },\n                comments: {\n                    anyOf: types,\n                    default: defaults.comments,\n                    description: nls.localize('quickSuggestions.comments', \"Enable quick suggestions inside comments.\")\n                },\n                other: {\n                    anyOf: types,\n                    default: defaults.other,\n                    description: nls.localize('quickSuggestions.other', \"Enable quick suggestions outside of strings and comments.\")\n                },\n            },\n            default: defaults,\n            markdownDescription: nls.localize('quickSuggestions', \"Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the '{0}'-setting which controls if suggestions are triggered by special characters.\", `#editor.suggestOnTriggerCharacters#`)\n        });\n        this.defaultValue = defaults;\n    }\n    validate(input) {\n        if (typeof input === 'boolean') {\n            // boolean -> all on/off\n            const value = input ? 'on' : 'off';\n            return { comments: value, strings: value, other: value };\n        }\n        if (!input || typeof input !== 'object') {\n            // invalid object\n            return this.defaultValue;\n        }\n        const { other, comments, strings } = input;\n        const allowedValues = ['on', 'inline', 'off'];\n        let validatedOther;\n        let validatedComments;\n        let validatedStrings;\n        if (typeof other === 'boolean') {\n            validatedOther = other ? 'on' : 'off';\n        }\n        else {\n            validatedOther = stringSet(other, this.defaultValue.other, allowedValues);\n        }\n        if (typeof comments === 'boolean') {\n            validatedComments = comments ? 'on' : 'off';\n        }\n        else {\n            validatedComments = stringSet(comments, this.defaultValue.comments, allowedValues);\n        }\n        if (typeof strings === 'boolean') {\n            validatedStrings = strings ? 'on' : 'off';\n        }\n        else {\n            validatedStrings = stringSet(strings, this.defaultValue.strings, allowedValues);\n        }\n        return {\n            other: validatedOther,\n            comments: validatedComments,\n            strings: validatedStrings\n        };\n    }\n}\nclass EditorRenderLineNumbersOption extends BaseEditorOption {\n    constructor() {\n        super(62 /* EditorOption.lineNumbers */, 'lineNumbers', { renderType: 1 /* RenderLineNumbersType.On */, renderFn: null }, {\n            type: 'string',\n            enum: ['off', 'on', 'relative', 'interval'],\n            enumDescriptions: [\n                nls.localize('lineNumbers.off', \"Line numbers are not rendered.\"),\n                nls.localize('lineNumbers.on', \"Line numbers are rendered as absolute number.\"),\n                nls.localize('lineNumbers.relative', \"Line numbers are rendered as distance in lines to cursor position.\"),\n                nls.localize('lineNumbers.interval', \"Line numbers are rendered every 10 lines.\")\n            ],\n            default: 'on',\n            description: nls.localize('lineNumbers', \"Controls the display of line numbers.\")\n        });\n    }\n    validate(lineNumbers) {\n        let renderType = this.defaultValue.renderType;\n        let renderFn = this.defaultValue.renderFn;\n        if (typeof lineNumbers !== 'undefined') {\n            if (typeof lineNumbers === 'function') {\n                renderType = 4 /* RenderLineNumbersType.Custom */;\n                renderFn = lineNumbers;\n            }\n            else if (lineNumbers === 'interval') {\n                renderType = 3 /* RenderLineNumbersType.Interval */;\n            }\n            else if (lineNumbers === 'relative') {\n                renderType = 2 /* RenderLineNumbersType.Relative */;\n            }\n            else if (lineNumbers === 'on') {\n                renderType = 1 /* RenderLineNumbersType.On */;\n            }\n            else {\n                renderType = 0 /* RenderLineNumbersType.Off */;\n            }\n        }\n        return {\n            renderType,\n            renderFn\n        };\n    }\n}\n//#endregion\n//#region renderValidationDecorations\n/**\n * @internal\n */\nexport function filterValidationDecorations(options) {\n    const renderValidationDecorations = options.get(89 /* EditorOption.renderValidationDecorations */);\n    if (renderValidationDecorations === 'editable') {\n        return options.get(83 /* EditorOption.readOnly */);\n    }\n    return renderValidationDecorations === 'on' ? false : true;\n}\nclass EditorRulers extends BaseEditorOption {\n    constructor() {\n        const defaults = [];\n        const columnSchema = { type: 'number', description: nls.localize('rulers.size', \"Number of monospace characters at which this editor ruler will render.\") };\n        super(93 /* EditorOption.rulers */, 'rulers', defaults, {\n            type: 'array',\n            items: {\n                anyOf: [\n                    columnSchema,\n                    {\n                        type: [\n                            'object'\n                        ],\n                        properties: {\n                            column: columnSchema,\n                            color: {\n                                type: 'string',\n                                description: nls.localize('rulers.color', \"Color of this editor ruler.\"),\n                                format: 'color-hex'\n                            }\n                        }\n                    }\n                ]\n            },\n            default: defaults,\n            description: nls.localize('rulers', \"Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.\")\n        });\n    }\n    validate(input) {\n        if (Array.isArray(input)) {\n            const rulers = [];\n            for (const _element of input) {\n                if (typeof _element === 'number') {\n                    rulers.push({\n                        column: EditorIntOption.clampedInt(_element, 0, 0, 10000),\n                        color: null\n                    });\n                }\n                else if (_element && typeof _element === 'object') {\n                    const element = _element;\n                    rulers.push({\n                        column: EditorIntOption.clampedInt(element.column, 0, 0, 10000),\n                        color: element.color\n                    });\n                }\n            }\n            rulers.sort((a, b) => a.column - b.column);\n            return rulers;\n        }\n        return this.defaultValue;\n    }\n}\nfunction _scrollbarVisibilityFromString(visibility, defaultValue) {\n    if (typeof visibility !== 'string') {\n        return defaultValue;\n    }\n    switch (visibility) {\n        case 'hidden': return 2 /* ScrollbarVisibility.Hidden */;\n        case 'visible': return 3 /* ScrollbarVisibility.Visible */;\n        default: return 1 /* ScrollbarVisibility.Auto */;\n    }\n}\nclass EditorScrollbar extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            vertical: 1 /* ScrollbarVisibility.Auto */,\n            horizontal: 1 /* ScrollbarVisibility.Auto */,\n            arrowSize: 11,\n            useShadows: true,\n            verticalHasArrows: false,\n            horizontalHasArrows: false,\n            horizontalScrollbarSize: 12,\n            horizontalSliderSize: 12,\n            verticalScrollbarSize: 14,\n            verticalSliderSize: 14,\n            handleMouseWheel: true,\n            alwaysConsumeMouseWheel: true,\n            scrollByPage: false\n        };\n        super(94 /* EditorOption.scrollbar */, 'scrollbar', defaults, {\n            'editor.scrollbar.vertical': {\n                type: 'string',\n                enum: ['auto', 'visible', 'hidden'],\n                enumDescriptions: [\n                    nls.localize('scrollbar.vertical.auto', \"The vertical scrollbar will be visible only when necessary.\"),\n                    nls.localize('scrollbar.vertical.visible', \"The vertical scrollbar will always be visible.\"),\n                    nls.localize('scrollbar.vertical.fit', \"The vertical scrollbar will always be hidden.\"),\n                ],\n                default: 'auto',\n                description: nls.localize('scrollbar.vertical', \"Controls the visibility of the vertical scrollbar.\")\n            },\n            'editor.scrollbar.horizontal': {\n                type: 'string',\n                enum: ['auto', 'visible', 'hidden'],\n                enumDescriptions: [\n                    nls.localize('scrollbar.horizontal.auto', \"The horizontal scrollbar will be visible only when necessary.\"),\n                    nls.localize('scrollbar.horizontal.visible', \"The horizontal scrollbar will always be visible.\"),\n                    nls.localize('scrollbar.horizontal.fit', \"The horizontal scrollbar will always be hidden.\"),\n                ],\n                default: 'auto',\n                description: nls.localize('scrollbar.horizontal', \"Controls the visibility of the horizontal scrollbar.\")\n            },\n            'editor.scrollbar.verticalScrollbarSize': {\n                type: 'number',\n                default: defaults.verticalScrollbarSize,\n                description: nls.localize('scrollbar.verticalScrollbarSize', \"The width of the vertical scrollbar.\")\n            },\n            'editor.scrollbar.horizontalScrollbarSize': {\n                type: 'number',\n                default: defaults.horizontalScrollbarSize,\n                description: nls.localize('scrollbar.horizontalScrollbarSize', \"The height of the horizontal scrollbar.\")\n            },\n            'editor.scrollbar.scrollByPage': {\n                type: 'boolean',\n                default: defaults.scrollByPage,\n                description: nls.localize('scrollbar.scrollByPage', \"Controls whether clicks scroll by page or jump to click position.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1000);\n        const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1000);\n        return {\n            arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1000),\n            vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),\n            horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),\n            useShadows: boolean(input.useShadows, this.defaultValue.useShadows),\n            verticalHasArrows: boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),\n            horizontalHasArrows: boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),\n            handleMouseWheel: boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),\n            alwaysConsumeMouseWheel: boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),\n            horizontalScrollbarSize: horizontalScrollbarSize,\n            horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1000),\n            verticalScrollbarSize: verticalScrollbarSize,\n            verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1000),\n            scrollByPage: boolean(input.scrollByPage, this.defaultValue.scrollByPage),\n        };\n    }\n}\n/**\n * @internal\n*/\nexport const inUntrustedWorkspace = 'inUntrustedWorkspace';\n/**\n * @internal\n */\nexport const unicodeHighlightConfigKeys = {\n    allowedCharacters: 'editor.unicodeHighlight.allowedCharacters',\n    invisibleCharacters: 'editor.unicodeHighlight.invisibleCharacters',\n    nonBasicASCII: 'editor.unicodeHighlight.nonBasicASCII',\n    ambiguousCharacters: 'editor.unicodeHighlight.ambiguousCharacters',\n    includeComments: 'editor.unicodeHighlight.includeComments',\n    includeStrings: 'editor.unicodeHighlight.includeStrings',\n    allowedLocales: 'editor.unicodeHighlight.allowedLocales',\n};\nclass UnicodeHighlight extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            nonBasicASCII: inUntrustedWorkspace,\n            invisibleCharacters: true,\n            ambiguousCharacters: true,\n            includeComments: inUntrustedWorkspace,\n            includeStrings: true,\n            allowedCharacters: {},\n            allowedLocales: { _os: true, _vscode: true },\n        };\n        super(115 /* EditorOption.unicodeHighlighting */, 'unicodeHighlight', defaults, {\n            [unicodeHighlightConfigKeys.nonBasicASCII]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.nonBasicASCII,\n                description: nls.localize('unicodeHighlight.nonBasicASCII', \"Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.\")\n            },\n            [unicodeHighlightConfigKeys.invisibleCharacters]: {\n                restricted: true,\n                type: 'boolean',\n                default: defaults.invisibleCharacters,\n                description: nls.localize('unicodeHighlight.invisibleCharacters', \"Controls whether characters that just reserve space or have no width at all are highlighted.\")\n            },\n            [unicodeHighlightConfigKeys.ambiguousCharacters]: {\n                restricted: true,\n                type: 'boolean',\n                default: defaults.ambiguousCharacters,\n                description: nls.localize('unicodeHighlight.ambiguousCharacters', \"Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.\")\n            },\n            [unicodeHighlightConfigKeys.includeComments]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.includeComments,\n                description: nls.localize('unicodeHighlight.includeComments', \"Controls whether characters in comments should also be subject to unicode highlighting.\")\n            },\n            [unicodeHighlightConfigKeys.includeStrings]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.includeStrings,\n                description: nls.localize('unicodeHighlight.includeStrings', \"Controls whether characters in strings should also be subject to unicode highlighting.\")\n            },\n            [unicodeHighlightConfigKeys.allowedCharacters]: {\n                restricted: true,\n                type: 'object',\n                default: defaults.allowedCharacters,\n                description: nls.localize('unicodeHighlight.allowedCharacters', \"Defines allowed characters that are not being highlighted.\"),\n                additionalProperties: {\n                    type: 'boolean'\n                }\n            },\n            [unicodeHighlightConfigKeys.allowedLocales]: {\n                restricted: true,\n                type: 'object',\n                additionalProperties: {\n                    type: 'boolean'\n                },\n                default: defaults.allowedLocales,\n                description: nls.localize('unicodeHighlight.allowedLocales', \"Unicode characters that are common in allowed locales are not being highlighted.\")\n            },\n        });\n    }\n    applyUpdate(value, update) {\n        let didChange = false;\n        if (update.allowedCharacters && value) {\n            // Treat allowedCharacters atomically\n            if (!objects.equals(value.allowedCharacters, update.allowedCharacters)) {\n                value = Object.assign(Object.assign({}, value), { allowedCharacters: update.allowedCharacters });\n                didChange = true;\n            }\n        }\n        if (update.allowedLocales && value) {\n            // Treat allowedLocales atomically\n            if (!objects.equals(value.allowedLocales, update.allowedLocales)) {\n                value = Object.assign(Object.assign({}, value), { allowedLocales: update.allowedLocales });\n                didChange = true;\n            }\n        }\n        const result = super.applyUpdate(value, update);\n        if (didChange) {\n            return new ApplyUpdateResult(result.newValue, true);\n        }\n        return result;\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            nonBasicASCII: primitiveSet(input.nonBasicASCII, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            invisibleCharacters: boolean(input.invisibleCharacters, this.defaultValue.invisibleCharacters),\n            ambiguousCharacters: boolean(input.ambiguousCharacters, this.defaultValue.ambiguousCharacters),\n            includeComments: primitiveSet(input.includeComments, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            includeStrings: primitiveSet(input.includeStrings, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            allowedCharacters: this.validateBooleanMap(_input.allowedCharacters, this.defaultValue.allowedCharacters),\n            allowedLocales: this.validateBooleanMap(_input.allowedLocales, this.defaultValue.allowedLocales),\n        };\n    }\n    validateBooleanMap(map, defaultValue) {\n        if ((typeof map !== 'object') || !map) {\n            return defaultValue;\n        }\n        const result = {};\n        for (const [key, value] of Object.entries(map)) {\n            if (value === true) {\n                result[key] = true;\n            }\n        }\n        return result;\n    }\n}\n/**\n * Configuration options for inline suggestions\n */\nclass InlineEditorSuggest extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            mode: 'subwordSmart'\n        };\n        super(57 /* EditorOption.inlineSuggest */, 'inlineSuggest', defaults, {\n            'editor.inlineSuggest.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('inlineSuggest.enabled', \"Controls whether to automatically show inline suggestions in the editor.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            mode: stringSet(input.mode, this.defaultValue.mode, ['prefix', 'subword', 'subwordSmart']),\n        };\n    }\n}\n/**\n * Configuration options for inline suggestions\n */\nclass BracketPairColorization extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.enabled,\n            independentColorPoolPerBracketType: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.independentColorPoolPerBracketType,\n        };\n        super(12 /* EditorOption.bracketPairColorization */, 'bracketPairColorization', defaults, {\n            'editor.bracketPairColorization.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: nls.localize('bracketPairColorization.enabled', \"Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.\", '`#workbench.colorCustomizations#`')\n            },\n            'editor.bracketPairColorization.independentColorPoolPerBracketType': {\n                type: 'boolean',\n                default: defaults.independentColorPoolPerBracketType,\n                description: nls.localize('bracketPairColorization.independentColorPoolPerBracketType', \"Controls whether each bracket type has its own independent color pool.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            independentColorPoolPerBracketType: boolean(input.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType),\n        };\n    }\n}\n/**\n * Configuration options for inline suggestions\n */\nclass GuideOptions extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            bracketPairs: false,\n            bracketPairsHorizontal: 'active',\n            highlightActiveBracketPair: true,\n            indentation: true,\n            highlightActiveIndentation: true\n        };\n        super(13 /* EditorOption.guides */, 'guides', defaults, {\n            'editor.guides.bracketPairs': {\n                type: ['boolean', 'string'],\n                enum: [true, 'active', false],\n                enumDescriptions: [\n                    nls.localize('editor.guides.bracketPairs.true', \"Enables bracket pair guides.\"),\n                    nls.localize('editor.guides.bracketPairs.active', \"Enables bracket pair guides only for the active bracket pair.\"),\n                    nls.localize('editor.guides.bracketPairs.false', \"Disables bracket pair guides.\"),\n                ],\n                default: defaults.bracketPairs,\n                description: nls.localize('editor.guides.bracketPairs', \"Controls whether bracket pair guides are enabled or not.\")\n            },\n            'editor.guides.bracketPairsHorizontal': {\n                type: ['boolean', 'string'],\n                enum: [true, 'active', false],\n                enumDescriptions: [\n                    nls.localize('editor.guides.bracketPairsHorizontal.true', \"Enables horizontal guides as addition to vertical bracket pair guides.\"),\n                    nls.localize('editor.guides.bracketPairsHorizontal.active', \"Enables horizontal guides only for the active bracket pair.\"),\n                    nls.localize('editor.guides.bracketPairsHorizontal.false', \"Disables horizontal bracket pair guides.\"),\n                ],\n                default: defaults.bracketPairsHorizontal,\n                description: nls.localize('editor.guides.bracketPairsHorizontal', \"Controls whether horizontal bracket pair guides are enabled or not.\")\n            },\n            'editor.guides.highlightActiveBracketPair': {\n                type: 'boolean',\n                default: defaults.highlightActiveBracketPair,\n                description: nls.localize('editor.guides.highlightActiveBracketPair', \"Controls whether the editor should highlight the active bracket pair.\")\n            },\n            'editor.guides.indentation': {\n                type: 'boolean',\n                default: defaults.indentation,\n                description: nls.localize('editor.guides.indentation', \"Controls whether the editor should render indent guides.\")\n            },\n            'editor.guides.highlightActiveIndentation': {\n                type: ['boolean', 'string'],\n                enum: [true, 'always', false],\n                enumDescriptions: [\n                    nls.localize('editor.guides.highlightActiveIndentation.true', \"Highlights the active indent guide.\"),\n                    nls.localize('editor.guides.highlightActiveIndentation.always', \"Highlights the active indent guide even if bracket guides are highlighted.\"),\n                    nls.localize('editor.guides.highlightActiveIndentation.false', \"Do not highlight the active indent guide.\"),\n                ],\n                default: defaults.highlightActiveIndentation,\n                description: nls.localize('editor.guides.highlightActiveIndentation', \"Controls whether the editor should highlight the active indent guide.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            bracketPairs: primitiveSet(input.bracketPairs, this.defaultValue.bracketPairs, [true, false, 'active']),\n            bracketPairsHorizontal: primitiveSet(input.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [true, false, 'active']),\n            highlightActiveBracketPair: boolean(input.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),\n            indentation: boolean(input.indentation, this.defaultValue.indentation),\n            highlightActiveIndentation: primitiveSet(input.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [true, false, 'always']),\n        };\n    }\n}\nfunction primitiveSet(value, defaultValue, allowedValues) {\n    const idx = allowedValues.indexOf(value);\n    if (idx === -1) {\n        return defaultValue;\n    }\n    return allowedValues[idx];\n}\nclass EditorSuggest extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            insertMode: 'insert',\n            filterGraceful: true,\n            snippetsPreventQuickSuggestions: true,\n            localityBonus: false,\n            shareSuggestSelections: false,\n            showIcons: true,\n            showStatusBar: false,\n            preview: false,\n            previewMode: 'subwordSmart',\n            showInlineDetails: true,\n            showMethods: true,\n            showFunctions: true,\n            showConstructors: true,\n            showDeprecated: true,\n            showFields: true,\n            showVariables: true,\n            showClasses: true,\n            showStructs: true,\n            showInterfaces: true,\n            showModules: true,\n            showProperties: true,\n            showEvents: true,\n            showOperators: true,\n            showUnits: true,\n            showValues: true,\n            showConstants: true,\n            showEnums: true,\n            showEnumMembers: true,\n            showKeywords: true,\n            showWords: true,\n            showColors: true,\n            showFiles: true,\n            showReferences: true,\n            showFolders: true,\n            showTypeParameters: true,\n            showSnippets: true,\n            showUsers: true,\n            showIssues: true,\n        };\n        super(108 /* EditorOption.suggest */, 'suggest', defaults, {\n            'editor.suggest.insertMode': {\n                type: 'string',\n                enum: ['insert', 'replace'],\n                enumDescriptions: [\n                    nls.localize('suggest.insertMode.insert', \"Insert suggestion without overwriting text right of the cursor.\"),\n                    nls.localize('suggest.insertMode.replace', \"Insert suggestion and overwrite text right of the cursor.\"),\n                ],\n                default: defaults.insertMode,\n                description: nls.localize('suggest.insertMode', \"Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.\")\n            },\n            'editor.suggest.filterGraceful': {\n                type: 'boolean',\n                default: defaults.filterGraceful,\n                description: nls.localize('suggest.filterGraceful', \"Controls whether filtering and sorting suggestions accounts for small typos.\")\n            },\n            'editor.suggest.localityBonus': {\n                type: 'boolean',\n                default: defaults.localityBonus,\n                description: nls.localize('suggest.localityBonus', \"Controls whether sorting favors words that appear close to the cursor.\")\n            },\n            'editor.suggest.shareSuggestSelections': {\n                type: 'boolean',\n                default: defaults.shareSuggestSelections,\n                markdownDescription: nls.localize('suggest.shareSuggestSelections', \"Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).\")\n            },\n            'editor.suggest.snippetsPreventQuickSuggestions': {\n                type: 'boolean',\n                default: defaults.snippetsPreventQuickSuggestions,\n                description: nls.localize('suggest.snippetsPreventQuickSuggestions', \"Controls whether an active snippet prevents quick suggestions.\")\n            },\n            'editor.suggest.showIcons': {\n                type: 'boolean',\n                default: defaults.showIcons,\n                description: nls.localize('suggest.showIcons', \"Controls whether to show or hide icons in suggestions.\")\n            },\n            'editor.suggest.showStatusBar': {\n                type: 'boolean',\n                default: defaults.showStatusBar,\n                description: nls.localize('suggest.showStatusBar', \"Controls the visibility of the status bar at the bottom of the suggest widget.\")\n            },\n            'editor.suggest.preview': {\n                type: 'boolean',\n                default: defaults.preview,\n                description: nls.localize('suggest.preview', \"Controls whether to preview the suggestion outcome in the editor.\")\n            },\n            'editor.suggest.showInlineDetails': {\n                type: 'boolean',\n                default: defaults.showInlineDetails,\n                description: nls.localize('suggest.showInlineDetails', \"Controls whether suggest details show inline with the label or only in the details widget\")\n            },\n            'editor.suggest.maxVisibleSuggestions': {\n                type: 'number',\n                deprecationMessage: nls.localize('suggest.maxVisibleSuggestions.dep', \"This setting is deprecated. The suggest widget can now be resized.\"),\n            },\n            'editor.suggest.filteredTypes': {\n                type: 'object',\n                deprecationMessage: nls.localize('deprecated', \"This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.\")\n            },\n            'editor.suggest.showMethods': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showMethods', \"When enabled IntelliSense shows `method`-suggestions.\")\n            },\n            'editor.suggest.showFunctions': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFunctions', \"When enabled IntelliSense shows `function`-suggestions.\")\n            },\n            'editor.suggest.showConstructors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showConstructors', \"When enabled IntelliSense shows `constructor`-suggestions.\")\n            },\n            'editor.suggest.showDeprecated': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showDeprecated', \"When enabled IntelliSense shows `deprecated`-suggestions.\")\n            },\n            'editor.suggest.showFields': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFields', \"When enabled IntelliSense shows `field`-suggestions.\")\n            },\n            'editor.suggest.showVariables': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showVariables', \"When enabled IntelliSense shows `variable`-suggestions.\")\n            },\n            'editor.suggest.showClasses': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showClasss', \"When enabled IntelliSense shows `class`-suggestions.\")\n            },\n            'editor.suggest.showStructs': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showStructs', \"When enabled IntelliSense shows `struct`-suggestions.\")\n            },\n            'editor.suggest.showInterfaces': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showInterfaces', \"When enabled IntelliSense shows `interface`-suggestions.\")\n            },\n            'editor.suggest.showModules': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showModules', \"When enabled IntelliSense shows `module`-suggestions.\")\n            },\n            'editor.suggest.showProperties': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showPropertys', \"When enabled IntelliSense shows `property`-suggestions.\")\n            },\n            'editor.suggest.showEvents': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEvents', \"When enabled IntelliSense shows `event`-suggestions.\")\n            },\n            'editor.suggest.showOperators': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showOperators', \"When enabled IntelliSense shows `operator`-suggestions.\")\n            },\n            'editor.suggest.showUnits': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showUnits', \"When enabled IntelliSense shows `unit`-suggestions.\")\n            },\n            'editor.suggest.showValues': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showValues', \"When enabled IntelliSense shows `value`-suggestions.\")\n            },\n            'editor.suggest.showConstants': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showConstants', \"When enabled IntelliSense shows `constant`-suggestions.\")\n            },\n            'editor.suggest.showEnums': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEnums', \"When enabled IntelliSense shows `enum`-suggestions.\")\n            },\n            'editor.suggest.showEnumMembers': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEnumMembers', \"When enabled IntelliSense shows `enumMember`-suggestions.\")\n            },\n            'editor.suggest.showKeywords': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showKeywords', \"When enabled IntelliSense shows `keyword`-suggestions.\")\n            },\n            'editor.suggest.showWords': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showTexts', \"When enabled IntelliSense shows `text`-suggestions.\")\n            },\n            'editor.suggest.showColors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showColors', \"When enabled IntelliSense shows `color`-suggestions.\")\n            },\n            'editor.suggest.showFiles': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFiles', \"When enabled IntelliSense shows `file`-suggestions.\")\n            },\n            'editor.suggest.showReferences': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showReferences', \"When enabled IntelliSense shows `reference`-suggestions.\")\n            },\n            'editor.suggest.showCustomcolors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showCustomcolors', \"When enabled IntelliSense shows `customcolor`-suggestions.\")\n            },\n            'editor.suggest.showFolders': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFolders', \"When enabled IntelliSense shows `folder`-suggestions.\")\n            },\n            'editor.suggest.showTypeParameters': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showTypeParameters', \"When enabled IntelliSense shows `typeParameter`-suggestions.\")\n            },\n            'editor.suggest.showSnippets': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showSnippets', \"When enabled IntelliSense shows `snippet`-suggestions.\")\n            },\n            'editor.suggest.showUsers': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showUsers', \"When enabled IntelliSense shows `user`-suggestions.\")\n            },\n            'editor.suggest.showIssues': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showIssues', \"When enabled IntelliSense shows `issues`-suggestions.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            insertMode: stringSet(input.insertMode, this.defaultValue.insertMode, ['insert', 'replace']),\n            filterGraceful: boolean(input.filterGraceful, this.defaultValue.filterGraceful),\n            snippetsPreventQuickSuggestions: boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),\n            localityBonus: boolean(input.localityBonus, this.defaultValue.localityBonus),\n            shareSuggestSelections: boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),\n            showIcons: boolean(input.showIcons, this.defaultValue.showIcons),\n            showStatusBar: boolean(input.showStatusBar, this.defaultValue.showStatusBar),\n            preview: boolean(input.preview, this.defaultValue.preview),\n            previewMode: stringSet(input.previewMode, this.defaultValue.previewMode, ['prefix', 'subword', 'subwordSmart']),\n            showInlineDetails: boolean(input.showInlineDetails, this.defaultValue.showInlineDetails),\n            showMethods: boolean(input.showMethods, this.defaultValue.showMethods),\n            showFunctions: boolean(input.showFunctions, this.defaultValue.showFunctions),\n            showConstructors: boolean(input.showConstructors, this.defaultValue.showConstructors),\n            showDeprecated: boolean(input.showDeprecated, this.defaultValue.showDeprecated),\n            showFields: boolean(input.showFields, this.defaultValue.showFields),\n            showVariables: boolean(input.showVariables, this.defaultValue.showVariables),\n            showClasses: boolean(input.showClasses, this.defaultValue.showClasses),\n            showStructs: boolean(input.showStructs, this.defaultValue.showStructs),\n            showInterfaces: boolean(input.showInterfaces, this.defaultValue.showInterfaces),\n            showModules: boolean(input.showModules, this.defaultValue.showModules),\n            showProperties: boolean(input.showProperties, this.defaultValue.showProperties),\n            showEvents: boolean(input.showEvents, this.defaultValue.showEvents),\n            showOperators: boolean(input.showOperators, this.defaultValue.showOperators),\n            showUnits: boolean(input.showUnits, this.defaultValue.showUnits),\n            showValues: boolean(input.showValues, this.defaultValue.showValues),\n            showConstants: boolean(input.showConstants, this.defaultValue.showConstants),\n            showEnums: boolean(input.showEnums, this.defaultValue.showEnums),\n            showEnumMembers: boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),\n            showKeywords: boolean(input.showKeywords, this.defaultValue.showKeywords),\n            showWords: boolean(input.showWords, this.defaultValue.showWords),\n            showColors: boolean(input.showColors, this.defaultValue.showColors),\n            showFiles: boolean(input.showFiles, this.defaultValue.showFiles),\n            showReferences: boolean(input.showReferences, this.defaultValue.showReferences),\n            showFolders: boolean(input.showFolders, this.defaultValue.showFolders),\n            showTypeParameters: boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),\n            showSnippets: boolean(input.showSnippets, this.defaultValue.showSnippets),\n            showUsers: boolean(input.showUsers, this.defaultValue.showUsers),\n            showIssues: boolean(input.showIssues, this.defaultValue.showIssues),\n        };\n    }\n}\nclass SmartSelect extends BaseEditorOption {\n    constructor() {\n        super(104 /* EditorOption.smartSelect */, 'smartSelect', {\n            selectLeadingAndTrailingWhitespace: true\n        }, {\n            'editor.smartSelect.selectLeadingAndTrailingWhitespace': {\n                description: nls.localize('selectLeadingAndTrailingWhitespace', \"Whether leading and trailing whitespace should always be selected.\"),\n                default: true,\n                type: 'boolean'\n            }\n        });\n    }\n    validate(input) {\n        if (!input || typeof input !== 'object') {\n            return this.defaultValue;\n        }\n        return {\n            selectLeadingAndTrailingWhitespace: boolean(input.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace)\n        };\n    }\n}\n//#endregion\n//#region tabFocusMode\nclass EditorTabFocusMode extends ComputedEditorOption {\n    constructor() {\n        super(132 /* EditorOption.tabFocusMode */);\n    }\n    compute(env, options, _) {\n        const readOnly = options.get(83 /* EditorOption.readOnly */);\n        return (readOnly ? true : env.tabFocusMode);\n    }\n}\nfunction _wrappingIndentFromString(wrappingIndent) {\n    switch (wrappingIndent) {\n        case 'none': return 0 /* WrappingIndent.None */;\n        case 'same': return 1 /* WrappingIndent.Same */;\n        case 'indent': return 2 /* WrappingIndent.Indent */;\n        case 'deepIndent': return 3 /* WrappingIndent.DeepIndent */;\n    }\n}\nclass EditorWrappingInfoComputer extends ComputedEditorOption {\n    constructor() {\n        super(134 /* EditorOption.wrappingInfo */);\n    }\n    compute(env, options, _) {\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        return {\n            isDominatedByLongLines: env.isDominatedByLongLines,\n            isWordWrapMinified: layoutInfo.isWordWrapMinified,\n            isViewportWrapping: layoutInfo.isViewportWrapping,\n            wrappingColumn: layoutInfo.wrappingColumn,\n        };\n    }\n}\nclass EditorDropIntoEditor extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true };\n        super(32 /* EditorOption.dropIntoEditor */, 'dropIntoEditor', defaults, {\n            'editor.dropIntoEditor.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: nls.localize('dropIntoEditor.enabled', \"Controls whether you can drag and drop a file into a text editor by holding down `shift` (instead of opening the file in an editor).\"),\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled)\n        };\n    }\n}\n//#endregion\nconst DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \\'Courier New\\', monospace';\nconst DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \\'Courier New\\', monospace';\nconst DEFAULT_LINUX_FONT_FAMILY = '\\'Droid Sans Mono\\', \\'monospace\\', monospace';\n/**\n * @internal\n */\nexport const EDITOR_FONT_DEFAULTS = {\n    fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),\n    fontWeight: 'normal',\n    fontSize: (platform.isMacintosh ? 12 : 14),\n    lineHeight: 0,\n    letterSpacing: 0,\n};\n/**\n * @internal\n */\nexport const editorOptionsRegistry = [];\nfunction register(option) {\n    editorOptionsRegistry[option.id] = option;\n    return option;\n}\nexport const EditorOptions = {\n    acceptSuggestionOnCommitCharacter: register(new EditorBooleanOption(0 /* EditorOption.acceptSuggestionOnCommitCharacter */, 'acceptSuggestionOnCommitCharacter', true, { markdownDescription: nls.localize('acceptSuggestionOnCommitCharacter', \"Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`; `) can be a commit character that accepts a suggestion and types that character.\") })),\n    acceptSuggestionOnEnter: register(new EditorStringEnumOption(1 /* EditorOption.acceptSuggestionOnEnter */, 'acceptSuggestionOnEnter', 'on', ['on', 'smart', 'off'], {\n        markdownEnumDescriptions: [\n            '',\n            nls.localize('acceptSuggestionOnEnterSmart', \"Only accept a suggestion with `Enter` when it makes a textual change.\"),\n            ''\n        ],\n        markdownDescription: nls.localize('acceptSuggestionOnEnter', \"Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.\")\n    })),\n    accessibilitySupport: register(new EditorAccessibilitySupport()),\n    accessibilityPageSize: register(new EditorIntOption(3 /* EditorOption.accessibilityPageSize */, 'accessibilityPageSize', 10, 1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, {\n        description: nls.localize('accessibilityPageSize', \"Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.\")\n    })),\n    ariaLabel: register(new EditorStringOption(4 /* EditorOption.ariaLabel */, 'ariaLabel', nls.localize('editorViewAccessibleLabel', \"Editor content\"))),\n    autoClosingBrackets: register(new EditorStringEnumOption(5 /* EditorOption.autoClosingBrackets */, 'autoClosingBrackets', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingBrackets.languageDefined', \"Use language configurations to determine when to autoclose brackets.\"),\n            nls.localize('editor.autoClosingBrackets.beforeWhitespace', \"Autoclose brackets only when the cursor is to the left of whitespace.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingBrackets', \"Controls whether the editor should automatically close brackets after the user adds an opening bracket.\")\n    })),\n    autoClosingDelete: register(new EditorStringEnumOption(6 /* EditorOption.autoClosingDelete */, 'autoClosingDelete', 'auto', ['always', 'auto', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingDelete.auto', \"Remove adjacent closing quotes or brackets only if they were automatically inserted.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingDelete', \"Controls whether the editor should remove adjacent closing quotes or brackets when deleting.\")\n    })),\n    autoClosingOvertype: register(new EditorStringEnumOption(7 /* EditorOption.autoClosingOvertype */, 'autoClosingOvertype', 'auto', ['always', 'auto', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingOvertype.auto', \"Type over closing quotes or brackets only if they were automatically inserted.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingOvertype', \"Controls whether the editor should type over closing quotes or brackets.\")\n    })),\n    autoClosingQuotes: register(new EditorStringEnumOption(8 /* EditorOption.autoClosingQuotes */, 'autoClosingQuotes', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingQuotes.languageDefined', \"Use language configurations to determine when to autoclose quotes.\"),\n            nls.localize('editor.autoClosingQuotes.beforeWhitespace', \"Autoclose quotes only when the cursor is to the left of whitespace.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingQuotes', \"Controls whether the editor should automatically close quotes after the user adds an opening quote.\")\n    })),\n    autoIndent: register(new EditorEnumOption(9 /* EditorOption.autoIndent */, 'autoIndent', 4 /* EditorAutoIndentStrategy.Full */, 'full', ['none', 'keep', 'brackets', 'advanced', 'full'], _autoIndentFromString, {\n        enumDescriptions: [\n            nls.localize('editor.autoIndent.none', \"The editor will not insert indentation automatically.\"),\n            nls.localize('editor.autoIndent.keep', \"The editor will keep the current line's indentation.\"),\n            nls.localize('editor.autoIndent.brackets', \"The editor will keep the current line's indentation and honor language defined brackets.\"),\n            nls.localize('editor.autoIndent.advanced', \"The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages.\"),\n            nls.localize('editor.autoIndent.full', \"The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.\"),\n        ],\n        description: nls.localize('autoIndent', \"Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.\")\n    })),\n    automaticLayout: register(new EditorBooleanOption(10 /* EditorOption.automaticLayout */, 'automaticLayout', false)),\n    autoSurround: register(new EditorStringEnumOption(11 /* EditorOption.autoSurround */, 'autoSurround', 'languageDefined', ['languageDefined', 'quotes', 'brackets', 'never'], {\n        enumDescriptions: [\n            nls.localize('editor.autoSurround.languageDefined', \"Use language configurations to determine when to automatically surround selections.\"),\n            nls.localize('editor.autoSurround.quotes', \"Surround with quotes but not brackets.\"),\n            nls.localize('editor.autoSurround.brackets', \"Surround with brackets but not quotes.\"),\n            ''\n        ],\n        description: nls.localize('autoSurround', \"Controls whether the editor should automatically surround selections when typing quotes or brackets.\")\n    })),\n    bracketPairColorization: register(new BracketPairColorization()),\n    bracketPairGuides: register(new GuideOptions()),\n    stickyTabStops: register(new EditorBooleanOption(106 /* EditorOption.stickyTabStops */, 'stickyTabStops', false, { description: nls.localize('stickyTabStops', \"Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.\") })),\n    codeLens: register(new EditorBooleanOption(14 /* EditorOption.codeLens */, 'codeLens', true, { description: nls.localize('codeLens', \"Controls whether the editor shows CodeLens.\") })),\n    codeLensFontFamily: register(new EditorStringOption(15 /* EditorOption.codeLensFontFamily */, 'codeLensFontFamily', '', { description: nls.localize('codeLensFontFamily', \"Controls the font family for CodeLens.\") })),\n    codeLensFontSize: register(new EditorIntOption(16 /* EditorOption.codeLensFontSize */, 'codeLensFontSize', 0, 0, 100, {\n        type: 'number',\n        default: 0,\n        minimum: 0,\n        maximum: 100,\n        markdownDescription: nls.localize('codeLensFontSize', \"Controls the font size in pixels for CodeLens. When set to `0`, 90% of `#editor.fontSize#` is used.\")\n    })),\n    colorDecorators: register(new EditorBooleanOption(17 /* EditorOption.colorDecorators */, 'colorDecorators', true, { description: nls.localize('colorDecorators', \"Controls whether the editor should render the inline color decorators and color picker.\") })),\n    columnSelection: register(new EditorBooleanOption(18 /* EditorOption.columnSelection */, 'columnSelection', false, { description: nls.localize('columnSelection', \"Enable that the selection with the mouse and keys is doing column selection.\") })),\n    comments: register(new EditorComments()),\n    contextmenu: register(new EditorBooleanOption(20 /* EditorOption.contextmenu */, 'contextmenu', true)),\n    copyWithSyntaxHighlighting: register(new EditorBooleanOption(21 /* EditorOption.copyWithSyntaxHighlighting */, 'copyWithSyntaxHighlighting', true, { description: nls.localize('copyWithSyntaxHighlighting', \"Controls whether syntax highlighting should be copied into the clipboard.\") })),\n    cursorBlinking: register(new EditorEnumOption(22 /* EditorOption.cursorBlinking */, 'cursorBlinking', 1 /* TextEditorCursorBlinkingStyle.Blink */, 'blink', ['blink', 'smooth', 'phase', 'expand', 'solid'], _cursorBlinkingStyleFromString, { description: nls.localize('cursorBlinking', \"Control the cursor animation style.\") })),\n    cursorSmoothCaretAnimation: register(new EditorBooleanOption(23 /* EditorOption.cursorSmoothCaretAnimation */, 'cursorSmoothCaretAnimation', false, { description: nls.localize('cursorSmoothCaretAnimation', \"Controls whether the smooth caret animation should be enabled.\") })),\n    cursorStyle: register(new EditorEnumOption(24 /* EditorOption.cursorStyle */, 'cursorStyle', TextEditorCursorStyle.Line, 'line', ['line', 'block', 'underline', 'line-thin', 'block-outline', 'underline-thin'], _cursorStyleFromString, { description: nls.localize('cursorStyle', \"Controls the cursor style.\") })),\n    cursorSurroundingLines: register(new EditorIntOption(25 /* EditorOption.cursorSurroundingLines */, 'cursorSurroundingLines', 0, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('cursorSurroundingLines', \"Controls the minimal number of visible leading and trailing lines surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.\") })),\n    cursorSurroundingLinesStyle: register(new EditorStringEnumOption(26 /* EditorOption.cursorSurroundingLinesStyle */, 'cursorSurroundingLinesStyle', 'default', ['default', 'all'], {\n        enumDescriptions: [\n            nls.localize('cursorSurroundingLinesStyle.default', \"`cursorSurroundingLines` is enforced only when triggered via the keyboard or API.\"),\n            nls.localize('cursorSurroundingLinesStyle.all', \"`cursorSurroundingLines` is enforced always.\")\n        ],\n        description: nls.localize('cursorSurroundingLinesStyle', \"Controls when `cursorSurroundingLines` should be enforced.\")\n    })),\n    cursorWidth: register(new EditorIntOption(27 /* EditorOption.cursorWidth */, 'cursorWidth', 0, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { markdownDescription: nls.localize('cursorWidth', \"Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.\") })),\n    disableLayerHinting: register(new EditorBooleanOption(28 /* EditorOption.disableLayerHinting */, 'disableLayerHinting', false)),\n    disableMonospaceOptimizations: register(new EditorBooleanOption(29 /* EditorOption.disableMonospaceOptimizations */, 'disableMonospaceOptimizations', false)),\n    domReadOnly: register(new EditorBooleanOption(30 /* EditorOption.domReadOnly */, 'domReadOnly', false)),\n    dragAndDrop: register(new EditorBooleanOption(31 /* EditorOption.dragAndDrop */, 'dragAndDrop', true, { description: nls.localize('dragAndDrop', \"Controls whether the editor should allow moving selections via drag and drop.\") })),\n    emptySelectionClipboard: register(new EditorEmptySelectionClipboard()),\n    dropIntoEditor: register(new EditorDropIntoEditor()),\n    experimental: register(new EditorExperimental()),\n    extraEditorClassName: register(new EditorStringOption(35 /* EditorOption.extraEditorClassName */, 'extraEditorClassName', '')),\n    fastScrollSensitivity: register(new EditorFloatOption(36 /* EditorOption.fastScrollSensitivity */, 'fastScrollSensitivity', 5, x => (x <= 0 ? 5 : x), { markdownDescription: nls.localize('fastScrollSensitivity', \"Scrolling speed multiplier when pressing `Alt`.\") })),\n    find: register(new EditorFind()),\n    fixedOverflowWidgets: register(new EditorBooleanOption(38 /* EditorOption.fixedOverflowWidgets */, 'fixedOverflowWidgets', false)),\n    folding: register(new EditorBooleanOption(39 /* EditorOption.folding */, 'folding', true, { description: nls.localize('folding', \"Controls whether the editor has code folding enabled.\") })),\n    foldingStrategy: register(new EditorStringEnumOption(40 /* EditorOption.foldingStrategy */, 'foldingStrategy', 'auto', ['auto', 'indentation'], {\n        enumDescriptions: [\n            nls.localize('foldingStrategy.auto', \"Use a language-specific folding strategy if available, else the indentation-based one.\"),\n            nls.localize('foldingStrategy.indentation', \"Use the indentation-based folding strategy.\"),\n        ],\n        description: nls.localize('foldingStrategy', \"Controls the strategy for computing folding ranges.\")\n    })),\n    foldingHighlight: register(new EditorBooleanOption(41 /* EditorOption.foldingHighlight */, 'foldingHighlight', true, { description: nls.localize('foldingHighlight', \"Controls whether the editor should highlight folded ranges.\") })),\n    foldingImportsByDefault: register(new EditorBooleanOption(42 /* EditorOption.foldingImportsByDefault */, 'foldingImportsByDefault', false, { description: nls.localize('foldingImportsByDefault', \"Controls whether the editor automatically collapses import ranges.\") })),\n    foldingMaximumRegions: register(new EditorIntOption(43 /* EditorOption.foldingMaximumRegions */, 'foldingMaximumRegions', 5000, 10, 65000, // limit must be less than foldingRanges MAX_FOLDING_REGIONS\n    { description: nls.localize('foldingMaximumRegions', \"The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.\") })),\n    unfoldOnClickAfterEndOfLine: register(new EditorBooleanOption(44 /* EditorOption.unfoldOnClickAfterEndOfLine */, 'unfoldOnClickAfterEndOfLine', false, { description: nls.localize('unfoldOnClickAfterEndOfLine', \"Controls whether clicking on the empty content after a folded line will unfold the line.\") })),\n    fontFamily: register(new EditorStringOption(45 /* EditorOption.fontFamily */, 'fontFamily', EDITOR_FONT_DEFAULTS.fontFamily, { description: nls.localize('fontFamily', \"Controls the font family.\") })),\n    fontInfo: register(new EditorFontInfo()),\n    fontLigatures2: register(new EditorFontLigatures()),\n    fontSize: register(new EditorFontSize()),\n    fontWeight: register(new EditorFontWeight()),\n    formatOnPaste: register(new EditorBooleanOption(50 /* EditorOption.formatOnPaste */, 'formatOnPaste', false, { description: nls.localize('formatOnPaste', \"Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.\") })),\n    formatOnType: register(new EditorBooleanOption(51 /* EditorOption.formatOnType */, 'formatOnType', false, { description: nls.localize('formatOnType', \"Controls whether the editor should automatically format the line after typing.\") })),\n    glyphMargin: register(new EditorBooleanOption(52 /* EditorOption.glyphMargin */, 'glyphMargin', true, { description: nls.localize('glyphMargin', \"Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.\") })),\n    gotoLocation: register(new EditorGoToLocation()),\n    hideCursorInOverviewRuler: register(new EditorBooleanOption(54 /* EditorOption.hideCursorInOverviewRuler */, 'hideCursorInOverviewRuler', false, { description: nls.localize('hideCursorInOverviewRuler', \"Controls whether the cursor should be hidden in the overview ruler.\") })),\n    hover: register(new EditorHover()),\n    inDiffEditor: register(new EditorBooleanOption(56 /* EditorOption.inDiffEditor */, 'inDiffEditor', false)),\n    letterSpacing: register(new EditorFloatOption(58 /* EditorOption.letterSpacing */, 'letterSpacing', EDITOR_FONT_DEFAULTS.letterSpacing, x => EditorFloatOption.clamp(x, -5, 20), { description: nls.localize('letterSpacing', \"Controls the letter spacing in pixels.\") })),\n    lightbulb: register(new EditorLightbulb()),\n    lineDecorationsWidth: register(new SimpleEditorOption(60 /* EditorOption.lineDecorationsWidth */, 'lineDecorationsWidth', 10)),\n    lineHeight: register(new EditorLineHeight()),\n    lineNumbers: register(new EditorRenderLineNumbersOption()),\n    lineNumbersMinChars: register(new EditorIntOption(63 /* EditorOption.lineNumbersMinChars */, 'lineNumbersMinChars', 5, 1, 300)),\n    linkedEditing: register(new EditorBooleanOption(64 /* EditorOption.linkedEditing */, 'linkedEditing', false, { description: nls.localize('linkedEditing', \"Controls whether the editor has linked editing enabled. Depending on the language, related symbols, e.g. HTML tags, are updated while editing.\") })),\n    links: register(new EditorBooleanOption(65 /* EditorOption.links */, 'links', true, { description: nls.localize('links', \"Controls whether the editor should detect links and make them clickable.\") })),\n    matchBrackets: register(new EditorStringEnumOption(66 /* EditorOption.matchBrackets */, 'matchBrackets', 'always', ['always', 'near', 'never'], { description: nls.localize('matchBrackets', \"Highlight matching brackets.\") })),\n    minimap: register(new EditorMinimap()),\n    mouseStyle: register(new EditorStringEnumOption(68 /* EditorOption.mouseStyle */, 'mouseStyle', 'text', ['text', 'default', 'copy'])),\n    mouseWheelScrollSensitivity: register(new EditorFloatOption(69 /* EditorOption.mouseWheelScrollSensitivity */, 'mouseWheelScrollSensitivity', 1, x => (x === 0 ? 1 : x), { markdownDescription: nls.localize('mouseWheelScrollSensitivity', \"A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.\") })),\n    mouseWheelZoom: register(new EditorBooleanOption(70 /* EditorOption.mouseWheelZoom */, 'mouseWheelZoom', false, { markdownDescription: nls.localize('mouseWheelZoom', \"Zoom the font of the editor when using mouse wheel and holding `Ctrl`.\") })),\n    multiCursorMergeOverlapping: register(new EditorBooleanOption(71 /* EditorOption.multiCursorMergeOverlapping */, 'multiCursorMergeOverlapping', true, { description: nls.localize('multiCursorMergeOverlapping', \"Merge multiple cursors when they are overlapping.\") })),\n    multiCursorModifier: register(new EditorEnumOption(72 /* EditorOption.multiCursorModifier */, 'multiCursorModifier', 'altKey', 'alt', ['ctrlCmd', 'alt'], _multiCursorModifierFromString, {\n        markdownEnumDescriptions: [\n            nls.localize('multiCursorModifier.ctrlCmd', \"Maps to `Control` on Windows and Linux and to `Command` on macOS.\"),\n            nls.localize('multiCursorModifier.alt', \"Maps to `Alt` on Windows and Linux and to `Option` on macOS.\")\n        ],\n        markdownDescription: nls.localize({\n            key: 'multiCursorModifier',\n            comment: [\n                '- `ctrlCmd` refers to a value the setting can take and should not be localized.',\n                '- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized.'\n            ]\n        }, \"The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).\")\n    })),\n    multiCursorPaste: register(new EditorStringEnumOption(73 /* EditorOption.multiCursorPaste */, 'multiCursorPaste', 'spread', ['spread', 'full'], {\n        markdownEnumDescriptions: [\n            nls.localize('multiCursorPaste.spread', \"Each cursor pastes a single line of the text.\"),\n            nls.localize('multiCursorPaste.full', \"Each cursor pastes the full text.\")\n        ],\n        markdownDescription: nls.localize('multiCursorPaste', \"Controls pasting when the line count of the pasted text matches the cursor count.\")\n    })),\n    occurrencesHighlight: register(new EditorBooleanOption(74 /* EditorOption.occurrencesHighlight */, 'occurrencesHighlight', true, { description: nls.localize('occurrencesHighlight', \"Controls whether the editor should highlight semantic symbol occurrences.\") })),\n    overviewRulerBorder: register(new EditorBooleanOption(75 /* EditorOption.overviewRulerBorder */, 'overviewRulerBorder', true, { description: nls.localize('overviewRulerBorder', \"Controls whether a border should be drawn around the overview ruler.\") })),\n    overviewRulerLanes: register(new EditorIntOption(76 /* EditorOption.overviewRulerLanes */, 'overviewRulerLanes', 3, 0, 3)),\n    padding: register(new EditorPadding()),\n    parameterHints: register(new EditorParameterHints()),\n    peekWidgetDefaultFocus: register(new EditorStringEnumOption(79 /* EditorOption.peekWidgetDefaultFocus */, 'peekWidgetDefaultFocus', 'tree', ['tree', 'editor'], {\n        enumDescriptions: [\n            nls.localize('peekWidgetDefaultFocus.tree', \"Focus the tree when opening peek\"),\n            nls.localize('peekWidgetDefaultFocus.editor', \"Focus the editor when opening peek\")\n        ],\n        description: nls.localize('peekWidgetDefaultFocus', \"Controls whether to focus the inline editor or the tree in the peek widget.\")\n    })),\n    definitionLinkOpensInPeek: register(new EditorBooleanOption(80 /* EditorOption.definitionLinkOpensInPeek */, 'definitionLinkOpensInPeek', false, { description: nls.localize('definitionLinkOpensInPeek', \"Controls whether the Go to Definition mouse gesture always opens the peek widget.\") })),\n    quickSuggestions: register(new EditorQuickSuggestions()),\n    quickSuggestionsDelay: register(new EditorIntOption(82 /* EditorOption.quickSuggestionsDelay */, 'quickSuggestionsDelay', 10, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('quickSuggestionsDelay', \"Controls the delay in milliseconds after which quick suggestions will show up.\") })),\n    readOnly: register(new EditorBooleanOption(83 /* EditorOption.readOnly */, 'readOnly', false)),\n    renameOnType: register(new EditorBooleanOption(84 /* EditorOption.renameOnType */, 'renameOnType', false, { description: nls.localize('renameOnType', \"Controls whether the editor auto renames on type.\"), markdownDeprecationMessage: nls.localize('renameOnTypeDeprecate', \"Deprecated, use `editor.linkedEditing` instead.\") })),\n    renderControlCharacters: register(new EditorBooleanOption(85 /* EditorOption.renderControlCharacters */, 'renderControlCharacters', true, { description: nls.localize('renderControlCharacters', \"Controls whether the editor should render control characters.\"), restricted: true })),\n    renderFinalNewline: register(new EditorBooleanOption(86 /* EditorOption.renderFinalNewline */, 'renderFinalNewline', true, { description: nls.localize('renderFinalNewline', \"Render last line number when the file ends with a newline.\") })),\n    renderLineHighlight: register(new EditorStringEnumOption(87 /* EditorOption.renderLineHighlight */, 'renderLineHighlight', 'line', ['none', 'gutter', 'line', 'all'], {\n        enumDescriptions: [\n            '',\n            '',\n            '',\n            nls.localize('renderLineHighlight.all', \"Highlights both the gutter and the current line.\"),\n        ],\n        description: nls.localize('renderLineHighlight', \"Controls how the editor should render the current line highlight.\")\n    })),\n    renderLineHighlightOnlyWhenFocus: register(new EditorBooleanOption(88 /* EditorOption.renderLineHighlightOnlyWhenFocus */, 'renderLineHighlightOnlyWhenFocus', false, { description: nls.localize('renderLineHighlightOnlyWhenFocus', \"Controls if the editor should render the current line highlight only when the editor is focused.\") })),\n    renderValidationDecorations: register(new EditorStringEnumOption(89 /* EditorOption.renderValidationDecorations */, 'renderValidationDecorations', 'editable', ['editable', 'on', 'off'])),\n    renderWhitespace: register(new EditorStringEnumOption(90 /* EditorOption.renderWhitespace */, 'renderWhitespace', 'selection', ['none', 'boundary', 'selection', 'trailing', 'all'], {\n        enumDescriptions: [\n            '',\n            nls.localize('renderWhitespace.boundary', \"Render whitespace characters except for single spaces between words.\"),\n            nls.localize('renderWhitespace.selection', \"Render whitespace characters only on selected text.\"),\n            nls.localize('renderWhitespace.trailing', \"Render only trailing whitespace characters.\"),\n            ''\n        ],\n        description: nls.localize('renderWhitespace', \"Controls how the editor should render whitespace characters.\")\n    })),\n    revealHorizontalRightPadding: register(new EditorIntOption(91 /* EditorOption.revealHorizontalRightPadding */, 'revealHorizontalRightPadding', 30, 0, 1000)),\n    roundedSelection: register(new EditorBooleanOption(92 /* EditorOption.roundedSelection */, 'roundedSelection', true, { description: nls.localize('roundedSelection', \"Controls whether selections should have rounded corners.\") })),\n    rulers: register(new EditorRulers()),\n    scrollbar: register(new EditorScrollbar()),\n    scrollBeyondLastColumn: register(new EditorIntOption(95 /* EditorOption.scrollBeyondLastColumn */, 'scrollBeyondLastColumn', 4, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('scrollBeyondLastColumn', \"Controls the number of extra characters beyond which the editor will scroll horizontally.\") })),\n    scrollBeyondLastLine: register(new EditorBooleanOption(96 /* EditorOption.scrollBeyondLastLine */, 'scrollBeyondLastLine', true, { description: nls.localize('scrollBeyondLastLine', \"Controls whether the editor will scroll beyond the last line.\") })),\n    scrollPredominantAxis: register(new EditorBooleanOption(97 /* EditorOption.scrollPredominantAxis */, 'scrollPredominantAxis', true, { description: nls.localize('scrollPredominantAxis', \"Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.\") })),\n    selectionClipboard: register(new EditorBooleanOption(98 /* EditorOption.selectionClipboard */, 'selectionClipboard', true, {\n        description: nls.localize('selectionClipboard', \"Controls whether the Linux primary clipboard should be supported.\"),\n        included: platform.isLinux\n    })),\n    selectionHighlight: register(new EditorBooleanOption(99 /* EditorOption.selectionHighlight */, 'selectionHighlight', true, { description: nls.localize('selectionHighlight', \"Controls whether the editor should highlight matches similar to the selection.\") })),\n    selectOnLineNumbers: register(new EditorBooleanOption(100 /* EditorOption.selectOnLineNumbers */, 'selectOnLineNumbers', true)),\n    showFoldingControls: register(new EditorStringEnumOption(101 /* EditorOption.showFoldingControls */, 'showFoldingControls', 'mouseover', ['always', 'never', 'mouseover'], {\n        enumDescriptions: [\n            nls.localize('showFoldingControls.always', \"Always show the folding controls.\"),\n            nls.localize('showFoldingControls.never', \"Never show the folding controls and reduce the gutter size.\"),\n            nls.localize('showFoldingControls.mouseover', \"Only show the folding controls when the mouse is over the gutter.\"),\n        ],\n        description: nls.localize('showFoldingControls', \"Controls when the folding controls on the gutter are shown.\")\n    })),\n    showUnused: register(new EditorBooleanOption(102 /* EditorOption.showUnused */, 'showUnused', true, { description: nls.localize('showUnused', \"Controls fading out of unused code.\") })),\n    showDeprecated: register(new EditorBooleanOption(128 /* EditorOption.showDeprecated */, 'showDeprecated', true, { description: nls.localize('showDeprecated', \"Controls strikethrough deprecated variables.\") })),\n    inlayHints: register(new EditorInlayHints()),\n    snippetSuggestions: register(new EditorStringEnumOption(103 /* EditorOption.snippetSuggestions */, 'snippetSuggestions', 'inline', ['top', 'bottom', 'inline', 'none'], {\n        enumDescriptions: [\n            nls.localize('snippetSuggestions.top', \"Show snippet suggestions on top of other suggestions.\"),\n            nls.localize('snippetSuggestions.bottom', \"Show snippet suggestions below other suggestions.\"),\n            nls.localize('snippetSuggestions.inline', \"Show snippets suggestions with other suggestions.\"),\n            nls.localize('snippetSuggestions.none', \"Do not show snippet suggestions.\"),\n        ],\n        description: nls.localize('snippetSuggestions', \"Controls whether snippets are shown with other suggestions and how they are sorted.\")\n    })),\n    smartSelect: register(new SmartSelect()),\n    smoothScrolling: register(new EditorBooleanOption(105 /* EditorOption.smoothScrolling */, 'smoothScrolling', false, { description: nls.localize('smoothScrolling', \"Controls whether the editor will scroll using an animation.\") })),\n    stopRenderingLineAfter: register(new EditorIntOption(107 /* EditorOption.stopRenderingLineAfter */, 'stopRenderingLineAfter', 10000, -1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */)),\n    suggest: register(new EditorSuggest()),\n    inlineSuggest: register(new InlineEditorSuggest()),\n    suggestFontSize: register(new EditorIntOption(109 /* EditorOption.suggestFontSize */, 'suggestFontSize', 0, 0, 1000, { markdownDescription: nls.localize('suggestFontSize', \"Font size for the suggest widget. When set to {0}, the value of {1} is used.\", '`0`', '`#editor.fontSize#`') })),\n    suggestLineHeight: register(new EditorIntOption(110 /* EditorOption.suggestLineHeight */, 'suggestLineHeight', 0, 0, 1000, { markdownDescription: nls.localize('suggestLineHeight', \"Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.\", '`0`', '`#editor.lineHeight#`') })),\n    suggestOnTriggerCharacters: register(new EditorBooleanOption(111 /* EditorOption.suggestOnTriggerCharacters */, 'suggestOnTriggerCharacters', true, { description: nls.localize('suggestOnTriggerCharacters', \"Controls whether suggestions should automatically show up when typing trigger characters.\") })),\n    suggestSelection: register(new EditorStringEnumOption(112 /* EditorOption.suggestSelection */, 'suggestSelection', 'first', ['first', 'recentlyUsed', 'recentlyUsedByPrefix'], {\n        markdownEnumDescriptions: [\n            nls.localize('suggestSelection.first', \"Always select the first suggestion.\"),\n            nls.localize('suggestSelection.recentlyUsed', \"Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently.\"),\n            nls.localize('suggestSelection.recentlyUsedByPrefix', \"Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.\"),\n        ],\n        description: nls.localize('suggestSelection', \"Controls how suggestions are pre-selected when showing the suggest list.\")\n    })),\n    tabCompletion: register(new EditorStringEnumOption(113 /* EditorOption.tabCompletion */, 'tabCompletion', 'off', ['on', 'off', 'onlySnippets'], {\n        enumDescriptions: [\n            nls.localize('tabCompletion.on', \"Tab complete will insert the best matching suggestion when pressing tab.\"),\n            nls.localize('tabCompletion.off', \"Disable tab completions.\"),\n            nls.localize('tabCompletion.onlySnippets', \"Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.\"),\n        ],\n        description: nls.localize('tabCompletion', \"Enables tab completions.\")\n    })),\n    tabIndex: register(new EditorIntOption(114 /* EditorOption.tabIndex */, 'tabIndex', 0, -1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */)),\n    unicodeHighlight: register(new UnicodeHighlight()),\n    unusualLineTerminators: register(new EditorStringEnumOption(116 /* EditorOption.unusualLineTerminators */, 'unusualLineTerminators', 'prompt', ['auto', 'off', 'prompt'], {\n        enumDescriptions: [\n            nls.localize('unusualLineTerminators.auto', \"Unusual line terminators are automatically removed.\"),\n            nls.localize('unusualLineTerminators.off', \"Unusual line terminators are ignored.\"),\n            nls.localize('unusualLineTerminators.prompt', \"Unusual line terminators prompt to be removed.\"),\n        ],\n        description: nls.localize('unusualLineTerminators', \"Remove unusual line terminators that might cause problems.\")\n    })),\n    useShadowDOM: register(new EditorBooleanOption(117 /* EditorOption.useShadowDOM */, 'useShadowDOM', true)),\n    useTabStops: register(new EditorBooleanOption(118 /* EditorOption.useTabStops */, 'useTabStops', true, { description: nls.localize('useTabStops', \"Inserting and deleting whitespace follows tab stops.\") })),\n    wordSeparators: register(new EditorStringOption(119 /* EditorOption.wordSeparators */, 'wordSeparators', USUAL_WORD_SEPARATORS, { description: nls.localize('wordSeparators', \"Characters that will be used as word separators when doing word related navigations or operations.\") })),\n    wordWrap: register(new EditorStringEnumOption(120 /* EditorOption.wordWrap */, 'wordWrap', 'off', ['off', 'on', 'wordWrapColumn', 'bounded'], {\n        markdownEnumDescriptions: [\n            nls.localize('wordWrap.off', \"Lines will never wrap.\"),\n            nls.localize('wordWrap.on', \"Lines will wrap at the viewport width.\"),\n            nls.localize({\n                key: 'wordWrap.wordWrapColumn',\n                comment: [\n                    '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n                ]\n            }, \"Lines will wrap at `#editor.wordWrapColumn#`.\"),\n            nls.localize({\n                key: 'wordWrap.bounded',\n                comment: [\n                    '- viewport means the edge of the visible window size.',\n                    '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n                ]\n            }, \"Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.\"),\n        ],\n        description: nls.localize({\n            key: 'wordWrap',\n            comment: [\n                '- \\'off\\', \\'on\\', \\'wordWrapColumn\\' and \\'bounded\\' refer to values the setting can take and should not be localized.',\n                '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n            ]\n        }, \"Controls how lines should wrap.\")\n    })),\n    wordWrapBreakAfterCharacters: register(new EditorStringOption(121 /* EditorOption.wordWrapBreakAfterCharacters */, 'wordWrapBreakAfterCharacters', \n    // allow-any-unicode-next-line\n    ' \\t})]?|/&.,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣')),\n    wordWrapBreakBeforeCharacters: register(new EditorStringOption(122 /* EditorOption.wordWrapBreakBeforeCharacters */, 'wordWrapBreakBeforeCharacters', \n    // allow-any-unicode-next-line\n    '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋')),\n    wordWrapColumn: register(new EditorIntOption(123 /* EditorOption.wordWrapColumn */, 'wordWrapColumn', 80, 1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, {\n        markdownDescription: nls.localize({\n            key: 'wordWrapColumn',\n            comment: [\n                '- `editor.wordWrap` refers to a different setting and should not be localized.',\n                '- \\'wordWrapColumn\\' and \\'bounded\\' refer to values the different setting can take and should not be localized.'\n            ]\n        }, \"Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.\")\n    })),\n    wordWrapOverride1: register(new EditorStringEnumOption(124 /* EditorOption.wordWrapOverride1 */, 'wordWrapOverride1', 'inherit', ['off', 'on', 'inherit'])),\n    wordWrapOverride2: register(new EditorStringEnumOption(125 /* EditorOption.wordWrapOverride2 */, 'wordWrapOverride2', 'inherit', ['off', 'on', 'inherit'])),\n    wrappingIndent: register(new EditorEnumOption(126 /* EditorOption.wrappingIndent */, 'wrappingIndent', 1 /* WrappingIndent.Same */, 'same', ['none', 'same', 'indent', 'deepIndent'], _wrappingIndentFromString, {\n        enumDescriptions: [\n            nls.localize('wrappingIndent.none', \"No indentation. Wrapped lines begin at column 1.\"),\n            nls.localize('wrappingIndent.same', \"Wrapped lines get the same indentation as the parent.\"),\n            nls.localize('wrappingIndent.indent', \"Wrapped lines get +1 indentation toward the parent.\"),\n            nls.localize('wrappingIndent.deepIndent', \"Wrapped lines get +2 indentation toward the parent.\"),\n        ],\n        description: nls.localize('wrappingIndent', \"Controls the indentation of wrapped lines.\"),\n    })),\n    wrappingStrategy: register(new EditorStringEnumOption(127 /* EditorOption.wrappingStrategy */, 'wrappingStrategy', 'simple', ['simple', 'advanced'], {\n        enumDescriptions: [\n            nls.localize('wrappingStrategy.simple', \"Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width.\"),\n            nls.localize('wrappingStrategy.advanced', \"Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.\")\n        ],\n        description: nls.localize('wrappingStrategy', \"Controls the algorithm that computes wrapping points.\")\n    })),\n    // Leave these at the end (because they have dependencies!)\n    editorClassName: register(new EditorClassName()),\n    pixelRatio: register(new EditorPixelRatio()),\n    tabFocusMode: register(new EditorTabFocusMode()),\n    layoutInfo: register(new EditorLayoutInfoComputer()),\n    wrappingInfo: register(new EditorWrappingInfoComputer())\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n    constructor() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(() => {\n                if (e.stack) {\n                    if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n                        throw new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n                    }\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    emit(e) {\n        this.listeners.forEach((listener) => {\n            listener(e);\n        });\n    }\n    onUnexpectedError(e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    }\n    // For external errors, we don't want the listeners to be called\n    onUnexpectedExternalError(e) {\n        this.unexpectedErrorHandler(e);\n    }\n}\nexport const errorHandler = new ErrorHandler();\nexport function onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nexport function onUnexpectedExternalError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        errorHandler.onUnexpectedExternalError(e);\n    }\n    return undefined;\n}\nexport function transformErrorForSerialization(error) {\n    if (error instanceof Error) {\n        const { name, message } = error;\n        const stack = error.stacktrace || error.stack;\n        return {\n            $isError: true,\n            name,\n            message,\n            stack,\n            noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\n        };\n    }\n    // return as is\n    return error;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error) {\n    if (error instanceof CancellationError) {\n        return true;\n    }\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n    constructor() {\n        super(canceledName);\n        this.name = this.message;\n    }\n}\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled() {\n    const error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\nexport function illegalArgument(name) {\n    if (name) {\n        return new Error(`Illegal argument: ${name}`);\n    }\n    else {\n        return new Error('Illegal argument');\n    }\n}\nexport function illegalState(name) {\n    if (name) {\n        return new Error(`Illegal state: ${name}`);\n    }\n    else {\n        return new Error('Illegal state');\n    }\n}\nexport class NotSupportedError extends Error {\n    constructor(message) {\n        super('NotSupported');\n        if (message) {\n            this.message = message;\n        }\n    }\n}\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'ErrorNoTelemetry';\n    }\n    static fromError(err) {\n        if (err instanceof ErrorNoTelemetry) {\n            return err;\n        }\n        const result = new ErrorNoTelemetry();\n        result.message = err.message;\n        result.stack = err.stack;\n        return result;\n    }\n    static isErrorNoTelemetry(err) {\n        return err.name === 'ErrorNoTelemetry';\n    }\n}\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n    constructor(message) {\n        super(message || 'An unexpected bug occurred.');\n        Object.setPrototypeOf(this, BugIndicatingError.prototype);\n        // Because we know for sure only buggy code throws this,\n        // we definitely want to break here and fix the bug.\n        // eslint-disable-next-line no-debugger\n        debugger;\n    }\n}\n","import { onUnexpectedError } from './errors.js';\nimport { combinedDisposable, Disposable, DisposableStore, SafeDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// _enableDisposeWithListenerWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onListenerDidAdd: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onListenerDidAdd = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which only fires once.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onFirstListenerAdd() {\n                listener = event(emitter.fire, emitter);\n            },\n            onLastListenerRemove() {\n                listener === null || listener === void 0 ? void 0 : listener.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        const options = {\n            leakWarningThreshold,\n            onFirstListenerAdd() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    clearTimeout(handle);\n                    handle = setTimeout(() => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    }, delay);\n                });\n            },\n            onLastListenerRemove() {\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = []) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        const flush = () => {\n            buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                }\n            },\n            onFirstListenerDidAdd() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onLastListenerRemove() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    class ChainableEvent {\n        constructor(event) {\n            this.event = event;\n            this.disposables = new DisposableStore();\n        }\n        map(fn) {\n            return new ChainableEvent(map(this.event, fn, this.disposables));\n        }\n        forEach(fn) {\n            return new ChainableEvent(forEach(this.event, fn, this.disposables));\n        }\n        filter(fn) {\n            return new ChainableEvent(filter(this.event, fn, this.disposables));\n        }\n        reduce(merge, initial) {\n            return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));\n        }\n        latch() {\n            return new ChainableEvent(latch(this.event, undefined, this.disposables));\n        }\n        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold, this.disposables));\n        }\n        on(listener, thisArgs, disposables) {\n            return this.event(listener, thisArgs, disposables);\n        }\n        once(listener, thisArgs, disposables) {\n            return once(this.event)(listener, thisArgs, disposables);\n        }\n        dispose() {\n            this.disposables.dispose();\n        }\n    }\n    function chain(event) {\n        return new ChainableEvent(event);\n    }\n    Event.chain = chain;\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    function runAndSubscribe(event, handler) {\n        handler(undefined);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    function runAndSubscribeWithStore(event, handler) {\n        let store = null;\n        function run(e) {\n            store === null || store === void 0 ? void 0 : store.dispose();\n            store = new DisposableStore();\n            handler(e, store);\n        }\n        run(undefined);\n        const disposable = event(e => run(e));\n        return toDisposable(() => {\n            disposable.dispose();\n            store === null || store === void 0 ? void 0 : store.dispose();\n        });\n    }\n    Event.runAndSubscribeWithStore = runAndSubscribeWithStore;\n    class EmitterObserver {\n        constructor(obs, store) {\n            this.obs = obs;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onFirstListenerAdd: () => {\n                    obs.addObserver(this);\n                },\n                onLastListenerRemove: () => {\n                    obs.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // console.assert(_observable === this.obs);\n            this._counter++;\n        }\n        handleChange(_observable, _change) {\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            if (--this._counter === 0) {\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this.obs.get());\n                }\n            }\n        }\n    }\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n})(Event || (Event = {}));\nclass EventProfiling {\n    constructor(name) {\n        this._listenerCount = 0;\n        this._invocationCount = 0;\n        this._elapsedOverall = 0;\n        this._name = `${name}_${EventProfiling._idPool++}`;\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch(true);\n        this._listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this._elapsedOverall += elapsed;\n            this._invocationCount += 1;\n            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.customThreshold = customThreshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        if (this._stacks) {\n            this._stacks.clear();\n        }\n    }\n    check(stack, listenerCount) {\n        let threshold = _globalLeakWarningThreshold;\n        if (typeof this.customThreshold === 'number') {\n            threshold = this.customThreshold;\n        }\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n}\nclass Stacktrace {\n    constructor(value) {\n        this.value = value;\n    }\n    static create() {\n        var _a;\n        return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\nclass Listener {\n    constructor(callback, callbackThis, stack) {\n        this.callback = callback;\n        this.callbackThis = callbackThis;\n        this.stack = stack;\n        this.subscription = new SafeDisposable();\n    }\n    invoke(e) {\n        this.callback.call(this.callbackThis, e);\n    }\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        var _a, _b;\n        this._disposed = false;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n        this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = (_b = this._options) === null || _b === void 0 ? void 0 : _b.deliveryQueue;\n    }\n    dispose() {\n        var _a, _b, _c, _d;\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = Array.from(this._listeners);\n                    queueMicrotask(() => {\n                        var _a;\n                        for (const listener of listeners) {\n                            if (listener.subscription.isset()) {\n                                listener.subscription.unset();\n                                (_a = listener.stack) === null || _a === void 0 ? void 0 : _a.print();\n                            }\n                        }\n                    });\n                }\n                this._listeners.clear();\n            }\n            (_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.clear(this);\n            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onLastListenerRemove) === null || _c === void 0 ? void 0 : _c.call(_b);\n            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (callback, thisArgs, disposables) => {\n                var _a, _b, _c;\n                if (!this._listeners) {\n                    this._listeners = new LinkedList();\n                }\n                const firstListener = this._listeners.isEmpty();\n                if (firstListener && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onFirstListenerAdd)) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                let removeMonitor;\n                let stack;\n                if (this._leakageMon && this._listeners.size >= 30) {\n                    // check and record this emitter for potential leakage\n                    stack = Stacktrace.create();\n                    removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);\n                }\n                if (_enableDisposeWithListenerWarning) {\n                    stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n                }\n                const listener = new Listener(callback, thisArgs, stack);\n                const removeListener = this._listeners.push(listener);\n                if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onFirstListenerDidAdd)) {\n                    this._options.onFirstListenerDidAdd(this);\n                }\n                if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onListenerDidAdd) {\n                    this._options.onListenerDidAdd(this, callback, thisArgs);\n                }\n                const result = listener.subscription.set(() => {\n                    removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n                    if (!this._disposed) {\n                        removeListener();\n                        if (this._options && this._options.onLastListenerRemove) {\n                            const hasListeners = (this._listeners && !this._listeners.isEmpty());\n                            if (!hasListeners) {\n                                this._options.onLastListenerRemove(this);\n                            }\n                        }\n                    }\n                });\n                if (disposables instanceof DisposableStore) {\n                    disposables.add(result);\n                }\n                else if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b;\n        if (this._listeners) {\n            // put all [listener,event]-pairs into delivery queue\n            // then emit all event. an inner/nested event might be\n            // the driver of this\n            if (!this._deliveryQueue) {\n                this._deliveryQueue = new PrivateEventDeliveryQueue();\n            }\n            for (const listener of this._listeners) {\n                this._deliveryQueue.push(this, listener, event);\n            }\n            // start/stop performance insight collection\n            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n            this._deliveryQueue.deliver();\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n        }\n    }\n}\nexport class EventDeliveryQueue {\n    constructor() {\n        this._queue = new LinkedList();\n    }\n    get size() {\n        return this._queue.size;\n    }\n    push(emitter, listener, event) {\n        this._queue.push(new EventDeliveryQueueElement(emitter, listener, event));\n    }\n    clear(emitter) {\n        const newQueue = new LinkedList();\n        for (const element of this._queue) {\n            if (element.emitter !== emitter) {\n                newQueue.push(element);\n            }\n        }\n        this._queue = newQueue;\n    }\n    deliver() {\n        while (this._queue.size > 0) {\n            const element = this._queue.shift();\n            try {\n                element.listener.invoke(element.event);\n            }\n            catch (e) {\n                onUnexpectedError(e);\n            }\n        }\n    }\n}\n/**\n * An `EventDeliveryQueue` that is guaranteed to be used by a single `Emitter`.\n */\nclass PrivateEventDeliveryQueue extends EventDeliveryQueue {\n    clear(emitter) {\n        // Here we can just clear the entire linked list because\n        // all elements are guaranteed to belong to this emitter\n        this._queue.clear();\n    }\n}\nclass EventDeliveryQueueElement {\n    constructor(emitter, listener, event) {\n        this.emitter = emitter;\n        this.listener = listener;\n        this.event = event;\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                const events = Array.from(this._eventQueue);\n                this._eventQueue.clear();\n                super.fire(this._mergeFn(events));\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._listeners) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onFirstListenerDidAdd: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onLastListenerRemove: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBefore = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet() {\n        return this._autoCloseBefore;\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = ';:.,=}])> \\n\\t';\n","const hasBuffer = (typeof Buffer !== 'undefined');\nlet textDecoder;\nexport class VSBuffer {\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * Math.pow(2, 24)\n        + source[offset + 1] * Math.pow(2, 16)\n        + source[offset + 2] * Math.pow(2, 8)\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/types.js';\nimport { DEFAULT_WORD_REGEXP, getWordAtText } from '../core/wordHelper.js';\nexport class UnicodeTextModelHighlighter {\n    static computeUnicodeHighlights(model, options, range) {\n        const startLine = range ? range.startLineNumber : 1;\n        const endLine = range ? range.endLineNumber : model.getLineCount();\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const candidates = codePointHighlighter.getCandidateCodePoints();\n        let regex;\n        if (candidates === 'allNonBasicAscii') {\n            regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n        }\n        else {\n            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n        }\n        const searcher = new Searcher(null, regex);\n        const ranges = [];\n        let hasMore = false;\n        let m;\n        let ambiguousCharacterCount = 0;\n        let invisibleCharacterCount = 0;\n        let nonBasicAsciiCharacterCount = 0;\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n            const lineContent = model.getLineContent(lineNumber);\n            const lineLength = lineContent.length;\n            // Reset regex to search from the beginning\n            searcher.reset(0);\n            do {\n                m = searcher.next(lineContent);\n                if (m) {\n                    let startIndex = m.index;\n                    let endIndex = m.index + m[0].length;\n                    // Extend range to entire code point\n                    if (startIndex > 0) {\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            startIndex--;\n                        }\n                    }\n                    if (endIndex + 1 < lineLength) {\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            endIndex++;\n                        }\n                    }\n                    const str = lineContent.substring(startIndex, endIndex);\n                    const word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n                    if (highlightReason !== 0 /* SimpleHighlightReason.None */) {\n                        if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {\n                            ambiguousCharacterCount++;\n                        }\n                        else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {\n                            invisibleCharacterCount++;\n                        }\n                        else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {\n                            nonBasicAsciiCharacterCount++;\n                        }\n                        else {\n                            assertNever(highlightReason);\n                        }\n                        const MAX_RESULT_LENGTH = 1000;\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\n                            hasMore = true;\n                            break forLoop;\n                        }\n                        ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n                    }\n                }\n            } while (m);\n        }\n        return {\n            ranges,\n            hasMore,\n            ambiguousCharacterCount,\n            invisibleCharacterCount,\n            nonBasicAsciiCharacterCount\n        };\n    }\n    static computeUnicodeHighlightReason(char, options) {\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n        switch (reason) {\n            case 0 /* SimpleHighlightReason.None */:\n                return null;\n            case 2 /* SimpleHighlightReason.Invisible */:\n                return { kind: 1 /* UnicodeHighlighterReasonKind.Invisible */ };\n            case 3 /* SimpleHighlightReason.Ambiguous */: {\n                const codePoint = char.codePointAt(0);\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n                const notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter((l) => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n                return { kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n            }\n            case 1 /* SimpleHighlightReason.NonBasicASCII */:\n                return { kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */ };\n        }\n    }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n    const src = `[${strings.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;\n    return src;\n}\nclass CodePointHighlighter {\n    constructor(options) {\n        this.options = options;\n        this.allowedCodePoints = new Set(options.allowedCodePoints);\n        this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n    }\n    getCandidateCodePoints() {\n        if (this.options.nonBasicASCII) {\n            return 'allNonBasicAscii';\n        }\n        const set = new Set();\n        if (this.options.invisibleCharacters) {\n            for (const cp of strings.InvisibleCharacters.codePoints) {\n                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n                    set.add(cp);\n                }\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n                set.add(cp);\n            }\n        }\n        for (const cp of this.allowedCodePoints) {\n            set.delete(cp);\n        }\n        return set;\n    }\n    shouldHighlightNonBasicASCII(character, wordContext) {\n        const codePoint = character.codePointAt(0);\n        if (this.allowedCodePoints.has(codePoint)) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.nonBasicASCII) {\n            return 1 /* SimpleHighlightReason.NonBasicASCII */;\n        }\n        let hasBasicASCIICharacters = false;\n        let hasNonConfusableNonBasicAsciiCharacter = false;\n        if (wordContext) {\n            for (const char of wordContext) {\n                const codePoint = char.codePointAt(0);\n                const isBasicASCII = strings.isBasicASCII(char);\n                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n                if (!isBasicASCII &&\n                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&\n                    !strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                    hasNonConfusableNonBasicAsciiCharacter = true;\n                }\n            }\n        }\n        if (\n        /* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&\n            /* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.invisibleCharacters) {\n            // TODO check for emojis\n            if (!isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                return 2 /* SimpleHighlightReason.Invisible */;\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n                return 3 /* SimpleHighlightReason.Ambiguous */;\n            }\n        }\n        return 0 /* SimpleHighlightReason.None */;\n    }\n}\nfunction isAllowedInvisibleCharacter(character) {\n    return character === ' ' || character === '\\n' || character === '\\t';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { globals } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DiffComputer } from '../diff/diffComputer.js';\nimport { MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel.js';\nimport { ensureValidWordDefinition, getWordAtText } from '../core/wordHelper.js';\nimport { computeLinks } from '../languages/linkComputer.js';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from './editorBaseApi.js';\nimport * as types from '../../../base/common/types.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { UnicodeTextModelHighlighter } from './unicodeTextModelHighlighter.js';\n/**\n * @internal\n */\nexport class MirrorModel extends BaseMirrorModel {\n    get uri() {\n        return this._uri;\n    }\n    get eol() {\n        return this._eol;\n    }\n    getValue() {\n        return this.getText();\n    }\n    getLinesContent() {\n        return this._lines.slice(0);\n    }\n    getLineCount() {\n        return this._lines.length;\n    }\n    getLineContent(lineNumber) {\n        return this._lines[lineNumber - 1];\n    }\n    getWordAtPosition(position, wordDefinition) {\n        const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n        if (wordAtText) {\n            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n        }\n        return null;\n    }\n    words(wordDefinition) {\n        const lines = this._lines;\n        const wordenize = this._wordenize.bind(this);\n        let lineNumber = 0;\n        let lineText = '';\n        let wordRangesIdx = 0;\n        let wordRanges = [];\n        return {\n            *[Symbol.iterator]() {\n                while (true) {\n                    if (wordRangesIdx < wordRanges.length) {\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n                        wordRangesIdx += 1;\n                        yield value;\n                    }\n                    else {\n                        if (lineNumber < lines.length) {\n                            lineText = lines[lineNumber];\n                            wordRanges = wordenize(lineText, wordDefinition);\n                            wordRangesIdx = 0;\n                            lineNumber += 1;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    getLineWords(lineNumber, wordDefinition) {\n        const content = this._lines[lineNumber - 1];\n        const ranges = this._wordenize(content, wordDefinition);\n        const words = [];\n        for (const range of ranges) {\n            words.push({\n                word: content.substring(range.start, range.end),\n                startColumn: range.start + 1,\n                endColumn: range.end + 1\n            });\n        }\n        return words;\n    }\n    _wordenize(content, wordDefinition) {\n        const result = [];\n        let match;\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n        while (match = wordDefinition.exec(content)) {\n            if (match[0].length === 0) {\n                // it did match the empty string\n                break;\n            }\n            result.push({ start: match.index, end: match.index + match[0].length });\n        }\n        return result;\n    }\n    getValueInRange(range) {\n        range = this._validateRange(range);\n        if (range.startLineNumber === range.endLineNumber) {\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n        }\n        const lineEnding = this._eol;\n        const startLineIndex = range.startLineNumber - 1;\n        const endLineIndex = range.endLineNumber - 1;\n        const resultLines = [];\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n            resultLines.push(this._lines[i]);\n        }\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n        return resultLines.join(lineEnding);\n    }\n    offsetAt(position) {\n        position = this._validatePosition(position);\n        this._ensureLineStarts();\n        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n    }\n    positionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        this._ensureLineStarts();\n        const out = this._lineStarts.getIndexOf(offset);\n        const lineLength = this._lines[out.index].length;\n        // Ensure we return a valid position\n        return {\n            lineNumber: 1 + out.index,\n            column: 1 + Math.min(out.remainder, lineLength)\n        };\n    }\n    _validateRange(range) {\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n        if (start.lineNumber !== range.startLineNumber\n            || start.column !== range.startColumn\n            || end.lineNumber !== range.endLineNumber\n            || end.column !== range.endColumn) {\n            return {\n                startLineNumber: start.lineNumber,\n                startColumn: start.column,\n                endLineNumber: end.lineNumber,\n                endColumn: end.column\n            };\n        }\n        return range;\n    }\n    _validatePosition(position) {\n        if (!Position.isIPosition(position)) {\n            throw new Error('bad position');\n        }\n        let { lineNumber, column } = position;\n        let hasChanged = false;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            column = 1;\n            hasChanged = true;\n        }\n        else if (lineNumber > this._lines.length) {\n            lineNumber = this._lines.length;\n            column = this._lines[lineNumber - 1].length + 1;\n            hasChanged = true;\n        }\n        else {\n            const maxCharacter = this._lines[lineNumber - 1].length + 1;\n            if (column < 1) {\n                column = 1;\n                hasChanged = true;\n            }\n            else if (column > maxCharacter) {\n                column = maxCharacter;\n                hasChanged = true;\n            }\n        }\n        if (!hasChanged) {\n            return position;\n        }\n        else {\n            return { lineNumber, column };\n        }\n    }\n}\n/**\n * @internal\n */\nexport class EditorSimpleWorker {\n    constructor(host, foreignModuleFactory) {\n        this._host = host;\n        this._models = Object.create(null);\n        this._foreignModuleFactory = foreignModuleFactory;\n        this._foreignModule = null;\n    }\n    dispose() {\n        this._models = Object.create(null);\n    }\n    _getModel(uri) {\n        return this._models[uri];\n    }\n    _getModels() {\n        const all = [];\n        Object.keys(this._models).forEach((key) => all.push(this._models[key]));\n        return all;\n    }\n    acceptNewModel(data) {\n        this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n    }\n    acceptModelChanged(strURL, e) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        const model = this._models[strURL];\n        model.onEvents(e);\n    }\n    acceptRemovedModel(strURL) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        delete this._models[strURL];\n    }\n    computeUnicodeHighlights(url, options, range) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(url);\n            if (!model) {\n                return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n            }\n            return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n        });\n    }\n    // ---- BEGIN diff --------------------------------------------------------------------------\n    computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const original = this._getModel(originalUrl);\n            const modified = this._getModel(modifiedUrl);\n            if (!original || !modified) {\n                return null;\n            }\n            return EditorSimpleWorker.computeDiff(original, modified, ignoreTrimWhitespace, maxComputationTime);\n        });\n    }\n    static computeDiff(originalTextModel, modifiedTextModel, ignoreTrimWhitespace, maxComputationTime) {\n        const originalLines = originalTextModel.getLinesContent();\n        const modifiedLines = modifiedTextModel.getLinesContent();\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            shouldComputeCharChanges: true,\n            shouldPostProcessCharChanges: true,\n            shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n            shouldMakePrettyDiff: true,\n            maxComputationTime: maxComputationTime\n        });\n        const diffResult = diffComputer.computeDiff();\n        const identical = (diffResult.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n        return {\n            quitEarly: diffResult.quitEarly,\n            identical: identical,\n            changes: diffResult.changes\n        };\n    }\n    static _modelsAreIdentical(original, modified) {\n        const originalLineCount = original.getLineCount();\n        const modifiedLineCount = modified.getLineCount();\n        if (originalLineCount !== modifiedLineCount) {\n            return false;\n        }\n        for (let line = 1; line <= originalLineCount; line++) {\n            const originalLine = original.getLineContent(line);\n            const modifiedLine = modified.getLineContent(line);\n            if (originalLine !== modifiedLine) {\n                return false;\n            }\n        }\n        return true;\n    }\n    computeMoreMinimalEdits(modelUrl, edits) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return edits;\n            }\n            const result = [];\n            let lastEol = undefined;\n            edits = edits.slice(0).sort((a, b) => {\n                if (a.range && b.range) {\n                    return Range.compareRangesUsingStarts(a.range, b.range);\n                }\n                // eol only changes should go to the end\n                const aRng = a.range ? 0 : 1;\n                const bRng = b.range ? 0 : 1;\n                return aRng - bRng;\n            });\n            for (let { range, text, eol } of edits) {\n                if (typeof eol === 'number') {\n                    lastEol = eol;\n                }\n                if (Range.isEmpty(range) && !text) {\n                    // empty change\n                    continue;\n                }\n                const original = model.getValueInRange(range);\n                text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n                if (original === text) {\n                    // noop\n                    continue;\n                }\n                // make sure diff won't take too long\n                if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n                    result.push({ range, text });\n                    continue;\n                }\n                // compute diff between original and edit.text\n                const changes = stringDiff(original, text, false);\n                const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n                for (const change of changes) {\n                    const start = model.positionAt(editOffset + change.originalStart);\n                    const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                    const newEdit = {\n                        text: text.substr(change.modifiedStart, change.modifiedLength),\n                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                    };\n                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                        result.push(newEdit);\n                    }\n                }\n            }\n            if (typeof lastEol === 'number') {\n                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n            }\n            return result;\n        });\n    }\n    // ---- END minimal edits ---------------------------------------------------------------\n    computeLinks(modelUrl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return null;\n            }\n            return computeLinks(model);\n        });\n    }\n    textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const sw = new StopWatch(true);\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            const seen = new Set();\n            outer: for (const url of modelUrls) {\n                const model = this._getModel(url);\n                if (!model) {\n                    continue;\n                }\n                for (const word of model.words(wordDefRegExp)) {\n                    if (word === leadingWord || !isNaN(Number(word))) {\n                        continue;\n                    }\n                    seen.add(word);\n                    if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n                        break outer;\n                    }\n                }\n            }\n            return { words: Array.from(seen), duration: sw.elapsed() };\n        });\n    }\n    // ---- END suggest --------------------------------------------------------------------------\n    //#region -- word ranges --\n    computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return Object.create(null);\n            }\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            const result = Object.create(null);\n            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n                const words = model.getLineWords(line, wordDefRegExp);\n                for (const word of words) {\n                    if (!isNaN(Number(word.word))) {\n                        continue;\n                    }\n                    let array = result[word.word];\n                    if (!array) {\n                        array = [];\n                        result[word.word] = array;\n                    }\n                    array.push({\n                        startLineNumber: line,\n                        startColumn: word.startColumn,\n                        endLineNumber: line,\n                        endColumn: word.endColumn\n                    });\n                }\n            }\n            return result;\n        });\n    }\n    //#endregion\n    navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return null;\n            }\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            if (range.startColumn === range.endColumn) {\n                range = {\n                    startLineNumber: range.startLineNumber,\n                    startColumn: range.startColumn,\n                    endLineNumber: range.endLineNumber,\n                    endColumn: range.endColumn + 1\n                };\n            }\n            const selectionText = model.getValueInRange(range);\n            const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n            if (!wordRange) {\n                return null;\n            }\n            const word = model.getValueInRange(wordRange);\n            const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n            return result;\n        });\n    }\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\n    loadForeignModule(moduleId, createData, foreignHostMethods) {\n        const proxyMethodRequest = (method, args) => {\n            return this._host.fhr(method, args);\n        };\n        const foreignHost = types.createProxyObject(foreignHostMethods, proxyMethodRequest);\n        const ctx = {\n            host: foreignHost,\n            getMirrorModels: () => {\n                return this._getModels();\n            }\n        };\n        if (this._foreignModuleFactory) {\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\n            // static foreing module\n            return Promise.resolve(types.getAllMethodNames(this._foreignModule));\n        }\n        // ESM-comment-begin\n        // \t\treturn new Promise<any>((resolve, reject) => {\n        // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n        // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n        // \n        // \t\t\t\tresolve(types.getAllMethodNames(this._foreignModule));\n        // \n        // \t\t\t}, reject);\n        // \t\t});\n        // ESM-comment-end\n        // ESM-uncomment-begin\n        return Promise.reject(new Error(`Unexpected usage`));\n        // ESM-uncomment-end\n    }\n    // foreign method request\n    fmr(method, args) {\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\n// ---- END diff --------------------------------------------------------------------------\n// ---- BEGIN minimal edits ---------------------------------------------------------------\nEditorSimpleWorker._diffLimit = 100000;\n// ---- BEGIN suggest --------------------------------------------------------------------------\nEditorSimpleWorker._suggestionsLimit = 10000;\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host) {\n    return new EditorSimpleWorker(host, null);\n}\nif (typeof importScripts === 'function') {\n    // Running in a web worker\n    globals.monaco = createMonacoBaseAPI();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as languages from '../../../common/languages.js';\nimport { NullState, nullTokenizeEncoded, nullTokenize } from '../../../common/languages/nullTokenize.js';\nimport * as monarchCommon from './monarchCommon.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nconst CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\nclass MonarchStackElementFactory {\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    static create(parent, state) {\n        return this._INSTANCE.create(parent, state);\n    }\n    create(parent, state) {\n        if (parent !== null && parent.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchStackElement(parent, state);\n        }\n        let stackElementId = MonarchStackElement.getStackElementId(parent);\n        if (stackElementId.length > 0) {\n            stackElementId += '|';\n        }\n        stackElementId += state;\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchStackElement(parent, state);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\nclass MonarchStackElement {\n    constructor(parent, state) {\n        this.parent = parent;\n        this.state = state;\n        this.depth = (this.parent ? this.parent.depth : 0) + 1;\n    }\n    static getStackElementId(element) {\n        let result = '';\n        while (element !== null) {\n            if (result.length > 0) {\n                result += '|';\n            }\n            result += element.state;\n            element = element.parent;\n        }\n        return result;\n    }\n    static _equals(a, b) {\n        while (a !== null && b !== null) {\n            if (a === b) {\n                return true;\n            }\n            if (a.state !== b.state) {\n                return false;\n            }\n            a = a.parent;\n            b = b.parent;\n        }\n        if (a === null && b === null) {\n            return true;\n        }\n        return false;\n    }\n    equals(other) {\n        return MonarchStackElement._equals(this, other);\n    }\n    push(state) {\n        return MonarchStackElementFactory.create(this, state);\n    }\n    pop() {\n        return this.parent;\n    }\n    popall() {\n        let result = this;\n        while (result.parent) {\n            result = result.parent;\n        }\n        return result;\n    }\n    switchTo(state) {\n        return MonarchStackElementFactory.create(this.parent, state);\n    }\n}\nclass EmbeddedLanguageData {\n    constructor(languageId, state) {\n        this.languageId = languageId;\n        this.state = state;\n    }\n    equals(other) {\n        return (this.languageId === other.languageId\n            && this.state.equals(other.state));\n    }\n    clone() {\n        const stateClone = this.state.clone();\n        // save an object\n        if (stateClone === this.state) {\n            return this;\n        }\n        return new EmbeddedLanguageData(this.languageId, this.state);\n    }\n}\n/**\n * Reuse the same line states up to a certain depth.\n */\nclass MonarchLineStateFactory {\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    static create(stack, embeddedLanguageData) {\n        return this._INSTANCE.create(stack, embeddedLanguageData);\n    }\n    create(stack, embeddedLanguageData) {\n        if (embeddedLanguageData !== null) {\n            // no caching when embedding\n            return new MonarchLineState(stack, embeddedLanguageData);\n        }\n        if (stack !== null && stack.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchLineState(stack, embeddedLanguageData);\n        }\n        const stackElementId = MonarchStackElement.getStackElementId(stack);\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchLineState(stack, null);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\nclass MonarchLineState {\n    constructor(stack, embeddedLanguageData) {\n        this.stack = stack;\n        this.embeddedLanguageData = embeddedLanguageData;\n    }\n    clone() {\n        const embeddedlanguageDataClone = this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null;\n        // save an object\n        if (embeddedlanguageDataClone === this.embeddedLanguageData) {\n            return this;\n        }\n        return MonarchLineStateFactory.create(this.stack, this.embeddedLanguageData);\n    }\n    equals(other) {\n        if (!(other instanceof MonarchLineState)) {\n            return false;\n        }\n        if (!this.stack.equals(other.stack)) {\n            return false;\n        }\n        if (this.embeddedLanguageData === null && other.embeddedLanguageData === null) {\n            return true;\n        }\n        if (this.embeddedLanguageData === null || other.embeddedLanguageData === null) {\n            return false;\n        }\n        return this.embeddedLanguageData.equals(other.embeddedLanguageData);\n    }\n}\nclass MonarchClassicTokensCollector {\n    constructor() {\n        this._tokens = [];\n        this._languageId = null;\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n    }\n    enterLanguage(languageId) {\n        this._languageId = languageId;\n    }\n    emit(startOffset, type) {\n        if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {\n            return;\n        }\n        this._lastTokenType = type;\n        this._lastTokenLanguage = this._languageId;\n        this._tokens.push(new languages.Token(startOffset, type, this._languageId));\n    }\n    nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n        const nestedLanguageId = embeddedLanguageData.languageId;\n        const embeddedModeState = embeddedLanguageData.state;\n        const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (!nestedLanguageTokenizationSupport) {\n            this.enterLanguage(nestedLanguageId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        const nestedResult = nestedLanguageTokenizationSupport.tokenize(embeddedLanguageLine, hasEOL, embeddedModeState);\n        if (offsetDelta !== 0) {\n            for (const token of nestedResult.tokens) {\n                this._tokens.push(new languages.Token(token.offset + offsetDelta, token.type, token.language));\n            }\n        }\n        else {\n            this._tokens = this._tokens.concat(nestedResult.tokens);\n        }\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n        this._languageId = null;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new languages.TokenizationResult(this._tokens, endState);\n    }\n}\nclass MonarchModernTokensCollector {\n    constructor(languageService, theme) {\n        this._languageService = languageService;\n        this._theme = theme;\n        this._prependTokens = null;\n        this._tokens = [];\n        this._currentLanguageId = 0 /* LanguageId.Null */;\n        this._lastTokenMetadata = 0;\n    }\n    enterLanguage(languageId) {\n        this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n    }\n    emit(startOffset, type) {\n        const metadata = this._theme.match(this._currentLanguageId, type);\n        if (this._lastTokenMetadata === metadata) {\n            return;\n        }\n        this._lastTokenMetadata = metadata;\n        this._tokens.push(startOffset);\n        this._tokens.push(metadata);\n    }\n    static _merge(a, b, c) {\n        const aLen = (a !== null ? a.length : 0);\n        const bLen = b.length;\n        const cLen = (c !== null ? c.length : 0);\n        if (aLen === 0 && bLen === 0 && cLen === 0) {\n            return new Uint32Array(0);\n        }\n        if (aLen === 0 && bLen === 0) {\n            return c;\n        }\n        if (bLen === 0 && cLen === 0) {\n            return a;\n        }\n        const result = new Uint32Array(aLen + bLen + cLen);\n        if (a !== null) {\n            result.set(a);\n        }\n        for (let i = 0; i < bLen; i++) {\n            result[aLen + i] = b[i];\n        }\n        if (c !== null) {\n            result.set(c, aLen + bLen);\n        }\n        return result;\n    }\n    nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n        const nestedLanguageId = embeddedLanguageData.languageId;\n        const embeddedModeState = embeddedLanguageData.state;\n        const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (!nestedLanguageTokenizationSupport) {\n            this.enterLanguage(nestedLanguageId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        const nestedResult = nestedLanguageTokenizationSupport.tokenizeEncoded(embeddedLanguageLine, hasEOL, embeddedModeState);\n        if (offsetDelta !== 0) {\n            for (let i = 0, len = nestedResult.tokens.length; i < len; i += 2) {\n                nestedResult.tokens[i] += offsetDelta;\n            }\n        }\n        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n        this._tokens = [];\n        this._currentLanguageId = 0;\n        this._lastTokenMetadata = 0;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n    }\n}\nlet MonarchTokenizer = class MonarchTokenizer {\n    constructor(languageService, standaloneThemeService, languageId, lexer, _configurationService) {\n        this._configurationService = _configurationService;\n        this._languageService = languageService;\n        this._standaloneThemeService = standaloneThemeService;\n        this._languageId = languageId;\n        this._lexer = lexer;\n        this._embeddedLanguages = Object.create(null);\n        this.embeddedLoaded = Promise.resolve(undefined);\n        // Set up listening for embedded modes\n        let emitting = false;\n        this._tokenizationRegistryListener = languages.TokenizationRegistry.onDidChange((e) => {\n            if (emitting) {\n                return;\n            }\n            let isOneOfMyEmbeddedModes = false;\n            for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n                const language = e.changedLanguages[i];\n                if (this._embeddedLanguages[language]) {\n                    isOneOfMyEmbeddedModes = true;\n                    break;\n                }\n            }\n            if (isOneOfMyEmbeddedModes) {\n                emitting = true;\n                languages.TokenizationRegistry.fire([this._languageId]);\n                emitting = false;\n            }\n        });\n        this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {\n            overrideIdentifier: this._languageId\n        });\n        this._configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('editor.maxTokenizationLineLength')) {\n                this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {\n                    overrideIdentifier: this._languageId\n                });\n            }\n        });\n    }\n    dispose() {\n        this._tokenizationRegistryListener.dispose();\n    }\n    getLoadStatus() {\n        const promises = [];\n        for (const nestedLanguageId in this._embeddedLanguages) {\n            const tokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n            if (tokenizationSupport) {\n                // The nested language is already loaded\n                if (tokenizationSupport instanceof MonarchTokenizer) {\n                    const nestedModeStatus = tokenizationSupport.getLoadStatus();\n                    if (nestedModeStatus.loaded === false) {\n                        promises.push(nestedModeStatus.promise);\n                    }\n                }\n                continue;\n            }\n            if (!languages.TokenizationRegistry.isResolved(nestedLanguageId)) {\n                // The nested language is in the process of being loaded\n                promises.push(languages.TokenizationRegistry.getOrCreate(nestedLanguageId));\n            }\n        }\n        if (promises.length === 0) {\n            return {\n                loaded: true\n            };\n        }\n        return {\n            loaded: false,\n            promise: Promise.all(promises).then(_ => undefined)\n        };\n    }\n    getInitialState() {\n        const rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n        return MonarchLineStateFactory.create(rootState, null);\n    }\n    tokenize(line, hasEOL, lineState) {\n        if (line.length >= this._maxTokenizationLineLength) {\n            return nullTokenize(this._languageId, lineState);\n        }\n        const tokensCollector = new MonarchClassicTokensCollector();\n        const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    tokenizeEncoded(line, hasEOL, lineState) {\n        if (line.length >= this._maxTokenizationLineLength) {\n            return nullTokenizeEncoded(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), lineState);\n        }\n        const tokensCollector = new MonarchModernTokensCollector(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme);\n        const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    _tokenize(line, hasEOL, lineState, collector) {\n        if (lineState.embeddedLanguageData) {\n            return this._nestedTokenize(line, hasEOL, lineState, 0, collector);\n        }\n        else {\n            return this._myTokenize(line, hasEOL, lineState, 0, collector);\n        }\n    }\n    _findLeavingNestedLanguageOffset(line, state) {\n        let rules = this._lexer.tokenizer[state.stack.state];\n        if (!rules) {\n            rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n            if (!rules) {\n                throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n            }\n        }\n        let popOffset = -1;\n        let hasEmbeddedPopRule = false;\n        for (const rule of rules) {\n            if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n                continue;\n            }\n            hasEmbeddedPopRule = true;\n            let regex = rule.regex;\n            const regexSource = rule.regex.source;\n            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n                const flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n            }\n            const result = line.search(regex);\n            if (result === -1 || (result !== 0 && rule.matchOnlyAtLineStart)) {\n                continue;\n            }\n            if (popOffset === -1 || result < popOffset) {\n                popOffset = result;\n            }\n        }\n        if (!hasEmbeddedPopRule) {\n            throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n        }\n        return popOffset;\n    }\n    _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n        const popOffset = this._findLeavingNestedLanguageOffset(line, lineState);\n        if (popOffset === -1) {\n            // tokenization will not leave nested language\n            const nestedEndState = tokensCollector.nestedLanguageTokenize(line, hasEOL, lineState.embeddedLanguageData, offsetDelta);\n            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedLanguageData(lineState.embeddedLanguageData.languageId, nestedEndState));\n        }\n        const nestedLanguageLine = line.substring(0, popOffset);\n        if (nestedLanguageLine.length > 0) {\n            // tokenize with the nested language\n            tokensCollector.nestedLanguageTokenize(nestedLanguageLine, false, lineState.embeddedLanguageData, offsetDelta);\n        }\n        const restOfTheLine = line.substring(popOffset);\n        return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n    }\n    _safeRuleName(rule) {\n        if (rule) {\n            return rule.name;\n        }\n        return '(unknown)';\n    }\n    _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n        tokensCollector.enterLanguage(this._languageId);\n        const lineWithoutLFLength = lineWithoutLF.length;\n        const line = (hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF);\n        const lineLength = line.length;\n        let embeddedLanguageData = lineState.embeddedLanguageData;\n        let stack = lineState.stack;\n        let pos = 0;\n        let groupMatching = null;\n        // See https://github.com/microsoft/monaco-editor/issues/1235\n        // Evaluate rules at least once for an empty line\n        let forceEvaluation = true;\n        while (forceEvaluation || pos < lineLength) {\n            const pos0 = pos;\n            const stackLen0 = stack.depth;\n            const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n            const state = stack.state;\n            let matches = null;\n            let matched = null;\n            let action = null;\n            let rule = null;\n            let enteringEmbeddedLanguage = null;\n            // check if we need to process group matches first\n            if (groupMatching) {\n                matches = groupMatching.matches;\n                const groupEntry = groupMatching.groups.shift();\n                matched = groupEntry.matched;\n                action = groupEntry.action;\n                rule = groupMatching.rule;\n                // cleanup if necessary\n                if (groupMatching.groups.length === 0) {\n                    groupMatching = null;\n                }\n            }\n            else {\n                // otherwise we match on the token stream\n                if (!forceEvaluation && pos >= lineLength) {\n                    // nothing to do\n                    break;\n                }\n                forceEvaluation = false;\n                // get the rules for this state\n                let rules = this._lexer.tokenizer[state];\n                if (!rules) {\n                    rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n                    if (!rules) {\n                        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n                    }\n                }\n                // try each rule until we match\n                const restOfLine = line.substr(pos);\n                for (const rule of rules) {\n                    if (pos === 0 || !rule.matchOnlyAtLineStart) {\n                        matches = restOfLine.match(rule.regex);\n                        if (matches) {\n                            matched = matches[0];\n                            action = rule.action;\n                            break;\n                        }\n                    }\n                }\n            }\n            // We matched 'rule' with 'matches' and 'action'\n            if (!matches) {\n                matches = [''];\n                matched = '';\n            }\n            if (!action) {\n                // bad: we didn't match anything, and there is no action to take\n                // we need to advance the stream or we get progress trouble\n                if (pos < lineLength) {\n                    matches = [line.charAt(pos)];\n                    matched = matches[0];\n                }\n                action = this._lexer.defaultToken;\n            }\n            if (matched === null) {\n                // should never happen, needed for strict null checking\n                break;\n            }\n            // advance stream\n            pos += matched.length;\n            // maybe call action function (used for 'cases')\n            while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n                action = action.test(matched, matches, state, pos === lineLength);\n            }\n            let result = null;\n            // set the result: either a string or an array of actions\n            if (typeof action === 'string' || Array.isArray(action)) {\n                result = action;\n            }\n            else if (action.group) {\n                result = action.group;\n            }\n            else if (action.token !== null && action.token !== undefined) {\n                // do $n replacements?\n                if (action.tokenSubst) {\n                    result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n                }\n                else {\n                    result = action.token;\n                }\n                // enter embedded language?\n                if (action.nextEmbedded) {\n                    if (action.nextEmbedded === '@pop') {\n                        if (!embeddedLanguageData) {\n                            throw monarchCommon.createError(this._lexer, 'cannot pop embedded language if not inside one');\n                        }\n                        embeddedLanguageData = null;\n                    }\n                    else if (embeddedLanguageData) {\n                        throw monarchCommon.createError(this._lexer, 'cannot enter embedded language from within an embedded language');\n                    }\n                    else {\n                        enteringEmbeddedLanguage = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n                    }\n                }\n                // state transformations\n                if (action.goBack) { // back up the stream..\n                    pos = Math.max(0, pos - action.goBack);\n                }\n                if (action.switchTo && typeof action.switchTo === 'string') {\n                    let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n                    if (nextState[0] === '@') {\n                        nextState = nextState.substr(1); // peel off starting '@'\n                    }\n                    if (!monarchCommon.findRules(this._lexer, nextState)) {\n                        throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                    }\n                    else {\n                        stack = stack.switchTo(nextState);\n                    }\n                }\n                else if (action.transform && typeof action.transform === 'function') {\n                    throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n                }\n                else if (action.next) {\n                    if (action.next === '@push') {\n                        if (stack.depth >= this._lexer.maxStack) {\n                            throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\n                                stack.state + ',' + stack.parent.state + ',...]');\n                        }\n                        else {\n                            stack = stack.push(state);\n                        }\n                    }\n                    else if (action.next === '@pop') {\n                        if (stack.depth <= 1) {\n                            throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.pop();\n                        }\n                    }\n                    else if (action.next === '@popall') {\n                        stack = stack.popall();\n                    }\n                    else {\n                        let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n                        if (nextState[0] === '@') {\n                            nextState = nextState.substr(1); // peel off starting '@'\n                        }\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\n                            throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.push(nextState);\n                        }\n                    }\n                }\n                if (action.log && typeof (action.log) === 'string') {\n                    monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n                }\n            }\n            // check result\n            if (result === null) {\n                throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n            }\n            const computeNewStateForEmbeddedLanguage = (enteringEmbeddedLanguage) => {\n                // support language names, mime types, and language ids\n                const languageId = (this._languageService.getLanguageIdByLanguageName(enteringEmbeddedLanguage)\n                    || this._languageService.getLanguageIdByMimeType(enteringEmbeddedLanguage)\n                    || enteringEmbeddedLanguage);\n                const embeddedLanguageData = this._getNestedEmbeddedLanguageData(languageId);\n                if (pos < lineLength) {\n                    // there is content from the embedded language on this line\n                    const restOfLine = lineWithoutLF.substr(pos);\n                    return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedLanguageData), offsetDelta + pos, tokensCollector);\n                }\n                else {\n                    return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n                }\n            };\n            // is the result a group match?\n            if (Array.isArray(result)) {\n                if (groupMatching && groupMatching.groups.length > 0) {\n                    throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n                }\n                if (matches.length !== result.length + 1) {\n                    throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n                }\n                let totalLen = 0;\n                for (let i = 1; i < matches.length; i++) {\n                    totalLen += matches[i].length;\n                }\n                if (totalLen !== matched.length) {\n                    throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n                }\n                groupMatching = {\n                    rule: rule,\n                    matches: matches,\n                    groups: []\n                };\n                for (let i = 0; i < result.length; i++) {\n                    groupMatching.groups[i] = {\n                        action: result[i],\n                        matched: matches[i + 1]\n                    };\n                }\n                pos -= matched.length;\n                // call recursively to initiate first result match\n                continue;\n            }\n            else {\n                // regular result\n                // check for '@rematch'\n                if (result === '@rematch') {\n                    pos -= matched.length;\n                    matched = ''; // better set the next state too..\n                    matches = null;\n                    result = '';\n                    // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n                    // a state transition should occur.\n                    if (enteringEmbeddedLanguage !== null) {\n                        return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n                    }\n                }\n                // check progress\n                if (matched.length === 0) {\n                    if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n                        continue;\n                    }\n                    else {\n                        throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n                    }\n                }\n                // return the result (and check for brace matching)\n                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n                let tokenType = null;\n                if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n                    const rest = result.substr('@brackets'.length);\n                    const bracket = findBracket(this._lexer, matched);\n                    if (!bracket) {\n                        throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n                    }\n                    tokenType = monarchCommon.sanitize(bracket.token + rest);\n                }\n                else {\n                    const token = (result === '' ? '' : result + this._lexer.tokenPostfix);\n                    tokenType = monarchCommon.sanitize(token);\n                }\n                if (pos0 < lineWithoutLFLength) {\n                    tokensCollector.emit(pos0 + offsetDelta, tokenType);\n                }\n            }\n            if (enteringEmbeddedLanguage !== null) {\n                return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n            }\n        }\n        return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n    }\n    _getNestedEmbeddedLanguageData(languageId) {\n        if (!this._languageService.isRegisteredLanguageId(languageId)) {\n            return new EmbeddedLanguageData(languageId, NullState);\n        }\n        if (languageId !== this._languageId) {\n            // Fire language loading event\n            languages.TokenizationRegistry.getOrCreate(languageId);\n            this._embeddedLanguages[languageId] = true;\n        }\n        const tokenizationSupport = languages.TokenizationRegistry.get(languageId);\n        if (tokenizationSupport) {\n            return new EmbeddedLanguageData(languageId, tokenizationSupport.getInitialState());\n        }\n        return new EmbeddedLanguageData(languageId, NullState);\n    }\n};\nMonarchTokenizer = __decorate([\n    __param(4, IConfigurationService)\n], MonarchTokenizer);\nexport { MonarchTokenizer };\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\nfunction findBracket(lexer, matched) {\n    if (!matched) {\n        return null;\n    }\n    matched = monarchCommon.fixCase(lexer, matched);\n    const brackets = lexer.brackets;\n    for (const bracket of brackets) {\n        if (bracket.open === matched) {\n            return { token: bracket.token, bracketType: 1 /* monarchCommon.MonarchBracket.Open */ };\n        }\n        else if (bracket.close === matched) {\n            return { token: bracket.token, bracketType: -1 /* monarchCommon.MonarchBracket.Close */ };\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../../common/tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../../common/languages.js';\nimport { RenderLineInput, renderViewLine2 as renderViewLine } from '../../common/viewLayout/viewLineRenderer.js';\nimport { ViewLineRenderingData } from '../../common/viewModel.js';\nimport { MonarchTokenizer } from '../common/monarch/monarchLexer.js';\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('standaloneColorizer', { createHTML: value => value });\nexport class Colorizer {\n    static colorizeElement(themeService, languageService, domNode, options) {\n        options = options || {};\n        const theme = options.theme || 'vs';\n        const mimeType = options.mimeType || domNode.getAttribute('lang') || domNode.getAttribute('data-lang');\n        if (!mimeType) {\n            console.error('Mode not detected');\n            return Promise.resolve();\n        }\n        const languageId = languageService.getLanguageIdByMimeType(mimeType) || mimeType;\n        themeService.setTheme(theme);\n        const text = domNode.firstChild ? domNode.firstChild.nodeValue : '';\n        domNode.className += ' ' + theme;\n        const render = (str) => {\n            var _a;\n            const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(str)) !== null && _a !== void 0 ? _a : str;\n            domNode.innerHTML = trustedhtml;\n        };\n        return this.colorize(languageService, text || '', languageId, options).then(render, (err) => console.error(err));\n    }\n    static colorize(languageService, text, languageId, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const languageIdCodec = languageService.languageIdCodec;\n            let tabSize = 4;\n            if (options && typeof options.tabSize === 'number') {\n                tabSize = options.tabSize;\n            }\n            if (strings.startsWithUTF8BOM(text)) {\n                text = text.substr(1);\n            }\n            const lines = strings.splitLines(text);\n            if (!languageService.isRegisteredLanguageId(languageId)) {\n                return _fakeColorize(lines, tabSize, languageIdCodec);\n            }\n            const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);\n            if (tokenizationSupport) {\n                return _colorize(lines, tabSize, tokenizationSupport, languageIdCodec);\n            }\n            return _fakeColorize(lines, tabSize, languageIdCodec);\n        });\n    }\n    static colorizeLine(line, mightContainNonBasicASCII, mightContainRTL, tokens, tabSize = 4) {\n        const isBasicASCII = ViewLineRenderingData.isBasicASCII(line, mightContainNonBasicASCII);\n        const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII, mightContainRTL);\n        const renderResult = renderViewLine(new RenderLineInput(false, true, line, false, isBasicASCII, containsRTL, 0, tokens, [], tabSize, 0, 0, 0, 0, -1, 'none', false, false, null));\n        return renderResult.html;\n    }\n    static colorizeModelLine(model, lineNumber, tabSize = 4) {\n        const content = model.getLineContent(lineNumber);\n        model.tokenization.forceTokenization(lineNumber);\n        const tokens = model.tokenization.getLineTokens(lineNumber);\n        const inflatedTokens = tokens.inflate();\n        return this.colorizeLine(content, model.mightContainNonBasicASCII(), model.mightContainRTL(), inflatedTokens, tabSize);\n    }\n}\nfunction _colorize(lines, tabSize, tokenizationSupport, languageIdCodec) {\n    return new Promise((c, e) => {\n        const execute = () => {\n            const result = _actualColorize(lines, tabSize, tokenizationSupport, languageIdCodec);\n            if (tokenizationSupport instanceof MonarchTokenizer) {\n                const status = tokenizationSupport.getLoadStatus();\n                if (status.loaded === false) {\n                    status.promise.then(execute, e);\n                    return;\n                }\n            }\n            c(result);\n        };\n        execute();\n    });\n}\nfunction _fakeColorize(lines, tabSize, languageIdCodec) {\n    let html = [];\n    const defaultMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = defaultMetadata;\n    for (let i = 0, length = lines.length; i < length; i++) {\n        const line = lines[i];\n        tokens[0] = line.length;\n        const lineTokens = new LineTokens(tokens, line, languageIdCodec);\n        const isBasicASCII = ViewLineRenderingData.isBasicASCII(line, /* check for basic ASCII */ true);\n        const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII, /* check for RTL */ true);\n        const renderResult = renderViewLine(new RenderLineInput(false, true, line, false, isBasicASCII, containsRTL, 0, lineTokens, [], tabSize, 0, 0, 0, 0, -1, 'none', false, false, null));\n        html = html.concat(renderResult.html);\n        html.push('<br/>');\n    }\n    return html.join('');\n}\nfunction _actualColorize(lines, tabSize, tokenizationSupport, languageIdCodec) {\n    let html = [];\n    let state = tokenizationSupport.getInitialState();\n    for (let i = 0, length = lines.length; i < length; i++) {\n        const line = lines[i];\n        const tokenizeResult = tokenizationSupport.tokenizeEncoded(line, true, state);\n        LineTokens.convertToEndOffset(tokenizeResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizeResult.tokens, line, languageIdCodec);\n        const isBasicASCII = ViewLineRenderingData.isBasicASCII(line, /* check for basic ASCII */ true);\n        const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII, /* check for RTL */ true);\n        const renderResult = renderViewLine(new RenderLineInput(false, true, line, false, isBasicASCII, containsRTL, 0, lineTokens.inflate(), [], tabSize, 0, 0, 0, 0, -1, 'none', false, false, null));\n        html = html.concat(renderResult.html);\n        html.push('<br/>');\n        state = tokenizeResult.endState;\n    }\n    return html.join('');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from './browser.js';\nimport * as platform from '../common/platform.js';\n/**\n * Browser feature we can support in current platform, browser and environment.\n */\nexport const BrowserFeatures = {\n    clipboard: {\n        writeText: (platform.isNative\n            || (document.queryCommandSupported && document.queryCommandSupported('copy'))\n            || !!(navigator && navigator.clipboard && navigator.clipboard.writeText)),\n        readText: (platform.isNative\n            || !!(navigator && navigator.clipboard && navigator.clipboard.readText))\n    },\n    keyboard: (() => {\n        if (platform.isNative || browser.isStandalone()) {\n            return 0 /* KeyboardSupport.Always */;\n        }\n        if (navigator.keyboard || browser.isSafari) {\n            return 1 /* KeyboardSupport.FullScreen */;\n        }\n        return 2 /* KeyboardSupport.None */;\n    })(),\n    // 'ontouchstart' in window always evaluates to true with typescript's modern typings. This causes `window` to be\n    // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast\n    touch: 'ontouchstart' in window || navigator.maxTouchPoints > 0,\n    pointerEvents: window.PointerEvent && ('ontouchstart' in window || window.navigator.maxTouchPoints > 0 || navigator.maxTouchPoints > 0)\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { illegalArgument } from './errors.js';\nexport function createKeybinding(keybinding, OS) {\n    if (keybinding === 0) {\n        return null;\n    }\n    const firstPart = (keybinding & 0x0000FFFF) >>> 0;\n    const chordPart = (keybinding & 0xFFFF0000) >>> 16;\n    if (chordPart !== 0) {\n        return new ChordKeybinding([\n            createSimpleKeybinding(firstPart, OS),\n            createSimpleKeybinding(chordPart, OS)\n        ]);\n    }\n    return new ChordKeybinding([createSimpleKeybinding(firstPart, OS)]);\n}\nexport function createSimpleKeybinding(keybinding, OS) {\n    const ctrlCmd = (keybinding & 2048 /* BinaryKeybindingsMask.CtrlCmd */ ? true : false);\n    const winCtrl = (keybinding & 256 /* BinaryKeybindingsMask.WinCtrl */ ? true : false);\n    const ctrlKey = (OS === 2 /* OperatingSystem.Macintosh */ ? winCtrl : ctrlCmd);\n    const shiftKey = (keybinding & 1024 /* BinaryKeybindingsMask.Shift */ ? true : false);\n    const altKey = (keybinding & 512 /* BinaryKeybindingsMask.Alt */ ? true : false);\n    const metaKey = (OS === 2 /* OperatingSystem.Macintosh */ ? ctrlCmd : winCtrl);\n    const keyCode = (keybinding & 255 /* BinaryKeybindingsMask.KeyCode */);\n    return new SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode);\n}\nexport class SimpleKeybinding {\n    constructor(ctrlKey, shiftKey, altKey, metaKey, keyCode) {\n        this.ctrlKey = ctrlKey;\n        this.shiftKey = shiftKey;\n        this.altKey = altKey;\n        this.metaKey = metaKey;\n        this.keyCode = keyCode;\n    }\n    equals(other) {\n        return (this.ctrlKey === other.ctrlKey\n            && this.shiftKey === other.shiftKey\n            && this.altKey === other.altKey\n            && this.metaKey === other.metaKey\n            && this.keyCode === other.keyCode);\n    }\n    isModifierKey() {\n        return (this.keyCode === 0 /* KeyCode.Unknown */\n            || this.keyCode === 5 /* KeyCode.Ctrl */\n            || this.keyCode === 57 /* KeyCode.Meta */\n            || this.keyCode === 6 /* KeyCode.Alt */\n            || this.keyCode === 4 /* KeyCode.Shift */);\n    }\n    toChord() {\n        return new ChordKeybinding([this]);\n    }\n    /**\n     * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?\n     */\n    isDuplicateModifierCase() {\n        return ((this.ctrlKey && this.keyCode === 5 /* KeyCode.Ctrl */)\n            || (this.shiftKey && this.keyCode === 4 /* KeyCode.Shift */)\n            || (this.altKey && this.keyCode === 6 /* KeyCode.Alt */)\n            || (this.metaKey && this.keyCode === 57 /* KeyCode.Meta */));\n    }\n}\nexport class ChordKeybinding {\n    constructor(parts) {\n        if (parts.length === 0) {\n            throw illegalArgument(`parts`);\n        }\n        this.parts = parts;\n    }\n}\nexport class ScanCodeBinding {\n    constructor(ctrlKey, shiftKey, altKey, metaKey, scanCode) {\n        this.ctrlKey = ctrlKey;\n        this.shiftKey = shiftKey;\n        this.altKey = altKey;\n        this.metaKey = metaKey;\n        this.scanCode = scanCode;\n    }\n    /**\n     * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?\n     */\n    isDuplicateModifierCase() {\n        return ((this.ctrlKey && (this.scanCode === 157 /* ScanCode.ControlLeft */ || this.scanCode === 161 /* ScanCode.ControlRight */))\n            || (this.shiftKey && (this.scanCode === 158 /* ScanCode.ShiftLeft */ || this.scanCode === 162 /* ScanCode.ShiftRight */))\n            || (this.altKey && (this.scanCode === 159 /* ScanCode.AltLeft */ || this.scanCode === 163 /* ScanCode.AltRight */))\n            || (this.metaKey && (this.scanCode === 160 /* ScanCode.MetaLeft */ || this.scanCode === 164 /* ScanCode.MetaRight */)));\n    }\n}\nexport class ResolvedKeybindingPart {\n    constructor(ctrlKey, shiftKey, altKey, metaKey, kbLabel, kbAriaLabel) {\n        this.ctrlKey = ctrlKey;\n        this.shiftKey = shiftKey;\n        this.altKey = altKey;\n        this.metaKey = metaKey;\n        this.keyLabel = kbLabel;\n        this.keyAriaLabel = kbAriaLabel;\n    }\n}\n/**\n * A resolved keybinding. Can be a simple keybinding or a chord keybinding.\n */\nexport class ResolvedKeybinding {\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from './browser.js';\nimport { EVENT_KEY_CODE_MAP, KeyCodeUtils } from '../common/keyCodes.js';\nimport { SimpleKeybinding } from '../common/keybindings.js';\nimport * as platform from '../common/platform.js';\nfunction extractKeyCode(e) {\n    if (e.charCode) {\n        // \"keypress\" events mostly\n        const char = String.fromCharCode(e.charCode).toUpperCase();\n        return KeyCodeUtils.fromString(char);\n    }\n    const keyCode = e.keyCode;\n    // browser quirks\n    if (keyCode === 3) {\n        return 7 /* KeyCode.PauseBreak */;\n    }\n    else if (browser.isFirefox) {\n        if (keyCode === 59) {\n            return 80 /* KeyCode.Semicolon */;\n        }\n        else if (keyCode === 107) {\n            return 81 /* KeyCode.Equal */;\n        }\n        else if (keyCode === 109) {\n            return 83 /* KeyCode.Minus */;\n        }\n        else if (platform.isMacintosh && keyCode === 224) {\n            return 57 /* KeyCode.Meta */;\n        }\n    }\n    else if (browser.isWebKit) {\n        if (keyCode === 91) {\n            return 57 /* KeyCode.Meta */;\n        }\n        else if (platform.isMacintosh && keyCode === 93) {\n            // the two meta keys in the Mac have different key codes (91 and 93)\n            return 57 /* KeyCode.Meta */;\n        }\n        else if (!platform.isMacintosh && keyCode === 92) {\n            return 57 /* KeyCode.Meta */;\n        }\n    }\n    // cross browser keycodes:\n    return EVENT_KEY_CODE_MAP[keyCode] || 0 /* KeyCode.Unknown */;\n}\nconst ctrlKeyMod = (platform.isMacintosh ? 256 /* KeyMod.WinCtrl */ : 2048 /* KeyMod.CtrlCmd */);\nconst altKeyMod = 512 /* KeyMod.Alt */;\nconst shiftKeyMod = 1024 /* KeyMod.Shift */;\nconst metaKeyMod = (platform.isMacintosh ? 2048 /* KeyMod.CtrlCmd */ : 256 /* KeyMod.WinCtrl */);\nexport class StandardKeyboardEvent {\n    constructor(source) {\n        this._standardKeyboardEventBrand = true;\n        const e = source;\n        this.browserEvent = e;\n        this.target = e.target;\n        this.ctrlKey = e.ctrlKey;\n        this.shiftKey = e.shiftKey;\n        this.altKey = e.altKey;\n        this.metaKey = e.metaKey;\n        this.keyCode = extractKeyCode(e);\n        this.code = e.code;\n        // console.info(e.type + \": keyCode: \" + e.keyCode + \", which: \" + e.which + \", charCode: \" + e.charCode + \", detail: \" + e.detail + \" ====> \" + this.keyCode + ' -- ' + KeyCode[this.keyCode]);\n        this.ctrlKey = this.ctrlKey || this.keyCode === 5 /* KeyCode.Ctrl */;\n        this.altKey = this.altKey || this.keyCode === 6 /* KeyCode.Alt */;\n        this.shiftKey = this.shiftKey || this.keyCode === 4 /* KeyCode.Shift */;\n        this.metaKey = this.metaKey || this.keyCode === 57 /* KeyCode.Meta */;\n        this._asKeybinding = this._computeKeybinding();\n        this._asRuntimeKeybinding = this._computeRuntimeKeybinding();\n        // console.log(`code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`);\n    }\n    preventDefault() {\n        if (this.browserEvent && this.browserEvent.preventDefault) {\n            this.browserEvent.preventDefault();\n        }\n    }\n    stopPropagation() {\n        if (this.browserEvent && this.browserEvent.stopPropagation) {\n            this.browserEvent.stopPropagation();\n        }\n    }\n    toKeybinding() {\n        return this._asRuntimeKeybinding;\n    }\n    equals(other) {\n        return this._asKeybinding === other;\n    }\n    _computeKeybinding() {\n        let key = 0 /* KeyCode.Unknown */;\n        if (this.keyCode !== 5 /* KeyCode.Ctrl */ && this.keyCode !== 4 /* KeyCode.Shift */ && this.keyCode !== 6 /* KeyCode.Alt */ && this.keyCode !== 57 /* KeyCode.Meta */) {\n            key = this.keyCode;\n        }\n        let result = 0;\n        if (this.ctrlKey) {\n            result |= ctrlKeyMod;\n        }\n        if (this.altKey) {\n            result |= altKeyMod;\n        }\n        if (this.shiftKey) {\n            result |= shiftKeyMod;\n        }\n        if (this.metaKey) {\n            result |= metaKeyMod;\n        }\n        result |= key;\n        return result;\n    }\n    _computeRuntimeKeybinding() {\n        let key = 0 /* KeyCode.Unknown */;\n        if (this.keyCode !== 5 /* KeyCode.Ctrl */ && this.keyCode !== 4 /* KeyCode.Shift */ && this.keyCode !== 6 /* KeyCode.Alt */ && this.keyCode !== 57 /* KeyCode.Meta */) {\n            key = this.keyCode;\n        }\n        return new SimpleKeybinding(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, key);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nlet hasDifferentOriginAncestorFlag = false;\nlet sameOriginWindowChainCache = null;\nfunction getParentWindowIfSameOrigin(w) {\n    if (!w.parent || w.parent === w) {\n        return null;\n    }\n    // Cannot really tell if we have access to the parent window unless we try to access something in it\n    try {\n        const location = w.location;\n        const parentLocation = w.parent.location;\n        if (location.origin !== 'null' && parentLocation.origin !== 'null' && location.origin !== parentLocation.origin) {\n            hasDifferentOriginAncestorFlag = true;\n            return null;\n        }\n    }\n    catch (e) {\n        hasDifferentOriginAncestorFlag = true;\n        return null;\n    }\n    return w.parent;\n}\nexport class IframeUtils {\n    /**\n     * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).\n     * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.\n     * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()\n     */\n    static getSameOriginWindowChain() {\n        if (!sameOriginWindowChainCache) {\n            sameOriginWindowChainCache = [];\n            let w = window;\n            let parent;\n            do {\n                parent = getParentWindowIfSameOrigin(w);\n                if (parent) {\n                    sameOriginWindowChainCache.push({\n                        window: w,\n                        iframeElement: w.frameElement || null\n                    });\n                }\n                else {\n                    sameOriginWindowChainCache.push({\n                        window: w,\n                        iframeElement: null\n                    });\n                }\n                w = parent;\n            } while (w);\n        }\n        return sameOriginWindowChainCache.slice(0);\n    }\n    /**\n     * Returns the position of `childWindow` relative to `ancestorWindow`\n     */\n    static getPositionOfChildWindowRelativeToAncestorWindow(childWindow, ancestorWindow) {\n        if (!ancestorWindow || childWindow === ancestorWindow) {\n            return {\n                top: 0,\n                left: 0\n            };\n        }\n        let top = 0, left = 0;\n        const windowChain = this.getSameOriginWindowChain();\n        for (const windowChainEl of windowChain) {\n            top += windowChainEl.window.scrollY;\n            left += windowChainEl.window.scrollX;\n            if (windowChainEl.window === ancestorWindow) {\n                break;\n            }\n            if (!windowChainEl.iframeElement) {\n                break;\n            }\n            const boundingRect = windowChainEl.iframeElement.getBoundingClientRect();\n            top += boundingRect.top;\n            left += boundingRect.left;\n        }\n        return {\n            top: top,\n            left: left\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from './browser.js';\nimport { IframeUtils } from './iframe.js';\nimport * as platform from '../common/platform.js';\nexport class StandardMouseEvent {\n    constructor(e) {\n        this.timestamp = Date.now();\n        this.browserEvent = e;\n        this.leftButton = e.button === 0;\n        this.middleButton = e.button === 1;\n        this.rightButton = e.button === 2;\n        this.buttons = e.buttons;\n        this.target = e.target;\n        this.detail = e.detail || 1;\n        if (e.type === 'dblclick') {\n            this.detail = 2;\n        }\n        this.ctrlKey = e.ctrlKey;\n        this.shiftKey = e.shiftKey;\n        this.altKey = e.altKey;\n        this.metaKey = e.metaKey;\n        if (typeof e.pageX === 'number') {\n            this.posx = e.pageX;\n            this.posy = e.pageY;\n        }\n        else {\n            // Probably hit by MSGestureEvent\n            this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n        // Find the position of the iframe this code is executing in relative to the iframe where the event was captured.\n        const iframeOffsets = IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);\n        this.posx -= iframeOffsets.left;\n        this.posy -= iframeOffsets.top;\n    }\n    preventDefault() {\n        this.browserEvent.preventDefault();\n    }\n    stopPropagation() {\n        this.browserEvent.stopPropagation();\n    }\n}\nexport class StandardWheelEvent {\n    constructor(e, deltaX = 0, deltaY = 0) {\n        this.browserEvent = e || null;\n        this.target = e ? (e.target || e.targetNode || e.srcElement) : null;\n        this.deltaY = deltaY;\n        this.deltaX = deltaX;\n        if (e) {\n            // Old (deprecated) wheel events\n            const e1 = e;\n            const e2 = e;\n            // vertical delta scroll\n            if (typeof e1.wheelDeltaY !== 'undefined') {\n                this.deltaY = e1.wheelDeltaY / 120;\n            }\n            else if (typeof e2.VERTICAL_AXIS !== 'undefined' && e2.axis === e2.VERTICAL_AXIS) {\n                this.deltaY = -e2.detail / 3;\n            }\n            else if (e.type === 'wheel') {\n                // Modern wheel event\n                // https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent\n                const ev = e;\n                if (ev.deltaMode === ev.DOM_DELTA_LINE) {\n                    // the deltas are expressed in lines\n                    if (browser.isFirefox && !platform.isMacintosh) {\n                        this.deltaY = -e.deltaY / 3;\n                    }\n                    else {\n                        this.deltaY = -e.deltaY;\n                    }\n                }\n                else {\n                    this.deltaY = -e.deltaY / 40;\n                }\n            }\n            // horizontal delta scroll\n            if (typeof e1.wheelDeltaX !== 'undefined') {\n                if (browser.isSafari && platform.isWindows) {\n                    this.deltaX = -(e1.wheelDeltaX / 120);\n                }\n                else {\n                    this.deltaX = e1.wheelDeltaX / 120;\n                }\n            }\n            else if (typeof e2.HORIZONTAL_AXIS !== 'undefined' && e2.axis === e2.HORIZONTAL_AXIS) {\n                this.deltaX = -e.detail / 3;\n            }\n            else if (e.type === 'wheel') {\n                // Modern wheel event\n                // https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent\n                const ev = e;\n                if (ev.deltaMode === ev.DOM_DELTA_LINE) {\n                    // the deltas are expressed in lines\n                    if (browser.isFirefox && !platform.isMacintosh) {\n                        this.deltaX = -e.deltaX / 3;\n                    }\n                    else {\n                        this.deltaX = -e.deltaX;\n                    }\n                }\n                else {\n                    this.deltaX = -e.deltaX / 40;\n                }\n            }\n            // Assume a vertical scroll if nothing else worked\n            if (this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta) {\n                this.deltaY = e.wheelDelta / 120;\n            }\n        }\n    }\n    preventDefault() {\n        if (this.browserEvent) {\n            this.browserEvent.preventDefault();\n        }\n    }\n    stopPropagation() {\n        if (this.browserEvent) {\n            this.browserEvent.stopPropagation();\n        }\n    }\n}\n","/*! @license DOMPurify 2.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.1/LICENSE */\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar hasOwnProperty = Object.hasOwnProperty,\n    setPrototypeOf = Object.setPrototypeOf,\n    isFrozen = Object.isFrozen,\n    getPrototypeOf = Object.getPrototypeOf,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar freeze = Object.freeze,\n    seal = Object.seal,\n    create = Object.create; // eslint-disable-line import/no-mutable-exports\n\nvar _ref = typeof Reflect !== 'undefined' && Reflect,\n    apply = _ref.apply,\n    construct = _ref.construct;\n\nif (!apply) {\n  apply = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\nif (!freeze) {\n  freeze = function freeze(x) {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function seal(x) {\n    return x;\n  };\n}\n\nif (!construct) {\n  construct = function construct(Func, args) {\n    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n  };\n}\n\nvar arrayForEach = unapply(Array.prototype.forEach);\nvar arrayPop = unapply(Array.prototype.pop);\nvar arrayPush = unapply(Array.prototype.push);\n\nvar stringToLowerCase = unapply(String.prototype.toLowerCase);\nvar stringMatch = unapply(String.prototype.match);\nvar stringReplace = unapply(String.prototype.replace);\nvar stringIndexOf = unapply(String.prototype.indexOf);\nvar stringTrim = unapply(String.prototype.trim);\n\nvar regExpTest = unapply(RegExp.prototype.test);\n\nvar typeErrorCreate = unconstruct(TypeError);\n\nfunction unapply(func) {\n  return function (thisArg) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return apply(func, thisArg, args);\n  };\n}\n\nfunction unconstruct(func) {\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return construct(func, args);\n  };\n}\n\n/* Add properties to a lookup table */\nfunction addToSet(set, array) {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  var l = array.length;\n  while (l--) {\n    var element = array[l];\n    if (typeof element === 'string') {\n      var lcElement = stringToLowerCase(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/* Shallow clone an object */\nfunction clone(object) {\n  var newObject = create(null);\n\n  var property = void 0;\n  for (property in object) {\n    if (apply(hasOwnProperty, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n\n  return newObject;\n}\n\n/* IE10 doesn't support __lookupGetter__ so lets'\n * simulate it. It also automatically checks\n * if the prop is function or getter and behaves\n * accordingly. */\nfunction lookupGetter(object, prop) {\n  while (object !== null) {\n    var desc = getOwnPropertyDescriptor(object, prop);\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n\n      if (typeof desc.value === 'function') {\n        return unapply(desc.value);\n      }\n    }\n\n    object = getPrototypeOf(object);\n  }\n\n  function fallbackValue(element) {\n    console.warn('fallback value for', element);\n    return null;\n  }\n\n  return fallbackValue;\n}\n\nvar html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n// SVG\nvar svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\nvar svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nvar svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\nvar mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nvar mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\nvar text = freeze(['#text']);\n\nvar html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n\nvar svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\nvar mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\nvar xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n// eslint-disable-next-line unicorn/better-regex\nvar MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nvar ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nvar DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nvar ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nvar IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nvar IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nvar ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar getGlobal = function getGlobal() {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {Document} document The document object (to determine policy name suffix)\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported).\n */\nvar _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  var suffix = null;\n  var ATTR_NAME = 'data-tt-policy-suffix';\n  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n    suffix = document.currentScript.getAttribute(ATTR_NAME);\n  }\n\n  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML: function createHTML(html$$1) {\n        return html$$1;\n      }\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n    return null;\n  }\n};\n\nfunction createDOMPurify() {\n  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n  var DOMPurify = function DOMPurify(root) {\n    return createDOMPurify(root);\n  };\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = '2.3.1';\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  var originalDocument = window.document;\n\n  var document = window.document;\n  var DocumentFragment = window.DocumentFragment,\n      HTMLTemplateElement = window.HTMLTemplateElement,\n      Node = window.Node,\n      Element = window.Element,\n      NodeFilter = window.NodeFilter,\n      _window$NamedNodeMap = window.NamedNodeMap,\n      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n      Text = window.Text,\n      Comment = window.Comment,\n      DOMParser = window.DOMParser,\n      trustedTypes = window.trustedTypes;\n\n\n  var ElementPrototype = Element.prototype;\n\n  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n  var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    var template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n  var _document = document,\n      implementation = _document.implementation,\n      createNodeIterator = _document.createNodeIterator,\n      createDocumentFragment = _document.createDocumentFragment,\n      getElementsByTagName = _document.getElementsByTagName;\n  var importNode = originalDocument.importNode;\n\n\n  var documentMode = {};\n  try {\n    documentMode = clone(document).documentMode ? document.documentMode : {};\n  } catch (_) {}\n\n  var hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n      ERB_EXPR$$1 = ERB_EXPR,\n      DATA_ATTR$$1 = DATA_ATTR,\n      ARIA_ATTR$$1 = ARIA_ATTR,\n      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n\n  var ALLOWED_TAGS = null;\n  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n  /* Allowed attribute names */\n  var ALLOWED_ATTR = null;\n  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  var FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  var FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  var ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  var ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  var SAFE_FOR_TEMPLATES = false;\n\n  /* Decide if document with <html>... should be returned */\n  var WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  var SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  var FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  var RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  var RETURN_DOM_FRAGMENT = false;\n\n  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n   * `Node` is imported into the current `Document`. If this flag is not enabled the\n   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n   * DOMPurify.\n   *\n   * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n   * might cause XSS from attacks hidden in closed shadowroots in case the browser\n   * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n   */\n  var RETURN_DOM_IMPORT = true;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  var RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks? */\n  var SANITIZE_DOM = true;\n\n  /* Keep element content when removing element? */\n  var KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  var IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  var USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  var FORBID_CONTENTS = null;\n  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n  /* Tags that are safe for data: URIs */\n  var DATA_URI_TAGS = null;\n  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n  /* Attributes safe for values like \"javascript:\" */\n  var URI_SAFE_ATTRIBUTES = null;\n  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  /* Document namespace */\n  var NAMESPACE = HTML_NAMESPACE;\n  var IS_EMPTY_INPUT = false;\n\n  /* Keep a reference to config to pass to hooks */\n  var CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  var formElement = document.createElement('form');\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  var _parseConfig = function _parseConfig(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html);\n        addToSet(ALLOWED_ATTR, html$1);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl);\n        addToSet(ALLOWED_ATTR, mathMl$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  var ALL_SVG_TAGS = addToSet({}, svg);\n  addToSet(ALL_SVG_TAGS, svgFilters);\n  addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n  var ALL_MATHML_TAGS = addToSet({}, mathMl);\n  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n  /**\n   *\n   *\n   * @param  {Element} element a DOM element whose namespace is being checked\n   * @returns {boolean} Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  var _checkValidNamespace = function _checkValidNamespace(element) {\n    var parent = getParentNode(element);\n\n    // In JSDOM, if we're inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: HTML_NAMESPACE,\n        tagName: 'template'\n      };\n    }\n\n    var tagName = stringToLowerCase(element.tagName);\n    var parentTagName = stringToLowerCase(parent.tagName);\n\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'svg';\n      }\n\n      // The only way to switch from MathML to SVG is via\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n      }\n\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'math';\n      }\n\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      // Certain elements are allowed in both SVG and HTML\n      // namespace. We need to specify them explicitly\n      // so that they don't get erronously deleted from\n      // HTML namespace.\n      var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n    }\n\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG or MathML). Return false just in case.\n    return false;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  var _forceRemove = function _forceRemove(node) {\n    arrayPush(DOMPurify.removed, { element: node });\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      node.parentNode.removeChild(node);\n    } catch (_) {\n      try {\n        node.outerHTML = emptyHTML;\n      } catch (_) {\n        node.remove();\n      }\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  var _removeAttribute = function _removeAttribute(name, node) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: node.getAttributeNode(name),\n        from: node\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: node\n      });\n    }\n\n    node.removeAttribute(name);\n\n    // We void attribute values for unremovable \"is\"\" attributes\n    if (name === 'is' && !ALLOWED_ATTR[name]) {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(node);\n        } catch (_) {}\n      } else {\n        try {\n          node.setAttribute(name, '');\n        } catch (_) {}\n      }\n    }\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  var _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    var doc = void 0;\n    var leadingWhitespace = void 0;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');\n      } catch (_) {}\n    }\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, 'template', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n\n    var body = doc.body || doc.documentElement;\n\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n    }\n\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n    }\n\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n\n  /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */\n  var _createIterator = function _createIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  var _isClobbered = function _isClobbered(elm) {\n    if (elm instanceof Text || elm instanceof Comment) {\n      return false;\n    }\n\n    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  var _isNode = function _isNode(object) {\n    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    arrayForEach(hooks[entryPoint], function (hook) {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  var _sanitizeElements = function _sanitizeElements(currentNode) {\n    var content = void 0;\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeElements', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check if tagname contains Unicode */\n    if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    var tagName = stringToLowerCase(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName: tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Mitigate a problem with templates inside select */\n    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n        if (childNodes && parentNode) {\n          var childCount = childNodes.length;\n\n          for (var i = childCount - 1; i >= 0; --i) {\n            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n          }\n        }\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n      content = stringReplace(content, ERB_EXPR$$1, ' ');\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeElements', currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      return false;\n\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n      return false;\n    }\n\n    return true;\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    var attr = void 0;\n    var value = void 0;\n    var lcName = void 0;\n    var l = void 0;\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n    var attributes = currentNode.attributes;\n\n    /* Check if we have attributes; if not we might have a text node */\n\n    if (!attributes) {\n      return;\n    }\n\n    var hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      attr = attributes[l];\n      var _attr = attr,\n          name = _attr.name,\n          namespaceURI = _attr.namespaceURI;\n\n      value = stringTrim(attr.value);\n      lcName = stringToLowerCase(name);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Remove attribute */\n      _removeAttribute(name, currentNode);\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n        value = stringReplace(value, ERB_EXPR$$1, ' ');\n      }\n\n      /* Is `value` valid for this attribute? */\n      var lcTag = currentNode.nodeName.toLowerCase();\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n\n        arrayPop(DOMPurify.removed);\n      } catch (_) {}\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    var shadowNode = void 0;\n    var shadowIterator = _createIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg) {\n    var body = void 0;\n    var importedNode = void 0;\n    var currentNode = void 0;\n    var oldNode = void 0;\n    var returnNode = void 0;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      // eslint-disable-next-line no-negated-condition\n      if (typeof dirty.toString !== 'function') {\n        throw typeErrorCreate('toString is not a function');\n      } else {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      }\n    }\n\n    /* Check we can run. Otherwise fall back or ignore */\n    if (!DOMPurify.isSupported) {\n      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n        if (typeof dirty === 'string') {\n          return window.toStaticHTML(dirty);\n        }\n\n        if (_isNode(dirty)) {\n          return window.toStaticHTML(dirty.outerHTML);\n        }\n      }\n\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) ; else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n      // eslint-disable-next-line unicorn/prefer-includes\n      dirty.indexOf('<') === -1) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : emptyHTML;\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Fix IE's strange behavior with manipulated textNodes #89 */\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n\n      oldNode = currentNode;\n    }\n\n    oldNode = null;\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (RETURN_DOM_IMPORT) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function (cfg) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    var lcTag = stringToLowerCase(tag);\n    var lcName = stringToLowerCase(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   */\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      arrayPop(hooks[entryPoint]);\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nvar purify = createDOMPurify();\n\n// ESM-comment-begin\n// define(function () { return purify; });\n// ESM-comment-end\n\n// ESM-uncomment-begin\nexport default purify;\nexport const version = purify.version;\nexport const isSupported = purify.isSupported;\nexport const sanitize = purify.sanitize;\nexport const setConfig = purify.setConfig;\nexport const clearConfig = purify.clearConfig;\nexport const isValidAttribute = purify.isValidAttribute;\nexport const addHook = purify.addHook;\nexport const removeHook = purify.removeHook;\nexport const removeHooks = purify.removeHooks;\nexport const removeAllHooks = purify.removeAllHooks;\n// ESM-uncomment-end\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { assertNever } from '../../../base/common/types.js';\nimport * as nls from '../../../nls.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport * as platform from '../../registry/common/platform.js';\n/**\n * Returns the css variable name for the given color identifier. Dots (`.`) are replaced with hyphens (`-`) and\n * everything is prefixed with `--vscode-`.\n *\n * @sample `editorSuggestWidget.background` is `--vscode-editorSuggestWidget-background`.\n */\nexport function asCssVariableName(colorIdent) {\n    return `--vscode-${colorIdent.replace(/\\./g, '-')}`;\n}\n// color registry\nexport const Extensions = {\n    ColorContribution: 'base.contributions.colors'\n};\nclass ColorRegistry {\n    constructor() {\n        this._onDidChangeSchema = new Emitter();\n        this.onDidChangeSchema = this._onDidChangeSchema.event;\n        this.colorSchema = { type: 'object', properties: {} };\n        this.colorReferenceSchema = { type: 'string', enum: [], enumDescriptions: [] };\n        this.colorsById = {};\n    }\n    registerColor(id, defaults, description, needsTransparency = false, deprecationMessage) {\n        const colorContribution = { id, description, defaults, needsTransparency, deprecationMessage };\n        this.colorsById[id] = colorContribution;\n        const propertySchema = { type: 'string', description, format: 'color-hex', defaultSnippets: [{ body: '${1:#ff0000}' }] };\n        if (deprecationMessage) {\n            propertySchema.deprecationMessage = deprecationMessage;\n        }\n        this.colorSchema.properties[id] = propertySchema;\n        this.colorReferenceSchema.enum.push(id);\n        this.colorReferenceSchema.enumDescriptions.push(description);\n        this._onDidChangeSchema.fire();\n        return id;\n    }\n    getColors() {\n        return Object.keys(this.colorsById).map(id => this.colorsById[id]);\n    }\n    resolveDefaultColor(id, theme) {\n        const colorDesc = this.colorsById[id];\n        if (colorDesc && colorDesc.defaults) {\n            const colorValue = colorDesc.defaults[theme.type];\n            return resolveColorValue(colorValue, theme);\n        }\n        return undefined;\n    }\n    getColorSchema() {\n        return this.colorSchema;\n    }\n    toString() {\n        const sorter = (a, b) => {\n            const cat1 = a.indexOf('.') === -1 ? 0 : 1;\n            const cat2 = b.indexOf('.') === -1 ? 0 : 1;\n            if (cat1 !== cat2) {\n                return cat1 - cat2;\n            }\n            return a.localeCompare(b);\n        };\n        return Object.keys(this.colorsById).sort(sorter).map(k => `- \\`${k}\\`: ${this.colorsById[k].description}`).join('\\n');\n    }\n}\nconst colorRegistry = new ColorRegistry();\nplatform.Registry.add(Extensions.ColorContribution, colorRegistry);\nfunction migrateColorDefaults(o) {\n    if (o === null) {\n        return o;\n    }\n    if (typeof o.hcLight === 'undefined') {\n        if (o.hcDark === null || typeof o.hcDark === 'string') {\n            o.hcLight = o.hcDark;\n        }\n        else {\n            o.hcLight = o.light;\n        }\n    }\n    return o;\n}\nexport function registerColor(id, defaults, description, needsTransparency, deprecationMessage) {\n    return colorRegistry.registerColor(id, migrateColorDefaults(defaults), description, needsTransparency, deprecationMessage);\n}\n// ----- base colors\nexport const foreground = registerColor('foreground', { dark: '#CCCCCC', light: '#616161', hcDark: '#FFFFFF', hcLight: '#292929' }, nls.localize('foreground', \"Overall foreground color. This color is only used if not overridden by a component.\"));\nexport const disabledForeground = registerColor('disabledForeground', { dark: '#CCCCCC80', light: '#61616180', hcDark: '#A5A5A5', hcLight: '#7F7F7F' }, nls.localize('disabledForeground', \"Overall foreground for disabled elements. This color is only used if not overridden by a component.\"));\nexport const errorForeground = registerColor('errorForeground', { dark: '#F48771', light: '#A1260D', hcDark: '#F48771', hcLight: '#B5200D' }, nls.localize('errorForeground', \"Overall foreground color for error messages. This color is only used if not overridden by a component.\"));\nexport const descriptionForeground = registerColor('descriptionForeground', { light: '#717171', dark: transparent(foreground, 0.7), hcDark: transparent(foreground, 0.7), hcLight: transparent(foreground, 0.7) }, nls.localize('descriptionForeground', \"Foreground color for description text providing additional information, for example for a label.\"));\nexport const iconForeground = registerColor('icon.foreground', { dark: '#C5C5C5', light: '#424242', hcDark: '#FFFFFF', hcLight: '#292929' }, nls.localize('iconForeground', \"The default color for icons in the workbench.\"));\nexport const focusBorder = registerColor('focusBorder', { dark: '#007FD4', light: '#0090F1', hcDark: '#F38518', hcLight: '#0F4A85' }, nls.localize('focusBorder', \"Overall border color for focused elements. This color is only used if not overridden by a component.\"));\nexport const contrastBorder = registerColor('contrastBorder', { light: null, dark: null, hcDark: '#6FC3DF', hcLight: '#0F4A85' }, nls.localize('contrastBorder', \"An extra border around elements to separate them from others for greater contrast.\"));\nexport const activeContrastBorder = registerColor('contrastActiveBorder', { light: null, dark: null, hcDark: focusBorder, hcLight: focusBorder }, nls.localize('activeContrastBorder', \"An extra border around active elements to separate them from others for greater contrast.\"));\nexport const selectionBackground = registerColor('selection.background', { light: null, dark: null, hcDark: null, hcLight: null }, nls.localize('selectionBackground', \"The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor.\"));\n// ------ text colors\nexport const textSeparatorForeground = registerColor('textSeparator.foreground', { light: '#0000002e', dark: '#ffffff2e', hcDark: Color.black, hcLight: '#292929' }, nls.localize('textSeparatorForeground', \"Color for text separators.\"));\nexport const textLinkForeground = registerColor('textLink.foreground', { light: '#006AB1', dark: '#3794FF', hcDark: '#3794FF', hcLight: '#0F4A85' }, nls.localize('textLinkForeground', \"Foreground color for links in text.\"));\nexport const textLinkActiveForeground = registerColor('textLink.activeForeground', { light: '#006AB1', dark: '#3794FF', hcDark: '#3794FF', hcLight: '#0F4A85' }, nls.localize('textLinkActiveForeground', \"Foreground color for links in text when clicked on and on mouse hover.\"));\nexport const textPreformatForeground = registerColor('textPreformat.foreground', { light: '#A31515', dark: '#D7BA7D', hcDark: '#D7BA7D', hcLight: '#292929' }, nls.localize('textPreformatForeground', \"Foreground color for preformatted text segments.\"));\nexport const textBlockQuoteBackground = registerColor('textBlockQuote.background', { light: '#7f7f7f1a', dark: '#7f7f7f1a', hcDark: null, hcLight: '#F2F2F2' }, nls.localize('textBlockQuoteBackground', \"Background color for block quotes in text.\"));\nexport const textBlockQuoteBorder = registerColor('textBlockQuote.border', { light: '#007acc80', dark: '#007acc80', hcDark: Color.white, hcLight: '#292929' }, nls.localize('textBlockQuoteBorder', \"Border color for block quotes in text.\"));\nexport const textCodeBlockBackground = registerColor('textCodeBlock.background', { light: '#dcdcdc66', dark: '#0a0a0a66', hcDark: Color.black, hcLight: '#F2F2F2' }, nls.localize('textCodeBlockBackground', \"Background color for code blocks in text.\"));\n// ----- widgets\nexport const widgetShadow = registerColor('widget.shadow', { dark: transparent(Color.black, .36), light: transparent(Color.black, .16), hcDark: null, hcLight: null }, nls.localize('widgetShadow', 'Shadow color of widgets such as find/replace inside the editor.'));\nexport const inputBackground = registerColor('input.background', { dark: '#3C3C3C', light: Color.white, hcDark: Color.black, hcLight: Color.white }, nls.localize('inputBoxBackground', \"Input box background.\"));\nexport const inputForeground = registerColor('input.foreground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, nls.localize('inputBoxForeground', \"Input box foreground.\"));\nexport const inputBorder = registerColor('input.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('inputBoxBorder', \"Input box border.\"));\nexport const inputActiveOptionBorder = registerColor('inputOption.activeBorder', { dark: '#007ACC00', light: '#007ACC00', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('inputBoxActiveOptionBorder', \"Border color of activated options in input fields.\"));\nexport const inputActiveOptionHoverBackground = registerColor('inputOption.hoverBackground', { dark: '#5a5d5e80', light: '#b8b8b850', hcDark: null, hcLight: null }, nls.localize('inputOption.hoverBackground', \"Background color of activated options in input fields.\"));\nexport const inputActiveOptionBackground = registerColor('inputOption.activeBackground', { dark: transparent(focusBorder, 0.4), light: transparent(focusBorder, 0.2), hcDark: Color.transparent, hcLight: Color.transparent }, nls.localize('inputOption.activeBackground', \"Background hover color of options in input fields.\"));\nexport const inputActiveOptionForeground = registerColor('inputOption.activeForeground', { dark: Color.white, light: Color.black, hcDark: null, hcLight: foreground }, nls.localize('inputOption.activeForeground', \"Foreground color of activated options in input fields.\"));\nexport const inputPlaceholderForeground = registerColor('input.placeholderForeground', { light: transparent(foreground, 0.5), dark: transparent(foreground, 0.5), hcDark: transparent(foreground, 0.7), hcLight: transparent(foreground, 0.7) }, nls.localize('inputPlaceholderForeground', \"Input box foreground color for placeholder text.\"));\nexport const inputValidationInfoBackground = registerColor('inputValidation.infoBackground', { dark: '#063B49', light: '#D6ECF2', hcDark: Color.black, hcLight: Color.white }, nls.localize('inputValidationInfoBackground', \"Input validation background color for information severity.\"));\nexport const inputValidationInfoForeground = registerColor('inputValidation.infoForeground', { dark: null, light: null, hcDark: null, hcLight: foreground }, nls.localize('inputValidationInfoForeground', \"Input validation foreground color for information severity.\"));\nexport const inputValidationInfoBorder = registerColor('inputValidation.infoBorder', { dark: '#007acc', light: '#007acc', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('inputValidationInfoBorder', \"Input validation border color for information severity.\"));\nexport const inputValidationWarningBackground = registerColor('inputValidation.warningBackground', { dark: '#352A05', light: '#F6F5D2', hcDark: Color.black, hcLight: Color.white }, nls.localize('inputValidationWarningBackground', \"Input validation background color for warning severity.\"));\nexport const inputValidationWarningForeground = registerColor('inputValidation.warningForeground', { dark: null, light: null, hcDark: null, hcLight: foreground }, nls.localize('inputValidationWarningForeground', \"Input validation foreground color for warning severity.\"));\nexport const inputValidationWarningBorder = registerColor('inputValidation.warningBorder', { dark: '#B89500', light: '#B89500', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('inputValidationWarningBorder', \"Input validation border color for warning severity.\"));\nexport const inputValidationErrorBackground = registerColor('inputValidation.errorBackground', { dark: '#5A1D1D', light: '#F2DEDE', hcDark: Color.black, hcLight: Color.white }, nls.localize('inputValidationErrorBackground', \"Input validation background color for error severity.\"));\nexport const inputValidationErrorForeground = registerColor('inputValidation.errorForeground', { dark: null, light: null, hcDark: null, hcLight: foreground }, nls.localize('inputValidationErrorForeground', \"Input validation foreground color for error severity.\"));\nexport const inputValidationErrorBorder = registerColor('inputValidation.errorBorder', { dark: '#BE1100', light: '#BE1100', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('inputValidationErrorBorder', \"Input validation border color for error severity.\"));\nexport const selectBackground = registerColor('dropdown.background', { dark: '#3C3C3C', light: Color.white, hcDark: Color.black, hcLight: Color.white }, nls.localize('dropdownBackground', \"Dropdown background.\"));\nexport const selectListBackground = registerColor('dropdown.listBackground', { dark: null, light: null, hcDark: Color.black, hcLight: Color.white }, nls.localize('dropdownListBackground', \"Dropdown list background.\"));\nexport const selectForeground = registerColor('dropdown.foreground', { dark: '#F0F0F0', light: null, hcDark: Color.white, hcLight: foreground }, nls.localize('dropdownForeground', \"Dropdown foreground.\"));\nexport const selectBorder = registerColor('dropdown.border', { dark: selectBackground, light: '#CECECE', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('dropdownBorder', \"Dropdown border.\"));\nexport const checkboxBackground = registerColor('checkbox.background', { dark: selectBackground, light: selectBackground, hcDark: selectBackground, hcLight: selectBackground }, nls.localize('checkbox.background', \"Background color of checkbox widget.\"));\nexport const checkboxForeground = registerColor('checkbox.foreground', { dark: selectForeground, light: selectForeground, hcDark: selectForeground, hcLight: selectForeground }, nls.localize('checkbox.foreground', \"Foreground color of checkbox widget.\"));\nexport const checkboxBorder = registerColor('checkbox.border', { dark: selectBorder, light: selectBorder, hcDark: selectBorder, hcLight: selectBorder }, nls.localize('checkbox.border', \"Border color of checkbox widget.\"));\nexport const buttonForeground = registerColor('button.foreground', { dark: Color.white, light: Color.white, hcDark: Color.white, hcLight: Color.white }, nls.localize('buttonForeground', \"Button foreground color.\"));\nexport const buttonSeparator = registerColor('button.separator', { dark: transparent(buttonForeground, .4), light: transparent(buttonForeground, .4), hcDark: transparent(buttonForeground, .4), hcLight: transparent(buttonForeground, .4) }, nls.localize('buttonSeparator', \"Button separator color.\"));\nexport const buttonBackground = registerColor('button.background', { dark: '#0E639C', light: '#007ACC', hcDark: null, hcLight: '#0F4A85' }, nls.localize('buttonBackground', \"Button background color.\"));\nexport const buttonHoverBackground = registerColor('button.hoverBackground', { dark: lighten(buttonBackground, 0.2), light: darken(buttonBackground, 0.2), hcDark: null, hcLight: null }, nls.localize('buttonHoverBackground', \"Button background color when hovering.\"));\nexport const buttonBorder = registerColor('button.border', { dark: contrastBorder, light: contrastBorder, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('buttonBorder', \"Button border color.\"));\nexport const buttonSecondaryForeground = registerColor('button.secondaryForeground', { dark: Color.white, light: Color.white, hcDark: Color.white, hcLight: foreground }, nls.localize('buttonSecondaryForeground', \"Secondary button foreground color.\"));\nexport const buttonSecondaryBackground = registerColor('button.secondaryBackground', { dark: '#3A3D41', light: '#5F6A79', hcDark: null, hcLight: Color.white }, nls.localize('buttonSecondaryBackground', \"Secondary button background color.\"));\nexport const buttonSecondaryHoverBackground = registerColor('button.secondaryHoverBackground', { dark: lighten(buttonSecondaryBackground, 0.2), light: darken(buttonSecondaryBackground, 0.2), hcDark: null, hcLight: null }, nls.localize('buttonSecondaryHoverBackground', \"Secondary button background color when hovering.\"));\nexport const badgeBackground = registerColor('badge.background', { dark: '#4D4D4D', light: '#C4C4C4', hcDark: Color.black, hcLight: '#0F4A85' }, nls.localize('badgeBackground', \"Badge background color. Badges are small information labels, e.g. for search results count.\"));\nexport const badgeForeground = registerColor('badge.foreground', { dark: Color.white, light: '#333', hcDark: Color.white, hcLight: Color.white }, nls.localize('badgeForeground', \"Badge foreground color. Badges are small information labels, e.g. for search results count.\"));\nexport const scrollbarShadow = registerColor('scrollbar.shadow', { dark: '#000000', light: '#DDDDDD', hcDark: null, hcLight: null }, nls.localize('scrollbarShadow', \"Scrollbar shadow to indicate that the view is scrolled.\"));\nexport const scrollbarSliderBackground = registerColor('scrollbarSlider.background', { dark: Color.fromHex('#797979').transparent(0.4), light: Color.fromHex('#646464').transparent(0.4), hcDark: transparent(contrastBorder, 0.6), hcLight: transparent(contrastBorder, 0.4) }, nls.localize('scrollbarSliderBackground', \"Scrollbar slider background color.\"));\nexport const scrollbarSliderHoverBackground = registerColor('scrollbarSlider.hoverBackground', { dark: Color.fromHex('#646464').transparent(0.7), light: Color.fromHex('#646464').transparent(0.7), hcDark: transparent(contrastBorder, 0.8), hcLight: transparent(contrastBorder, 0.8) }, nls.localize('scrollbarSliderHoverBackground', \"Scrollbar slider background color when hovering.\"));\nexport const scrollbarSliderActiveBackground = registerColor('scrollbarSlider.activeBackground', { dark: Color.fromHex('#BFBFBF').transparent(0.4), light: Color.fromHex('#000000').transparent(0.6), hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('scrollbarSliderActiveBackground', \"Scrollbar slider background color when clicked on.\"));\nexport const progressBarBackground = registerColor('progressBar.background', { dark: Color.fromHex('#0E70C0'), light: Color.fromHex('#0E70C0'), hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('progressBarBackground', \"Background color of the progress bar that can show for long running operations.\"));\nexport const editorErrorBackground = registerColor('editorError.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorError.background', 'Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorErrorForeground = registerColor('editorError.foreground', { dark: '#F14C4C', light: '#E51400', hcDark: '#F48771', hcLight: '#B5200D' }, nls.localize('editorError.foreground', 'Foreground color of error squigglies in the editor.'));\nexport const editorErrorBorder = registerColor('editorError.border', { dark: null, light: null, hcDark: Color.fromHex('#E47777').transparent(0.8), hcLight: '#B5200D' }, nls.localize('errorBorder', 'Border color of error boxes in the editor.'));\nexport const editorWarningBackground = registerColor('editorWarning.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorWarning.background', 'Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorWarningForeground = registerColor('editorWarning.foreground', { dark: '#CCA700', light: '#BF8803', hcDark: '#FFD37', hcLight: '#895503' }, nls.localize('editorWarning.foreground', 'Foreground color of warning squigglies in the editor.'));\nexport const editorWarningBorder = registerColor('editorWarning.border', { dark: null, light: null, hcDark: Color.fromHex('#FFCC00').transparent(0.8), hcLight: '#' }, nls.localize('warningBorder', 'Border color of warning boxes in the editor.'));\nexport const editorInfoBackground = registerColor('editorInfo.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorInfo.background', 'Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorInfoForeground = registerColor('editorInfo.foreground', { dark: '#3794FF', light: '#1a85ff', hcDark: '#3794FF', hcLight: '#1a85ff' }, nls.localize('editorInfo.foreground', 'Foreground color of info squigglies in the editor.'));\nexport const editorInfoBorder = registerColor('editorInfo.border', { dark: null, light: null, hcDark: Color.fromHex('#3794FF').transparent(0.8), hcLight: '#292929' }, nls.localize('infoBorder', 'Border color of info boxes in the editor.'));\nexport const editorHintForeground = registerColor('editorHint.foreground', { dark: Color.fromHex('#eeeeee').transparent(0.7), light: '#6c6c6c', hcDark: null, hcLight: null }, nls.localize('editorHint.foreground', 'Foreground color of hint squigglies in the editor.'));\nexport const editorHintBorder = registerColor('editorHint.border', { dark: null, light: null, hcDark: Color.fromHex('#eeeeee').transparent(0.8), hcLight: '#292929' }, nls.localize('hintBorder', 'Border color of hint boxes in the editor.'));\nexport const sashHoverBorder = registerColor('sash.hoverBorder', { dark: focusBorder, light: focusBorder, hcDark: focusBorder, hcLight: focusBorder }, nls.localize('sashActiveBorder', \"Border color of active sashes.\"));\n/**\n * Editor background color.\n */\nexport const editorBackground = registerColor('editor.background', { light: '#ffffff', dark: '#1E1E1E', hcDark: Color.black, hcLight: Color.white }, nls.localize('editorBackground', \"Editor background color.\"));\n/**\n * Editor foreground color.\n */\nexport const editorForeground = registerColor('editor.foreground', { light: '#333333', dark: '#BBBBBB', hcDark: Color.white, hcLight: foreground }, nls.localize('editorForeground', \"Editor default foreground color.\"));\n/**\n * Sticky scroll\n */\nexport const editorStickyScrollBackground = registerColor('editorStickyScroll.background', { light: editorBackground, dark: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorStickyScrollBackground', \"Sticky scroll background color for the editor\"));\nexport const editorStickyScrollHoverBackground = registerColor('editorStickyScrollHover.background', { dark: '#2A2D2E', light: '#F0F0F0', hcDark: null, hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localize('editorStickyScrollHoverBackground', \"Sticky scroll on hover background color for the editor\"));\n/**\n * Editor widgets\n */\nexport const editorWidgetBackground = registerColor('editorWidget.background', { dark: '#252526', light: '#F3F3F3', hcDark: '#0C141F', hcLight: Color.white }, nls.localize('editorWidgetBackground', 'Background color of editor widgets, such as find/replace.'));\nexport const editorWidgetForeground = registerColor('editorWidget.foreground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, nls.localize('editorWidgetForeground', 'Foreground color of editor widgets, such as find/replace.'));\nexport const editorWidgetBorder = registerColor('editorWidget.border', { dark: '#454545', light: '#C8C8C8', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorWidgetBorder', 'Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget.'));\nexport const editorWidgetResizeBorder = registerColor('editorWidget.resizeBorder', { light: null, dark: null, hcDark: null, hcLight: null }, nls.localize('editorWidgetResizeBorder', \"Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget.\"));\n/**\n * Quick pick widget\n */\nexport const quickInputBackground = registerColor('quickInput.background', { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('pickerBackground', \"Quick picker background color. The quick picker widget is the container for pickers like the command palette.\"));\nexport const quickInputForeground = registerColor('quickInput.foreground', { dark: editorWidgetForeground, light: editorWidgetForeground, hcDark: editorWidgetForeground, hcLight: editorWidgetForeground }, nls.localize('pickerForeground', \"Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.\"));\nexport const quickInputTitleBackground = registerColor('quickInputTitle.background', { dark: new Color(new RGBA(255, 255, 255, 0.105)), light: new Color(new RGBA(0, 0, 0, 0.06)), hcDark: '#000000', hcLight: Color.white }, nls.localize('pickerTitleBackground', \"Quick picker title background color. The quick picker widget is the container for pickers like the command palette.\"));\nexport const pickerGroupForeground = registerColor('pickerGroup.foreground', { dark: '#3794FF', light: '#0066BF', hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('pickerGroupForeground', \"Quick picker color for grouping labels.\"));\nexport const pickerGroupBorder = registerColor('pickerGroup.border', { dark: '#3F3F46', light: '#CCCEDB', hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('pickerGroupBorder', \"Quick picker color for grouping borders.\"));\n/**\n * Keybinding label\n */\nexport const keybindingLabelBackground = registerColor('keybindingLabel.background', { dark: new Color(new RGBA(128, 128, 128, 0.17)), light: new Color(new RGBA(221, 221, 221, 0.4)), hcDark: Color.transparent, hcLight: Color.transparent }, nls.localize('keybindingLabelBackground', \"Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.\"));\nexport const keybindingLabelForeground = registerColor('keybindingLabel.foreground', { dark: Color.fromHex('#CCCCCC'), light: Color.fromHex('#555555'), hcDark: Color.white, hcLight: foreground }, nls.localize('keybindingLabelForeground', \"Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.\"));\nexport const keybindingLabelBorder = registerColor('keybindingLabel.border', { dark: new Color(new RGBA(51, 51, 51, 0.6)), light: new Color(new RGBA(204, 204, 204, 0.4)), hcDark: new Color(new RGBA(111, 195, 223)), hcLight: contrastBorder }, nls.localize('keybindingLabelBorder', \"Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.\"));\nexport const keybindingLabelBottomBorder = registerColor('keybindingLabel.bottomBorder', { dark: new Color(new RGBA(68, 68, 68, 0.6)), light: new Color(new RGBA(187, 187, 187, 0.4)), hcDark: new Color(new RGBA(111, 195, 223)), hcLight: foreground }, nls.localize('keybindingLabelBottomBorder', \"Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.\"));\n/**\n * Editor selection colors.\n */\nexport const editorSelectionBackground = registerColor('editor.selectionBackground', { light: '#ADD6FF', dark: '#264F78', hcDark: '#f3f518', hcLight: '#0F4A85' }, nls.localize('editorSelectionBackground', \"Color of the editor selection.\"));\nexport const editorSelectionForeground = registerColor('editor.selectionForeground', { light: null, dark: null, hcDark: '#000000', hcLight: Color.white }, nls.localize('editorSelectionForeground', \"Color of the selected text for high contrast.\"));\nexport const editorInactiveSelection = registerColor('editor.inactiveSelectionBackground', { light: transparent(editorSelectionBackground, 0.5), dark: transparent(editorSelectionBackground, 0.5), hcDark: transparent(editorSelectionBackground, 0.7), hcLight: transparent(editorSelectionBackground, 0.5) }, nls.localize('editorInactiveSelection', \"Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorSelectionHighlight = registerColor('editor.selectionHighlightBackground', { light: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), dark: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), hcDark: null, hcLight: null }, nls.localize('editorSelectionHighlight', 'Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSelectionHighlightBorder = registerColor('editor.selectionHighlightBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorSelectionHighlightBorder', \"Border color for regions with the same content as the selection.\"));\n/**\n * Editor find match colors.\n */\nexport const editorFindMatch = registerColor('editor.findMatchBackground', { light: '#A8AC94', dark: '#515C6A', hcDark: null, hcLight: null }, nls.localize('editorFindMatch', \"Color of the current search match.\"));\nexport const editorFindMatchHighlight = registerColor('editor.findMatchHighlightBackground', { light: '#EA5C0055', dark: '#EA5C0055', hcDark: null, hcLight: null }, nls.localize('findMatchHighlight', \"Color of the other search matches. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorFindRangeHighlight = registerColor('editor.findRangeHighlightBackground', { dark: '#3a3d4166', light: '#b4b4b44d', hcDark: null, hcLight: null }, nls.localize('findRangeHighlight', \"Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorFindMatchBorder = registerColor('editor.findMatchBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorFindMatchBorder', \"Border color of the current search match.\"));\nexport const editorFindMatchHighlightBorder = registerColor('editor.findMatchHighlightBorder', { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('findMatchHighlightBorder', \"Border color of the other search matches.\"));\nexport const editorFindRangeHighlightBorder = registerColor('editor.findRangeHighlightBorder', { dark: null, light: null, hcDark: transparent(activeContrastBorder, 0.4), hcLight: transparent(activeContrastBorder, 0.4) }, nls.localize('findRangeHighlightBorder', \"Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations.\"), true);\n/**\n * Search Editor query match colors.\n *\n * Distinct from normal editor find match to allow for better differentiation\n */\nexport const searchEditorFindMatch = registerColor('searchEditor.findMatchBackground', { light: transparent(editorFindMatchHighlight, 0.66), dark: transparent(editorFindMatchHighlight, 0.66), hcDark: editorFindMatchHighlight, hcLight: editorFindMatchHighlight }, nls.localize('searchEditor.queryMatch', \"Color of the Search Editor query matches.\"));\nexport const searchEditorFindMatchBorder = registerColor('searchEditor.findMatchBorder', { light: transparent(editorFindMatchHighlightBorder, 0.66), dark: transparent(editorFindMatchHighlightBorder, 0.66), hcDark: editorFindMatchHighlightBorder, hcLight: editorFindMatchHighlightBorder }, nls.localize('searchEditor.editorFindMatchBorder', \"Border color of the Search Editor query matches.\"));\n/**\n * Editor hover\n */\nexport const editorHoverHighlight = registerColor('editor.hoverHighlightBackground', { light: '#ADD6FF26', dark: '#264f7840', hcDark: '#ADD6FF26', hcLight: null }, nls.localize('hoverHighlight', 'Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorHoverBackground = registerColor('editorHoverWidget.background', { light: editorWidgetBackground, dark: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('hoverBackground', 'Background color of the editor hover.'));\nexport const editorHoverForeground = registerColor('editorHoverWidget.foreground', { light: editorWidgetForeground, dark: editorWidgetForeground, hcDark: editorWidgetForeground, hcLight: editorWidgetForeground }, nls.localize('hoverForeground', 'Foreground color of the editor hover.'));\nexport const editorHoverBorder = registerColor('editorHoverWidget.border', { light: editorWidgetBorder, dark: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, nls.localize('hoverBorder', 'Border color of the editor hover.'));\nexport const editorHoverStatusBarBackground = registerColor('editorHoverWidget.statusBarBackground', { dark: lighten(editorHoverBackground, 0.2), light: darken(editorHoverBackground, 0.05), hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('statusBarBackground', \"Background color of the editor hover status bar.\"));\n/**\n * Editor link colors\n */\nexport const editorActiveLinkForeground = registerColor('editorLink.activeForeground', { dark: '#4E94CE', light: Color.blue, hcDark: Color.cyan, hcLight: '#292929' }, nls.localize('activeLinkForeground', 'Color of active links.'));\n/**\n * Inline hints\n */\nexport const editorInlayHintForeground = registerColor('editorInlayHint.foreground', { dark: transparent(badgeForeground, .8), light: transparent(badgeForeground, .8), hcDark: badgeForeground, hcLight: badgeForeground }, nls.localize('editorInlayHintForeground', 'Foreground color of inline hints'));\nexport const editorInlayHintBackground = registerColor('editorInlayHint.background', { dark: transparent(badgeBackground, .6), light: transparent(badgeBackground, .3), hcDark: badgeBackground, hcLight: badgeBackground }, nls.localize('editorInlayHintBackground', 'Background color of inline hints'));\nexport const editorInlayHintTypeForeground = registerColor('editorInlayHint.typeForeground', { dark: editorInlayHintForeground, light: editorInlayHintForeground, hcDark: editorInlayHintForeground, hcLight: editorInlayHintForeground }, nls.localize('editorInlayHintForegroundTypes', 'Foreground color of inline hints for types'));\nexport const editorInlayHintTypeBackground = registerColor('editorInlayHint.typeBackground', { dark: editorInlayHintBackground, light: editorInlayHintBackground, hcDark: editorInlayHintBackground, hcLight: editorInlayHintBackground }, nls.localize('editorInlayHintBackgroundTypes', 'Background color of inline hints for types'));\nexport const editorInlayHintParameterForeground = registerColor('editorInlayHint.parameterForeground', { dark: editorInlayHintForeground, light: editorInlayHintForeground, hcDark: editorInlayHintForeground, hcLight: editorInlayHintForeground }, nls.localize('editorInlayHintForegroundParameter', 'Foreground color of inline hints for parameters'));\nexport const editorInlayHintParameterBackground = registerColor('editorInlayHint.parameterBackground', { dark: editorInlayHintBackground, light: editorInlayHintBackground, hcDark: editorInlayHintBackground, hcLight: editorInlayHintBackground }, nls.localize('editorInlayHintBackgroundParameter', 'Background color of inline hints for parameters'));\n/**\n * Editor lighbulb icon colors\n */\nexport const editorLightBulbForeground = registerColor('editorLightBulb.foreground', { dark: '#FFCC00', light: '#DDB100', hcDark: '#FFCC00', hcLight: '#007ACC' }, nls.localize('editorLightBulbForeground', \"The color used for the lightbulb actions icon.\"));\nexport const editorLightBulbAutoFixForeground = registerColor('editorLightBulbAutoFix.foreground', { dark: '#75BEFF', light: '#007ACC', hcDark: '#75BEFF', hcLight: '#007ACC' }, nls.localize('editorLightBulbAutoFixForeground', \"The color used for the lightbulb auto fix actions icon.\"));\n/**\n * Diff Editor Colors\n */\nexport const defaultInsertColor = new Color(new RGBA(155, 185, 85, .2));\nexport const defaultRemoveColor = new Color(new RGBA(255, 0, 0, .2));\nexport const diffInserted = registerColor('diffEditor.insertedTextBackground', { dark: '#9ccc2c33', light: '#9ccc2c66', hcDark: null, hcLight: null }, nls.localize('diffEditorInserted', 'Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const diffRemoved = registerColor('diffEditor.removedTextBackground', { dark: '#ff000066', light: '#ff00004d', hcDark: null, hcLight: null }, nls.localize('diffEditorRemoved', 'Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const diffInsertedLine = registerColor('diffEditor.insertedLineBackground', { dark: defaultInsertColor, light: defaultInsertColor, hcDark: null, hcLight: null }, nls.localize('diffEditorInsertedLines', 'Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const diffRemovedLine = registerColor('diffEditor.removedLineBackground', { dark: defaultRemoveColor, light: defaultRemoveColor, hcDark: null, hcLight: null }, nls.localize('diffEditorRemovedLines', 'Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const diffInsertedLineGutter = registerColor('diffEditorGutter.insertedLineBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('diffEditorInsertedLineGutter', 'Background color for the margin where lines got inserted.'));\nexport const diffRemovedLineGutter = registerColor('diffEditorGutter.removedLineBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('diffEditorRemovedLineGutter', 'Background color for the margin where lines got removed.'));\nexport const diffOverviewRulerInserted = registerColor('diffEditorOverview.insertedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('diffEditorOverviewInserted', 'Diff overview ruler foreground for inserted content.'));\nexport const diffOverviewRulerRemoved = registerColor('diffEditorOverview.removedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('diffEditorOverviewRemoved', 'Diff overview ruler foreground for removed content.'));\nexport const diffInsertedOutline = registerColor('diffEditor.insertedTextBorder', { dark: null, light: null, hcDark: '#33ff2eff', hcLight: '#374E06' }, nls.localize('diffEditorInsertedOutline', 'Outline color for the text that got inserted.'));\nexport const diffRemovedOutline = registerColor('diffEditor.removedTextBorder', { dark: null, light: null, hcDark: '#FF008F', hcLight: '#AD0707' }, nls.localize('diffEditorRemovedOutline', 'Outline color for text that got removed.'));\nexport const diffBorder = registerColor('diffEditor.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('diffEditorBorder', 'Border color between the two text editors.'));\nexport const diffDiagonalFill = registerColor('diffEditor.diagonalFill', { dark: '#cccccc33', light: '#22222233', hcDark: null, hcLight: null }, nls.localize('diffDiagonalFill', \"Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views.\"));\n/**\n * List and tree colors\n */\nexport const listFocusBackground = registerColor('list.focusBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listFocusBackground', \"List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listFocusForeground = registerColor('list.focusForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listFocusForeground', \"List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listFocusOutline = registerColor('list.focusOutline', { dark: focusBorder, light: focusBorder, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('listFocusOutline', \"List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listFocusAndSelectionOutline = registerColor('list.focusAndSelectionOutline', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listFocusAndSelectionOutline', \"List/Tree outline color for the focused item when the list/tree is active and selected. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listActiveSelectionBackground = registerColor('list.activeSelectionBackground', { dark: '#04395E', light: '#0060C0', hcDark: null, hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localize('listActiveSelectionBackground', \"List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listActiveSelectionForeground = registerColor('list.activeSelectionForeground', { dark: Color.white, light: Color.white, hcDark: null, hcLight: null }, nls.localize('listActiveSelectionForeground', \"List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listActiveSelectionIconForeground = registerColor('list.activeSelectionIconForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listActiveSelectionIconForeground', \"List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveSelectionBackground = registerColor('list.inactiveSelectionBackground', { dark: '#37373D', light: '#E4E6F1', hcDark: null, hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localize('listInactiveSelectionBackground', \"List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveSelectionForeground = registerColor('list.inactiveSelectionForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listInactiveSelectionForeground', \"List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveSelectionIconForeground = registerColor('list.inactiveSelectionIconForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listInactiveSelectionIconForeground', \"List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveFocusBackground = registerColor('list.inactiveFocusBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listInactiveFocusBackground', \"List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveFocusOutline = registerColor('list.inactiveFocusOutline', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listInactiveFocusOutline', \"List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listHoverBackground = registerColor('list.hoverBackground', { dark: '#2A2D2E', light: '#F0F0F0', hcDark: null, hcLight: Color.fromHex('#0F4A85').transparent(0.1) }, nls.localize('listHoverBackground', \"List/Tree background when hovering over items using the mouse.\"));\nexport const listHoverForeground = registerColor('list.hoverForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('listHoverForeground', \"List/Tree foreground when hovering over items using the mouse.\"));\nexport const listDropBackground = registerColor('list.dropBackground', { dark: '#062F4A', light: '#D6EBFF', hcDark: null, hcLight: null }, nls.localize('listDropBackground', \"List/Tree drag and drop background when moving items around using the mouse.\"));\nexport const listHighlightForeground = registerColor('list.highlightForeground', { dark: '#2AAAFF', light: '#0066BF', hcDark: focusBorder, hcLight: focusBorder }, nls.localize('highlight', 'List/Tree foreground color of the match highlights when searching inside the list/tree.'));\nexport const listFocusHighlightForeground = registerColor('list.focusHighlightForeground', { dark: listHighlightForeground, light: ifDefinedThenElse(listActiveSelectionBackground, listHighlightForeground, '#BBE7FF'), hcDark: listHighlightForeground, hcLight: listHighlightForeground }, nls.localize('listFocusHighlightForeground', 'List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree.'));\nexport const listInvalidItemForeground = registerColor('list.invalidItemForeground', { dark: '#B89500', light: '#B89500', hcDark: '#B89500', hcLight: '#B5200D' }, nls.localize('invalidItemForeground', 'List/Tree foreground color for invalid items, for example an unresolved root in explorer.'));\nexport const listErrorForeground = registerColor('list.errorForeground', { dark: '#F88070', light: '#B01011', hcDark: null, hcLight: null }, nls.localize('listErrorForeground', 'Foreground color of list items containing errors.'));\nexport const listWarningForeground = registerColor('list.warningForeground', { dark: '#CCA700', light: '#855F00', hcDark: null, hcLight: null }, nls.localize('listWarningForeground', 'Foreground color of list items containing warnings.'));\nexport const listFilterWidgetBackground = registerColor('listFilterWidget.background', { light: darken(editorWidgetBackground, 0), dark: lighten(editorWidgetBackground, 0), hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('listFilterWidgetBackground', 'Background color of the type filter widget in lists and trees.'));\nexport const listFilterWidgetOutline = registerColor('listFilterWidget.outline', { dark: Color.transparent, light: Color.transparent, hcDark: '#f38518', hcLight: '#007ACC' }, nls.localize('listFilterWidgetOutline', 'Outline color of the type filter widget in lists and trees.'));\nexport const listFilterWidgetNoMatchesOutline = registerColor('listFilterWidget.noMatchesOutline', { dark: '#BE1100', light: '#BE1100', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('listFilterWidgetNoMatchesOutline', 'Outline color of the type filter widget in lists and trees, when there are no matches.'));\nexport const listFilterWidgetShadow = registerColor('listFilterWidget.shadow', { dark: widgetShadow, light: widgetShadow, hcDark: widgetShadow, hcLight: widgetShadow }, nls.localize('listFilterWidgetShadow', 'Shadown color of the type filter widget in lists and trees.'));\nexport const listFilterMatchHighlight = registerColor('list.filterMatchBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('listFilterMatchHighlight', 'Background color of the filtered match.'));\nexport const listFilterMatchHighlightBorder = registerColor('list.filterMatchBorder', { dark: editorFindMatchHighlightBorder, light: editorFindMatchHighlightBorder, hcDark: contrastBorder, hcLight: activeContrastBorder }, nls.localize('listFilterMatchHighlightBorder', 'Border color of the filtered match.'));\nexport const treeIndentGuidesStroke = registerColor('tree.indentGuidesStroke', { dark: '#585858', light: '#a9a9a9', hcDark: '#a9a9a9', hcLight: '#a5a5a5' }, nls.localize('treeIndentGuidesStroke', \"Tree stroke color for the indentation guides.\"));\nexport const tableColumnsBorder = registerColor('tree.tableColumnsBorder', { dark: '#CCCCCC20', light: '#61616120', hcDark: null, hcLight: null }, nls.localize('tableColumnsBorder', \"Table border color between columns.\"));\nexport const tableOddRowsBackgroundColor = registerColor('tree.tableOddRowsBackground', { dark: transparent(foreground, 0.04), light: transparent(foreground, 0.04), hcDark: null, hcLight: null }, nls.localize('tableOddRowsBackgroundColor', \"Background color for odd table rows.\"));\nexport const listDeemphasizedForeground = registerColor('list.deemphasizedForeground', { dark: '#8C8C8C', light: '#8E8E90', hcDark: '#A7A8A9', hcLight: '#666666' }, nls.localize('listDeemphasizedForeground', \"List/Tree foreground color for items that are deemphasized. \"));\n/**\n * Quick pick widget (dependent on List and tree colors)\n */\nexport const _deprecatedQuickInputListFocusBackground = registerColor('quickInput.list.focusBackground', { dark: null, light: null, hcDark: null, hcLight: null }, '', undefined, nls.localize('quickInput.list.focusBackground deprecation', \"Please use quickInputList.focusBackground instead\"));\nexport const quickInputListFocusForeground = registerColor('quickInputList.focusForeground', { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hcDark: listActiveSelectionForeground, hcLight: listActiveSelectionForeground }, nls.localize('quickInput.listFocusForeground', \"Quick picker foreground color for the focused item.\"));\nexport const quickInputListFocusIconForeground = registerColor('quickInputList.focusIconForeground', { dark: listActiveSelectionIconForeground, light: listActiveSelectionIconForeground, hcDark: listActiveSelectionIconForeground, hcLight: listActiveSelectionIconForeground }, nls.localize('quickInput.listFocusIconForeground', \"Quick picker icon foreground color for the focused item.\"));\nexport const quickInputListFocusBackground = registerColor('quickInputList.focusBackground', { dark: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), light: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), hcDark: null, hcLight: null }, nls.localize('quickInput.listFocusBackground', \"Quick picker background color for the focused item.\"));\n/**\n * Menu colors\n */\nexport const menuBorder = registerColor('menu.border', { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('menuBorder', \"Border color of menus.\"));\nexport const menuForeground = registerColor('menu.foreground', { dark: selectForeground, light: foreground, hcDark: selectForeground, hcLight: selectForeground }, nls.localize('menuForeground', \"Foreground color of menu items.\"));\nexport const menuBackground = registerColor('menu.background', { dark: selectBackground, light: selectBackground, hcDark: selectBackground, hcLight: selectBackground }, nls.localize('menuBackground', \"Background color of menu items.\"));\nexport const menuSelectionForeground = registerColor('menu.selectionForeground', { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hcDark: listActiveSelectionForeground, hcLight: listActiveSelectionForeground }, nls.localize('menuSelectionForeground', \"Foreground color of the selected menu item in menus.\"));\nexport const menuSelectionBackground = registerColor('menu.selectionBackground', { dark: listActiveSelectionBackground, light: listActiveSelectionBackground, hcDark: listActiveSelectionBackground, hcLight: listActiveSelectionBackground }, nls.localize('menuSelectionBackground', \"Background color of the selected menu item in menus.\"));\nexport const menuSelectionBorder = registerColor('menu.selectionBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('menuSelectionBorder', \"Border color of the selected menu item in menus.\"));\nexport const menuSeparatorBackground = registerColor('menu.separatorBackground', { dark: '#606060', light: '#D4D4D4', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('menuSeparatorBackground', \"Color of a separator menu item in menus.\"));\n/**\n * Toolbar colors\n */\nexport const toolbarHoverBackground = registerColor('toolbar.hoverBackground', { dark: '#5a5d5e50', light: '#b8b8b850', hcDark: null, hcLight: null }, nls.localize('toolbarHoverBackground', \"Toolbar background when hovering over actions using the mouse\"));\nexport const toolbarHoverOutline = registerColor('toolbar.hoverOutline', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('toolbarHoverOutline', \"Toolbar outline when hovering over actions using the mouse\"));\nexport const toolbarActiveBackground = registerColor('toolbar.activeBackground', { dark: lighten(toolbarHoverBackground, 0.1), light: darken(toolbarHoverBackground, 0.1), hcDark: null, hcLight: null }, nls.localize('toolbarActiveBackground', \"Toolbar background when holding the mouse over actions\"));\n/**\n * Snippet placeholder colors\n */\nexport const snippetTabstopHighlightBackground = registerColor('editor.snippetTabstopHighlightBackground', { dark: new Color(new RGBA(124, 124, 124, 0.3)), light: new Color(new RGBA(10, 50, 100, 0.2)), hcDark: new Color(new RGBA(124, 124, 124, 0.3)), hcLight: new Color(new RGBA(10, 50, 100, 0.2)) }, nls.localize('snippetTabstopHighlightBackground', \"Highlight background color of a snippet tabstop.\"));\nexport const snippetTabstopHighlightBorder = registerColor('editor.snippetTabstopHighlightBorder', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('snippetTabstopHighlightBorder', \"Highlight border color of a snippet tabstop.\"));\nexport const snippetFinalTabstopHighlightBackground = registerColor('editor.snippetFinalTabstopHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('snippetFinalTabstopHighlightBackground', \"Highlight background color of the final tabstop of a snippet.\"));\nexport const snippetFinalTabstopHighlightBorder = registerColor('editor.snippetFinalTabstopHighlightBorder', { dark: '#525252', light: new Color(new RGBA(10, 50, 100, 0.5)), hcDark: '#525252', hcLight: '#292929' }, nls.localize('snippetFinalTabstopHighlightBorder', \"Highlight border color of the final tabstop of a snippet.\"));\n/**\n * Breadcrumb colors\n */\nexport const breadcrumbsForeground = registerColor('breadcrumb.foreground', { light: transparent(foreground, 0.8), dark: transparent(foreground, 0.8), hcDark: transparent(foreground, 0.8), hcLight: transparent(foreground, 0.8) }, nls.localize('breadcrumbsFocusForeground', \"Color of focused breadcrumb items.\"));\nexport const breadcrumbsBackground = registerColor('breadcrumb.background', { light: editorBackground, dark: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('breadcrumbsBackground', \"Background color of breadcrumb items.\"));\nexport const breadcrumbsFocusForeground = registerColor('breadcrumb.focusForeground', { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hcDark: lighten(foreground, 0.1), hcLight: lighten(foreground, 0.1) }, nls.localize('breadcrumbsFocusForeground', \"Color of focused breadcrumb items.\"));\nexport const breadcrumbsActiveSelectionForeground = registerColor('breadcrumb.activeSelectionForeground', { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hcDark: lighten(foreground, 0.1), hcLight: lighten(foreground, 0.1) }, nls.localize('breadcrumbsSelectedForeground', \"Color of selected breadcrumb items.\"));\nexport const breadcrumbsPickerBackground = registerColor('breadcrumbPicker.background', { light: editorWidgetBackground, dark: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, nls.localize('breadcrumbsSelectedBackground', \"Background color of breadcrumb item picker.\"));\n/**\n * Merge-conflict colors\n */\nconst headerTransparency = 0.5;\nconst currentBaseColor = Color.fromHex('#40C8AE').transparent(headerTransparency);\nconst incomingBaseColor = Color.fromHex('#40A6FF').transparent(headerTransparency);\nconst commonBaseColor = Color.fromHex('#606060').transparent(0.4);\nconst contentTransparency = 0.4;\nconst rulerTransparency = 1;\nexport const mergeCurrentHeaderBackground = registerColor('merge.currentHeaderBackground', { dark: currentBaseColor, light: currentBaseColor, hcDark: null, hcLight: null }, nls.localize('mergeCurrentHeaderBackground', 'Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeCurrentContentBackground = registerColor('merge.currentContentBackground', { dark: transparent(mergeCurrentHeaderBackground, contentTransparency), light: transparent(mergeCurrentHeaderBackground, contentTransparency), hcDark: transparent(mergeCurrentHeaderBackground, contentTransparency), hcLight: transparent(mergeCurrentHeaderBackground, contentTransparency) }, nls.localize('mergeCurrentContentBackground', 'Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeIncomingHeaderBackground = registerColor('merge.incomingHeaderBackground', { dark: incomingBaseColor, light: incomingBaseColor, hcDark: null, hcLight: null }, nls.localize('mergeIncomingHeaderBackground', 'Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeIncomingContentBackground = registerColor('merge.incomingContentBackground', { dark: transparent(mergeIncomingHeaderBackground, contentTransparency), light: transparent(mergeIncomingHeaderBackground, contentTransparency), hcDark: transparent(mergeIncomingHeaderBackground, contentTransparency), hcLight: transparent(mergeIncomingHeaderBackground, contentTransparency) }, nls.localize('mergeIncomingContentBackground', 'Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeCommonHeaderBackground = registerColor('merge.commonHeaderBackground', { dark: commonBaseColor, light: commonBaseColor, hcDark: null, hcLight: null }, nls.localize('mergeCommonHeaderBackground', 'Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeCommonContentBackground = registerColor('merge.commonContentBackground', { dark: transparent(mergeCommonHeaderBackground, contentTransparency), light: transparent(mergeCommonHeaderBackground, contentTransparency), hcDark: transparent(mergeCommonHeaderBackground, contentTransparency), hcLight: transparent(mergeCommonHeaderBackground, contentTransparency) }, nls.localize('mergeCommonContentBackground', 'Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeBorder = registerColor('merge.border', { dark: null, light: null, hcDark: '#C3DF6F', hcLight: '#007ACC' }, nls.localize('mergeBorder', 'Border color on headers and the splitter in inline merge-conflicts.'));\nexport const overviewRulerCurrentContentForeground = registerColor('editorOverviewRuler.currentContentForeground', { dark: transparent(mergeCurrentHeaderBackground, rulerTransparency), light: transparent(mergeCurrentHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, nls.localize('overviewRulerCurrentContentForeground', 'Current overview ruler foreground for inline merge-conflicts.'));\nexport const overviewRulerIncomingContentForeground = registerColor('editorOverviewRuler.incomingContentForeground', { dark: transparent(mergeIncomingHeaderBackground, rulerTransparency), light: transparent(mergeIncomingHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, nls.localize('overviewRulerIncomingContentForeground', 'Incoming overview ruler foreground for inline merge-conflicts.'));\nexport const overviewRulerCommonContentForeground = registerColor('editorOverviewRuler.commonContentForeground', { dark: transparent(mergeCommonHeaderBackground, rulerTransparency), light: transparent(mergeCommonHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, nls.localize('overviewRulerCommonContentForeground', 'Common ancestor overview ruler foreground for inline merge-conflicts.'));\nexport const overviewRulerFindMatchForeground = registerColor('editorOverviewRuler.findMatchForeground', { dark: '#d186167e', light: '#d186167e', hcDark: '#AB5A00', hcLight: '' }, nls.localize('overviewRulerFindMatchForeground', 'Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerSelectionHighlightForeground = registerColor('editorOverviewRuler.selectionHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hcDark: '#A0A0A0CC', hcLight: '#A0A0A0CC' }, nls.localize('overviewRulerSelectionHighlightForeground', 'Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const minimapFindMatch = registerColor('minimap.findMatchHighlight', { light: '#d18616', dark: '#d18616', hcDark: '#AB5A00', hcLight: '#0F4A85' }, nls.localize('minimapFindMatchHighlight', 'Minimap marker color for find matches.'), true);\nexport const minimapSelectionOccurrenceHighlight = registerColor('minimap.selectionOccurrenceHighlight', { light: '#c9c9c9', dark: '#676767', hcDark: '#ffffff', hcLight: '#0F4A85' }, nls.localize('minimapSelectionOccurrenceHighlight', 'Minimap marker color for repeating editor selections.'), true);\nexport const minimapSelection = registerColor('minimap.selectionHighlight', { light: '#ADD6FF', dark: '#264F78', hcDark: '#ffffff', hcLight: '#0F4A85' }, nls.localize('minimapSelectionHighlight', 'Minimap marker color for the editor selection.'), true);\nexport const minimapError = registerColor('minimap.errorHighlight', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('minimapError', 'Minimap marker color for errors.'));\nexport const minimapWarning = registerColor('minimap.warningHighlight', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Minimap marker color for warnings.'));\nexport const minimapBackground = registerColor('minimap.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('minimapBackground', \"Minimap background color.\"));\nexport const minimapForegroundOpacity = registerColor('minimap.foregroundOpacity', { dark: Color.fromHex('#000f'), light: Color.fromHex('#000f'), hcDark: Color.fromHex('#000f'), hcLight: Color.fromHex('#000f') }, nls.localize('minimapForegroundOpacity', 'Opacity of foreground elements rendered in the minimap. For example, \"#000000c0\" will render the elements with 75% opacity.'));\nexport const minimapSliderBackground = registerColor('minimapSlider.background', { light: transparent(scrollbarSliderBackground, 0.5), dark: transparent(scrollbarSliderBackground, 0.5), hcDark: transparent(scrollbarSliderBackground, 0.5), hcLight: transparent(scrollbarSliderBackground, 0.5) }, nls.localize('minimapSliderBackground', \"Minimap slider background color.\"));\nexport const minimapSliderHoverBackground = registerColor('minimapSlider.hoverBackground', { light: transparent(scrollbarSliderHoverBackground, 0.5), dark: transparent(scrollbarSliderHoverBackground, 0.5), hcDark: transparent(scrollbarSliderHoverBackground, 0.5), hcLight: transparent(scrollbarSliderHoverBackground, 0.5) }, nls.localize('minimapSliderHoverBackground', \"Minimap slider background color when hovering.\"));\nexport const minimapSliderActiveBackground = registerColor('minimapSlider.activeBackground', { light: transparent(scrollbarSliderActiveBackground, 0.5), dark: transparent(scrollbarSliderActiveBackground, 0.5), hcDark: transparent(scrollbarSliderActiveBackground, 0.5), hcLight: transparent(scrollbarSliderActiveBackground, 0.5) }, nls.localize('minimapSliderActiveBackground', \"Minimap slider background color when clicked on.\"));\nexport const problemsErrorIconForeground = registerColor('problemsErrorIcon.foreground', { dark: editorErrorForeground, light: editorErrorForeground, hcDark: editorErrorForeground, hcLight: editorErrorForeground }, nls.localize('problemsErrorIconForeground', \"The color used for the problems error icon.\"));\nexport const problemsWarningIconForeground = registerColor('problemsWarningIcon.foreground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningForeground, hcLight: editorWarningForeground }, nls.localize('problemsWarningIconForeground', \"The color used for the problems warning icon.\"));\nexport const problemsInfoIconForeground = registerColor('problemsInfoIcon.foreground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoForeground, hcLight: editorInfoForeground }, nls.localize('problemsInfoIconForeground', \"The color used for the problems info icon.\"));\n/**\n * Chart colors\n */\nexport const chartsForeground = registerColor('charts.foreground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, nls.localize('chartsForeground', \"The foreground color used in charts.\"));\nexport const chartsLines = registerColor('charts.lines', { dark: transparent(foreground, .5), light: transparent(foreground, .5), hcDark: transparent(foreground, .5), hcLight: transparent(foreground, .5) }, nls.localize('chartsLines', \"The color used for horizontal lines in charts.\"));\nexport const chartsRed = registerColor('charts.red', { dark: editorErrorForeground, light: editorErrorForeground, hcDark: editorErrorForeground, hcLight: editorErrorForeground }, nls.localize('chartsRed', \"The red color used in chart visualizations.\"));\nexport const chartsBlue = registerColor('charts.blue', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoForeground, hcLight: editorInfoForeground }, nls.localize('chartsBlue', \"The blue color used in chart visualizations.\"));\nexport const chartsYellow = registerColor('charts.yellow', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningForeground, hcLight: editorWarningForeground }, nls.localize('chartsYellow', \"The yellow color used in chart visualizations.\"));\nexport const chartsOrange = registerColor('charts.orange', { dark: minimapFindMatch, light: minimapFindMatch, hcDark: minimapFindMatch, hcLight: minimapFindMatch }, nls.localize('chartsOrange', \"The orange color used in chart visualizations.\"));\nexport const chartsGreen = registerColor('charts.green', { dark: '#89D185', light: '#388A34', hcDark: '#89D185', hcLight: '#374e06' }, nls.localize('chartsGreen', \"The green color used in chart visualizations.\"));\nexport const chartsPurple = registerColor('charts.purple', { dark: '#B180D7', light: '#652D90', hcDark: '#B180D7', hcLight: '#652D90' }, nls.localize('chartsPurple', \"The purple color used in chart visualizations.\"));\n// ----- color functions\nexport function executeTransform(transform, theme) {\n    var _a, _b, _c;\n    switch (transform.op) {\n        case 0 /* ColorTransformType.Darken */:\n            return (_a = resolveColorValue(transform.value, theme)) === null || _a === void 0 ? void 0 : _a.darken(transform.factor);\n        case 1 /* ColorTransformType.Lighten */:\n            return (_b = resolveColorValue(transform.value, theme)) === null || _b === void 0 ? void 0 : _b.lighten(transform.factor);\n        case 2 /* ColorTransformType.Transparent */:\n            return (_c = resolveColorValue(transform.value, theme)) === null || _c === void 0 ? void 0 : _c.transparent(transform.factor);\n        case 3 /* ColorTransformType.OneOf */:\n            for (const candidate of transform.values) {\n                const color = resolveColorValue(candidate, theme);\n                if (color) {\n                    return color;\n                }\n            }\n            return undefined;\n        case 5 /* ColorTransformType.IfDefinedThenElse */:\n            return resolveColorValue(theme.defines(transform.if) ? transform.then : transform.else, theme);\n        case 4 /* ColorTransformType.LessProminent */: {\n            const from = resolveColorValue(transform.value, theme);\n            if (!from) {\n                return undefined;\n            }\n            const backgroundColor = resolveColorValue(transform.background, theme);\n            if (!backgroundColor) {\n                return from.transparent(transform.factor * transform.transparency);\n            }\n            return from.isDarkerThan(backgroundColor)\n                ? Color.getLighterColor(from, backgroundColor, transform.factor).transparent(transform.transparency)\n                : Color.getDarkerColor(from, backgroundColor, transform.factor).transparent(transform.transparency);\n        }\n        default:\n            throw assertNever(transform);\n    }\n}\nexport function darken(colorValue, factor) {\n    return { op: 0 /* ColorTransformType.Darken */, value: colorValue, factor };\n}\nexport function lighten(colorValue, factor) {\n    return { op: 1 /* ColorTransformType.Lighten */, value: colorValue, factor };\n}\nexport function transparent(colorValue, factor) {\n    return { op: 2 /* ColorTransformType.Transparent */, value: colorValue, factor };\n}\nexport function oneOf(...colorValues) {\n    return { op: 3 /* ColorTransformType.OneOf */, values: colorValues };\n}\nexport function ifDefinedThenElse(ifArg, thenArg, elseArg) {\n    return { op: 5 /* ColorTransformType.IfDefinedThenElse */, if: ifArg, then: thenArg, else: elseArg };\n}\nfunction lessProminent(colorValue, backgroundColorValue, factor, transparency) {\n    return { op: 4 /* ColorTransformType.LessProminent */, value: colorValue, background: backgroundColorValue, factor, transparency };\n}\n// ----- implementation\n/**\n * @param colorValue Resolve a color value in the context of a theme\n */\nexport function resolveColorValue(colorValue, theme) {\n    if (colorValue === null) {\n        return undefined;\n    }\n    else if (typeof colorValue === 'string') {\n        if (colorValue[0] === '#') {\n            return Color.fromHex(colorValue);\n        }\n        return theme.getColor(colorValue);\n    }\n    else if (colorValue instanceof Color) {\n        return colorValue;\n    }\n    else if (typeof colorValue === 'object') {\n        return executeTransform(colorValue, theme);\n    }\n    return undefined;\n}\nexport const workbenchColorsSchemaId = 'vscode://schemas/workbench-colors';\nconst schemaRegistry = platform.Registry.as(JSONExtensions.JSONContribution);\nschemaRegistry.registerSchema(workbenchColorsSchemaId, colorRegistry.getColorSchema());\nconst delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(workbenchColorsSchemaId), 200);\ncolorRegistry.onDidChangeSchema(() => {\n    if (!delayer.isScheduled()) {\n        delayer.schedule();\n    }\n});\n// setTimeout(_ => console.log(colorRegistry.toString()), 5000);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../base/browser/dom.js';\nimport { GlobalPointerMoveMonitor } from '../../base/browser/globalPointerMoveMonitor.js';\nimport { StandardMouseEvent } from '../../base/browser/mouseEvent.js';\nimport { RunOnceScheduler } from '../../base/common/async.js';\nimport { Disposable } from '../../base/common/lifecycle.js';\nimport { asCssVariableName } from '../../platform/theme/common/colorRegistry.js';\n/**\n * Coordinates relative to the whole document (e.g. mouse event's pageX and pageY)\n */\nexport class PageCoordinates {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this._pageCoordinatesBrand = undefined;\n    }\n    toClientCoordinates() {\n        return new ClientCoordinates(this.x - dom.StandardWindow.scrollX, this.y - dom.StandardWindow.scrollY);\n    }\n}\n/**\n * Coordinates within the application's client area (i.e. origin is document's scroll position).\n *\n * For example, clicking in the top-left corner of the client area will\n * always result in a mouse event with a client.x value of 0, regardless\n * of whether the page is scrolled horizontally.\n */\nexport class ClientCoordinates {\n    constructor(clientX, clientY) {\n        this.clientX = clientX;\n        this.clientY = clientY;\n        this._clientCoordinatesBrand = undefined;\n    }\n    toPageCoordinates() {\n        return new PageCoordinates(this.clientX + dom.StandardWindow.scrollX, this.clientY + dom.StandardWindow.scrollY);\n    }\n}\n/**\n * The position of the editor in the page.\n */\nexport class EditorPagePosition {\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this._editorPagePositionBrand = undefined;\n    }\n}\n/**\n * Coordinates relative to the the (top;left) of the editor that can be used safely with other internal editor metrics.\n * **NOTE**: This position is obtained by taking page coordinates and transforming them relative to the\n * editor's (top;left) position in a way in which scale transformations are taken into account.\n * **NOTE**: These coordinates could be negative if the mouse position is outside the editor.\n */\nexport class CoordinatesRelativeToEditor {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this._positionRelativeToEditorBrand = undefined;\n    }\n}\nexport function createEditorPagePosition(editorViewDomNode) {\n    const editorPos = dom.getDomNodePagePosition(editorViewDomNode);\n    return new EditorPagePosition(editorPos.left, editorPos.top, editorPos.width, editorPos.height);\n}\nexport function createCoordinatesRelativeToEditor(editorViewDomNode, editorPagePosition, pos) {\n    // The editor's page position is read from the DOM using getBoundingClientRect().\n    //\n    // getBoundingClientRect() returns the actual dimensions, while offsetWidth and offsetHeight\n    // reflect the unscaled size. We can use this difference to detect a transform:scale()\n    // and we will apply the transformation in inverse to get mouse coordinates that make sense inside the editor.\n    //\n    // This could be expanded to cover rotation as well maybe by walking the DOM up from `editorViewDomNode`\n    // and computing the effective transformation matrix using getComputedStyle(element).transform.\n    //\n    const scaleX = editorPagePosition.width / editorViewDomNode.offsetWidth;\n    const scaleY = editorPagePosition.height / editorViewDomNode.offsetHeight;\n    // Adjust mouse offsets if editor appears to be scaled via transforms\n    const relativeX = (pos.x - editorPagePosition.x) / scaleX;\n    const relativeY = (pos.y - editorPagePosition.y) / scaleY;\n    return new CoordinatesRelativeToEditor(relativeX, relativeY);\n}\nexport class EditorMouseEvent extends StandardMouseEvent {\n    constructor(e, isFromPointerCapture, editorViewDomNode) {\n        super(e);\n        this._editorMouseEventBrand = undefined;\n        this.isFromPointerCapture = isFromPointerCapture;\n        this.pos = new PageCoordinates(this.posx, this.posy);\n        this.editorPos = createEditorPagePosition(editorViewDomNode);\n        this.relativePos = createCoordinatesRelativeToEditor(editorViewDomNode, this.editorPos, this.pos);\n    }\n}\nexport class EditorMouseEventFactory {\n    constructor(editorViewDomNode) {\n        this._editorViewDomNode = editorViewDomNode;\n    }\n    _create(e) {\n        return new EditorMouseEvent(e, false, this._editorViewDomNode);\n    }\n    onContextMenu(target, callback) {\n        return dom.addDisposableListener(target, 'contextmenu', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onMouseUp(target, callback) {\n        return dom.addDisposableListener(target, 'mouseup', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onMouseDown(target, callback) {\n        return dom.addDisposableListener(target, dom.EventType.MOUSE_DOWN, (e) => {\n            callback(this._create(e));\n        });\n    }\n    onPointerDown(target, callback) {\n        return dom.addDisposableListener(target, dom.EventType.POINTER_DOWN, (e) => {\n            callback(this._create(e), e.pointerId);\n        });\n    }\n    onMouseLeave(target, callback) {\n        return dom.addDisposableListener(target, dom.EventType.MOUSE_LEAVE, (e) => {\n            callback(this._create(e));\n        });\n    }\n    onMouseMove(target, callback) {\n        return dom.addDisposableListener(target, 'mousemove', (e) => callback(this._create(e)));\n    }\n}\nexport class EditorPointerEventFactory {\n    constructor(editorViewDomNode) {\n        this._editorViewDomNode = editorViewDomNode;\n    }\n    _create(e) {\n        return new EditorMouseEvent(e, false, this._editorViewDomNode);\n    }\n    onPointerUp(target, callback) {\n        return dom.addDisposableListener(target, 'pointerup', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onPointerDown(target, callback) {\n        return dom.addDisposableListener(target, dom.EventType.POINTER_DOWN, (e) => {\n            callback(this._create(e), e.pointerId);\n        });\n    }\n    onPointerLeave(target, callback) {\n        return dom.addDisposableListener(target, dom.EventType.POINTER_LEAVE, (e) => {\n            callback(this._create(e));\n        });\n    }\n    onPointerMove(target, callback) {\n        return dom.addDisposableListener(target, 'pointermove', (e) => callback(this._create(e)));\n    }\n}\nexport class GlobalEditorPointerMoveMonitor extends Disposable {\n    constructor(editorViewDomNode) {\n        super();\n        this._editorViewDomNode = editorViewDomNode;\n        this._globalPointerMoveMonitor = this._register(new GlobalPointerMoveMonitor());\n        this._keydownListener = null;\n    }\n    startMonitoring(initialElement, pointerId, initialButtons, pointerMoveCallback, onStopCallback) {\n        // Add a <<capture>> keydown event listener that will cancel the monitoring\n        // if something other than a modifier key is pressed\n        this._keydownListener = dom.addStandardDisposableListener(document, 'keydown', (e) => {\n            const kb = e.toKeybinding();\n            if (kb.isModifierKey()) {\n                // Allow modifier keys\n                return;\n            }\n            this._globalPointerMoveMonitor.stopMonitoring(true, e.browserEvent);\n        }, true);\n        this._globalPointerMoveMonitor.startMonitoring(initialElement, pointerId, initialButtons, (e) => {\n            pointerMoveCallback(new EditorMouseEvent(e, true, this._editorViewDomNode));\n        }, (e) => {\n            this._keydownListener.dispose();\n            onStopCallback(e);\n        });\n    }\n    stopMonitoring() {\n        this._globalPointerMoveMonitor.stopMonitoring(true);\n    }\n}\n/**\n * A helper to create dynamic css rules, bound to a class name.\n * Rules are reused.\n * Reference counting and delayed garbage collection ensure that no rules leak.\n*/\nexport class DynamicCssRules {\n    constructor(_editor) {\n        this._editor = _editor;\n        this._instanceId = ++DynamicCssRules._idPool;\n        this._counter = 0;\n        this._rules = new Map();\n        // We delay garbage collection so that hanging rules can be reused.\n        this._garbageCollectionScheduler = new RunOnceScheduler(() => this.garbageCollect(), 1000);\n    }\n    createClassNameRef(options) {\n        const rule = this.getOrCreateRule(options);\n        rule.increaseRefCount();\n        return {\n            className: rule.className,\n            dispose: () => {\n                rule.decreaseRefCount();\n                this._garbageCollectionScheduler.schedule();\n            }\n        };\n    }\n    getOrCreateRule(properties) {\n        const key = this.computeUniqueKey(properties);\n        let existingRule = this._rules.get(key);\n        if (!existingRule) {\n            const counter = this._counter++;\n            existingRule = new RefCountedCssRule(key, `dyn-rule-${this._instanceId}-${counter}`, dom.isInShadowDOM(this._editor.getContainerDomNode())\n                ? this._editor.getContainerDomNode()\n                : undefined, properties);\n            this._rules.set(key, existingRule);\n        }\n        return existingRule;\n    }\n    computeUniqueKey(properties) {\n        return JSON.stringify(properties);\n    }\n    garbageCollect() {\n        for (const rule of this._rules.values()) {\n            if (!rule.hasReferences()) {\n                this._rules.delete(rule.key);\n                rule.dispose();\n            }\n        }\n    }\n}\nDynamicCssRules._idPool = 0;\nclass RefCountedCssRule {\n    constructor(key, className, _containerElement, properties) {\n        this.key = key;\n        this.className = className;\n        this.properties = properties;\n        this._referenceCount = 0;\n        this._styleElement = dom.createStyleSheet(_containerElement);\n        this._styleElement.textContent = this.getCssText(this.className, this.properties);\n    }\n    getCssText(className, properties) {\n        let str = `.${className} {`;\n        for (const prop in properties) {\n            const value = properties[prop];\n            let cssValue;\n            if (typeof value === 'object') {\n                cssValue = `var(${asCssVariableName(value.id)})`;\n            }\n            else {\n                cssValue = value;\n            }\n            const cssPropName = camelToDashes(prop);\n            str += `\\n\\t${cssPropName}: ${cssValue};`;\n        }\n        str += `\\n}`;\n        return str;\n    }\n    dispose() {\n        this._styleElement.remove();\n    }\n    increaseRefCount() {\n        this._referenceCount++;\n    }\n    decreaseRefCount() {\n        this._referenceCount--;\n    }\n    hasReferences() {\n        return this._referenceCount > 0;\n    }\n}\nfunction camelToDashes(str) {\n    return str.replace(/(^[A-Z])/, ([first]) => first.toLowerCase())\n        .replace(/([A-Z])/g, ([letter]) => `-${letter.toLowerCase()}`);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/core/cursorColumns.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/cursor/cursorAtomicMoveOperations.js';\nclass UnknownHitTestResult {\n    constructor(hitTarget = null) {\n        this.hitTarget = hitTarget;\n        this.type = 0 /* HitTestResultType.Unknown */;\n    }\n}\nclass ContentHitTestResult {\n    constructor(position, spanNode, injectedText) {\n        this.position = position;\n        this.spanNode = spanNode;\n        this.injectedText = injectedText;\n        this.type = 1 /* HitTestResultType.Content */;\n    }\n}\nvar HitTestResult;\n(function (HitTestResult) {\n    function createFromDOMInfo(ctx, spanNode, offset) {\n        const position = ctx.getPositionFromDOMInfo(spanNode, offset);\n        if (position) {\n            return new ContentHitTestResult(position, spanNode, null);\n        }\n        return new UnknownHitTestResult(spanNode);\n    }\n    HitTestResult.createFromDOMInfo = createFromDOMInfo;\n})(HitTestResult || (HitTestResult = {}));\nexport class PointerHandlerLastRenderData {\n    constructor(lastViewCursorsRenderData, lastTextareaPosition) {\n        this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n        this.lastTextareaPosition = lastTextareaPosition;\n    }\n}\nexport class MouseTarget {\n    static _deduceRage(position, range = null) {\n        if (!range && position) {\n            return new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n        }\n        return range !== null && range !== void 0 ? range : null;\n    }\n    static createUnknown(element, mouseColumn, position) {\n        return { type: 0 /* MouseTargetType.UNKNOWN */, element, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static createTextarea(element, mouseColumn) {\n        return { type: 1 /* MouseTargetType.TEXTAREA */, element, mouseColumn, position: null, range: null };\n    }\n    static createMargin(type, element, mouseColumn, position, range, detail) {\n        return { type, element, mouseColumn, position, range, detail };\n    }\n    static createViewZone(type, element, mouseColumn, position, detail) {\n        return { type, element, mouseColumn, position, range: this._deduceRage(position), detail };\n    }\n    static createContentText(element, mouseColumn, position, range, detail) {\n        return { type: 6 /* MouseTargetType.CONTENT_TEXT */, element, mouseColumn, position, range: this._deduceRage(position, range), detail };\n    }\n    static createContentEmpty(element, mouseColumn, position, detail) {\n        return { type: 7 /* MouseTargetType.CONTENT_EMPTY */, element, mouseColumn, position, range: this._deduceRage(position), detail };\n    }\n    static createContentWidget(element, mouseColumn, detail) {\n        return { type: 9 /* MouseTargetType.CONTENT_WIDGET */, element, mouseColumn, position: null, range: null, detail };\n    }\n    static createScrollbar(element, mouseColumn, position) {\n        return { type: 11 /* MouseTargetType.SCROLLBAR */, element, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static createOverlayWidget(element, mouseColumn, detail) {\n        return { type: 12 /* MouseTargetType.OVERLAY_WIDGET */, element, mouseColumn, position: null, range: null, detail };\n    }\n    static createOutsideEditor(mouseColumn, position) {\n        return { type: 13 /* MouseTargetType.OUTSIDE_EDITOR */, element: null, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static _typeToString(type) {\n        if (type === 1 /* MouseTargetType.TEXTAREA */) {\n            return 'TEXTAREA';\n        }\n        if (type === 2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */) {\n            return 'GUTTER_GLYPH_MARGIN';\n        }\n        if (type === 3 /* MouseTargetType.GUTTER_LINE_NUMBERS */) {\n            return 'GUTTER_LINE_NUMBERS';\n        }\n        if (type === 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */) {\n            return 'GUTTER_LINE_DECORATIONS';\n        }\n        if (type === 5 /* MouseTargetType.GUTTER_VIEW_ZONE */) {\n            return 'GUTTER_VIEW_ZONE';\n        }\n        if (type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n            return 'CONTENT_TEXT';\n        }\n        if (type === 7 /* MouseTargetType.CONTENT_EMPTY */) {\n            return 'CONTENT_EMPTY';\n        }\n        if (type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */) {\n            return 'CONTENT_VIEW_ZONE';\n        }\n        if (type === 9 /* MouseTargetType.CONTENT_WIDGET */) {\n            return 'CONTENT_WIDGET';\n        }\n        if (type === 10 /* MouseTargetType.OVERVIEW_RULER */) {\n            return 'OVERVIEW_RULER';\n        }\n        if (type === 11 /* MouseTargetType.SCROLLBAR */) {\n            return 'SCROLLBAR';\n        }\n        if (type === 12 /* MouseTargetType.OVERLAY_WIDGET */) {\n            return 'OVERLAY_WIDGET';\n        }\n        return 'UNKNOWN';\n    }\n    static toString(target) {\n        return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + JSON.stringify(target.detail);\n    }\n}\nclass ElementPath {\n    static isTextArea(path) {\n        return (path.length === 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 6 /* PartFingerprint.TextArea */);\n    }\n    static isChildOfViewLines(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 7 /* PartFingerprint.ViewLines */);\n    }\n    static isStrictChildOfViewLines(path) {\n        return (path.length > 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 7 /* PartFingerprint.ViewLines */);\n    }\n    static isChildOfScrollableElement(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 5 /* PartFingerprint.ScrollableElement */);\n    }\n    static isChildOfMinimap(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 8 /* PartFingerprint.Minimap */);\n    }\n    static isChildOfContentWidgets(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 1 /* PartFingerprint.ContentWidgets */);\n    }\n    static isChildOfOverflowingContentWidgets(path) {\n        return (path.length >= 1\n            && path[0] === 2 /* PartFingerprint.OverflowingContentWidgets */);\n    }\n    static isChildOfOverlayWidgets(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 4 /* PartFingerprint.OverlayWidgets */);\n    }\n}\nexport class HitTestContext {\n    constructor(context, viewHelper, lastRenderData) {\n        this.viewModel = context.viewModel;\n        const options = context.configuration.options;\n        this.layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        this.viewDomNode = viewHelper.viewDomNode;\n        this.lineHeight = options.get(61 /* EditorOption.lineHeight */);\n        this.stickyTabStops = options.get(106 /* EditorOption.stickyTabStops */);\n        this.typicalHalfwidthCharacterWidth = options.get(46 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth;\n        this.lastRenderData = lastRenderData;\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    getZoneAtCoord(mouseVerticalOffset) {\n        return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n    }\n    static getZoneAtCoord(context, mouseVerticalOffset) {\n        // The target is either a view zone or the empty space after the last view-line\n        const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n        if (viewZoneWhitespace) {\n            const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n            const lineCount = context.viewModel.getLineCount();\n            let positionBefore = null;\n            let position;\n            let positionAfter = null;\n            if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n                // There are more lines after this view zone\n                positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n            }\n            if (viewZoneWhitespace.afterLineNumber > 0) {\n                // There are more lines above this view zone\n                positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.viewModel.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n            }\n            if (positionAfter === null) {\n                position = positionBefore;\n            }\n            else if (positionBefore === null) {\n                position = positionAfter;\n            }\n            else if (mouseVerticalOffset < viewZoneMiddle) {\n                position = positionBefore;\n            }\n            else {\n                position = positionAfter;\n            }\n            return {\n                viewZoneId: viewZoneWhitespace.id,\n                afterLineNumber: viewZoneWhitespace.afterLineNumber,\n                positionBefore: positionBefore,\n                positionAfter: positionAfter,\n                position: position\n            };\n        }\n        return null;\n    }\n    getFullLineRangeAtCoord(mouseVerticalOffset) {\n        if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n            // Below the last line\n            const lineNumber = this._context.viewModel.getLineCount();\n            const maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n            return {\n                range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\n                isAfterLines: true\n            };\n        }\n        const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n        const maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n        return {\n            range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n            isAfterLines: false\n        };\n    }\n    getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n        return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n    }\n    isAfterLines(mouseVerticalOffset) {\n        return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n    }\n    isInTopPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n    }\n    isInBottomPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n    }\n    getVerticalOffsetForLineNumber(lineNumber) {\n        return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n    findAttribute(element, attr) {\n        return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n    }\n    static _findAttribute(element, attr, stopAt) {\n        while (element && element !== document.body) {\n            if (element.hasAttribute && element.hasAttribute(attr)) {\n                return element.getAttribute(attr);\n            }\n            if (element === stopAt) {\n                return null;\n            }\n            element = element.parentNode;\n        }\n        return null;\n    }\n    getLineWidth(lineNumber) {\n        return this._viewHelper.getLineWidth(lineNumber);\n    }\n    visibleRangeForPosition(lineNumber, column) {\n        return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n    }\n    getPositionFromDOMInfo(spanNode, offset) {\n        return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n    }\n    getCurrentScrollTop() {\n        return this._context.viewLayout.getCurrentScrollTop();\n    }\n    getCurrentScrollLeft() {\n        return this._context.viewLayout.getCurrentScrollLeft();\n    }\n}\nclass BareHitTestRequest {\n    constructor(ctx, editorPos, pos, relativePos) {\n        this.editorPos = editorPos;\n        this.pos = pos;\n        this.relativePos = relativePos;\n        this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + this.relativePos.y);\n        this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + this.relativePos.x - ctx.layoutInfo.contentLeft;\n        this.isInMarginArea = (this.relativePos.x < ctx.layoutInfo.contentLeft && this.relativePos.x >= ctx.layoutInfo.glyphMarginLeft);\n        this.isInContentArea = !this.isInMarginArea;\n        this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n    }\n}\nclass HitTestRequest extends BareHitTestRequest {\n    constructor(ctx, editorPos, pos, relativePos, target) {\n        super(ctx, editorPos, pos, relativePos);\n        this._ctx = ctx;\n        if (target) {\n            this.target = target;\n            this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);\n        }\n        else {\n            this.target = null;\n            this.targetPath = new Uint8Array(0);\n        }\n    }\n    toString() {\n        return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\\n\\ttarget: ${this.target ? this.target.outerHTML : null}`;\n    }\n    _getMouseColumn(position = null) {\n        if (position && position.column < this._ctx.viewModel.getLineMaxColumn(position.lineNumber)) {\n            // Most likely, the line contains foreign decorations...\n            return CursorColumns.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(position.lineNumber), position.column, this._ctx.viewModel.model.getOptions().tabSize) + 1;\n        }\n        return this.mouseColumn;\n    }\n    fulfillUnknown(position = null) {\n        return MouseTarget.createUnknown(this.target, this._getMouseColumn(position), position);\n    }\n    fulfillTextarea() {\n        return MouseTarget.createTextarea(this.target, this._getMouseColumn());\n    }\n    fulfillMargin(type, position, range, detail) {\n        return MouseTarget.createMargin(type, this.target, this._getMouseColumn(position), position, range, detail);\n    }\n    fulfillViewZone(type, position, detail) {\n        return MouseTarget.createViewZone(type, this.target, this._getMouseColumn(position), position, detail);\n    }\n    fulfillContentText(position, range, detail) {\n        return MouseTarget.createContentText(this.target, this._getMouseColumn(position), position, range, detail);\n    }\n    fulfillContentEmpty(position, detail) {\n        return MouseTarget.createContentEmpty(this.target, this._getMouseColumn(position), position, detail);\n    }\n    fulfillContentWidget(detail) {\n        return MouseTarget.createContentWidget(this.target, this._getMouseColumn(), detail);\n    }\n    fulfillScrollbar(position) {\n        return MouseTarget.createScrollbar(this.target, this._getMouseColumn(position), position);\n    }\n    fulfillOverlayWidget(detail) {\n        return MouseTarget.createOverlayWidget(this.target, this._getMouseColumn(), detail);\n    }\n    withTarget(target) {\n        return new HitTestRequest(this._ctx, this.editorPos, this.pos, this.relativePos, target);\n    }\n}\nconst EMPTY_CONTENT_AFTER_LINES = { isAfterLines: true };\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n    return {\n        isAfterLines: false,\n        horizontalDistanceToText: horizontalDistanceToText\n    };\n}\nexport class MouseTargetFactory {\n    constructor(context, viewHelper) {\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    mouseTargetIsWidget(e) {\n        const t = e.target;\n        const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n            return true;\n        }\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(path)) {\n            return true;\n        }\n        return false;\n    }\n    createMouseTarget(lastRenderData, editorPos, pos, relativePos, target) {\n        const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n        const request = new HitTestRequest(ctx, editorPos, pos, relativePos, target);\n        try {\n            const r = MouseTargetFactory._createMouseTarget(ctx, request, false);\n            // console.log(MouseTarget.toString(r));\n            return r;\n        }\n        catch (err) {\n            // console.log(err);\n            return request.fulfillUnknown();\n        }\n    }\n    static _createMouseTarget(ctx, request, domHitTestExecuted) {\n        // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n        // First ensure the request has a target\n        if (request.target === null) {\n            if (domHitTestExecuted) {\n                // Still no target... and we have already executed hit test...\n                return request.fulfillUnknown();\n            }\n            const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n            if (hitTestResult.type === 1 /* HitTestResultType.Content */) {\n                return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n            }\n            return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n        }\n        // we know for a fact that request.target is not null\n        const resolvedRequest = request;\n        let result = null;\n        result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest, domHitTestExecuted);\n        result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n        return (result || request.fulfillUnknown());\n    }\n    static _hitTestContentWidget(ctx, request) {\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfillContentWidget(widgetId);\n            }\n            else {\n                return request.fulfillUnknown();\n            }\n        }\n        return null;\n    }\n    static _hitTestOverlayWidget(ctx, request) {\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfillOverlayWidget(widgetId);\n            }\n            else {\n                return request.fulfillUnknown();\n            }\n        }\n        return null;\n    }\n    static _hitTestViewCursor(ctx, request) {\n        if (request.target) {\n            // Check if we've hit a painted cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            for (const d of lastViewCursorsRenderData) {\n                if (request.target === d.domNode) {\n                    return request.fulfillContentText(d.position, null, { mightBeForeignElement: false, injectedText: null });\n                }\n            }\n        }\n        if (request.isInContentArea) {\n            // Edge has a bug when hit-testing the exact position of a cursor,\n            // instead of returning the correct dom node, it returns the\n            // first or last rendered view line dom node, therefore help it out\n            // and first check if we are on top of a cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n            const mouseVerticalOffset = request.mouseVerticalOffset;\n            for (const d of lastViewCursorsRenderData) {\n                if (mouseContentHorizontalOffset < d.contentLeft) {\n                    // mouse position is to the left of the cursor\n                    continue;\n                }\n                if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\n                    // mouse position is to the right of the cursor\n                    continue;\n                }\n                const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\n                if (cursorVerticalOffset <= mouseVerticalOffset\n                    && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\n                    return request.fulfillContentText(d.position, null, { mightBeForeignElement: false, injectedText: null });\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestViewZone(ctx, request) {\n        const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n        if (viewZoneData) {\n            const mouseTargetType = (request.isInContentArea ? 8 /* MouseTargetType.CONTENT_VIEW_ZONE */ : 5 /* MouseTargetType.GUTTER_VIEW_ZONE */);\n            return request.fulfillViewZone(mouseTargetType, viewZoneData.position, viewZoneData);\n        }\n        return null;\n    }\n    static _hitTestTextArea(ctx, request) {\n        // Is it the textarea?\n        if (ElementPath.isTextArea(request.targetPath)) {\n            if (ctx.lastRenderData.lastTextareaPosition) {\n                return request.fulfillContentText(ctx.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: false, injectedText: null });\n            }\n            return request.fulfillTextarea();\n        }\n        return null;\n    }\n    static _hitTestMargin(ctx, request) {\n        if (request.isInMarginArea) {\n            const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n            const pos = res.range.getStartPosition();\n            let offset = Math.abs(request.relativePos.x);\n            const detail = {\n                isAfterLines: res.isAfterLines,\n                glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n                glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n                lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n                offsetX: offset\n            };\n            offset -= ctx.layoutInfo.glyphMarginLeft;\n            if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n                // On the glyph margin\n                return request.fulfillMargin(2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.glyphMarginWidth;\n            if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n                // On the line numbers\n                return request.fulfillMargin(3 /* MouseTargetType.GUTTER_LINE_NUMBERS */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.lineNumbersWidth;\n            // On the line decorations\n            return request.fulfillMargin(4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\n        }\n        return null;\n    }\n    static _hitTestViewLines(ctx, request, domHitTestExecuted) {\n        if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n            return null;\n        }\n        if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n            return request.fulfillContentEmpty(new Position(1, 1), EMPTY_CONTENT_AFTER_LINES);\n        }\n        // Check if it is below any lines and any view zones\n        if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n            // This most likely indicates it happened after the last view-line\n            const lineCount = ctx.viewModel.getLineCount();\n            const maxLineColumn = ctx.viewModel.getLineMaxColumn(lineCount);\n            return request.fulfillContentEmpty(new Position(lineCount, maxLineColumn), EMPTY_CONTENT_AFTER_LINES);\n        }\n        if (domHitTestExecuted) {\n            // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n            // See https://github.com/microsoft/vscode/issues/46942\n            if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n                const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n                if (ctx.viewModel.getLineLength(lineNumber) === 0) {\n                    const lineWidth = ctx.getLineWidth(lineNumber);\n                    const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                    return request.fulfillContentEmpty(new Position(lineNumber, 1), detail);\n                }\n                const lineWidth = ctx.getLineWidth(lineNumber);\n                if (request.mouseContentHorizontalOffset >= lineWidth) {\n                    const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                    const pos = new Position(lineNumber, ctx.viewModel.getLineMaxColumn(lineNumber));\n                    return request.fulfillContentEmpty(pos, detail);\n                }\n            }\n            // We have already executed hit test...\n            return request.fulfillUnknown();\n        }\n        const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n        if (hitTestResult.type === 1 /* HitTestResultType.Content */) {\n            return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n        }\n        return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n    }\n    static _hitTestMinimap(ctx, request) {\n        if (ElementPath.isChildOfMinimap(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    static _hitTestScrollbarSlider(ctx, request) {\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            if (request.target && request.target.nodeType === 1) {\n                const className = request.target.className;\n                if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n                    const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n                    const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n                    return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestScrollbar(ctx, request) {\n        // Is it the overview ruler?\n        // Is it a child of the scrollable element?\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    getMouseColumn(relativePos) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + relativePos.x - layoutInfo.contentLeft;\n        return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(46 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth);\n    }\n    static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n        if (mouseContentHorizontalOffset < 0) {\n            return 1;\n        }\n        const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n        return (chars + 1);\n    }\n    static createMouseTargetFromHitTestPosition(ctx, request, spanNode, pos, injectedText) {\n        const lineNumber = pos.lineNumber;\n        const column = pos.column;\n        const lineWidth = ctx.getLineWidth(lineNumber);\n        if (request.mouseContentHorizontalOffset > lineWidth) {\n            const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n            return request.fulfillContentEmpty(pos, detail);\n        }\n        const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n        if (!visibleRange) {\n            return request.fulfillUnknown(pos);\n        }\n        const columnHorizontalOffset = visibleRange.left;\n        if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {\n            return request.fulfillContentText(pos, null, { mightBeForeignElement: !!injectedText, injectedText });\n        }\n        const points = [];\n        points.push({ offset: visibleRange.left, column: column });\n        if (column > 1) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column - 1 });\n            }\n        }\n        const lineMaxColumn = ctx.viewModel.getLineMaxColumn(lineNumber);\n        if (column < lineMaxColumn) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column + 1 });\n            }\n        }\n        points.sort((a, b) => a.offset - b.offset);\n        const mouseCoordinates = request.pos.toClientCoordinates();\n        const spanNodeClientRect = spanNode.getBoundingClientRect();\n        const mouseIsOverSpanNode = (spanNodeClientRect.left <= mouseCoordinates.clientX && mouseCoordinates.clientX <= spanNodeClientRect.right);\n        for (let i = 1; i < points.length; i++) {\n            const prev = points[i - 1];\n            const curr = points[i];\n            if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n                const rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n                // See https://github.com/microsoft/vscode/issues/152819\n                // Due to the use of zwj, the browser's hit test result is skewed towards the left\n                // Here we try to correct that if the mouse horizontal offset is closer to the right than the left\n                const prevDelta = Math.abs(prev.offset - request.mouseContentHorizontalOffset);\n                const nextDelta = Math.abs(curr.offset - request.mouseContentHorizontalOffset);\n                const resultPos = (prevDelta < nextDelta\n                    ? new Position(lineNumber, prev.column)\n                    : new Position(lineNumber, curr.column));\n                return request.fulfillContentText(resultPos, rng, { mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText, injectedText });\n            }\n        }\n        return request.fulfillContentText(pos, null, { mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText, injectedText });\n    }\n    /**\n     * Most probably WebKit browsers and Edge\n     */\n    static _doHitTestWithCaretRangeFromPoint(ctx, request) {\n        // In Chrome, especially on Linux it is possible to click between lines,\n        // so try to adjust the `hity` below so that it lands in the center of a line\n        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        const lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n        const lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);\n        let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n        if (adjustedPageY <= request.editorPos.y) {\n            adjustedPageY = request.editorPos.y + 1;\n        }\n        if (adjustedPageY >= request.editorPos.y + request.editorPos.height) {\n            adjustedPageY = request.editorPos.y + request.editorPos.height - 1;\n        }\n        const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n        const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());\n        if (r.type === 1 /* HitTestResultType.Content */) {\n            return r;\n        }\n        // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n        return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());\n    }\n    static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n        const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n        let range;\n        if (shadowRoot) {\n            if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n                range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n            }\n            else {\n                range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n            }\n        }\n        else {\n            range = document.caretRangeFromPoint(coords.clientX, coords.clientY);\n        }\n        if (!range || !range.startContainer) {\n            return new UnknownHitTestResult();\n        }\n        // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n        const startContainer = range.startContainer;\n        if (startContainer.nodeType === startContainer.TEXT_NODE) {\n            // startContainer is expected to be the token text\n            const parent1 = startContainer.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, parent1, range.startOffset);\n            }\n            else {\n                return new UnknownHitTestResult(startContainer.parentNode);\n            }\n        }\n        else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n            // startContainer is expected to be the token span\n            const parent1 = startContainer.parentNode; // expected to be the view line container span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent2ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, startContainer, startContainer.textContent.length);\n            }\n            else {\n                return new UnknownHitTestResult(startContainer);\n            }\n        }\n        return new UnknownHitTestResult();\n    }\n    /**\n     * Most probably Gecko\n     */\n    static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n        const hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n            // offsetNode is expected to be the token text\n            const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode.parentNode, hitResult.offset);\n            }\n            else {\n                return new UnknownHitTestResult(hitResult.offsetNode.parentNode);\n            }\n        }\n        // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n        // Some other times, it returns the `<span>` with the inline decoration\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n            const parent1 = hitResult.offsetNode.parentNode;\n            const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\n            const parent2 = parent1 ? parent1.parentNode : null;\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent1ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n                const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n                if (tokenSpan) {\n                    return HitTestResult.createFromDOMInfo(ctx, tokenSpan, 0);\n                }\n            }\n            else if (parent2ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` with the inline decoration\n                return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode, 0);\n            }\n        }\n        return new UnknownHitTestResult(hitResult.offsetNode);\n    }\n    static _snapToSoftTabBoundary(position, viewModel) {\n        const lineContent = viewModel.getLineContent(position.lineNumber);\n        const { tabSize } = viewModel.model.getOptions();\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Direction.Nearest */);\n        if (newPosition !== -1) {\n            return new Position(position.lineNumber, newPosition + 1);\n        }\n        return position;\n    }\n    static _doHitTest(ctx, request) {\n        let result = new UnknownHitTestResult();\n        if (typeof document.caretRangeFromPoint === 'function') {\n            result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n        }\n        else if (document.caretPositionFromPoint) {\n            result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());\n        }\n        if (result.type === 1 /* HitTestResultType.Content */) {\n            const injectedText = ctx.viewModel.getInjectedTextAt(result.position);\n            const normalizedPosition = ctx.viewModel.normalizePosition(result.position, 2 /* PositionAffinity.None */);\n            if (injectedText || !normalizedPosition.equals(result.position)) {\n                result = new ContentHitTestResult(normalizedPosition, result.spanNode, injectedText);\n            }\n        }\n        // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n        if (result.type === 1 /* HitTestResultType.Content */ && ctx.stickyTabStops) {\n            result = new ContentHitTestResult(this._snapToSoftTabBoundary(result.position, ctx.viewModel), result.spanNode, result.injectedText);\n        }\n        return result;\n    }\n}\nexport function shadowCaretRangeFromPoint(shadowRoot, x, y) {\n    const range = document.createRange();\n    // Get the element under the point\n    let el = shadowRoot.elementFromPoint(x, y);\n    if (el !== null) {\n        // Get the last child of the element until its firstChild is a text node\n        // This assumes that the pointer is on the right of the line, out of the tokens\n        // and that we want to get the offset of the last token of the line\n        while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n            el = el.lastChild;\n        }\n        // Grab its rect\n        const rect = el.getBoundingClientRect();\n        // And its font\n        const font = window.getComputedStyle(el, null).getPropertyValue('font');\n        // And also its txt content\n        const text = el.innerText;\n        // Position the pixel cursor at the left of the element\n        let pixelCursor = rect.left;\n        let offset = 0;\n        let step;\n        // If the point is on the right of the box put the cursor after the last character\n        if (x > rect.left + rect.width) {\n            offset = text.length;\n        }\n        else {\n            const charWidthReader = CharWidthReader.getInstance();\n            // Goes through all the characters of the innerText, and checks if the x of the point\n            // belongs to the character.\n            for (let i = 0; i < text.length + 1; i++) {\n                // The step is half the width of the character\n                step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\n                // Move to the center of the character\n                pixelCursor += step;\n                // If the x of the point is smaller that the position of the cursor, the point is over that character\n                if (x < pixelCursor) {\n                    offset = i;\n                    break;\n                }\n                // Move between the current character and the next\n                pixelCursor += step;\n            }\n        }\n        // Creates a range with the text node of the element and set the offset found\n        range.setStart(el.firstChild, offset);\n        range.setEnd(el.firstChild, offset);\n    }\n    return range;\n}\nclass CharWidthReader {\n    constructor() {\n        this._cache = {};\n        this._canvas = document.createElement('canvas');\n    }\n    static getInstance() {\n        if (!CharWidthReader._INSTANCE) {\n            CharWidthReader._INSTANCE = new CharWidthReader();\n        }\n        return CharWidthReader._INSTANCE;\n    }\n    getCharWidth(char, font) {\n        const cacheKey = char + font;\n        if (this._cache[cacheKey]) {\n            return this._cache[cacheKey];\n        }\n        const context = this._canvas.getContext('2d');\n        context.font = font;\n        const metrics = context.measureText(char);\n        const width = metrics.width;\n        this._cache[cacheKey] = width;\n        return width;\n    }\n}\nCharWidthReader._INSTANCE = null;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nexport const _debugComposition = false;\nexport class TextAreaState {\n    constructor(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\n        this.value = value;\n        this.selectionStart = selectionStart;\n        this.selectionEnd = selectionEnd;\n        this.selectionStartPosition = selectionStartPosition;\n        this.selectionEndPosition = selectionEndPosition;\n    }\n    toString() {\n        return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;\n    }\n    static readFromTextArea(textArea) {\n        return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\n    }\n    collapseSelection() {\n        return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\n    }\n    writeToTextArea(reason, textArea, select) {\n        if (_debugComposition) {\n            console.log(`writeToTextArea ${reason}: ${this.toString()}`);\n        }\n        textArea.setValue(reason, this.value);\n        if (select) {\n            textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n        }\n    }\n    deduceEditorPosition(offset) {\n        if (offset <= this.selectionStart) {\n            const str = this.value.substring(offset, this.selectionStart);\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\n        }\n        if (offset >= this.selectionEnd) {\n            const str = this.value.substring(this.selectionEnd, offset);\n            return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\n        }\n        const str1 = this.value.substring(this.selectionStart, offset);\n        if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\n        }\n        const str2 = this.value.substring(offset, this.selectionEnd);\n        return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\n    }\n    _finishDeduceEditorPosition(anchor, deltaText, signum) {\n        let lineFeedCnt = 0;\n        let lastLineFeedIndex = -1;\n        while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n            lineFeedCnt++;\n        }\n        return [anchor, signum * deltaText.length, lineFeedCnt];\n    }\n    static deduceInput(previousState, currentState, couldBeEmojiInput) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceInput');\n            console.log(`PREVIOUS STATE: ${previousState.toString()}`);\n            console.log(`CURRENT STATE: ${currentState.toString()}`);\n        }\n        const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionStart, currentState.selectionStart);\n        const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd, currentState.value.length - currentState.selectionEnd);\n        const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n        const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n        const previousSelectionStart = previousState.selectionStart - prefixLength;\n        const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n        const currentSelectionStart = currentState.selectionStart - prefixLength;\n        const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n        if (_debugComposition) {\n            console.log(`AFTER DIFFING PREVIOUS STATE: <${previousValue}>, selectionStart: ${previousSelectionStart}, selectionEnd: ${previousSelectionEnd}`);\n            console.log(`AFTER DIFFING CURRENT STATE: <${currentValue}>, selectionStart: ${currentSelectionStart}, selectionEnd: ${currentSelectionEnd}`);\n        }\n        if (currentSelectionStart === currentSelectionEnd) {\n            // no current selection\n            const replacePreviousCharacters = (previousState.selectionStart - prefixLength);\n            if (_debugComposition) {\n                console.log(`REMOVE PREVIOUS: ${replacePreviousCharacters} chars`);\n            }\n            return {\n                text: currentValue,\n                replacePrevCharCnt: replacePreviousCharacters,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        // there is a current selection => composition case\n        const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n        return {\n            text: currentValue,\n            replacePrevCharCnt: replacePreviousCharacters,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n    }\n    static deduceAndroidCompositionInput(previousState, currentState) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceAndroidCompositionInput');\n            console.log(`PREVIOUS STATE: ${previousState.toString()}`);\n            console.log(`CURRENT STATE: ${currentState.toString()}`);\n        }\n        if (previousState.value === currentState.value) {\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: currentState.selectionEnd - previousState.selectionEnd\n            };\n        }\n        const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionEnd);\n        const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd);\n        const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n        const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n        const previousSelectionStart = previousState.selectionStart - prefixLength;\n        const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n        const currentSelectionStart = currentState.selectionStart - prefixLength;\n        const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n        if (_debugComposition) {\n            console.log(`AFTER DIFFING PREVIOUS STATE: <${previousValue}>, selectionStart: ${previousSelectionStart}, selectionEnd: ${previousSelectionEnd}`);\n            console.log(`AFTER DIFFING CURRENT STATE: <${currentValue}>, selectionStart: ${currentSelectionStart}, selectionEnd: ${currentSelectionEnd}`);\n        }\n        return {\n            text: currentValue,\n            replacePrevCharCnt: previousSelectionEnd,\n            replaceNextCharCnt: previousValue.length - previousSelectionEnd,\n            positionDelta: currentSelectionEnd - currentValue.length\n        };\n    }\n}\nTextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\nexport class PagedScreenReaderStrategy {\n    static _getPageOfLine(lineNumber, linesPerPage) {\n        return Math.floor((lineNumber - 1) / linesPerPage);\n    }\n    static _getRangeForPage(page, linesPerPage) {\n        const offset = page * linesPerPage;\n        const startLineNumber = offset + 1;\n        const endLineNumber = offset + linesPerPage;\n        return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n    }\n    static fromEditorSelection(previousState, model, selection, linesPerPage, trimLongText) {\n        const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n        const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n        const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n        const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n        const pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n        let pretext = model.getValueInRange(pretextRange, 1 /* EndOfLinePreference.LF */);\n        const lastLine = model.getLineCount();\n        const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n        const posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n        let posttext = model.getValueInRange(posttextRange, 1 /* EndOfLinePreference.LF */);\n        let text;\n        if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n            // take full selection\n            text = model.getValueInRange(selection, 1 /* EndOfLinePreference.LF */);\n        }\n        else {\n            const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n            const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n            text = (model.getValueInRange(selectionRange1, 1 /* EndOfLinePreference.LF */)\n                + String.fromCharCode(8230)\n                + model.getValueInRange(selectionRange2, 1 /* EndOfLinePreference.LF */));\n        }\n        // Chromium handles very poorly text even of a few thousand chars\n        // Cut text to avoid stalling the entire UI\n        if (trimLongText) {\n            const LIMIT_CHARS = 500;\n            if (pretext.length > LIMIT_CHARS) {\n                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\n            }\n            if (posttext.length > LIMIT_CHARS) {\n                posttext = posttext.substring(0, LIMIT_CHARS);\n            }\n            if (text.length > 2 * LIMIT_CHARS) {\n                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n            }\n        }\n        return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n    TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n    forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n    constructor() {\n        this._lastState = null;\n    }\n    set(lastCopiedValue, data) {\n        this._lastState = { lastCopiedValue, data };\n    }\n    get(pastedText) {\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n            // match!\n            return this._lastState.data;\n        }\n        this._lastState = null;\n        return null;\n    }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\nclass CompositionContext {\n    constructor() {\n        this._lastTypeTextLength = 0;\n    }\n    handleCompositionUpdate(text) {\n        text = text || '';\n        const typeInput = {\n            text: text,\n            replacePrevCharCnt: this._lastTypeTextLength,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n        this._lastTypeTextLength = text.length;\n        return typeInput;\n    }\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nexport class TextAreaInput extends Disposable {\n    constructor(_host, _textArea, _OS, _browser) {\n        super();\n        this._host = _host;\n        this._textArea = _textArea;\n        this._OS = _OS;\n        this._browser = _browser;\n        this._onFocus = this._register(new Emitter());\n        this.onFocus = this._onFocus.event;\n        this._onBlur = this._register(new Emitter());\n        this.onBlur = this._onBlur.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onKeyUp = this._register(new Emitter());\n        this.onKeyUp = this._onKeyUp.event;\n        this._onCut = this._register(new Emitter());\n        this.onCut = this._onCut.event;\n        this._onPaste = this._register(new Emitter());\n        this.onPaste = this._onPaste.event;\n        this._onType = this._register(new Emitter());\n        this.onType = this._onType.event;\n        this._onCompositionStart = this._register(new Emitter());\n        this.onCompositionStart = this._onCompositionStart.event;\n        this._onCompositionUpdate = this._register(new Emitter());\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\n        this._onCompositionEnd = this._register(new Emitter());\n        this.onCompositionEnd = this._onCompositionEnd.event;\n        this._onSelectionChangeRequest = this._register(new Emitter());\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n        this._textAreaState = TextAreaState.EMPTY;\n        this._selectionChangeListener = null;\n        this.writeScreenReaderContent('ctor');\n        this._hasFocus = false;\n        this._currentComposition = null;\n        let lastKeyDown = null;\n        this._register(this._textArea.onKeyDown((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            if (e.keyCode === 109 /* KeyCode.KEY_IN_COMPOSITION */\n                || (this._currentComposition && e.keyCode === 1 /* KeyCode.Backspace */)) {\n                // Stop propagation for keyDown events if the IME is processing key input\n                e.stopPropagation();\n            }\n            if (e.equals(9 /* KeyCode.Escape */)) {\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n                e.preventDefault();\n            }\n            lastKeyDown = e;\n            this._onKeyDown.fire(e);\n        }));\n        this._register(this._textArea.onKeyUp((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            this._onKeyUp.fire(e);\n        }));\n        this._register(this._textArea.onCompositionStart((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionstart]`, e);\n            }\n            const currentComposition = new CompositionContext();\n            if (this._currentComposition) {\n                // simply reset the composition context\n                this._currentComposition = currentComposition;\n                return;\n            }\n            this._currentComposition = currentComposition;\n            if (this._OS === 2 /* OperatingSystem.Macintosh */\n                && lastKeyDown\n                && lastKeyDown.equals(109 /* KeyCode.KEY_IN_COMPOSITION */)\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\n                && this._textAreaState.selectionStart > 0\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data\n                && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n                // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n                if (_debugComposition) {\n                    console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n                }\n                // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n                currentComposition.handleCompositionUpdate('x');\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // when tapping on the editor, Android enters composition mode to edit the current word\n                // so we cannot clear the textarea on Android and we must pretend the current word was selected\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            this._onCompositionStart.fire({ data: e.data });\n        }));\n        this._register(this._textArea.onCompositionUpdate((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionupdate]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionUpdate.fire(e);\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n            this._onType.fire(typeInput);\n            this._onCompositionUpdate.fire(e);\n        }));\n        this._register(this._textArea.onCompositionEnd((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionend]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // https://github.com/microsoft/monaco-editor/issues/1663\n                // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n                return;\n            }\n            this._currentComposition = null;\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionEnd.fire();\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n            this._onType.fire(typeInput);\n            this._onCompositionEnd.fire();\n        }));\n        this._register(this._textArea.onInput((e) => {\n            if (_debugComposition) {\n                console.log(`[input]`, e);\n            }\n            // Pretend here we touched the text area, as the `input` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\n            if (this._currentComposition) {\n                return;\n            }\n            const newState = TextAreaState.readFromTextArea(this._textArea);\n            const typeInput = TextAreaState.deduceInput(this._textAreaState, newState, /*couldBeEmojiInput*/ this._OS === 2 /* OperatingSystem.Macintosh */);\n            if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n                // Ignore invalid input but keep it around for next time\n                return;\n            }\n            this._textAreaState = newState;\n            if (typeInput.text !== ''\n                || typeInput.replacePrevCharCnt !== 0\n                || typeInput.replaceNextCharCnt !== 0\n                || typeInput.positionDelta !== 0) {\n                this._onType.fire(typeInput);\n            }\n        }));\n        // --- Clipboard operations\n        this._register(this._textArea.onCut((e) => {\n            // Pretend here we touched the text area, as the `cut` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\n            this._ensureClipboardGetsEditorSelection(e);\n            this._asyncTriggerCut.schedule();\n        }));\n        this._register(this._textArea.onCopy((e) => {\n            this._ensureClipboardGetsEditorSelection(e);\n        }));\n        this._register(this._textArea.onPaste((e) => {\n            // Pretend here we touched the text area, as the `paste` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\n            e.preventDefault();\n            if (!e.clipboardData) {\n                return;\n            }\n            let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n            if (!text) {\n                return;\n            }\n            // try the in-memory store\n            metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n            this._onPaste.fire({\n                text: text,\n                metadata: metadata\n            });\n        }));\n        this._register(this._textArea.onFocus(() => {\n            const hadFocus = this._hasFocus;\n            this._setHasFocus(true);\n            if (this._browser.isSafari && !hadFocus && this._hasFocus) {\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n                // Safari will always move the selection at offset 0 in the textarea\n                this._asyncFocusGainWriteScreenReaderContent.schedule();\n            }\n        }));\n        this._register(this._textArea.onBlur(() => {\n            if (this._currentComposition) {\n                // See https://github.com/microsoft/vscode/issues/112621\n                // where compositionend is not triggered when the editor\n                // is taken off-dom during a composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('blurWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n            this._setHasFocus(false);\n        }));\n        this._register(this._textArea.onSyntheticTap(() => {\n            if (this._browser.isAndroid && this._currentComposition) {\n                // on Android, tapping does not cancel the current composition, so the\n                // textarea is stuck showing the old composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('tapWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n        }));\n    }\n    _installSelectionChangeListener() {\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n        // When using a Braille display, it is possible for users to reposition the\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\n        //\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n        // using a Braille display from all the other cases.\n        //\n        // The problems with the `selectionchange` event are:\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n        //  * the event is emitted when tabbing into the textarea\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n        //  * the event sometimes comes in bursts for a single logical textarea operation\n        // `selectionchange` events often come multiple times for a single logical change\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\n        let previousSelectionChangeEventTime = 0;\n        return dom.addDisposableListener(document, 'selectionchange', (e) => {\n            if (!this._hasFocus) {\n                return;\n            }\n            if (this._currentComposition) {\n                return;\n            }\n            if (!this._browser.isChrome) {\n                // Support only for Chrome until testing happens on other browsers\n                return;\n            }\n            const now = Date.now();\n            const delta1 = now - previousSelectionChangeEventTime;\n            previousSelectionChangeEventTime = now;\n            if (delta1 < 5) {\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n                // => ignore it\n                return;\n            }\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n            this._textArea.resetSelectionChangeTime();\n            if (delta2 < 100) {\n                // received a `selectionchange` event within 100ms since we touched the textarea\n                // => ignore it, since we caused it\n                return;\n            }\n            if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newValue = this._textArea.getValue();\n            if (this._textAreaState.value !== newValue) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newSelectionStart = this._textArea.getSelectionStart();\n            const newSelectionEnd = this._textArea.getSelectionEnd();\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n                // Nothing to do...\n                return;\n            }\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n            this._onSelectionChangeRequest.fire(newSelection);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n    }\n    focusTextArea() {\n        // Setting this._hasFocus and writing the screen reader content\n        // will result in a focus() and setSelectionRange() in the textarea\n        this._setHasFocus(true);\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n        this.refreshFocusState();\n    }\n    isFocused() {\n        return this._hasFocus;\n    }\n    refreshFocusState() {\n        this._setHasFocus(this._textArea.hasFocus());\n    }\n    _setHasFocus(newHasFocus) {\n        if (this._hasFocus === newHasFocus) {\n            // no change\n            return;\n        }\n        this._hasFocus = newHasFocus;\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n        if (this._hasFocus) {\n            this._selectionChangeListener = this._installSelectionChangeListener();\n        }\n        if (this._hasFocus) {\n            this.writeScreenReaderContent('focusgain');\n        }\n        if (this._hasFocus) {\n            this._onFocus.fire();\n        }\n        else {\n            this._onBlur.fire();\n        }\n    }\n    _setAndWriteTextAreaState(reason, textAreaState) {\n        if (!this._hasFocus) {\n            textAreaState = textAreaState.collapseSelection();\n        }\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n        this._textAreaState = textAreaState;\n    }\n    writeScreenReaderContent(reason) {\n        if (this._currentComposition) {\n            // Do not write to the text area when doing composition\n            return;\n        }\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n    }\n    _ensureClipboardGetsEditorSelection(e) {\n        const dataToCopy = this._host.getDataToCopy();\n        const storedMetadata = {\n            version: 1,\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\n            multicursorText: dataToCopy.multicursorText,\n            mode: dataToCopy.mode\n        };\n        InMemoryClipboardMetadataManager.INSTANCE.set(\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\n        (this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\n        e.preventDefault();\n        if (e.clipboardData) {\n            ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n        }\n    }\n}\nclass ClipboardEventUtils {\n    static getTextData(clipboardData) {\n        const text = clipboardData.getData(Mimes.text);\n        let metadata = null;\n        const rawmetadata = clipboardData.getData('vscode-editor-data');\n        if (typeof rawmetadata === 'string') {\n            try {\n                metadata = JSON.parse(rawmetadata);\n                if (metadata.version !== 1) {\n                    metadata = null;\n                }\n            }\n            catch (err) {\n                // no problem!\n            }\n        }\n        if (text.length === 0 && metadata === null && clipboardData.files.length > 0) {\n            // no textual data pasted, generate text from file names\n            const files = Array.prototype.slice.call(clipboardData.files, 0);\n            return [files.map(file => file.name).join('\\n'), null];\n        }\n        return [text, metadata];\n    }\n    static setTextData(clipboardData, text, html, metadata) {\n        clipboardData.setData(Mimes.text, text);\n        if (typeof html === 'string') {\n            clipboardData.setData('text/html', html);\n        }\n        clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n    }\n}\nexport class TextAreaWrapper extends Disposable {\n    constructor(_actual) {\n        super();\n        this._actual = _actual;\n        this.onKeyDown = this._register(dom.createEventEmitter(this._actual, 'keydown')).event;\n        this.onKeyUp = this._register(dom.createEventEmitter(this._actual, 'keyup')).event;\n        this.onCompositionStart = this._register(dom.createEventEmitter(this._actual, 'compositionstart')).event;\n        this.onCompositionUpdate = this._register(dom.createEventEmitter(this._actual, 'compositionupdate')).event;\n        this.onCompositionEnd = this._register(dom.createEventEmitter(this._actual, 'compositionend')).event;\n        this.onInput = this._register(dom.createEventEmitter(this._actual, 'input')).event;\n        this.onCut = this._register(dom.createEventEmitter(this._actual, 'cut')).event;\n        this.onCopy = this._register(dom.createEventEmitter(this._actual, 'copy')).event;\n        this.onPaste = this._register(dom.createEventEmitter(this._actual, 'paste')).event;\n        this.onFocus = this._register(dom.createEventEmitter(this._actual, 'focus')).event;\n        this.onBlur = this._register(dom.createEventEmitter(this._actual, 'blur')).event;\n        this._onSyntheticTap = this._register(new Emitter());\n        this.onSyntheticTap = this._onSyntheticTap.event;\n        this._ignoreSelectionChangeTime = 0;\n        this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n    }\n    hasFocus() {\n        const shadowRoot = dom.getShadowRoot(this._actual);\n        if (shadowRoot) {\n            return shadowRoot.activeElement === this._actual;\n        }\n        else if (dom.isInDOM(this._actual)) {\n            return document.activeElement === this._actual;\n        }\n        else {\n            return false;\n        }\n    }\n    setIgnoreSelectionChangeTime(reason) {\n        this._ignoreSelectionChangeTime = Date.now();\n    }\n    getIgnoreSelectionChangeTime() {\n        return this._ignoreSelectionChangeTime;\n    }\n    resetSelectionChangeTime() {\n        this._ignoreSelectionChangeTime = 0;\n    }\n    getValue() {\n        // console.log('current value: ' + this._textArea.value);\n        return this._actual.value;\n    }\n    setValue(reason, value) {\n        const textArea = this._actual;\n        if (textArea.value === value) {\n            // No change\n            return;\n        }\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n        this.setIgnoreSelectionChangeTime('setValue');\n        textArea.value = value;\n    }\n    getSelectionStart() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n    }\n    getSelectionEnd() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n    }\n    setSelectionRange(reason, selectionStart, selectionEnd) {\n        const textArea = this._actual;\n        let activeElement = null;\n        const shadowRoot = dom.getShadowRoot(textArea);\n        if (shadowRoot) {\n            activeElement = shadowRoot.activeElement;\n        }\n        else {\n            activeElement = document.activeElement;\n        }\n        const currentIsFocused = (activeElement === textArea);\n        const currentSelectionStart = textArea.selectionStart;\n        const currentSelectionEnd = textArea.selectionEnd;\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n            // No change\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n        if (currentIsFocused) {\n            // No need to focus, only need to change the selection range\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n        // Here, we try to undo the browser's desperate reveal.\n        try {\n            const scrollState = dom.saveParentsScrollTop(textArea);\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.focus();\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            dom.restoreParentsScrollTop(textArea, scrollState);\n        }\n        catch (e) {\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './textAreaHandler.css';\nimport * as nls from '../../../nls.js';\nimport * as browser from '../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { CopyOptions, TextAreaInput, TextAreaWrapper } from './textAreaInput.js';\nimport { PagedScreenReaderStrategy, TextAreaState, _debugComposition } from './textAreaState.js';\nimport { PartFingerprints, ViewPart } from '../view/viewPart.js';\nimport { LineNumbersOverlay } from '../viewParts/lineNumbers/lineNumbers.js';\nimport { Margin } from '../viewParts/margin/margin.js';\nimport { EditorOptions } from '../../common/config/editorOptions.js';\nimport { getMapForWordSeparators } from '../../common/core/wordCharacterClassifier.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { TokenizationRegistry } from '../../common/languages.js';\nimport { Color } from '../../../base/common/color.js';\nclass VisibleTextAreaData {\n    constructor(_context, modelLineNumber, distanceToModelLineStart, widthOfHiddenLineTextBefore, distanceToModelLineEnd) {\n        this._context = _context;\n        this.modelLineNumber = modelLineNumber;\n        this.distanceToModelLineStart = distanceToModelLineStart;\n        this.widthOfHiddenLineTextBefore = widthOfHiddenLineTextBefore;\n        this.distanceToModelLineEnd = distanceToModelLineEnd;\n        this._visibleTextAreaBrand = undefined;\n        this.startPosition = null;\n        this.endPosition = null;\n        this.visibleTextareaStart = null;\n        this.visibleTextareaEnd = null;\n        /**\n         * When doing composition, the currently composed text might be split up into\n         * multiple tokens, then merged again into a single token, etc. Here we attempt\n         * to keep the presentation of the <textarea> stable by using the previous used\n         * style if multiple tokens come into play. This avoids flickering.\n         */\n        this._previousPresentation = null;\n    }\n    prepareRender(visibleRangeProvider) {\n        const startModelPosition = new Position(this.modelLineNumber, this.distanceToModelLineStart + 1);\n        const endModelPosition = new Position(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);\n        this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(startModelPosition);\n        this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(endModelPosition);\n        if (this.startPosition.lineNumber === this.endPosition.lineNumber) {\n            this.visibleTextareaStart = visibleRangeProvider.visibleRangeForPosition(this.startPosition);\n            this.visibleTextareaEnd = visibleRangeProvider.visibleRangeForPosition(this.endPosition);\n        }\n        else {\n            // TODO: what if the view positions are not on the same line?\n            this.visibleTextareaStart = null;\n            this.visibleTextareaEnd = null;\n        }\n    }\n    definePresentation(tokenPresentation) {\n        if (!this._previousPresentation) {\n            // To avoid flickering, once set, always reuse a presentation throughout the entire IME session\n            if (tokenPresentation) {\n                this._previousPresentation = tokenPresentation;\n            }\n            else {\n                this._previousPresentation = {\n                    foreground: 1 /* ColorId.DefaultForeground */,\n                    italic: false,\n                    bold: false,\n                    underline: false,\n                    strikethrough: false,\n                };\n            }\n        }\n        return this._previousPresentation;\n    }\n}\nconst canUseZeroSizeTextarea = (browser.isFirefox);\nexport class TextAreaHandler extends ViewPart {\n    constructor(context, viewController, visibleRangeProvider) {\n        super(context);\n        // --- end view API\n        this._primaryCursorPosition = new Position(1, 1);\n        this._primaryCursorVisibleRange = null;\n        this._viewController = viewController;\n        this._visibleRangeProvider = visibleRangeProvider;\n        this._scrollLeft = 0;\n        this._scrollTop = 0;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        this._setAccessibilityOptions(options);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentHeight = layoutInfo.height;\n        this._fontInfo = options.get(46 /* EditorOption.fontInfo */);\n        this._lineHeight = options.get(61 /* EditorOption.lineHeight */);\n        this._emptySelectionClipboard = options.get(33 /* EditorOption.emptySelectionClipboard */);\n        this._copyWithSyntaxHighlighting = options.get(21 /* EditorOption.copyWithSyntaxHighlighting */);\n        this._visibleTextArea = null;\n        this._selections = [new Selection(1, 1, 1, 1)];\n        this._modelSelections = [new Selection(1, 1, 1, 1)];\n        this._lastRenderPosition = null;\n        // Text Area (The focus will always be in the textarea when the cursor is blinking)\n        this.textArea = createFastDomNode(document.createElement('textarea'));\n        PartFingerprints.write(this.textArea, 6 /* PartFingerprint.TextArea */);\n        this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n        this.textArea.setAttribute('wrap', 'off');\n        this.textArea.setAttribute('autocorrect', 'off');\n        this.textArea.setAttribute('autocapitalize', 'off');\n        this.textArea.setAttribute('autocomplete', 'off');\n        this.textArea.setAttribute('spellcheck', 'false');\n        this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n        this.textArea.setAttribute('tabindex', String(options.get(114 /* EditorOption.tabIndex */)));\n        this.textArea.setAttribute('role', 'textbox');\n        this.textArea.setAttribute('aria-roledescription', nls.localize('editor', \"editor\"));\n        this.textArea.setAttribute('aria-multiline', 'true');\n        this.textArea.setAttribute('aria-haspopup', 'false');\n        this.textArea.setAttribute('aria-autocomplete', 'both');\n        if (options.get(30 /* EditorOption.domReadOnly */) && options.get(83 /* EditorOption.readOnly */)) {\n            this.textArea.setAttribute('readonly', 'true');\n        }\n        this.textAreaCover = createFastDomNode(document.createElement('div'));\n        this.textAreaCover.setPosition('absolute');\n        const simpleModel = {\n            getLineCount: () => {\n                return this._context.viewModel.getLineCount();\n            },\n            getLineMaxColumn: (lineNumber) => {\n                return this._context.viewModel.getLineMaxColumn(lineNumber);\n            },\n            getValueInRange: (range, eol) => {\n                return this._context.viewModel.getValueInRange(range, eol);\n            }\n        };\n        const textAreaInputHost = {\n            getDataToCopy: () => {\n                const rawTextToCopy = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, platform.isWindows);\n                const newLineCharacter = this._context.viewModel.model.getEOL();\n                const isFromEmptySelection = (this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty());\n                const multicursorText = (Array.isArray(rawTextToCopy) ? rawTextToCopy : null);\n                const text = (Array.isArray(rawTextToCopy) ? rawTextToCopy.join(newLineCharacter) : rawTextToCopy);\n                let html = undefined;\n                let mode = null;\n                if (CopyOptions.forceCopyWithSyntaxHighlighting || (this._copyWithSyntaxHighlighting && text.length < 65536)) {\n                    const richText = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);\n                    if (richText) {\n                        html = richText.html;\n                        mode = richText.mode;\n                    }\n                }\n                return {\n                    isFromEmptySelection,\n                    multicursorText,\n                    text,\n                    html,\n                    mode\n                };\n            },\n            getScreenReaderContent: (currentState) => {\n                if (this._accessibilitySupport === 1 /* AccessibilitySupport.Disabled */) {\n                    // We know for a fact that a screen reader is not attached\n                    // On OSX, we write the character before the cursor to allow for \"long-press\" composition\n                    // Also on OSX, we write the word before the cursor to allow for the Accessibility Keyboard to give good hints\n                    const selection = this._selections[0];\n                    if (platform.isMacintosh && selection.isEmpty()) {\n                        const position = selection.getStartPosition();\n                        let textBefore = this._getWordBeforePosition(position);\n                        if (textBefore.length === 0) {\n                            textBefore = this._getCharacterBeforePosition(position);\n                        }\n                        if (textBefore.length > 0) {\n                            return new TextAreaState(textBefore, textBefore.length, textBefore.length, position, position);\n                        }\n                    }\n                    // on Safari, document.execCommand('cut') and document.execCommand('copy') will just not work\n                    // if the textarea has no content selected. So if there is an editor selection, ensure something\n                    // is selected in the textarea.\n                    if (browser.isSafari && !selection.isEmpty()) {\n                        const placeholderText = 'vscode-placeholder';\n                        return new TextAreaState(placeholderText, 0, placeholderText.length, null, null);\n                    }\n                    return TextAreaState.EMPTY;\n                }\n                if (browser.isAndroid) {\n                    // when tapping in the editor on a word, Android enters composition mode.\n                    // in the `compositionstart` event we cannot clear the textarea, because\n                    // it then forgets to ever send a `compositionend`.\n                    // we therefore only write the current word in the textarea\n                    const selection = this._selections[0];\n                    if (selection.isEmpty()) {\n                        const position = selection.getStartPosition();\n                        const [wordAtPosition, positionOffsetInWord] = this._getAndroidWordAtPosition(position);\n                        if (wordAtPosition.length > 0) {\n                            return new TextAreaState(wordAtPosition, positionOffsetInWord, positionOffsetInWord, position, position);\n                        }\n                    }\n                    return TextAreaState.EMPTY;\n                }\n                return PagedScreenReaderStrategy.fromEditorSelection(currentState, simpleModel, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0 /* AccessibilitySupport.Unknown */);\n            },\n            deduceModelPosition: (viewAnchorPosition, deltaOffset, lineFeedCnt) => {\n                return this._context.viewModel.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt);\n            }\n        };\n        const textAreaWrapper = this._register(new TextAreaWrapper(this.textArea.domNode));\n        this._textAreaInput = this._register(new TextAreaInput(textAreaInputHost, textAreaWrapper, platform.OS, browser));\n        this._register(this._textAreaInput.onKeyDown((e) => {\n            this._viewController.emitKeyDown(e);\n        }));\n        this._register(this._textAreaInput.onKeyUp((e) => {\n            this._viewController.emitKeyUp(e);\n        }));\n        this._register(this._textAreaInput.onPaste((e) => {\n            let pasteOnNewLine = false;\n            let multicursorText = null;\n            let mode = null;\n            if (e.metadata) {\n                pasteOnNewLine = (this._emptySelectionClipboard && !!e.metadata.isFromEmptySelection);\n                multicursorText = (typeof e.metadata.multicursorText !== 'undefined' ? e.metadata.multicursorText : null);\n                mode = e.metadata.mode;\n            }\n            this._viewController.paste(e.text, pasteOnNewLine, multicursorText, mode);\n        }));\n        this._register(this._textAreaInput.onCut(() => {\n            this._viewController.cut();\n        }));\n        this._register(this._textAreaInput.onType((e) => {\n            if (e.replacePrevCharCnt || e.replaceNextCharCnt || e.positionDelta) {\n                // must be handled through the new command\n                if (_debugComposition) {\n                    console.log(` => compositionType: <<${e.text}>>, ${e.replacePrevCharCnt}, ${e.replaceNextCharCnt}, ${e.positionDelta}`);\n                }\n                this._viewController.compositionType(e.text, e.replacePrevCharCnt, e.replaceNextCharCnt, e.positionDelta);\n            }\n            else {\n                if (_debugComposition) {\n                    console.log(` => type: <<${e.text}>>`);\n                }\n                this._viewController.type(e.text);\n            }\n        }));\n        this._register(this._textAreaInput.onSelectionChangeRequest((modelSelection) => {\n            this._viewController.setSelection(modelSelection);\n        }));\n        this._register(this._textAreaInput.onCompositionStart((e) => {\n            // The textarea might contain some content when composition starts.\n            //\n            // When we make the textarea visible, it always has a height of 1 line,\n            // so we don't need to worry too much about content on lines above or below\n            // the selection.\n            //\n            // However, the text on the current line needs to be made visible because\n            // some IME methods allow to move to other glyphs on the current line\n            // (by pressing arrow keys).\n            //\n            // (1) The textarea might contain only some parts of the current line,\n            // like the word before the selection. Also, the content inside the textarea\n            // can grow or shrink as composition occurs. We therefore anchor the textarea\n            // in terms of distance to a certain line start and line end.\n            //\n            // (2) Also, we should not make \\t characters visible, because their rendering\n            // inside the <textarea> will not align nicely with our rendering. We therefore\n            // will hide (if necessary) some of the leading text on the current line.\n            const ta = this.textArea.domNode;\n            const modelSelection = this._modelSelections[0];\n            const { distanceToModelLineStart, widthOfHiddenTextBefore } = (() => {\n                // Find the text that is on the current line before the selection\n                const textBeforeSelection = ta.value.substring(0, Math.min(ta.selectionStart, ta.selectionEnd));\n                const lineFeedOffset1 = textBeforeSelection.lastIndexOf('\\n');\n                const lineTextBeforeSelection = textBeforeSelection.substring(lineFeedOffset1 + 1);\n                // We now search to see if we should hide some part of it (if it contains \\t)\n                const tabOffset1 = lineTextBeforeSelection.lastIndexOf('\\t');\n                const desiredVisibleBeforeCharCount = lineTextBeforeSelection.length - tabOffset1 - 1;\n                const startModelPosition = modelSelection.getStartPosition();\n                const visibleBeforeCharCount = Math.min(startModelPosition.column - 1, desiredVisibleBeforeCharCount);\n                const distanceToModelLineStart = startModelPosition.column - 1 - visibleBeforeCharCount;\n                const hiddenLineTextBefore = lineTextBeforeSelection.substring(0, lineTextBeforeSelection.length - visibleBeforeCharCount);\n                const widthOfHiddenTextBefore = measureText(hiddenLineTextBefore, this._fontInfo);\n                return { distanceToModelLineStart, widthOfHiddenTextBefore };\n            })();\n            const { distanceToModelLineEnd } = (() => {\n                // Find the text that is on the current line after the selection\n                const textAfterSelection = ta.value.substring(Math.max(ta.selectionStart, ta.selectionEnd));\n                const lineFeedOffset2 = textAfterSelection.indexOf('\\n');\n                const lineTextAfterSelection = lineFeedOffset2 === -1 ? textAfterSelection : textAfterSelection.substring(0, lineFeedOffset2);\n                const tabOffset2 = lineTextAfterSelection.indexOf('\\t');\n                const desiredVisibleAfterCharCount = (tabOffset2 === -1 ? lineTextAfterSelection.length : lineTextAfterSelection.length - tabOffset2 - 1);\n                const endModelPosition = modelSelection.getEndPosition();\n                const visibleAfterCharCount = Math.min(this._context.viewModel.model.getLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column, desiredVisibleAfterCharCount);\n                const distanceToModelLineEnd = this._context.viewModel.model.getLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column - visibleAfterCharCount;\n                return { distanceToModelLineEnd };\n            })();\n            // Scroll to reveal the location in the editor where composition occurs\n            this._context.viewModel.revealRange('keyboard', true, Range.fromPositions(this._selections[0].getStartPosition()), 0 /* viewEvents.VerticalRevealType.Simple */, 1 /* ScrollType.Immediate */);\n            this._visibleTextArea = new VisibleTextAreaData(this._context, modelSelection.startLineNumber, distanceToModelLineStart, widthOfHiddenTextBefore, distanceToModelLineEnd);\n            this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n            this._render();\n            // Show the textarea\n            this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME} ime-input`);\n            this._viewController.compositionStart();\n            this._context.viewModel.onCompositionStart();\n        }));\n        this._register(this._textAreaInput.onCompositionUpdate((e) => {\n            if (!this._visibleTextArea) {\n                return;\n            }\n            this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n            this._render();\n        }));\n        this._register(this._textAreaInput.onCompositionEnd(() => {\n            this._visibleTextArea = null;\n            this._render();\n            this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n            this._viewController.compositionEnd();\n            this._context.viewModel.onCompositionEnd();\n        }));\n        this._register(this._textAreaInput.onFocus(() => {\n            this._context.viewModel.setHasFocus(true);\n        }));\n        this._register(this._textAreaInput.onBlur(() => {\n            this._context.viewModel.setHasFocus(false);\n        }));\n    }\n    dispose() {\n        super.dispose();\n    }\n    _getAndroidWordAtPosition(position) {\n        const ANDROID_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\",.<>/?';\n        const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n        const wordSeparators = getMapForWordSeparators(ANDROID_WORD_SEPARATORS);\n        let goingLeft = true;\n        let startColumn = position.column;\n        let goingRight = true;\n        let endColumn = position.column;\n        let distance = 0;\n        while (distance < 50 && (goingLeft || goingRight)) {\n            if (goingLeft && startColumn <= 1) {\n                goingLeft = false;\n            }\n            if (goingLeft) {\n                const charCode = lineContent.charCodeAt(startColumn - 2);\n                const charClass = wordSeparators.get(charCode);\n                if (charClass !== 0 /* WordCharacterClass.Regular */) {\n                    goingLeft = false;\n                }\n                else {\n                    startColumn--;\n                }\n            }\n            if (goingRight && endColumn > lineContent.length) {\n                goingRight = false;\n            }\n            if (goingRight) {\n                const charCode = lineContent.charCodeAt(endColumn - 1);\n                const charClass = wordSeparators.get(charCode);\n                if (charClass !== 0 /* WordCharacterClass.Regular */) {\n                    goingRight = false;\n                }\n                else {\n                    endColumn++;\n                }\n            }\n            distance++;\n        }\n        return [lineContent.substring(startColumn - 1, endColumn - 1), position.column - startColumn];\n    }\n    _getWordBeforePosition(position) {\n        const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n        const wordSeparators = getMapForWordSeparators(this._context.configuration.options.get(119 /* EditorOption.wordSeparators */));\n        let column = position.column;\n        let distance = 0;\n        while (column > 1) {\n            const charCode = lineContent.charCodeAt(column - 2);\n            const charClass = wordSeparators.get(charCode);\n            if (charClass !== 0 /* WordCharacterClass.Regular */ || distance > 50) {\n                return lineContent.substring(column - 1, position.column - 1);\n            }\n            distance++;\n            column--;\n        }\n        return lineContent.substring(0, position.column - 1);\n    }\n    _getCharacterBeforePosition(position) {\n        if (position.column > 1) {\n            const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n            const charBefore = lineContent.charAt(position.column - 2);\n            if (!strings.isHighSurrogate(charBefore.charCodeAt(0))) {\n                return charBefore;\n            }\n        }\n        return '';\n    }\n    _getAriaLabel(options) {\n        const accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        if (accessibilitySupport === 1 /* AccessibilitySupport.Disabled */) {\n            return nls.localize('accessibilityOffAriaLabel', \"The editor is not accessible at this time. Press {0} for options.\", platform.isLinux ? 'Shift+Alt+F1' : 'Alt+F1');\n        }\n        return options.get(4 /* EditorOption.ariaLabel */);\n    }\n    _setAccessibilityOptions(options) {\n        this._accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        const accessibilityPageSize = options.get(3 /* EditorOption.accessibilityPageSize */);\n        if (this._accessibilitySupport === 2 /* AccessibilitySupport.Enabled */ && accessibilityPageSize === EditorOptions.accessibilityPageSize.defaultValue) {\n            // If a screen reader is attached and the default value is not set we should automatically increase the page size to 500 for a better experience\n            this._accessibilityPageSize = 500;\n        }\n        else {\n            this._accessibilityPageSize = accessibilityPageSize;\n        }\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        this._setAccessibilityOptions(options);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentHeight = layoutInfo.height;\n        this._fontInfo = options.get(46 /* EditorOption.fontInfo */);\n        this._lineHeight = options.get(61 /* EditorOption.lineHeight */);\n        this._emptySelectionClipboard = options.get(33 /* EditorOption.emptySelectionClipboard */);\n        this._copyWithSyntaxHighlighting = options.get(21 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n        this.textArea.setAttribute('tabindex', String(options.get(114 /* EditorOption.tabIndex */)));\n        if (e.hasChanged(30 /* EditorOption.domReadOnly */) || e.hasChanged(83 /* EditorOption.readOnly */)) {\n            if (options.get(30 /* EditorOption.domReadOnly */) && options.get(83 /* EditorOption.readOnly */)) {\n                this.textArea.setAttribute('readonly', 'true');\n            }\n            else {\n                this.textArea.removeAttribute('readonly');\n            }\n        }\n        if (e.hasChanged(2 /* EditorOption.accessibilitySupport */)) {\n            this._textAreaInput.writeScreenReaderContent('strategy changed');\n        }\n        return true;\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections.slice(0);\n        this._modelSelections = e.modelSelections.slice(0);\n        this._textAreaInput.writeScreenReaderContent('selection changed');\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        this._scrollLeft = e.scrollLeft;\n        this._scrollTop = e.scrollTop;\n        return true;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    // --- begin view API\n    isFocused() {\n        return this._textAreaInput.isFocused();\n    }\n    focusTextArea() {\n        this._textAreaInput.focusTextArea();\n    }\n    getLastRenderData() {\n        return this._lastRenderPosition;\n    }\n    setAriaOptions(options) {\n        if (options.activeDescendant) {\n            this.textArea.setAttribute('aria-haspopup', 'true');\n            this.textArea.setAttribute('aria-autocomplete', 'list');\n            this.textArea.setAttribute('aria-activedescendant', options.activeDescendant);\n        }\n        else {\n            this.textArea.setAttribute('aria-haspopup', 'false');\n            this.textArea.setAttribute('aria-autocomplete', 'both');\n            this.textArea.removeAttribute('aria-activedescendant');\n        }\n        if (options.role) {\n            this.textArea.setAttribute('role', options.role);\n        }\n    }\n    prepareRender(ctx) {\n        var _a;\n        this._primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);\n        this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(this._primaryCursorPosition);\n        (_a = this._visibleTextArea) === null || _a === void 0 ? void 0 : _a.prepareRender(ctx);\n    }\n    render(ctx) {\n        this._textAreaInput.writeScreenReaderContent('render');\n        this._render();\n    }\n    _render() {\n        if (this._visibleTextArea) {\n            // The text area is visible for composition reasons\n            const visibleStart = this._visibleTextArea.visibleTextareaStart;\n            const visibleEnd = this._visibleTextArea.visibleTextareaEnd;\n            const startPosition = this._visibleTextArea.startPosition;\n            const endPosition = this._visibleTextArea.endPosition;\n            if (startPosition && endPosition && visibleStart && visibleEnd && visibleEnd.left >= this._scrollLeft && visibleStart.left <= this._scrollLeft + this._contentWidth) {\n                const top = (this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop);\n                const lineCount = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n                let scrollLeft = this._visibleTextArea.widthOfHiddenLineTextBefore;\n                let left = (this._contentLeft + visibleStart.left - this._scrollLeft);\n                // See https://github.com/microsoft/vscode/issues/141725#issuecomment-1050670841\n                // Here we are adding +1 to avoid flickering that might be caused by having a width that is too small.\n                // This could be caused by rounding errors that might only show up with certain font families.\n                // In other words, a pixel might be lost when doing something like\n                //      `Math.round(end) - Math.round(start)`\n                // vs\n                //      `Math.round(end - start)`\n                let width = visibleEnd.left - visibleStart.left + 1;\n                if (left < this._contentLeft) {\n                    // the textarea would be rendered on top of the margin,\n                    // so reduce its width. We use the same technique as\n                    // for hiding text before\n                    const delta = (this._contentLeft - left);\n                    left += delta;\n                    scrollLeft += delta;\n                    width -= delta;\n                }\n                if (width > this._contentWidth) {\n                    // the textarea would be wider than the content width,\n                    // so reduce its width.\n                    width = this._contentWidth;\n                }\n                // Try to render the textarea with the color/font style to match the text under it\n                const viewLineData = this._context.viewModel.getViewLineData(startPosition.lineNumber);\n                const startTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(startPosition.column - 1);\n                const endTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(endPosition.column - 1);\n                const textareaSpansSingleToken = (startTokenIndex === endTokenIndex);\n                const presentation = this._visibleTextArea.definePresentation((textareaSpansSingleToken ? viewLineData.tokens.getPresentation(startTokenIndex) : null));\n                this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n                this.textArea.domNode.scrollLeft = scrollLeft;\n                this._doRender({\n                    lastRenderPosition: null,\n                    top: top,\n                    left: left,\n                    width: width,\n                    height: this._lineHeight,\n                    useCover: false,\n                    color: (TokenizationRegistry.getColorMap() || [])[presentation.foreground],\n                    italic: presentation.italic,\n                    bold: presentation.bold,\n                    underline: presentation.underline,\n                    strikethrough: presentation.strikethrough\n                });\n            }\n            return;\n        }\n        if (!this._primaryCursorVisibleRange) {\n            // The primary cursor is outside the viewport => place textarea to the top left\n            this._renderAtTopLeft();\n            return;\n        }\n        const left = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;\n        if (left < this._contentLeft || left > this._contentLeft + this._contentWidth) {\n            // cursor is outside the viewport\n            this._renderAtTopLeft();\n            return;\n        }\n        const top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;\n        if (top < 0 || top > this._contentHeight) {\n            // cursor is outside the viewport\n            this._renderAtTopLeft();\n            return;\n        }\n        // The primary cursor is in the viewport (at least vertically) => place textarea on the cursor\n        if (platform.isMacintosh) {\n            // For the popup emoji input, we will make the text area as high as the line height\n            // We will also make the fontSize and lineHeight the correct dimensions to help with the placement of these pickers\n            this._doRender({\n                lastRenderPosition: this._primaryCursorPosition,\n                top: top,\n                left: left,\n                width: (canUseZeroSizeTextarea ? 0 : 1),\n                height: this._lineHeight,\n                useCover: false\n            });\n            // In case the textarea contains a word, we're going to try to align the textarea's cursor\n            // with our cursor by scrolling the textarea as much as possible\n            this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;\n            const lineCount = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n            this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n            return;\n        }\n        this._doRender({\n            lastRenderPosition: this._primaryCursorPosition,\n            top: top,\n            left: left,\n            width: (canUseZeroSizeTextarea ? 0 : 1),\n            height: (canUseZeroSizeTextarea ? 0 : 1),\n            useCover: false\n        });\n    }\n    _newlinecount(text) {\n        let result = 0;\n        let startIndex = -1;\n        do {\n            startIndex = text.indexOf('\\n', startIndex + 1);\n            if (startIndex === -1) {\n                break;\n            }\n            result++;\n        } while (true);\n        return result;\n    }\n    _renderAtTopLeft() {\n        // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)\n        // specifically, when doing Korean IME, setting the textarea to 0x0 breaks IME badly.\n        this._doRender({\n            lastRenderPosition: null,\n            top: 0,\n            left: 0,\n            width: (canUseZeroSizeTextarea ? 0 : 1),\n            height: (canUseZeroSizeTextarea ? 0 : 1),\n            useCover: true\n        });\n    }\n    _doRender(renderData) {\n        this._lastRenderPosition = renderData.lastRenderPosition;\n        const ta = this.textArea;\n        const tac = this.textAreaCover;\n        applyFontInfo(ta, this._fontInfo);\n        ta.setTop(renderData.top);\n        ta.setLeft(renderData.left);\n        ta.setWidth(renderData.width);\n        ta.setHeight(renderData.height);\n        ta.setColor(renderData.color ? Color.Format.CSS.formatHex(renderData.color) : '');\n        ta.setFontStyle(renderData.italic ? 'italic' : '');\n        if (renderData.bold) {\n            // fontWeight is also set by `applyFontInfo`, so only overwrite it if necessary\n            ta.setFontWeight('bold');\n        }\n        ta.setTextDecoration(`${renderData.underline ? ' underline' : ''}${renderData.strikethrough ? ' line-through' : ''}`);\n        tac.setTop(renderData.useCover ? renderData.top : 0);\n        tac.setLeft(renderData.useCover ? renderData.left : 0);\n        tac.setWidth(renderData.useCover ? renderData.width : 0);\n        tac.setHeight(renderData.useCover ? renderData.height : 0);\n        const options = this._context.configuration.options;\n        if (options.get(52 /* EditorOption.glyphMargin */)) {\n            tac.setClassName('monaco-editor-background textAreaCover ' + Margin.OUTER_CLASS_NAME);\n        }\n        else {\n            if (options.get(62 /* EditorOption.lineNumbers */).renderType !== 0 /* RenderLineNumbersType.Off */) {\n                tac.setClassName('monaco-editor-background textAreaCover ' + LineNumbersOverlay.CLASS_NAME);\n            }\n            else {\n                tac.setClassName('monaco-editor-background textAreaCover');\n            }\n        }\n    }\n}\nfunction measureText(text, fontInfo) {\n    if (text.length === 0) {\n        return 0;\n    }\n    const container = document.createElement('div');\n    container.style.position = 'absolute';\n    container.style.top = '-50000px';\n    container.style.width = '50000px';\n    const regularDomNode = document.createElement('span');\n    applyFontInfo(regularDomNode, fontInfo);\n    regularDomNode.style.whiteSpace = 'pre'; // just like the textarea\n    regularDomNode.append(text);\n    container.appendChild(regularDomNode);\n    document.body.appendChild(container);\n    const res = regularDomNode.offsetWidth;\n    document.body.removeChild(container);\n    return res;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './core/position.js';\nimport { Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { createScopedLineTokens } from './languages/supports.js';\nimport { CursorColumns } from './core/cursorColumns.js';\nimport { normalizeIndentation } from './core/indentation.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    constructor(languageId, modelOptions, configuration, languageConfigurationService) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._cursorMoveConfigurationBrand = undefined;\n        this._languageId = languageId;\n        const options = configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        this.readOnly = options.get(83 /* EditorOption.readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(106 /* EditorOption.stickyTabStops */);\n        this.lineHeight = options.get(61 /* EditorOption.lineHeight */);\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(118 /* EditorOption.useTabStops */);\n        this.wordSeparators = options.get(119 /* EditorOption.wordSeparators */);\n        this.emptySelectionClipboard = options.get(33 /* EditorOption.emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(21 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(71 /* EditorOption.multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(73 /* EditorOption.multiCursorPaste */);\n        this.autoClosingBrackets = options.get(5 /* EditorOption.autoClosingBrackets */);\n        this.autoClosingQuotes = options.get(8 /* EditorOption.autoClosingQuotes */);\n        this.autoClosingDelete = options.get(6 /* EditorOption.autoClosingDelete */);\n        this.autoClosingOvertype = options.get(7 /* EditorOption.autoClosingOvertype */);\n        this.autoSurround = options.get(11 /* EditorOption.autoSurround */);\n        this.autoIndent = options.get(9 /* EditorOption.autoIndent */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: this._getShouldAutoClose(languageId, this.autoClosingQuotes),\n            bracket: this._getShouldAutoClose(languageId, this.autoClosingBrackets)\n        };\n        this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoClosingPairs();\n        const surroundingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getSurroundingPairs();\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n    }\n    static shouldRecreate(e) {\n        return (e.hasChanged(133 /* EditorOption.layoutInfo */)\n            || e.hasChanged(119 /* EditorOption.wordSeparators */)\n            || e.hasChanged(33 /* EditorOption.emptySelectionClipboard */)\n            || e.hasChanged(71 /* EditorOption.multiCursorMergeOverlapping */)\n            || e.hasChanged(73 /* EditorOption.multiCursorPaste */)\n            || e.hasChanged(5 /* EditorOption.autoClosingBrackets */)\n            || e.hasChanged(8 /* EditorOption.autoClosingQuotes */)\n            || e.hasChanged(6 /* EditorOption.autoClosingDelete */)\n            || e.hasChanged(7 /* EditorOption.autoClosingOvertype */)\n            || e.hasChanged(11 /* EditorOption.autoSurround */)\n            || e.hasChanged(118 /* EditorOption.useTabStops */)\n            || e.hasChanged(61 /* EditorOption.lineHeight */)\n            || e.hasChanged(83 /* EditorOption.readOnly */));\n    }\n    get electricChars() {\n        var _a;\n        if (!this._electricChars) {\n            this._electricChars = {};\n            const electricChars = (_a = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || _a === void 0 ? void 0 : _a.getElectricCharacters();\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        const electricCharacterSupport = this.languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).electricCharacter;\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    normalizeIndentation(str) {\n        return normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    _getShouldAutoClose(languageId, autoCloseConfig) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return this._getLanguageDefinedShouldAutoClose(languageId);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    _getLanguageDefinedShouldAutoClose(languageId) {\n        const autoCloseBeforeSet = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoCloseBeforeSet();\n        return c => autoCloseBeforeSet.indexOf(c) !== -1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    visibleColumnFromColumn(model, position) {\n        return CursorColumns.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, this.tabSize);\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    columnFromVisibleColumn(model, lineNumber, visibleColumn) {\n        const result = CursorColumns.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, this.tabSize);\n        const minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n}\nexport class CursorState {\n    constructor(modelState, viewState) {\n        this._cursorStateBrand = undefined;\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selection = Selection.liftSelection(modelSelection);\n        const modelState = new SingleCursorState(Range.fromPositions(selection.getSelectionStart()), 0, selection.getPosition(), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        const states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this._singleCursorStateBrand = undefined;\n        this.selectionStart = selectionStart;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        if (selectionStart.isEmpty() || !position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n            return Selection.fromPositions(selectionStart.getStartPosition(), position);\n        }\n        else {\n            return Selection.fromPositions(selectionStart.getEndPosition(), position);\n        }\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this._editOperationResultBrand = undefined;\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode || !cursor.modelState.hasSelection()) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(cursor.modelState.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.description = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n            if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        const chIsQuote = isQuote(ch);\n        const autoCloseConfig = (chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets);\n        const shouldAutoCloseBefore = (chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket);\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, ch));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { isFirefox } from '../../base/browser/browser.js';\nimport * as types from '../../base/common/types.js';\nimport { status } from '../../base/browser/ui/aria/aria.js';\nimport { Command, EditorCommand, registerEditorCommand, UndoCommand, RedoCommand, SelectAllCommand } from './editorExtensions.js';\nimport { ICodeEditorService } from './services/codeEditorService.js';\nimport { ColumnSelection } from '../common/cursor/cursorColumnSelection.js';\nimport { CursorState } from '../common/cursorCommon.js';\nimport { DeleteOperations } from '../common/cursor/cursorDeleteOperations.js';\nimport { CursorMove as CursorMove_, CursorMoveCommands } from '../common/cursor/cursorMoveCommands.js';\nimport { TypeOperations } from '../common/cursor/cursorTypeOperations.js';\nimport { Position } from '../common/core/position.js';\nimport { Range } from '../common/core/range.js';\nimport { EditorContextKeys } from '../common/editorContextKeys.js';\nimport { ContextKeyExpr } from '../../platform/contextkey/common/contextkey.js';\nimport { KeybindingsRegistry } from '../../platform/keybinding/common/keybindingsRegistry.js';\nconst CORE_WEIGHT = 0 /* KeybindingWeight.EditorCore */;\nexport class CoreEditorCommand extends EditorCommand {\n    runEditorCommand(accessor, editor, args) {\n        const viewModel = editor._getViewModel();\n        if (!viewModel) {\n            // the editor has no view => has no cursors\n            return;\n        }\n        this.runCoreEditorCommand(viewModel, args || {});\n    }\n}\nexport var EditorScroll_;\n(function (EditorScroll_) {\n    const isEditorScrollArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const scrollArg = arg;\n        if (!types.isString(scrollArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(scrollArg.by) && !types.isString(scrollArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(scrollArg.value) && !types.isNumber(scrollArg.value)) {\n            return false;\n        }\n        if (!types.isUndefined(scrollArg.revealCursor) && !types.isBoolean(scrollArg.revealCursor)) {\n            return false;\n        }\n        return true;\n    };\n    EditorScroll_.description = {\n        description: 'Scroll editor in the given direction',\n        args: [\n            {\n                name: 'Editor scroll argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory direction value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'up', 'down'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'page', 'halfPage', 'editor'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n\t\t\t\t`,\n                constraint: isEditorScrollArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['up', 'down']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'page', 'halfPage', 'editor']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'revealCursor': {\n                            'type': 'boolean',\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Directions in the view for editor scroll command.\n     */\n    EditorScroll_.RawDirection = {\n        Up: 'up',\n        Down: 'down',\n    };\n    /**\n     * Units for editor scroll 'by' argument\n     */\n    EditorScroll_.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Page: 'page',\n        HalfPage: 'halfPage',\n        Editor: 'editor'\n    };\n    function parse(args) {\n        let direction;\n        switch (args.to) {\n            case EditorScroll_.RawDirection.Up:\n                direction = 1 /* Direction.Up */;\n                break;\n            case EditorScroll_.RawDirection.Down:\n                direction = 2 /* Direction.Down */;\n                break;\n            default:\n                // Illegal arguments\n                return null;\n        }\n        let unit;\n        switch (args.by) {\n            case EditorScroll_.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case EditorScroll_.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case EditorScroll_.RawUnit.Page:\n                unit = 3 /* Unit.Page */;\n                break;\n            case EditorScroll_.RawUnit.HalfPage:\n                unit = 4 /* Unit.HalfPage */;\n                break;\n            case EditorScroll_.RawUnit.Editor:\n                unit = 5 /* Unit.Editor */;\n                break;\n            default:\n                unit = 2 /* Unit.WrappedLine */;\n        }\n        const value = Math.floor(args.value || 1);\n        const revealCursor = !!args.revealCursor;\n        return {\n            direction: direction,\n            unit: unit,\n            value: value,\n            revealCursor: revealCursor,\n            select: (!!args.select)\n        };\n    }\n    EditorScroll_.parse = parse;\n})(EditorScroll_ || (EditorScroll_ = {}));\nexport var RevealLine_;\n(function (RevealLine_) {\n    const isRevealLineArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const reveaLineArg = arg;\n        if (!types.isNumber(reveaLineArg.lineNumber) && !types.isString(reveaLineArg.lineNumber)) {\n            return false;\n        }\n        if (!types.isUndefined(reveaLineArg.at) && !types.isString(reveaLineArg.at)) {\n            return false;\n        }\n        return true;\n    };\n    RevealLine_.description = {\n        description: 'Reveal the given line at the given logical position',\n        args: [\n            {\n                name: 'Reveal line argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'lineNumber': A mandatory line number value.\n\t\t\t\t\t* 'at': Logical position at which line has to be revealed.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'top', 'center', 'bottom'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t`,\n                constraint: isRevealLineArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['lineNumber'],\n                    'properties': {\n                        'lineNumber': {\n                            'type': ['number', 'string'],\n                        },\n                        'at': {\n                            'type': 'string',\n                            'enum': ['top', 'center', 'bottom']\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Values for reveal line 'at' argument\n     */\n    RevealLine_.RawAtArgument = {\n        Top: 'top',\n        Center: 'center',\n        Bottom: 'bottom'\n    };\n})(RevealLine_ || (RevealLine_ = {}));\nclass EditorOrNativeTextInputCommand {\n    constructor(target) {\n        // 1. handle case when focus is in editor.\n        target.addImplementation(10000, 'code-editor', (accessor, args) => {\n            // Only if editor text focus (i.e. not if editor has widget focus).\n            const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();\n            if (focusedEditor && focusedEditor.hasTextFocus()) {\n                return this._runEditorCommand(accessor, focusedEditor, args);\n            }\n            return false;\n        });\n        // 2. handle case when focus is in some other `input` / `textarea`.\n        target.addImplementation(1000, 'generic-dom-input-textarea', (accessor, args) => {\n            // Only if focused on an element that allows for entering text\n            const activeElement = document.activeElement;\n            if (activeElement && ['input', 'textarea'].indexOf(activeElement.tagName.toLowerCase()) >= 0) {\n                this.runDOMCommand();\n                return true;\n            }\n            return false;\n        });\n        // 3. (default) handle case when focus is somewhere else.\n        target.addImplementation(0, 'generic-dom', (accessor, args) => {\n            // Redirecting to active editor\n            const activeEditor = accessor.get(ICodeEditorService).getActiveCodeEditor();\n            if (activeEditor) {\n                activeEditor.focus();\n                return this._runEditorCommand(accessor, activeEditor, args);\n            }\n            return false;\n        });\n    }\n    _runEditorCommand(accessor, editor, args) {\n        const result = this.runEditorCommand(accessor, editor, args);\n        if (result) {\n            return result;\n        }\n        return true;\n    }\n}\nexport var CoreNavigationCommands;\n(function (CoreNavigationCommands) {\n    class BaseMoveToCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._minimalReveal = opts.minimalReveal;\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            const cursorStateChanged = viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, [\n                CursorMoveCommands.moveTo(viewModel, viewModel.getPrimaryCursorState(), this._inSelectionMode, args.position, args.viewPosition)\n            ]);\n            if (cursorStateChanged) {\n                viewModel.revealPrimaryCursor(args.source, true, this._minimalReveal);\n            }\n        }\n    }\n    CoreNavigationCommands.MoveTo = registerEditorCommand(new BaseMoveToCommand({\n        id: '_moveTo',\n        minimalReveal: true,\n        inSelectionMode: false,\n        precondition: undefined\n    }));\n    CoreNavigationCommands.MoveToSelect = registerEditorCommand(new BaseMoveToCommand({\n        id: '_moveToSelect',\n        minimalReveal: false,\n        inSelectionMode: true,\n        precondition: undefined\n    }));\n    class ColumnSelectCommand extends CoreEditorCommand {\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            const result = this._getColumnSelectResult(viewModel, viewModel.getPrimaryCursorState(), viewModel.getCursorColumnSelectData(), args);\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, result.viewStates.map((viewState) => CursorState.fromViewState(viewState)));\n            viewModel.setCursorColumnSelectData({\n                isReal: true,\n                fromViewLineNumber: result.fromLineNumber,\n                fromViewVisualColumn: result.fromVisualColumn,\n                toViewLineNumber: result.toLineNumber,\n                toViewVisualColumn: result.toVisualColumn\n            });\n            if (result.reversed) {\n                viewModel.revealTopMostCursor(args.source);\n            }\n            else {\n                viewModel.revealBottomMostCursor(args.source);\n            }\n        }\n    }\n    CoreNavigationCommands.ColumnSelect = registerEditorCommand(new class extends ColumnSelectCommand {\n        constructor() {\n            super({\n                id: 'columnSelect',\n                precondition: undefined\n            });\n        }\n        _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {\n            // validate `args`\n            const validatedPosition = viewModel.model.validatePosition(args.position);\n            const validatedViewPosition = viewModel.coordinatesConverter.validateViewPosition(new Position(args.viewPosition.lineNumber, args.viewPosition.column), validatedPosition);\n            const fromViewLineNumber = args.doColumnSelect ? prevColumnSelectData.fromViewLineNumber : validatedViewPosition.lineNumber;\n            const fromViewVisualColumn = args.doColumnSelect ? prevColumnSelectData.fromViewVisualColumn : args.mouseColumn - 1;\n            return ColumnSelection.columnSelect(viewModel.cursorConfig, viewModel, fromViewLineNumber, fromViewVisualColumn, validatedViewPosition.lineNumber, args.mouseColumn - 1);\n        }\n    });\n    CoreNavigationCommands.CursorColumnSelectLeft = registerEditorCommand(new class extends ColumnSelectCommand {\n        constructor() {\n            super({\n                id: 'cursorColumnSelectLeft',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 15 /* KeyCode.LeftArrow */,\n                    linux: { primary: 0 }\n                }\n            });\n        }\n        _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {\n            return ColumnSelection.columnSelectLeft(viewModel.cursorConfig, viewModel, prevColumnSelectData);\n        }\n    });\n    CoreNavigationCommands.CursorColumnSelectRight = registerEditorCommand(new class extends ColumnSelectCommand {\n        constructor() {\n            super({\n                id: 'cursorColumnSelectRight',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 17 /* KeyCode.RightArrow */,\n                    linux: { primary: 0 }\n                }\n            });\n        }\n        _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {\n            return ColumnSelection.columnSelectRight(viewModel.cursorConfig, viewModel, prevColumnSelectData);\n        }\n    });\n    class ColumnSelectUpCommand extends ColumnSelectCommand {\n        constructor(opts) {\n            super(opts);\n            this._isPaged = opts.isPaged;\n        }\n        _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {\n            return ColumnSelection.columnSelectUp(viewModel.cursorConfig, viewModel, prevColumnSelectData, this._isPaged);\n        }\n    }\n    CoreNavigationCommands.CursorColumnSelectUp = registerEditorCommand(new ColumnSelectUpCommand({\n        isPaged: false,\n        id: 'cursorColumnSelectUp',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */,\n            linux: { primary: 0 }\n        }\n    }));\n    CoreNavigationCommands.CursorColumnSelectPageUp = registerEditorCommand(new ColumnSelectUpCommand({\n        isPaged: true,\n        id: 'cursorColumnSelectPageUp',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 11 /* KeyCode.PageUp */,\n            linux: { primary: 0 }\n        }\n    }));\n    class ColumnSelectDownCommand extends ColumnSelectCommand {\n        constructor(opts) {\n            super(opts);\n            this._isPaged = opts.isPaged;\n        }\n        _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {\n            return ColumnSelection.columnSelectDown(viewModel.cursorConfig, viewModel, prevColumnSelectData, this._isPaged);\n        }\n    }\n    CoreNavigationCommands.CursorColumnSelectDown = registerEditorCommand(new ColumnSelectDownCommand({\n        isPaged: false,\n        id: 'cursorColumnSelectDown',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */,\n            linux: { primary: 0 }\n        }\n    }));\n    CoreNavigationCommands.CursorColumnSelectPageDown = registerEditorCommand(new ColumnSelectDownCommand({\n        isPaged: true,\n        id: 'cursorColumnSelectPageDown',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 12 /* KeyCode.PageDown */,\n            linux: { primary: 0 }\n        }\n    }));\n    class CursorMoveImpl extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'cursorMove',\n                precondition: undefined,\n                description: CursorMove_.description\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const parsed = CursorMove_.parse(args);\n            if (!parsed) {\n                // illegal arguments\n                return;\n            }\n            this._runCursorMove(viewModel, args.source, parsed);\n        }\n        _runCursorMove(viewModel, source, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(source, 3 /* CursorChangeReason.Explicit */, CursorMoveImpl._move(viewModel, viewModel.getCursorStates(), args));\n            viewModel.revealPrimaryCursor(source, true);\n        }\n        static _move(viewModel, cursors, args) {\n            const inSelectionMode = args.select;\n            const value = args.value;\n            switch (args.direction) {\n                case 0 /* CursorMove_.Direction.Left */:\n                case 1 /* CursorMove_.Direction.Right */:\n                case 2 /* CursorMove_.Direction.Up */:\n                case 3 /* CursorMove_.Direction.Down */:\n                case 4 /* CursorMove_.Direction.PrevBlankLine */:\n                case 5 /* CursorMove_.Direction.NextBlankLine */:\n                case 6 /* CursorMove_.Direction.WrappedLineStart */:\n                case 7 /* CursorMove_.Direction.WrappedLineFirstNonWhitespaceCharacter */:\n                case 8 /* CursorMove_.Direction.WrappedLineColumnCenter */:\n                case 9 /* CursorMove_.Direction.WrappedLineEnd */:\n                case 10 /* CursorMove_.Direction.WrappedLineLastNonWhitespaceCharacter */:\n                    return CursorMoveCommands.simpleMove(viewModel, cursors, args.direction, inSelectionMode, value, args.unit);\n                case 11 /* CursorMove_.Direction.ViewPortTop */:\n                case 13 /* CursorMove_.Direction.ViewPortBottom */:\n                case 12 /* CursorMove_.Direction.ViewPortCenter */:\n                case 14 /* CursorMove_.Direction.ViewPortIfOutside */:\n                    return CursorMoveCommands.viewportMove(viewModel, cursors, args.direction, inSelectionMode, value);\n                default:\n                    return null;\n            }\n        }\n    }\n    CoreNavigationCommands.CursorMoveImpl = CursorMoveImpl;\n    CoreNavigationCommands.CursorMove = registerEditorCommand(new CursorMoveImpl());\n    class CursorMoveBasedCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._staticArgs = opts.args;\n        }\n        runCoreEditorCommand(viewModel, dynamicArgs) {\n            let args = this._staticArgs;\n            if (this._staticArgs.value === -1 /* Constants.PAGE_SIZE_MARKER */) {\n                // -1 is a marker for page size\n                args = {\n                    direction: this._staticArgs.direction,\n                    unit: this._staticArgs.unit,\n                    select: this._staticArgs.select,\n                    value: dynamicArgs.pageSize || viewModel.cursorConfig.pageSize\n                };\n            }\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(dynamicArgs.source, 3 /* CursorChangeReason.Explicit */, CursorMoveCommands.simpleMove(viewModel, viewModel.getCursorStates(), args.direction, args.select, args.value, args.unit));\n            viewModel.revealPrimaryCursor(dynamicArgs.source, true);\n        }\n    }\n    CoreNavigationCommands.CursorLeft = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 0 /* CursorMove_.Direction.Left */,\n            unit: 0 /* CursorMove_.Unit.None */,\n            select: false,\n            value: 1\n        },\n        id: 'cursorLeft',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 15 /* KeyCode.LeftArrow */,\n            mac: { primary: 15 /* KeyCode.LeftArrow */, secondary: [256 /* KeyMod.WinCtrl */ | 32 /* KeyCode.KeyB */] }\n        }\n    }));\n    CoreNavigationCommands.CursorLeftSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 0 /* CursorMove_.Direction.Left */,\n            unit: 0 /* CursorMove_.Unit.None */,\n            select: true,\n            value: 1\n        },\n        id: 'cursorLeftSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* KeyMod.Shift */ | 15 /* KeyCode.LeftArrow */\n        }\n    }));\n    CoreNavigationCommands.CursorRight = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 1 /* CursorMove_.Direction.Right */,\n            unit: 0 /* CursorMove_.Unit.None */,\n            select: false,\n            value: 1\n        },\n        id: 'cursorRight',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 17 /* KeyCode.RightArrow */,\n            mac: { primary: 17 /* KeyCode.RightArrow */, secondary: [256 /* KeyMod.WinCtrl */ | 36 /* KeyCode.KeyF */] }\n        }\n    }));\n    CoreNavigationCommands.CursorRightSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 1 /* CursorMove_.Direction.Right */,\n            unit: 0 /* CursorMove_.Unit.None */,\n            select: true,\n            value: 1\n        },\n        id: 'cursorRightSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* KeyMod.Shift */ | 17 /* KeyCode.RightArrow */\n        }\n    }));\n    CoreNavigationCommands.CursorUp = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 2 /* CursorMove_.Direction.Up */,\n            unit: 2 /* CursorMove_.Unit.WrappedLine */,\n            select: false,\n            value: 1\n        },\n        id: 'cursorUp',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 16 /* KeyCode.UpArrow */,\n            mac: { primary: 16 /* KeyCode.UpArrow */, secondary: [256 /* KeyMod.WinCtrl */ | 46 /* KeyCode.KeyP */] }\n        }\n    }));\n    CoreNavigationCommands.CursorUpSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 2 /* CursorMove_.Direction.Up */,\n            unit: 2 /* CursorMove_.Unit.WrappedLine */,\n            select: true,\n            value: 1\n        },\n        id: 'cursorUpSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */,\n            secondary: [2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */],\n            mac: { primary: 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */ },\n            linux: { primary: 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */ }\n        }\n    }));\n    CoreNavigationCommands.CursorPageUp = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 2 /* CursorMove_.Direction.Up */,\n            unit: 2 /* CursorMove_.Unit.WrappedLine */,\n            select: false,\n            value: -1 /* Constants.PAGE_SIZE_MARKER */\n        },\n        id: 'cursorPageUp',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 11 /* KeyCode.PageUp */\n        }\n    }));\n    CoreNavigationCommands.CursorPageUpSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 2 /* CursorMove_.Direction.Up */,\n            unit: 2 /* CursorMove_.Unit.WrappedLine */,\n            select: true,\n            value: -1 /* Constants.PAGE_SIZE_MARKER */\n        },\n        id: 'cursorPageUpSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* KeyMod.Shift */ | 11 /* KeyCode.PageUp */\n        }\n    }));\n    CoreNavigationCommands.CursorDown = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 3 /* CursorMove_.Direction.Down */,\n            unit: 2 /* CursorMove_.Unit.WrappedLine */,\n            select: false,\n            value: 1\n        },\n        id: 'cursorDown',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 18 /* KeyCode.DownArrow */,\n            mac: { primary: 18 /* KeyCode.DownArrow */, secondary: [256 /* KeyMod.WinCtrl */ | 44 /* KeyCode.KeyN */] }\n        }\n    }));\n    CoreNavigationCommands.CursorDownSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 3 /* CursorMove_.Direction.Down */,\n            unit: 2 /* CursorMove_.Unit.WrappedLine */,\n            select: true,\n            value: 1\n        },\n        id: 'cursorDownSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */,\n            secondary: [2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */],\n            mac: { primary: 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */ },\n            linux: { primary: 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */ }\n        }\n    }));\n    CoreNavigationCommands.CursorPageDown = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 3 /* CursorMove_.Direction.Down */,\n            unit: 2 /* CursorMove_.Unit.WrappedLine */,\n            select: false,\n            value: -1 /* Constants.PAGE_SIZE_MARKER */\n        },\n        id: 'cursorPageDown',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 12 /* KeyCode.PageDown */\n        }\n    }));\n    CoreNavigationCommands.CursorPageDownSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 3 /* CursorMove_.Direction.Down */,\n            unit: 2 /* CursorMove_.Unit.WrappedLine */,\n            select: true,\n            value: -1 /* Constants.PAGE_SIZE_MARKER */\n        },\n        id: 'cursorPageDownSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* KeyMod.Shift */ | 12 /* KeyCode.PageDown */\n        }\n    }));\n    CoreNavigationCommands.CreateCursor = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'createCursor',\n                precondition: undefined\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            let newState;\n            if (args.wholeLine) {\n                newState = CursorMoveCommands.line(viewModel, viewModel.getPrimaryCursorState(), false, args.position, args.viewPosition);\n            }\n            else {\n                newState = CursorMoveCommands.moveTo(viewModel, viewModel.getPrimaryCursorState(), false, args.position, args.viewPosition);\n            }\n            const states = viewModel.getCursorStates();\n            // Check if we should remove a cursor (sort of like a toggle)\n            if (states.length > 1) {\n                const newModelPosition = (newState.modelState ? newState.modelState.position : null);\n                const newViewPosition = (newState.viewState ? newState.viewState.position : null);\n                for (let i = 0, len = states.length; i < len; i++) {\n                    const state = states[i];\n                    if (newModelPosition && !state.modelState.selection.containsPosition(newModelPosition)) {\n                        continue;\n                    }\n                    if (newViewPosition && !state.viewState.selection.containsPosition(newViewPosition)) {\n                        continue;\n                    }\n                    // => Remove the cursor\n                    states.splice(i, 1);\n                    viewModel.model.pushStackElement();\n                    viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, states);\n                    return;\n                }\n            }\n            // => Add the new cursor\n            states.push(newState);\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, states);\n        }\n    });\n    CoreNavigationCommands.LastCursorMoveToSelect = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: '_lastCursorMoveToSelect',\n                precondition: undefined\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const lastAddedCursorIndex = viewModel.getLastAddedCursorIndex();\n            const states = viewModel.getCursorStates();\n            const newStates = states.slice(0);\n            newStates[lastAddedCursorIndex] = CursorMoveCommands.moveTo(viewModel, states[lastAddedCursorIndex], true, args.position, args.viewPosition);\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, newStates);\n        }\n    });\n    class HomeCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, CursorMoveCommands.moveToBeginningOfLine(viewModel, viewModel.getCursorStates(), this._inSelectionMode));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.CursorHome = registerEditorCommand(new HomeCommand({\n        inSelectionMode: false,\n        id: 'cursorHome',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 14 /* KeyCode.Home */,\n            mac: { primary: 14 /* KeyCode.Home */, secondary: [2048 /* KeyMod.CtrlCmd */ | 15 /* KeyCode.LeftArrow */] }\n        }\n    }));\n    CoreNavigationCommands.CursorHomeSelect = registerEditorCommand(new HomeCommand({\n        inSelectionMode: true,\n        id: 'cursorHomeSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* KeyMod.Shift */ | 14 /* KeyCode.Home */,\n            mac: { primary: 1024 /* KeyMod.Shift */ | 14 /* KeyCode.Home */, secondary: [2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 15 /* KeyCode.LeftArrow */] }\n        }\n    }));\n    class LineStartCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, this._exec(viewModel.getCursorStates()));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n        _exec(cursors) {\n            const result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const lineNumber = cursor.modelState.position.lineNumber;\n                result[i] = CursorState.fromModelState(cursor.modelState.move(this._inSelectionMode, lineNumber, 1, 0));\n            }\n            return result;\n        }\n    }\n    CoreNavigationCommands.CursorLineStart = registerEditorCommand(new LineStartCommand({\n        inSelectionMode: false,\n        id: 'cursorLineStart',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 0,\n            mac: { primary: 256 /* KeyMod.WinCtrl */ | 31 /* KeyCode.KeyA */ }\n        }\n    }));\n    CoreNavigationCommands.CursorLineStartSelect = registerEditorCommand(new LineStartCommand({\n        inSelectionMode: true,\n        id: 'cursorLineStartSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 0,\n            mac: { primary: 256 /* KeyMod.WinCtrl */ | 1024 /* KeyMod.Shift */ | 31 /* KeyCode.KeyA */ }\n        }\n    }));\n    class EndCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, CursorMoveCommands.moveToEndOfLine(viewModel, viewModel.getCursorStates(), this._inSelectionMode, args.sticky || false));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.CursorEnd = registerEditorCommand(new EndCommand({\n        inSelectionMode: false,\n        id: 'cursorEnd',\n        precondition: undefined,\n        kbOpts: {\n            args: { sticky: false },\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 13 /* KeyCode.End */,\n            mac: { primary: 13 /* KeyCode.End */, secondary: [2048 /* KeyMod.CtrlCmd */ | 17 /* KeyCode.RightArrow */] }\n        },\n        description: {\n            description: `Go to End`,\n            args: [{\n                    name: 'args',\n                    schema: {\n                        type: 'object',\n                        properties: {\n                            'sticky': {\n                                description: nls.localize('stickydesc', \"Stick to the end even when going to longer lines\"),\n                                type: 'boolean',\n                                default: false\n                            }\n                        }\n                    }\n                }]\n        }\n    }));\n    CoreNavigationCommands.CursorEndSelect = registerEditorCommand(new EndCommand({\n        inSelectionMode: true,\n        id: 'cursorEndSelect',\n        precondition: undefined,\n        kbOpts: {\n            args: { sticky: false },\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* KeyMod.Shift */ | 13 /* KeyCode.End */,\n            mac: { primary: 1024 /* KeyMod.Shift */ | 13 /* KeyCode.End */, secondary: [2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 17 /* KeyCode.RightArrow */] }\n        },\n        description: {\n            description: `Select to End`,\n            args: [{\n                    name: 'args',\n                    schema: {\n                        type: 'object',\n                        properties: {\n                            'sticky': {\n                                description: nls.localize('stickydesc', \"Stick to the end even when going to longer lines\"),\n                                type: 'boolean',\n                                default: false\n                            }\n                        }\n                    }\n                }]\n        }\n    }));\n    class LineEndCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, this._exec(viewModel, viewModel.getCursorStates()));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n        _exec(viewModel, cursors) {\n            const result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const lineNumber = cursor.modelState.position.lineNumber;\n                const maxColumn = viewModel.model.getLineMaxColumn(lineNumber);\n                result[i] = CursorState.fromModelState(cursor.modelState.move(this._inSelectionMode, lineNumber, maxColumn, 0));\n            }\n            return result;\n        }\n    }\n    CoreNavigationCommands.CursorLineEnd = registerEditorCommand(new LineEndCommand({\n        inSelectionMode: false,\n        id: 'cursorLineEnd',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 0,\n            mac: { primary: 256 /* KeyMod.WinCtrl */ | 35 /* KeyCode.KeyE */ }\n        }\n    }));\n    CoreNavigationCommands.CursorLineEndSelect = registerEditorCommand(new LineEndCommand({\n        inSelectionMode: true,\n        id: 'cursorLineEndSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 0,\n            mac: { primary: 256 /* KeyMod.WinCtrl */ | 1024 /* KeyMod.Shift */ | 35 /* KeyCode.KeyE */ }\n        }\n    }));\n    class TopCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, CursorMoveCommands.moveToBeginningOfBuffer(viewModel, viewModel.getCursorStates(), this._inSelectionMode));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.CursorTop = registerEditorCommand(new TopCommand({\n        inSelectionMode: false,\n        id: 'cursorTop',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* KeyMod.CtrlCmd */ | 14 /* KeyCode.Home */,\n            mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 16 /* KeyCode.UpArrow */ }\n        }\n    }));\n    CoreNavigationCommands.CursorTopSelect = registerEditorCommand(new TopCommand({\n        inSelectionMode: true,\n        id: 'cursorTopSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 14 /* KeyCode.Home */,\n            mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */ }\n        }\n    }));\n    class BottomCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, CursorMoveCommands.moveToEndOfBuffer(viewModel, viewModel.getCursorStates(), this._inSelectionMode));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.CursorBottom = registerEditorCommand(new BottomCommand({\n        inSelectionMode: false,\n        id: 'cursorBottom',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* KeyMod.CtrlCmd */ | 13 /* KeyCode.End */,\n            mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 18 /* KeyCode.DownArrow */ }\n        }\n    }));\n    CoreNavigationCommands.CursorBottomSelect = registerEditorCommand(new BottomCommand({\n        inSelectionMode: true,\n        id: 'cursorBottomSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 13 /* KeyCode.End */,\n            mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */ }\n        }\n    }));\n    class EditorScrollImpl extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'editorScroll',\n                precondition: undefined,\n                description: EditorScroll_.description\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const parsed = EditorScroll_.parse(args);\n            if (!parsed) {\n                // illegal arguments\n                return;\n            }\n            this._runEditorScroll(viewModel, args.source, parsed);\n        }\n        _runEditorScroll(viewModel, source, args) {\n            const desiredScrollTop = this._computeDesiredScrollTop(viewModel, args);\n            if (args.revealCursor) {\n                // must ensure cursor is in new visible range\n                const desiredVisibleViewRange = viewModel.getCompletelyVisibleViewRangeAtScrollTop(desiredScrollTop);\n                viewModel.setCursorStates(source, 3 /* CursorChangeReason.Explicit */, [\n                    CursorMoveCommands.findPositionInViewportIfOutside(viewModel, viewModel.getPrimaryCursorState(), desiredVisibleViewRange, args.select)\n                ]);\n            }\n            viewModel.viewLayout.setScrollPosition({ scrollTop: desiredScrollTop }, 0 /* ScrollType.Smooth */);\n        }\n        _computeDesiredScrollTop(viewModel, args) {\n            if (args.unit === 1 /* EditorScroll_.Unit.Line */) {\n                // scrolling by model lines\n                const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n                const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n                let desiredTopModelLineNumber;\n                if (args.direction === 1 /* EditorScroll_.Direction.Up */) {\n                    // must go x model lines up\n                    desiredTopModelLineNumber = Math.max(1, visibleModelRange.startLineNumber - args.value);\n                }\n                else {\n                    // must go x model lines down\n                    desiredTopModelLineNumber = Math.min(viewModel.model.getLineCount(), visibleModelRange.startLineNumber + args.value);\n                }\n                const viewPosition = viewModel.coordinatesConverter.convertModelPositionToViewPosition(new Position(desiredTopModelLineNumber, 1));\n                return viewModel.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n            }\n            if (args.unit === 5 /* EditorScroll_.Unit.Editor */) {\n                let desiredTopModelLineNumber = 0;\n                if (args.direction === 2 /* EditorScroll_.Direction.Down */) {\n                    desiredTopModelLineNumber = viewModel.model.getLineCount() - viewModel.cursorConfig.pageSize;\n                }\n                return viewModel.viewLayout.getVerticalOffsetForLineNumber(desiredTopModelLineNumber);\n            }\n            let noOfLines;\n            if (args.unit === 3 /* EditorScroll_.Unit.Page */) {\n                noOfLines = viewModel.cursorConfig.pageSize * args.value;\n            }\n            else if (args.unit === 4 /* EditorScroll_.Unit.HalfPage */) {\n                noOfLines = Math.round(viewModel.cursorConfig.pageSize / 2) * args.value;\n            }\n            else {\n                noOfLines = args.value;\n            }\n            const deltaLines = (args.direction === 1 /* EditorScroll_.Direction.Up */ ? -1 : 1) * noOfLines;\n            return viewModel.viewLayout.getCurrentScrollTop() + deltaLines * viewModel.cursorConfig.lineHeight;\n        }\n    }\n    CoreNavigationCommands.EditorScrollImpl = EditorScrollImpl;\n    CoreNavigationCommands.EditorScroll = registerEditorCommand(new EditorScrollImpl());\n    CoreNavigationCommands.ScrollLineUp = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'scrollLineUp',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 16 /* KeyCode.UpArrow */,\n                    mac: { primary: 256 /* KeyMod.WinCtrl */ | 11 /* KeyCode.PageUp */ }\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            CoreNavigationCommands.EditorScroll._runEditorScroll(viewModel, args.source, {\n                direction: 1 /* EditorScroll_.Direction.Up */,\n                unit: 2 /* EditorScroll_.Unit.WrappedLine */,\n                value: 1,\n                revealCursor: false,\n                select: false\n            });\n        }\n    });\n    CoreNavigationCommands.ScrollPageUp = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'scrollPageUp',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 11 /* KeyCode.PageUp */,\n                    win: { primary: 512 /* KeyMod.Alt */ | 11 /* KeyCode.PageUp */ },\n                    linux: { primary: 512 /* KeyMod.Alt */ | 11 /* KeyCode.PageUp */ }\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            CoreNavigationCommands.EditorScroll._runEditorScroll(viewModel, args.source, {\n                direction: 1 /* EditorScroll_.Direction.Up */,\n                unit: 3 /* EditorScroll_.Unit.Page */,\n                value: 1,\n                revealCursor: false,\n                select: false\n            });\n        }\n    });\n    CoreNavigationCommands.ScrollEditorTop = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'scrollEditorTop',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            CoreNavigationCommands.EditorScroll._runEditorScroll(viewModel, args.source, {\n                direction: 1 /* EditorScroll_.Direction.Up */,\n                unit: 5 /* EditorScroll_.Unit.Editor */,\n                value: 1,\n                revealCursor: false,\n                select: false\n            });\n        }\n    });\n    CoreNavigationCommands.ScrollLineDown = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'scrollLineDown',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 18 /* KeyCode.DownArrow */,\n                    mac: { primary: 256 /* KeyMod.WinCtrl */ | 12 /* KeyCode.PageDown */ }\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            CoreNavigationCommands.EditorScroll._runEditorScroll(viewModel, args.source, {\n                direction: 2 /* EditorScroll_.Direction.Down */,\n                unit: 2 /* EditorScroll_.Unit.WrappedLine */,\n                value: 1,\n                revealCursor: false,\n                select: false\n            });\n        }\n    });\n    CoreNavigationCommands.ScrollPageDown = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'scrollPageDown',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 12 /* KeyCode.PageDown */,\n                    win: { primary: 512 /* KeyMod.Alt */ | 12 /* KeyCode.PageDown */ },\n                    linux: { primary: 512 /* KeyMod.Alt */ | 12 /* KeyCode.PageDown */ }\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            CoreNavigationCommands.EditorScroll._runEditorScroll(viewModel, args.source, {\n                direction: 2 /* EditorScroll_.Direction.Down */,\n                unit: 3 /* EditorScroll_.Unit.Page */,\n                value: 1,\n                revealCursor: false,\n                select: false\n            });\n        }\n    });\n    CoreNavigationCommands.ScrollEditorBottom = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'scrollEditorBottom',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            CoreNavigationCommands.EditorScroll._runEditorScroll(viewModel, args.source, {\n                direction: 2 /* EditorScroll_.Direction.Down */,\n                unit: 5 /* EditorScroll_.Unit.Editor */,\n                value: 1,\n                revealCursor: false,\n                select: false\n            });\n        }\n    });\n    class WordCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, [\n                CursorMoveCommands.word(viewModel, viewModel.getPrimaryCursorState(), this._inSelectionMode, args.position)\n            ]);\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.WordSelect = registerEditorCommand(new WordCommand({\n        inSelectionMode: false,\n        id: '_wordSelect',\n        precondition: undefined\n    }));\n    CoreNavigationCommands.WordSelectDrag = registerEditorCommand(new WordCommand({\n        inSelectionMode: true,\n        id: '_wordSelectDrag',\n        precondition: undefined\n    }));\n    CoreNavigationCommands.LastCursorWordSelect = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'lastCursorWordSelect',\n                precondition: undefined\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const lastAddedCursorIndex = viewModel.getLastAddedCursorIndex();\n            const states = viewModel.getCursorStates();\n            const newStates = states.slice(0);\n            const lastAddedState = states[lastAddedCursorIndex];\n            newStates[lastAddedCursorIndex] = CursorMoveCommands.word(viewModel, lastAddedState, lastAddedState.modelState.hasSelection(), args.position);\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, newStates);\n        }\n    });\n    class LineCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, [\n                CursorMoveCommands.line(viewModel, viewModel.getPrimaryCursorState(), this._inSelectionMode, args.position, args.viewPosition)\n            ]);\n            viewModel.revealPrimaryCursor(args.source, false);\n        }\n    }\n    CoreNavigationCommands.LineSelect = registerEditorCommand(new LineCommand({\n        inSelectionMode: false,\n        id: '_lineSelect',\n        precondition: undefined\n    }));\n    CoreNavigationCommands.LineSelectDrag = registerEditorCommand(new LineCommand({\n        inSelectionMode: true,\n        id: '_lineSelectDrag',\n        precondition: undefined\n    }));\n    class LastCursorLineCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const lastAddedCursorIndex = viewModel.getLastAddedCursorIndex();\n            const states = viewModel.getCursorStates();\n            const newStates = states.slice(0);\n            newStates[lastAddedCursorIndex] = CursorMoveCommands.line(viewModel, states[lastAddedCursorIndex], this._inSelectionMode, args.position, args.viewPosition);\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, newStates);\n        }\n    }\n    CoreNavigationCommands.LastCursorLineSelect = registerEditorCommand(new LastCursorLineCommand({\n        inSelectionMode: false,\n        id: 'lastCursorLineSelect',\n        precondition: undefined\n    }));\n    CoreNavigationCommands.LastCursorLineSelectDrag = registerEditorCommand(new LastCursorLineCommand({\n        inSelectionMode: true,\n        id: 'lastCursorLineSelectDrag',\n        precondition: undefined\n    }));\n    CoreNavigationCommands.CancelSelection = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'cancelSelection',\n                precondition: EditorContextKeys.hasNonEmptySelection,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 9 /* KeyCode.Escape */,\n                    secondary: [1024 /* KeyMod.Shift */ | 9 /* KeyCode.Escape */]\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, [\n                CursorMoveCommands.cancelSelection(viewModel, viewModel.getPrimaryCursorState())\n            ]);\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    });\n    CoreNavigationCommands.RemoveSecondaryCursors = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'removeSecondaryCursors',\n                precondition: EditorContextKeys.hasMultipleSelections,\n                kbOpts: {\n                    weight: CORE_WEIGHT + 1,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 9 /* KeyCode.Escape */,\n                    secondary: [1024 /* KeyMod.Shift */ | 9 /* KeyCode.Escape */]\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, [\n                viewModel.getPrimaryCursorState()\n            ]);\n            viewModel.revealPrimaryCursor(args.source, true);\n            status(nls.localize('removedCursor', \"Removed secondary cursors\"));\n        }\n    });\n    CoreNavigationCommands.RevealLine = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'revealLine',\n                precondition: undefined,\n                description: RevealLine_.description\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const revealLineArg = args;\n            const lineNumberArg = revealLineArg.lineNumber || 0;\n            let lineNumber = typeof lineNumberArg === 'number' ? (lineNumberArg + 1) : (parseInt(lineNumberArg) + 1);\n            if (lineNumber < 1) {\n                lineNumber = 1;\n            }\n            const lineCount = viewModel.model.getLineCount();\n            if (lineNumber > lineCount) {\n                lineNumber = lineCount;\n            }\n            const range = new Range(lineNumber, 1, lineNumber, viewModel.model.getLineMaxColumn(lineNumber));\n            let revealAt = 0 /* VerticalRevealType.Simple */;\n            if (revealLineArg.at) {\n                switch (revealLineArg.at) {\n                    case RevealLine_.RawAtArgument.Top:\n                        revealAt = 3 /* VerticalRevealType.Top */;\n                        break;\n                    case RevealLine_.RawAtArgument.Center:\n                        revealAt = 1 /* VerticalRevealType.Center */;\n                        break;\n                    case RevealLine_.RawAtArgument.Bottom:\n                        revealAt = 4 /* VerticalRevealType.Bottom */;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            const viewRange = viewModel.coordinatesConverter.convertModelRangeToViewRange(range);\n            viewModel.revealRange(args.source, false, viewRange, revealAt, 0 /* ScrollType.Smooth */);\n        }\n    });\n    CoreNavigationCommands.SelectAll = new class extends EditorOrNativeTextInputCommand {\n        constructor() {\n            super(SelectAllCommand);\n        }\n        runDOMCommand() {\n            if (isFirefox) {\n                document.activeElement.focus();\n                document.activeElement.select();\n            }\n            document.execCommand('selectAll');\n        }\n        runEditorCommand(accessor, editor, args) {\n            const viewModel = editor._getViewModel();\n            if (!viewModel) {\n                // the editor has no view => has no cursors\n                return;\n            }\n            this.runCoreEditorCommand(viewModel, args);\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates('keyboard', 3 /* CursorChangeReason.Explicit */, [\n                CursorMoveCommands.selectAll(viewModel, viewModel.getPrimaryCursorState())\n            ]);\n        }\n    }();\n    CoreNavigationCommands.SetSelection = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'setSelection',\n                precondition: undefined\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, [\n                CursorState.fromModelSelection(args.selection)\n            ]);\n        }\n    });\n})(CoreNavigationCommands || (CoreNavigationCommands = {}));\nconst columnSelectionCondition = ContextKeyExpr.and(EditorContextKeys.textInputFocus, EditorContextKeys.columnSelection);\nfunction registerColumnSelection(id, keybinding) {\n    KeybindingsRegistry.registerKeybindingRule({\n        id: id,\n        primary: keybinding,\n        when: columnSelectionCondition,\n        weight: CORE_WEIGHT + 1\n    });\n}\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectLeft.id, 1024 /* KeyMod.Shift */ | 15 /* KeyCode.LeftArrow */);\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectRight.id, 1024 /* KeyMod.Shift */ | 17 /* KeyCode.RightArrow */);\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectUp.id, 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */);\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectPageUp.id, 1024 /* KeyMod.Shift */ | 11 /* KeyCode.PageUp */);\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectDown.id, 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */);\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectPageDown.id, 1024 /* KeyMod.Shift */ | 12 /* KeyCode.PageDown */);\nfunction registerCommand(command) {\n    command.register();\n    return command;\n}\nexport var CoreEditingCommands;\n(function (CoreEditingCommands) {\n    class CoreEditingCommand extends EditorCommand {\n        runEditorCommand(accessor, editor, args) {\n            const viewModel = editor._getViewModel();\n            if (!viewModel) {\n                // the editor has no view => has no cursors\n                return;\n            }\n            this.runCoreEditingCommand(editor, viewModel, args || {});\n        }\n    }\n    CoreEditingCommands.CoreEditingCommand = CoreEditingCommand;\n    CoreEditingCommands.LineBreakInsert = registerEditorCommand(new class extends CoreEditingCommand {\n        constructor() {\n            super({\n                id: 'lineBreakInsert',\n                precondition: EditorContextKeys.writable,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 0,\n                    mac: { primary: 256 /* KeyMod.WinCtrl */ | 45 /* KeyCode.KeyO */ }\n                }\n            });\n        }\n        runCoreEditingCommand(editor, viewModel, args) {\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, TypeOperations.lineBreakInsert(viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map(s => s.modelState.selection)));\n        }\n    });\n    CoreEditingCommands.Outdent = registerEditorCommand(new class extends CoreEditingCommand {\n        constructor() {\n            super({\n                id: 'outdent',\n                precondition: EditorContextKeys.writable,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, EditorContextKeys.tabDoesNotMoveFocus),\n                    primary: 1024 /* KeyMod.Shift */ | 2 /* KeyCode.Tab */\n                }\n            });\n        }\n        runCoreEditingCommand(editor, viewModel, args) {\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, TypeOperations.outdent(viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map(s => s.modelState.selection)));\n            editor.pushUndoStop();\n        }\n    });\n    CoreEditingCommands.Tab = registerEditorCommand(new class extends CoreEditingCommand {\n        constructor() {\n            super({\n                id: 'tab',\n                precondition: EditorContextKeys.writable,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, EditorContextKeys.tabDoesNotMoveFocus),\n                    primary: 2 /* KeyCode.Tab */\n                }\n            });\n        }\n        runCoreEditingCommand(editor, viewModel, args) {\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, TypeOperations.tab(viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map(s => s.modelState.selection)));\n            editor.pushUndoStop();\n        }\n    });\n    CoreEditingCommands.DeleteLeft = registerEditorCommand(new class extends CoreEditingCommand {\n        constructor() {\n            super({\n                id: 'deleteLeft',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 1 /* KeyCode.Backspace */,\n                    secondary: [1024 /* KeyMod.Shift */ | 1 /* KeyCode.Backspace */],\n                    mac: { primary: 1 /* KeyCode.Backspace */, secondary: [1024 /* KeyMod.Shift */ | 1 /* KeyCode.Backspace */, 256 /* KeyMod.WinCtrl */ | 38 /* KeyCode.KeyH */, 256 /* KeyMod.WinCtrl */ | 1 /* KeyCode.Backspace */] }\n                }\n            });\n        }\n        runCoreEditingCommand(editor, viewModel, args) {\n            const [shouldPushStackElementBefore, commands] = DeleteOperations.deleteLeft(viewModel.getPrevEditOperationType(), viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map(s => s.modelState.selection), viewModel.getCursorAutoClosedCharacters());\n            if (shouldPushStackElementBefore) {\n                editor.pushUndoStop();\n            }\n            editor.executeCommands(this.id, commands);\n            viewModel.setPrevEditOperationType(2 /* EditOperationType.DeletingLeft */);\n        }\n    });\n    CoreEditingCommands.DeleteRight = registerEditorCommand(new class extends CoreEditingCommand {\n        constructor() {\n            super({\n                id: 'deleteRight',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 20 /* KeyCode.Delete */,\n                    mac: { primary: 20 /* KeyCode.Delete */, secondary: [256 /* KeyMod.WinCtrl */ | 34 /* KeyCode.KeyD */, 256 /* KeyMod.WinCtrl */ | 20 /* KeyCode.Delete */] }\n                }\n            });\n        }\n        runCoreEditingCommand(editor, viewModel, args) {\n            const [shouldPushStackElementBefore, commands] = DeleteOperations.deleteRight(viewModel.getPrevEditOperationType(), viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map(s => s.modelState.selection));\n            if (shouldPushStackElementBefore) {\n                editor.pushUndoStop();\n            }\n            editor.executeCommands(this.id, commands);\n            viewModel.setPrevEditOperationType(3 /* EditOperationType.DeletingRight */);\n        }\n    });\n    CoreEditingCommands.Undo = new class extends EditorOrNativeTextInputCommand {\n        constructor() {\n            super(UndoCommand);\n        }\n        runDOMCommand() {\n            document.execCommand('undo');\n        }\n        runEditorCommand(accessor, editor, args) {\n            if (!editor.hasModel() || editor.getOption(83 /* EditorOption.readOnly */) === true) {\n                return;\n            }\n            return editor.getModel().undo();\n        }\n    }();\n    CoreEditingCommands.Redo = new class extends EditorOrNativeTextInputCommand {\n        constructor() {\n            super(RedoCommand);\n        }\n        runDOMCommand() {\n            document.execCommand('redo');\n        }\n        runEditorCommand(accessor, editor, args) {\n            if (!editor.hasModel() || editor.getOption(83 /* EditorOption.readOnly */) === true) {\n                return;\n            }\n            return editor.getModel().redo();\n        }\n    }();\n})(CoreEditingCommands || (CoreEditingCommands = {}));\n/**\n * A command that will invoke a command on the focused editor.\n */\nclass EditorHandlerCommand extends Command {\n    constructor(id, handlerId, description) {\n        super({\n            id: id,\n            precondition: undefined,\n            description: description\n        });\n        this._handlerId = handlerId;\n    }\n    runCommand(accessor, args) {\n        const editor = accessor.get(ICodeEditorService).getFocusedCodeEditor();\n        if (!editor) {\n            return;\n        }\n        editor.trigger('keyboard', this._handlerId, args);\n    }\n}\nfunction registerOverwritableCommand(handlerId, description) {\n    registerCommand(new EditorHandlerCommand('default:' + handlerId, handlerId));\n    registerCommand(new EditorHandlerCommand(handlerId, handlerId, description));\n}\nregisterOverwritableCommand(\"type\" /* Handler.Type */, {\n    description: `Type`,\n    args: [{\n            name: 'args',\n            schema: {\n                'type': 'object',\n                'required': ['text'],\n                'properties': {\n                    'text': {\n                        'type': 'string'\n                    }\n                },\n            }\n        }]\n});\nregisterOverwritableCommand(\"replacePreviousChar\" /* Handler.ReplacePreviousChar */);\nregisterOverwritableCommand(\"compositionType\" /* Handler.CompositionType */);\nregisterOverwritableCommand(\"compositionStart\" /* Handler.CompositionStart */);\nregisterOverwritableCommand(\"compositionEnd\" /* Handler.CompositionEnd */);\nregisterOverwritableCommand(\"paste\" /* Handler.Paste */);\nregisterOverwritableCommand(\"cut\" /* Handler.Cut */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { SmoothScrollableElement } from '../../../../base/browser/ui/scrollbar/scrollableElement.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { registerThemingParticipant, getThemeTypeSelector } from '../../../../platform/theme/common/themeService.js';\nimport { scrollbarShadow, scrollbarSliderActiveBackground, scrollbarSliderBackground, scrollbarSliderHoverBackground } from '../../../../platform/theme/common/colorRegistry.js';\nexport class EditorScrollbar extends ViewPart {\n    constructor(context, linesContent, viewDomNode, overflowGuardDomNode) {\n        super(context);\n        const options = this._context.configuration.options;\n        const scrollbar = options.get(94 /* EditorOption.scrollbar */);\n        const mouseWheelScrollSensitivity = options.get(69 /* EditorOption.mouseWheelScrollSensitivity */);\n        const fastScrollSensitivity = options.get(36 /* EditorOption.fastScrollSensitivity */);\n        const scrollPredominantAxis = options.get(97 /* EditorOption.scrollPredominantAxis */);\n        const scrollbarOptions = {\n            listenOnDomNode: viewDomNode.domNode,\n            className: 'editor-scrollable' + ' ' + getThemeTypeSelector(context.theme.type),\n            useShadows: false,\n            lazyRender: true,\n            vertical: scrollbar.vertical,\n            horizontal: scrollbar.horizontal,\n            verticalHasArrows: scrollbar.verticalHasArrows,\n            horizontalHasArrows: scrollbar.horizontalHasArrows,\n            verticalScrollbarSize: scrollbar.verticalScrollbarSize,\n            verticalSliderSize: scrollbar.verticalSliderSize,\n            horizontalScrollbarSize: scrollbar.horizontalScrollbarSize,\n            horizontalSliderSize: scrollbar.horizontalSliderSize,\n            handleMouseWheel: scrollbar.handleMouseWheel,\n            alwaysConsumeMouseWheel: scrollbar.alwaysConsumeMouseWheel,\n            arrowSize: scrollbar.arrowSize,\n            mouseWheelScrollSensitivity: mouseWheelScrollSensitivity,\n            fastScrollSensitivity: fastScrollSensitivity,\n            scrollPredominantAxis: scrollPredominantAxis,\n            scrollByPage: scrollbar.scrollByPage,\n        };\n        this.scrollbar = this._register(new SmoothScrollableElement(linesContent.domNode, scrollbarOptions, this._context.viewLayout.getScrollable()));\n        PartFingerprints.write(this.scrollbar.getDomNode(), 5 /* PartFingerprint.ScrollableElement */);\n        this.scrollbarDomNode = createFastDomNode(this.scrollbar.getDomNode());\n        this.scrollbarDomNode.setPosition('absolute');\n        this._setLayout();\n        // When having a zone widget that calls .focus() on one of its dom elements,\n        // the browser will try desperately to reveal that dom node, unexpectedly\n        // changing the .scrollTop of this.linesContent\n        const onBrowserDesperateReveal = (domNode, lookAtScrollTop, lookAtScrollLeft) => {\n            const newScrollPosition = {};\n            if (lookAtScrollTop) {\n                const deltaTop = domNode.scrollTop;\n                if (deltaTop) {\n                    newScrollPosition.scrollTop = this._context.viewLayout.getCurrentScrollTop() + deltaTop;\n                    domNode.scrollTop = 0;\n                }\n            }\n            if (lookAtScrollLeft) {\n                const deltaLeft = domNode.scrollLeft;\n                if (deltaLeft) {\n                    newScrollPosition.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + deltaLeft;\n                    domNode.scrollLeft = 0;\n                }\n            }\n            this._context.viewModel.viewLayout.setScrollPosition(newScrollPosition, 1 /* ScrollType.Immediate */);\n        };\n        // I've seen this happen both on the view dom node & on the lines content dom node.\n        this._register(dom.addDisposableListener(viewDomNode.domNode, 'scroll', (e) => onBrowserDesperateReveal(viewDomNode.domNode, true, true)));\n        this._register(dom.addDisposableListener(linesContent.domNode, 'scroll', (e) => onBrowserDesperateReveal(linesContent.domNode, true, false)));\n        this._register(dom.addDisposableListener(overflowGuardDomNode.domNode, 'scroll', (e) => onBrowserDesperateReveal(overflowGuardDomNode.domNode, true, false)));\n        this._register(dom.addDisposableListener(this.scrollbarDomNode.domNode, 'scroll', (e) => onBrowserDesperateReveal(this.scrollbarDomNode.domNode, true, false)));\n    }\n    dispose() {\n        super.dispose();\n    }\n    _setLayout() {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        this.scrollbarDomNode.setLeft(layoutInfo.contentLeft);\n        const minimap = options.get(67 /* EditorOption.minimap */);\n        const side = minimap.side;\n        if (side === 'right') {\n            this.scrollbarDomNode.setWidth(layoutInfo.contentWidth + layoutInfo.minimap.minimapWidth);\n        }\n        else {\n            this.scrollbarDomNode.setWidth(layoutInfo.contentWidth);\n        }\n        this.scrollbarDomNode.setHeight(layoutInfo.height);\n    }\n    getOverviewRulerLayoutInfo() {\n        return this.scrollbar.getOverviewRulerLayoutInfo();\n    }\n    getDomNode() {\n        return this.scrollbarDomNode;\n    }\n    delegateVerticalScrollbarPointerDown(browserEvent) {\n        this.scrollbar.delegateVerticalScrollbarPointerDown(browserEvent);\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        if (e.hasChanged(94 /* EditorOption.scrollbar */)\n            || e.hasChanged(69 /* EditorOption.mouseWheelScrollSensitivity */)\n            || e.hasChanged(36 /* EditorOption.fastScrollSensitivity */)) {\n            const options = this._context.configuration.options;\n            const scrollbar = options.get(94 /* EditorOption.scrollbar */);\n            const mouseWheelScrollSensitivity = options.get(69 /* EditorOption.mouseWheelScrollSensitivity */);\n            const fastScrollSensitivity = options.get(36 /* EditorOption.fastScrollSensitivity */);\n            const scrollPredominantAxis = options.get(97 /* EditorOption.scrollPredominantAxis */);\n            const newOpts = {\n                vertical: scrollbar.vertical,\n                horizontal: scrollbar.horizontal,\n                verticalScrollbarSize: scrollbar.verticalScrollbarSize,\n                horizontalScrollbarSize: scrollbar.horizontalScrollbarSize,\n                scrollByPage: scrollbar.scrollByPage,\n                handleMouseWheel: scrollbar.handleMouseWheel,\n                mouseWheelScrollSensitivity: mouseWheelScrollSensitivity,\n                fastScrollSensitivity: fastScrollSensitivity,\n                scrollPredominantAxis: scrollPredominantAxis\n            };\n            this.scrollbar.updateOptions(newOpts);\n        }\n        if (e.hasChanged(133 /* EditorOption.layoutInfo */)) {\n            this._setLayout();\n        }\n        return true;\n    }\n    onScrollChanged(e) {\n        return true;\n    }\n    onThemeChanged(e) {\n        this.scrollbar.updateClassName('editor-scrollable' + ' ' + getThemeTypeSelector(this._context.theme.type));\n        return true;\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        // Nothing to do\n    }\n    render(ctx) {\n        this.scrollbar.renderNow();\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    // Scrollbars\n    const scrollbarShadowColor = theme.getColor(scrollbarShadow);\n    if (scrollbarShadowColor) {\n        collector.addRule(`\n\t\t\t.monaco-scrollable-element > .shadow.top {\n\t\t\t\tbox-shadow: ${scrollbarShadowColor} 0 6px 6px -6px inset;\n\t\t\t}\n\n\t\t\t.monaco-scrollable-element > .shadow.left {\n\t\t\t\tbox-shadow: ${scrollbarShadowColor} 6px 0 6px -6px inset;\n\t\t\t}\n\n\t\t\t.monaco-scrollable-element > .shadow.top.left {\n\t\t\t\tbox-shadow: ${scrollbarShadowColor} 6px 6px 6px -6px inset;\n\t\t\t}\n\t\t`);\n    }\n    const scrollbarSliderBackgroundColor = theme.getColor(scrollbarSliderBackground);\n    if (scrollbarSliderBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-scrollable-element > .scrollbar > .slider {\n\t\t\t\tbackground: ${scrollbarSliderBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const scrollbarSliderHoverBackgroundColor = theme.getColor(scrollbarSliderHoverBackground);\n    if (scrollbarSliderHoverBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-scrollable-element > .scrollbar > .slider:hover {\n\t\t\t\tbackground: ${scrollbarSliderHoverBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const scrollbarSliderActiveBackgroundColor = theme.getColor(scrollbarSliderActiveBackground);\n    if (scrollbarSliderActiveBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-scrollable-element > .scrollbar > .slider.active {\n\t\t\t\tbackground: ${scrollbarSliderActiveBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './glyphMargin.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nexport class DecorationToRender {\n    constructor(startLineNumber, endLineNumber, className) {\n        this._decorationToRenderBrand = undefined;\n        this.startLineNumber = +startLineNumber;\n        this.endLineNumber = +endLineNumber;\n        this.className = String(className);\n    }\n}\nexport class DedupOverlay extends DynamicViewOverlay {\n    _render(visibleStartLineNumber, visibleEndLineNumber, decorations) {\n        const output = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            output[lineIndex] = [];\n        }\n        if (decorations.length === 0) {\n            return output;\n        }\n        decorations.sort((a, b) => {\n            if (a.className === b.className) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.endLineNumber - b.endLineNumber;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return (a.className < b.className ? -1 : 1);\n        });\n        let prevClassName = null;\n        let prevEndLineIndex = 0;\n        for (let i = 0, len = decorations.length; i < len; i++) {\n            const d = decorations[i];\n            const className = d.className;\n            let startLineIndex = Math.max(d.startLineNumber, visibleStartLineNumber) - visibleStartLineNumber;\n            const endLineIndex = Math.min(d.endLineNumber, visibleEndLineNumber) - visibleStartLineNumber;\n            if (prevClassName === className) {\n                startLineIndex = Math.max(prevEndLineIndex + 1, startLineIndex);\n                prevEndLineIndex = Math.max(prevEndLineIndex, endLineIndex);\n            }\n            else {\n                prevClassName = className;\n                prevEndLineIndex = endLineIndex;\n            }\n            for (let i = startLineIndex; i <= prevEndLineIndex; i++) {\n                output[i].push(prevClassName);\n            }\n        }\n        return output;\n    }\n}\nexport class GlyphMarginOverlay extends DedupOverlay {\n    constructor(context) {\n        super();\n        this._context = context;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        this._lineHeight = options.get(61 /* EditorOption.lineHeight */);\n        this._glyphMargin = options.get(52 /* EditorOption.glyphMargin */);\n        this._glyphMarginLeft = layoutInfo.glyphMarginLeft;\n        this._glyphMarginWidth = layoutInfo.glyphMarginWidth;\n        this._renderResult = null;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        this._renderResult = null;\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        this._lineHeight = options.get(61 /* EditorOption.lineHeight */);\n        this._glyphMargin = options.get(52 /* EditorOption.glyphMargin */);\n        this._glyphMarginLeft = layoutInfo.glyphMarginLeft;\n        this._glyphMarginWidth = layoutInfo.glyphMarginWidth;\n        return true;\n    }\n    onDecorationsChanged(e) {\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    _getDecorations(ctx) {\n        const decorations = ctx.getDecorationsInViewport();\n        const r = [];\n        let rLen = 0;\n        for (let i = 0, len = decorations.length; i < len; i++) {\n            const d = decorations[i];\n            const glyphMarginClassName = d.options.glyphMarginClassName;\n            if (glyphMarginClassName) {\n                r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, glyphMarginClassName);\n            }\n        }\n        return r;\n    }\n    prepareRender(ctx) {\n        if (!this._glyphMargin) {\n            this._renderResult = null;\n            return;\n        }\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        const toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));\n        const lineHeight = this._lineHeight.toString();\n        const left = this._glyphMarginLeft.toString();\n        const width = this._glyphMarginWidth.toString();\n        const common = '\" style=\"left:' + left + 'px;width:' + width + 'px' + ';height:' + lineHeight + 'px;\"></div>';\n        const output = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            const classNames = toRender[lineIndex];\n            if (classNames.length === 0) {\n                output[lineIndex] = '';\n            }\n            else {\n                output[lineIndex] = ('<div class=\"cgmr codicon '\n                    + classNames.join(' ')\n                    + common);\n            }\n        }\n        this._renderResult = output;\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderResult) {\n            return '';\n        }\n        const lineIndex = lineNumber - startLineNumber;\n        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n            return '';\n        }\n        return this._renderResult[lineIndex];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        if (states !== null && states.length > CursorsController.MAX_CURSOR_COUNT) {\n            states = states.slice(0, CursorsController.MAX_CURSOR_COUNT);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealPrimary(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\nCursorsController.MAX_CURSOR_COUNT = 10000;\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = new Array();\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = new Array();\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nexport function calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nexport function calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nexport function resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nexport const AverageBufferSize = 65535;\nexport function createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nexport class LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        return endOffset - startOffset;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nexport class PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (this.isBasicASCII) {\n            this.isBasicASCII = lineStarts.isBasicASCII;\n        }\n        if (!this.isBasicASCII && !this.containsRTL) {\n            // No need to check if it is basic ASCII\n            this.containsRTL = strings.containsRTL(chunk);\n        }\n        if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\n            // No need to check if it is basic ASCII\n            this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { combinedDisposable, Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    constructor(source, languageId, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._deltaDecorationCallCnt = 0;\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n    }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: guessedIndentation.tabSize,\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions({\n            tabSize: options.tabSize,\n            indentSize: options.indentSize,\n            insertSpaces: options.insertSpaces,\n            trimAutoWhitespace: options.trimAutoWhitespace,\n            defaultEOL: options.defaultEOL,\n            bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n        });\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null) {\n            // There's nothing to do\n            return;\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Flush all tokens\n        this._tokenizationTextModelPart.flush();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    onBeforeDetached() {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update tokens and decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n                this._tokenizationTextModelPart.acceptEdit(change.range, change.text, eolCount, firstLineLength, lastLineLength);\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n            // Delete + Insert due to an overview ruler status change\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        const result = new Array(newDecorationsLen);\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n            let node = null;\n            if (oldDecorationIndex < oldDecorationsLen) {\n                // (1) get ourselves an old node\n                do {\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\n                // (2) remove the node from the tree (if it exists)\n                if (node) {\n                    if (node.options.after) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                    }\n                    this._decorationsTree.delete(node);\n                    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                }\n            }\n            if (newDecorationIndex < newDecorationsLen) {\n                // (3) create a new node if necessary\n                if (!node) {\n                    const internalDecorationId = (++this._lastDecorationId);\n                    const decorationId = `${this._instanceId};${internalDecorationId}`;\n                    node = new IntervalNode(decorationId, 0, 0);\n                    this._decorations[decorationId] = node;\n                }\n                // (4) initialize node\n                const newDecoration = newDecorations[newDecorationIndex];\n                const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                const options = _normalizeOptions(newDecoration.options);\n                const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                node.ownerId = ownerId;\n                node.reset(versionId, startOffset, endOffset, range);\n                node.setOptions(options);\n                if (node.options.after) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                }\n                if (node.options.before) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                }\n                this._onDidChangeDecorations.checkAffectedAndFire(options);\n                this._decorationsTree.insert(node);\n                result[newDecorationIndex] = node.id;\n                newDecorationIndex++;\n            }\n            else {\n                if (node) {\n                    delete this._decorations[node.id];\n                }\n            }\n        }\n        return result;\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setMode(languageId) {\n        this.tokenization.setLanguageId(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n};\nTextModel = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService)\n], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n}\nexport class ModelDecorationOptions {\n    constructor(options) {\n        var _a, _b;\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = (_a = options.hideInCommentTokens) !== null && _a !== void 0 ? _a : false;\n        this.hideInStringTokens = (_b = options.hideInStringTokens) !== null && _b !== void 0 ? _b : false;\n    }\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nexport class DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        var _a;\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFire) {\n                this.handleBeforeFire(this._affectedInjectedTextLines);\n                const event = {\n                    affectsMinimap: this._affectsMinimap,\n                    affectsOverviewRuler: this._affectsOverviewRuler\n                };\n                this._shouldFire = false;\n                this._affectsMinimap = false;\n                this._affectsOverviewRuler = false;\n                this._actual.fire(event);\n            }\n            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        if (!this._affectsMinimap) {\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n        }\n        if (!this._affectsOverviewRuler) {\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n        }\n        this._shouldFire = true;\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._shouldFire = true;\n    }\n}\n//#endregion\nexport class DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._themeService = _themeService;\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStart = ViewportStart.create(this.model);\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n            const wrappingStrategy = options.get(127 /* EditorOption.wrappingStrategy */);\n            const wrappingInfo = options.get(134 /* EditorOption.wrappingInfo */);\n            const wrappingIndent = options.get(126 /* EditorOption.wrappingIndent */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            if (e.scrollTopChanged) {\n                this._viewportStart.invalidate();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._register(this._themeService.onDidColorThemeChange((theme) => {\n            this._invalidateDecorationsColorCache();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this._viewportStart.dispose();\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    tokenizeViewport() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        for (const modelVisibleRange of modelVisibleRanges) {\n            this.model.tokenization.tokenizeViewport(modelVisibleRange.startLineNumber, modelVisibleRange.endLineNumber);\n        }\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        // We might need to restore the current centered view range, so save it (if available)\n        let previousViewportStartModelPosition = null;\n        if (this._viewportStart.isValid) {\n            const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n            previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n        }\n        let restorePreviousViewportStart = false;\n        const options = this._configuration.options;\n        const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n        const wrappingStrategy = options.get(127 /* EditorOption.wrappingStrategy */);\n        const wrappingInfo = options.get(134 /* EditorOption.wrappingInfo */);\n        const wrappingIndent = options.get(126 /* EditorOption.wrappingIndent */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            if (this.viewLayout.getCurrentScrollTop() !== 0) {\n                // Never change the scroll position from 0 to something else...\n                restorePreviousViewportStart = true;\n            }\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(83 /* EditorOption.readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n            const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n            const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n            this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n        }\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes);\n                const versionId = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* textModelEvents.RawContentChangedType.Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* textModelEvents.RawContentChangedType.EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            const viewportStartWasValid = this._viewportStart.isValid;\n            this._viewportStart.invalidate();\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n                const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n                    eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n                }\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._tokenizeViewportSoon.schedule();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            if (e.tokenizationSupportChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges) {\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(ranges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(133 /* EditorOption.layoutInfo */);\n        const lineHeight = this._configuration.options.get(61 /* EditorOption.lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    getHiddenAreas() {\n        return this._lines.getHiddenAreas();\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStart.update(this, startLineNumber);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewportViewLineRenderingData(visibleRange, lineNumber) {\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    getViewLineRenderingData(lineNumber) {\n        const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    _getViewLineRenderingData(lineNumber, inlineDecorations) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    _invalidateDecorationsColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts1 = decoration.options.overviewRuler;\n            if (opts1) {\n                opts1.invalidateCachedColor();\n            }\n            const opts2 = decoration.options.minimap;\n            if (opts2) {\n                opts2.invalidateCachedColor();\n            }\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(46 /* EditorOption.fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* CursorChangeReason.NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            return callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass ViewportStart {\n    constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n        this._model = _model;\n        this._viewLineNumber = _viewLineNumber;\n        this._isValid = _isValid;\n        this._modelTrackedRange = _modelTrackedRange;\n        this._startLineDelta = _startLineDelta;\n    }\n    static create(model) {\n        const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n    }\n    get viewLineNumber() {\n        return this._viewLineNumber;\n    }\n    get isValid() {\n        return this._isValid;\n    }\n    get modelTrackedRange() {\n        return this._modelTrackedRange;\n    }\n    get startLineDelta() {\n        return this._startLineDelta;\n    }\n    dispose() {\n        this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    }\n    update(viewModel, startLineNumber) {\n        const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n        const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n        this._viewLineNumber = startLineNumber;\n        this._isValid = true;\n        this._modelTrackedRange = viewportStartLineTrackedRange;\n        this._startLineDelta = scrollTop - viewportStartLineTop;\n    }\n    invalidate() {\n        this._isValid = false;\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport '../services/markerDecorations.js';\nimport './media/editor.css';\nimport * as nls from '../../../nls.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, EventDeliveryQueue } from '../../../base/common/event.js';\nimport { Disposable, dispose } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { EditorConfiguration } from '../config/editorConfiguration.js';\nimport { EditorExtensionsRegistry } from '../editorExtensions.js';\nimport { ICodeEditorService } from '../services/codeEditorService.js';\nimport { View } from '../view.js';\nimport { ViewUserInputEvents } from '../view/viewUserInputEvents.js';\nimport { filterValidationDecorations } from '../../common/config/editorOptions.js';\nimport { CursorsController } from '../../common/cursor/cursor.js';\nimport { CursorColumns } from '../../common/core/cursorColumns.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { InternalEditorAction } from '../../common/editorAction.js';\nimport * as editorCommon from '../../common/editorCommon.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\nimport { editorUnnecessaryCodeBorder, editorUnnecessaryCodeOpacity } from '../../common/core/editorColorRegistry.js';\nimport { editorErrorBorder, editorErrorForeground, editorHintBorder, editorHintForeground, editorInfoBorder, editorInfoForeground, editorWarningBorder, editorWarningForeground, editorForeground, editorErrorBackground, editorInfoBackground, editorWarningBackground } from '../../../platform/theme/common/colorRegistry.js';\nimport { ViewModel } from '../../common/viewModel/viewModelImpl.js';\nimport { ICommandService } from '../../../platform/commands/common/commands.js';\nimport { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { INotificationService } from '../../../platform/notification/common/notification.js';\nimport { IThemeService, registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { withNullAsUndefined } from '../../../base/common/types.js';\nimport { MonospaceLineBreaksComputerFactory } from '../../common/viewModel/monospaceLineBreaksComputer.js';\nimport { DOMLineBreaksComputerFactory } from '../view/domLineBreaksComputer.js';\nimport { WordOperations } from '../../common/cursor/cursorWordOperations.js';\nimport { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';\nlet EDITOR_ID = 0;\nclass ModelData {\n    constructor(model, viewModel, view, hasRealView, listenersToRemove) {\n        this.model = model;\n        this.viewModel = viewModel;\n        this.view = view;\n        this.hasRealView = hasRealView;\n        this.listenersToRemove = listenersToRemove;\n    }\n    dispose() {\n        dispose(this.listenersToRemove);\n        this.model.onBeforeDetached();\n        if (this.hasRealView) {\n            this.view.dispose();\n        }\n        this.viewModel.dispose();\n    }\n}\nlet CodeEditorWidget = class CodeEditorWidget extends Disposable {\n    constructor(domElement, _options, codeEditorWidgetOptions, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        //#region Eventing\n        this._deliveryQueue = new EventDeliveryQueue();\n        this._onDidDispose = this._register(new Emitter());\n        this.onDidDispose = this._onDidDispose.event;\n        this._onDidChangeModelContent = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelContent = this._onDidChangeModelContent.event;\n        this._onDidChangeModelLanguage = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event;\n        this._onDidChangeModelLanguageConfiguration = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event;\n        this._onDidChangeModelOptions = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelOptions = this._onDidChangeModelOptions.event;\n        this._onDidChangeModelDecorations = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event;\n        this._onDidChangeModelTokens = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelTokens = this._onDidChangeModelTokens.event;\n        this._onDidChangeConfiguration = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;\n        this._onDidChangeModel = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModel = this._onDidChangeModel.event;\n        this._onDidChangeCursorPosition = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event;\n        this._onDidChangeCursorSelection = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event;\n        this._onDidAttemptReadOnlyEdit = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event;\n        this._onDidLayoutChange = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidLayoutChange = this._onDidLayoutChange.event;\n        this._editorTextFocus = this._register(new BooleanEventEmitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue;\n        this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse;\n        this._editorWidgetFocus = this._register(new BooleanEventEmitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue;\n        this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse;\n        this._onWillType = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onWillType = this._onWillType.event;\n        this._onDidType = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidType = this._onDidType.event;\n        this._onDidCompositionStart = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidCompositionStart = this._onDidCompositionStart.event;\n        this._onDidCompositionEnd = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidCompositionEnd = this._onDidCompositionEnd.event;\n        this._onDidPaste = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidPaste = this._onDidPaste.event;\n        this._onMouseUp = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onMouseUp = this._onMouseUp.event;\n        this._onMouseDown = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onMouseDown = this._onMouseDown.event;\n        this._onMouseDrag = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onMouseDrag = this._onMouseDrag.event;\n        this._onMouseDrop = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onMouseDrop = this._onMouseDrop.event;\n        this._onMouseDropCanceled = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onMouseDropCanceled = this._onMouseDropCanceled.event;\n        this._onDropIntoEditor = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDropIntoEditor = this._onDropIntoEditor.event;\n        this._onContextMenu = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onContextMenu = this._onContextMenu.event;\n        this._onMouseMove = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onMouseMove = this._onMouseMove.event;\n        this._onMouseLeave = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onMouseLeave = this._onMouseLeave.event;\n        this._onMouseWheel = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onMouseWheel = this._onMouseWheel.event;\n        this._onKeyUp = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onKeyUp = this._onKeyUp.event;\n        this._onKeyDown = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onKeyDown = this._onKeyDown.event;\n        this._onDidContentSizeChange = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._onDidScrollChange = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidScrollChange = this._onDidScrollChange.event;\n        this._onDidChangeViewZones = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeViewZones = this._onDidChangeViewZones.event;\n        this._onDidChangeHiddenAreas = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeHiddenAreas = this._onDidChangeHiddenAreas.event;\n        this._bannerDomNode = null;\n        this._dropIntoEditorDecorations = this.createDecorationsCollection();\n        const options = Object.assign({}, _options);\n        this._domElement = domElement;\n        this._overflowWidgetsDomNode = options.overflowWidgetsDomNode;\n        delete options.overflowWidgetsDomNode;\n        this._id = (++EDITOR_ID);\n        this._decorationTypeKeysToIds = {};\n        this._decorationTypeSubtypes = {};\n        this._telemetryData = codeEditorWidgetOptions.telemetryData;\n        this._configuration = this._register(this._createConfiguration(codeEditorWidgetOptions.isSimpleWidget || false, options, accessibilityService));\n        this._register(this._configuration.onDidChange((e) => {\n            this._onDidChangeConfiguration.fire(e);\n            const options = this._configuration.options;\n            if (e.hasChanged(133 /* EditorOption.layoutInfo */)) {\n                const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n                this._onDidLayoutChange.fire(layoutInfo);\n            }\n        }));\n        this._contextKeyService = this._register(contextKeyService.createScoped(this._domElement));\n        this._notificationService = notificationService;\n        this._codeEditorService = codeEditorService;\n        this._commandService = commandService;\n        this._themeService = themeService;\n        this._register(new EditorContextKeysManager(this, this._contextKeyService));\n        this._register(new EditorModeContext(this, this._contextKeyService, languageFeaturesService));\n        this._instantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));\n        this._modelData = null;\n        this._contributions = {};\n        this._actions = {};\n        this._focusTracker = new CodeEditorWidgetFocusTracker(domElement);\n        this._register(this._focusTracker.onChange(() => {\n            this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());\n        }));\n        this._contentWidgets = {};\n        this._overlayWidgets = {};\n        let contributions;\n        if (Array.isArray(codeEditorWidgetOptions.contributions)) {\n            contributions = codeEditorWidgetOptions.contributions;\n        }\n        else {\n            contributions = EditorExtensionsRegistry.getEditorContributions();\n        }\n        for (const desc of contributions) {\n            if (this._contributions[desc.id]) {\n                onUnexpectedError(new Error(`Cannot have two contributions with the same id ${desc.id}`));\n                continue;\n            }\n            try {\n                const contribution = this._instantiationService.createInstance(desc.ctor, this);\n                this._contributions[desc.id] = contribution;\n            }\n            catch (err) {\n                onUnexpectedError(err);\n            }\n        }\n        EditorExtensionsRegistry.getEditorActions().forEach((action) => {\n            if (this._actions[action.id]) {\n                onUnexpectedError(new Error(`Cannot have two actions with the same id ${action.id}`));\n                return;\n            }\n            const internalAction = new InternalEditorAction(action.id, action.label, action.alias, withNullAsUndefined(action.precondition), () => {\n                return this._instantiationService.invokeFunction((accessor) => {\n                    return Promise.resolve(action.runEditorCommand(accessor, this, null));\n                });\n            }, this._contextKeyService);\n            this._actions[internalAction.id] = internalAction;\n        });\n        const isDropIntoEnabled = () => {\n            return !this._configuration.options.get(83 /* EditorOption.readOnly */)\n                && this._configuration.options.get(32 /* EditorOption.dropIntoEditor */).enabled;\n        };\n        this._register(new dom.DragAndDropObserver(this._domElement, {\n            onDragEnter: () => undefined,\n            onDragOver: e => {\n                if (!isDropIntoEnabled()) {\n                    return;\n                }\n                const target = this.getTargetAtClientPoint(e.clientX, e.clientY);\n                if (target === null || target === void 0 ? void 0 : target.position) {\n                    this.showDropIndicatorAt(target.position);\n                }\n            },\n            onDrop: (e) => __awaiter(this, void 0, void 0, function* () {\n                if (!isDropIntoEnabled()) {\n                    return;\n                }\n                this.removeDropIndicator();\n                if (!e.dataTransfer) {\n                    return;\n                }\n                const target = this.getTargetAtClientPoint(e.clientX, e.clientY);\n                if (target === null || target === void 0 ? void 0 : target.position) {\n                    this._onDropIntoEditor.fire({ position: target.position, event: e });\n                }\n            }),\n            onDragLeave: () => {\n                this.removeDropIndicator();\n            },\n            onDragEnd: () => {\n                this.removeDropIndicator();\n            },\n        }));\n        this._codeEditorService.addCodeEditor(this);\n    }\n    //#endregion\n    get isSimpleWidget() {\n        return this._configuration.isSimpleWidget;\n    }\n    _createConfiguration(isSimpleWidget, options, accessibilityService) {\n        return new EditorConfiguration(isSimpleWidget, options, this._domElement, accessibilityService);\n    }\n    getId() {\n        return this.getEditorType() + ':' + this._id;\n    }\n    getEditorType() {\n        return editorCommon.EditorType.ICodeEditor;\n    }\n    dispose() {\n        this._codeEditorService.removeCodeEditor(this);\n        this._focusTracker.dispose();\n        const keys = Object.keys(this._contributions);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const contributionId = keys[i];\n            this._contributions[contributionId].dispose();\n        }\n        this._contributions = {};\n        this._actions = {};\n        this._contentWidgets = {};\n        this._overlayWidgets = {};\n        this._removeDecorationTypes();\n        this._postDetachModelCleanup(this._detachModel());\n        this._onDidDispose.fire();\n        super.dispose();\n    }\n    invokeWithinContext(fn) {\n        return this._instantiationService.invokeFunction(fn);\n    }\n    updateOptions(newOptions) {\n        this._configuration.updateOptions(newOptions || {});\n    }\n    getOptions() {\n        return this._configuration.options;\n    }\n    getOption(id) {\n        return this._configuration.options.get(id);\n    }\n    getRawOptions() {\n        return this._configuration.getRawOptions();\n    }\n    getOverflowWidgetsDomNode() {\n        return this._overflowWidgetsDomNode;\n    }\n    getConfiguredWordAtPosition(position) {\n        if (!this._modelData) {\n            return null;\n        }\n        return WordOperations.getWordAtPosition(this._modelData.model, this._configuration.options.get(119 /* EditorOption.wordSeparators */), position);\n    }\n    getValue(options = null) {\n        if (!this._modelData) {\n            return '';\n        }\n        const preserveBOM = (options && options.preserveBOM) ? true : false;\n        let eolPreference = 0 /* EndOfLinePreference.TextDefined */;\n        if (options && options.lineEnding && options.lineEnding === '\\n') {\n            eolPreference = 1 /* EndOfLinePreference.LF */;\n        }\n        else if (options && options.lineEnding && options.lineEnding === '\\r\\n') {\n            eolPreference = 2 /* EndOfLinePreference.CRLF */;\n        }\n        return this._modelData.model.getValue(eolPreference, preserveBOM);\n    }\n    setValue(newValue) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.model.setValue(newValue);\n    }\n    getModel() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.model;\n    }\n    setModel(_model = null) {\n        const model = _model;\n        if (this._modelData === null && model === null) {\n            // Current model is the new model\n            return;\n        }\n        if (this._modelData && this._modelData.model === model) {\n            // Current model is the new model\n            return;\n        }\n        const hasTextFocus = this.hasTextFocus();\n        const detachedModel = this._detachModel();\n        this._attachModel(model);\n        if (hasTextFocus && this.hasModel()) {\n            this.focus();\n        }\n        const e = {\n            oldModelUrl: detachedModel ? detachedModel.uri : null,\n            newModelUrl: model ? model.uri : null\n        };\n        this._removeDecorationTypes();\n        this._onDidChangeModel.fire(e);\n        this._postDetachModelCleanup(detachedModel);\n    }\n    _removeDecorationTypes() {\n        this._decorationTypeKeysToIds = {};\n        if (this._decorationTypeSubtypes) {\n            for (const decorationType in this._decorationTypeSubtypes) {\n                const subTypes = this._decorationTypeSubtypes[decorationType];\n                for (const subType in subTypes) {\n                    this._removeDecorationType(decorationType + '-' + subType);\n                }\n            }\n            this._decorationTypeSubtypes = {};\n        }\n    }\n    getVisibleRanges() {\n        if (!this._modelData) {\n            return [];\n        }\n        return this._modelData.viewModel.getVisibleRanges();\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        if (!this._modelData) {\n            return [];\n        }\n        return this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow();\n    }\n    getWhitespaces() {\n        if (!this._modelData) {\n            return [];\n        }\n        return this._modelData.viewModel.viewLayout.getWhitespaces();\n    }\n    static _getVerticalOffsetAfterPosition(modelData, modelLineNumber, modelColumn, includeViewZones) {\n        const modelPosition = modelData.model.validatePosition({\n            lineNumber: modelLineNumber,\n            column: modelColumn\n        });\n        const viewPosition = modelData.viewModel.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        return modelData.viewModel.viewLayout.getVerticalOffsetAfterLineNumber(viewPosition.lineNumber, includeViewZones);\n    }\n    getTopForLineNumber(lineNumber, includeViewZones = false) {\n        if (!this._modelData) {\n            return -1;\n        }\n        return CodeEditorWidget._getVerticalOffsetForPosition(this._modelData, lineNumber, 1, includeViewZones);\n    }\n    getTopForPosition(lineNumber, column) {\n        if (!this._modelData) {\n            return -1;\n        }\n        return CodeEditorWidget._getVerticalOffsetForPosition(this._modelData, lineNumber, column, false);\n    }\n    static _getVerticalOffsetForPosition(modelData, modelLineNumber, modelColumn, includeViewZones = false) {\n        const modelPosition = modelData.model.validatePosition({\n            lineNumber: modelLineNumber,\n            column: modelColumn\n        });\n        const viewPosition = modelData.viewModel.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        return modelData.viewModel.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber, includeViewZones);\n    }\n    getBottomForLineNumber(lineNumber, includeViewZones = false) {\n        if (!this._modelData) {\n            return -1;\n        }\n        return CodeEditorWidget._getVerticalOffsetAfterPosition(this._modelData, lineNumber, 1, includeViewZones);\n    }\n    setHiddenAreas(ranges) {\n        var _a;\n        (_a = this._modelData) === null || _a === void 0 ? void 0 : _a.viewModel.setHiddenAreas(ranges.map(r => Range.lift(r)));\n    }\n    getVisibleColumnFromPosition(rawPosition) {\n        if (!this._modelData) {\n            return rawPosition.column;\n        }\n        const position = this._modelData.model.validatePosition(rawPosition);\n        const tabSize = this._modelData.model.getOptions().tabSize;\n        return CursorColumns.visibleColumnFromColumn(this._modelData.model.getLineContent(position.lineNumber), position.column, tabSize) + 1;\n    }\n    getPosition() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel.getPosition();\n    }\n    setPosition(position, source = 'api') {\n        if (!this._modelData) {\n            return;\n        }\n        if (!Position.isIPosition(position)) {\n            throw new Error('Invalid arguments');\n        }\n        this._modelData.viewModel.setSelections(source, [{\n                selectionStartLineNumber: position.lineNumber,\n                selectionStartColumn: position.column,\n                positionLineNumber: position.lineNumber,\n                positionColumn: position.column\n            }]);\n    }\n    _sendRevealRange(modelRange, verticalType, revealHorizontal, scrollType) {\n        if (!this._modelData) {\n            return;\n        }\n        if (!Range.isIRange(modelRange)) {\n            throw new Error('Invalid arguments');\n        }\n        const validatedModelRange = this._modelData.model.validateRange(modelRange);\n        const viewRange = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(validatedModelRange);\n        this._modelData.viewModel.revealRange('api', revealHorizontal, viewRange, verticalType, scrollType);\n    }\n    revealLine(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLine(lineNumber, 0 /* VerticalRevealType.Simple */, scrollType);\n    }\n    revealLineInCenter(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLine(lineNumber, 1 /* VerticalRevealType.Center */, scrollType);\n    }\n    revealLineInCenterIfOutsideViewport(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLine(lineNumber, 2 /* VerticalRevealType.CenterIfOutsideViewport */, scrollType);\n    }\n    revealLineNearTop(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLine(lineNumber, 5 /* VerticalRevealType.NearTop */, scrollType);\n    }\n    _revealLine(lineNumber, revealType, scrollType) {\n        if (typeof lineNumber !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(new Range(lineNumber, 1, lineNumber, 1), revealType, false, scrollType);\n    }\n    revealPosition(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealPosition(position, 0 /* VerticalRevealType.Simple */, true, scrollType);\n    }\n    revealPositionInCenter(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealPosition(position, 1 /* VerticalRevealType.Center */, true, scrollType);\n    }\n    revealPositionInCenterIfOutsideViewport(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealPosition(position, 2 /* VerticalRevealType.CenterIfOutsideViewport */, true, scrollType);\n    }\n    revealPositionNearTop(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealPosition(position, 5 /* VerticalRevealType.NearTop */, true, scrollType);\n    }\n    _revealPosition(position, verticalType, revealHorizontal, scrollType) {\n        if (!Position.isIPosition(position)) {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(new Range(position.lineNumber, position.column, position.lineNumber, position.column), verticalType, revealHorizontal, scrollType);\n    }\n    getSelection() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel.getSelection();\n    }\n    getSelections() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel.getSelections();\n    }\n    setSelection(something, source = 'api') {\n        const isSelection = Selection.isISelection(something);\n        const isRange = Range.isIRange(something);\n        if (!isSelection && !isRange) {\n            throw new Error('Invalid arguments');\n        }\n        if (isSelection) {\n            this._setSelectionImpl(something, source);\n        }\n        else if (isRange) {\n            // act as if it was an IRange\n            const selection = {\n                selectionStartLineNumber: something.startLineNumber,\n                selectionStartColumn: something.startColumn,\n                positionLineNumber: something.endLineNumber,\n                positionColumn: something.endColumn\n            };\n            this._setSelectionImpl(selection, source);\n        }\n    }\n    _setSelectionImpl(sel, source) {\n        if (!this._modelData) {\n            return;\n        }\n        const selection = new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n        this._modelData.viewModel.setSelections(source, [selection]);\n    }\n    revealLines(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 0 /* VerticalRevealType.Simple */, scrollType);\n    }\n    revealLinesInCenter(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 1 /* VerticalRevealType.Center */, scrollType);\n    }\n    revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 2 /* VerticalRevealType.CenterIfOutsideViewport */, scrollType);\n    }\n    revealLinesNearTop(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 5 /* VerticalRevealType.NearTop */, scrollType);\n    }\n    _revealLines(startLineNumber, endLineNumber, verticalType, scrollType) {\n        if (typeof startLineNumber !== 'number' || typeof endLineNumber !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(new Range(startLineNumber, 1, endLineNumber, 1), verticalType, false, scrollType);\n    }\n    revealRange(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */, revealVerticalInCenter = false, revealHorizontal = true) {\n        this._revealRange(range, revealVerticalInCenter ? 1 /* VerticalRevealType.Center */ : 0 /* VerticalRevealType.Simple */, revealHorizontal, scrollType);\n    }\n    revealRangeInCenter(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealRange(range, 1 /* VerticalRevealType.Center */, true, scrollType);\n    }\n    revealRangeInCenterIfOutsideViewport(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealRange(range, 2 /* VerticalRevealType.CenterIfOutsideViewport */, true, scrollType);\n    }\n    revealRangeNearTop(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealRange(range, 5 /* VerticalRevealType.NearTop */, true, scrollType);\n    }\n    revealRangeNearTopIfOutsideViewport(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealRange(range, 6 /* VerticalRevealType.NearTopIfOutsideViewport */, true, scrollType);\n    }\n    revealRangeAtTop(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealRange(range, 3 /* VerticalRevealType.Top */, true, scrollType);\n    }\n    _revealRange(range, verticalType, revealHorizontal, scrollType) {\n        if (!Range.isIRange(range)) {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(Range.lift(range), verticalType, revealHorizontal, scrollType);\n    }\n    setSelections(ranges, source = 'api', reason = 0 /* CursorChangeReason.NotSet */) {\n        if (!this._modelData) {\n            return;\n        }\n        if (!ranges || ranges.length === 0) {\n            throw new Error('Invalid arguments');\n        }\n        for (let i = 0, len = ranges.length; i < len; i++) {\n            if (!Selection.isISelection(ranges[i])) {\n                throw new Error('Invalid arguments');\n            }\n        }\n        this._modelData.viewModel.setSelections(source, ranges, reason);\n    }\n    getContentWidth() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getContentWidth();\n    }\n    getScrollWidth() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getScrollWidth();\n    }\n    getScrollLeft() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getCurrentScrollLeft();\n    }\n    getContentHeight() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getContentHeight();\n    }\n    getScrollHeight() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getScrollHeight();\n    }\n    getScrollTop() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getCurrentScrollTop();\n    }\n    setScrollLeft(newScrollLeft, scrollType = 1 /* editorCommon.ScrollType.Immediate */) {\n        if (!this._modelData) {\n            return;\n        }\n        if (typeof newScrollLeft !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._modelData.viewModel.viewLayout.setScrollPosition({\n            scrollLeft: newScrollLeft\n        }, scrollType);\n    }\n    setScrollTop(newScrollTop, scrollType = 1 /* editorCommon.ScrollType.Immediate */) {\n        if (!this._modelData) {\n            return;\n        }\n        if (typeof newScrollTop !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._modelData.viewModel.viewLayout.setScrollPosition({\n            scrollTop: newScrollTop\n        }, scrollType);\n    }\n    setScrollPosition(position, scrollType = 1 /* editorCommon.ScrollType.Immediate */) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.viewLayout.setScrollPosition(position, scrollType);\n    }\n    saveViewState() {\n        if (!this._modelData) {\n            return null;\n        }\n        const contributionsState = {};\n        const keys = Object.keys(this._contributions);\n        for (const id of keys) {\n            const contribution = this._contributions[id];\n            if (typeof contribution.saveViewState === 'function') {\n                contributionsState[id] = contribution.saveViewState();\n            }\n        }\n        const cursorState = this._modelData.viewModel.saveCursorState();\n        const viewState = this._modelData.viewModel.saveState();\n        return {\n            cursorState: cursorState,\n            viewState: viewState,\n            contributionsState: contributionsState\n        };\n    }\n    restoreViewState(s) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        const codeEditorState = s;\n        if (codeEditorState && codeEditorState.cursorState && codeEditorState.viewState) {\n            const cursorState = codeEditorState.cursorState;\n            if (Array.isArray(cursorState)) {\n                if (cursorState.length > 0) {\n                    this._modelData.viewModel.restoreCursorState(cursorState);\n                }\n            }\n            else {\n                // Backwards compatibility\n                this._modelData.viewModel.restoreCursorState([cursorState]);\n            }\n            const contributionsState = codeEditorState.contributionsState || {};\n            const keys = Object.keys(this._contributions);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const id = keys[i];\n                const contribution = this._contributions[id];\n                if (typeof contribution.restoreViewState === 'function') {\n                    contribution.restoreViewState(contributionsState[id]);\n                }\n            }\n            const reducedState = this._modelData.viewModel.reduceRestoreState(codeEditorState.viewState);\n            this._modelData.view.restoreState(reducedState);\n        }\n    }\n    getContribution(id) {\n        return (this._contributions[id] || null);\n    }\n    getActions() {\n        const result = [];\n        const keys = Object.keys(this._actions);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const id = keys[i];\n            result.push(this._actions[id]);\n        }\n        return result;\n    }\n    getSupportedActions() {\n        let result = this.getActions();\n        result = result.filter(action => action.isSupported());\n        return result;\n    }\n    getAction(id) {\n        return this._actions[id] || null;\n    }\n    trigger(source, handlerId, payload) {\n        payload = payload || {};\n        switch (handlerId) {\n            case \"compositionStart\" /* editorCommon.Handler.CompositionStart */:\n                this._startComposition();\n                return;\n            case \"compositionEnd\" /* editorCommon.Handler.CompositionEnd */:\n                this._endComposition(source);\n                return;\n            case \"type\" /* editorCommon.Handler.Type */: {\n                const args = payload;\n                this._type(source, args.text || '');\n                return;\n            }\n            case \"replacePreviousChar\" /* editorCommon.Handler.ReplacePreviousChar */: {\n                const args = payload;\n                this._compositionType(source, args.text || '', args.replaceCharCnt || 0, 0, 0);\n                return;\n            }\n            case \"compositionType\" /* editorCommon.Handler.CompositionType */: {\n                const args = payload;\n                this._compositionType(source, args.text || '', args.replacePrevCharCnt || 0, args.replaceNextCharCnt || 0, args.positionDelta || 0);\n                return;\n            }\n            case \"paste\" /* editorCommon.Handler.Paste */: {\n                const args = payload;\n                this._paste(source, args.text || '', args.pasteOnNewLine || false, args.multicursorText || null, args.mode || null);\n                return;\n            }\n            case \"cut\" /* editorCommon.Handler.Cut */:\n                this._cut(source);\n                return;\n        }\n        const action = this.getAction(handlerId);\n        if (action) {\n            Promise.resolve(action.run()).then(undefined, onUnexpectedError);\n            return;\n        }\n        if (!this._modelData) {\n            return;\n        }\n        if (this._triggerEditorCommand(source, handlerId, payload)) {\n            return;\n        }\n        this._triggerCommand(handlerId, payload);\n    }\n    _triggerCommand(handlerId, payload) {\n        this._commandService.executeCommand(handlerId, payload);\n    }\n    _startComposition() {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.startComposition();\n        this._onDidCompositionStart.fire();\n    }\n    _endComposition(source) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.endComposition(source);\n        this._onDidCompositionEnd.fire();\n    }\n    _type(source, text) {\n        if (!this._modelData || text.length === 0) {\n            return;\n        }\n        if (source === 'keyboard') {\n            this._onWillType.fire(text);\n        }\n        this._modelData.viewModel.type(text, source);\n        if (source === 'keyboard') {\n            this._onDidType.fire(text);\n        }\n    }\n    _compositionType(source, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source);\n    }\n    _paste(source, text, pasteOnNewLine, multicursorText, mode) {\n        if (!this._modelData || text.length === 0) {\n            return;\n        }\n        const viewModel = this._modelData.viewModel;\n        const startPosition = viewModel.getSelection().getStartPosition();\n        viewModel.paste(text, pasteOnNewLine, multicursorText, source);\n        const endPosition = viewModel.getSelection().getStartPosition();\n        if (source === 'keyboard') {\n            this._onDidPaste.fire({\n                range: new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column),\n                languageId: mode\n            });\n        }\n    }\n    _cut(source) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.cut(source);\n    }\n    _triggerEditorCommand(source, handlerId, payload) {\n        const command = EditorExtensionsRegistry.getEditorCommand(handlerId);\n        if (command) {\n            payload = payload || {};\n            payload.source = source;\n            this._instantiationService.invokeFunction((accessor) => {\n                Promise.resolve(command.runEditorCommand(accessor, this, payload)).then(undefined, onUnexpectedError);\n            });\n            return true;\n        }\n        return false;\n    }\n    _getViewModel() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel;\n    }\n    pushUndoStop() {\n        if (!this._modelData) {\n            return false;\n        }\n        if (this._configuration.options.get(83 /* EditorOption.readOnly */)) {\n            // read only editor => sorry!\n            return false;\n        }\n        this._modelData.model.pushStackElement();\n        return true;\n    }\n    popUndoStop() {\n        if (!this._modelData) {\n            return false;\n        }\n        if (this._configuration.options.get(83 /* EditorOption.readOnly */)) {\n            // read only editor => sorry!\n            return false;\n        }\n        this._modelData.model.popStackElement();\n        return true;\n    }\n    executeEdits(source, edits, endCursorState) {\n        if (!this._modelData) {\n            return false;\n        }\n        if (this._configuration.options.get(83 /* EditorOption.readOnly */)) {\n            // read only editor => sorry!\n            return false;\n        }\n        let cursorStateComputer;\n        if (!endCursorState) {\n            cursorStateComputer = () => null;\n        }\n        else if (Array.isArray(endCursorState)) {\n            cursorStateComputer = () => endCursorState;\n        }\n        else {\n            cursorStateComputer = endCursorState;\n        }\n        this._modelData.viewModel.executeEdits(source, edits, cursorStateComputer);\n        return true;\n    }\n    executeCommand(source, command) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.executeCommand(command, source);\n    }\n    executeCommands(source, commands) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.executeCommands(commands, source);\n    }\n    createDecorationsCollection(decorations) {\n        return new EditorDecorationsCollection(this, decorations);\n    }\n    changeDecorations(callback) {\n        if (!this._modelData) {\n            // callback will not be called\n            return null;\n        }\n        return this._modelData.model.changeDecorations(callback, this._id);\n    }\n    getLineDecorations(lineNumber) {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.model.getLineDecorations(lineNumber, this._id, filterValidationDecorations(this._configuration.options));\n    }\n    getDecorationsInRange(range) {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.model.getDecorationsInRange(range, this._id, filterValidationDecorations(this._configuration.options));\n    }\n    /**\n     * @deprecated\n     */\n    deltaDecorations(oldDecorations, newDecorations) {\n        if (!this._modelData) {\n            return [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            return oldDecorations;\n        }\n        return this._modelData.model.deltaDecorations(oldDecorations, newDecorations, this._id);\n    }\n    removeDecorations(decorationIds) {\n        if (!this._modelData || decorationIds.length === 0) {\n            return;\n        }\n        this._modelData.model.changeDecorations((changeAccessor) => {\n            changeAccessor.deltaDecorations(decorationIds, []);\n        });\n    }\n    removeDecorationsByType(decorationTypeKey) {\n        // remove decorations for type and sub type\n        const oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey];\n        if (oldDecorationsIds) {\n            this.deltaDecorations(oldDecorationsIds, []);\n        }\n        if (this._decorationTypeKeysToIds.hasOwnProperty(decorationTypeKey)) {\n            delete this._decorationTypeKeysToIds[decorationTypeKey];\n        }\n        if (this._decorationTypeSubtypes.hasOwnProperty(decorationTypeKey)) {\n            delete this._decorationTypeSubtypes[decorationTypeKey];\n        }\n    }\n    getLayoutInfo() {\n        const options = this._configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        return layoutInfo;\n    }\n    createOverviewRuler(cssClassName) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        return this._modelData.view.createOverviewRuler(cssClassName);\n    }\n    getContainerDomNode() {\n        return this._domElement;\n    }\n    getDomNode() {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        return this._modelData.view.domNode.domNode;\n    }\n    delegateVerticalScrollbarPointerDown(browserEvent) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.delegateVerticalScrollbarPointerDown(browserEvent);\n    }\n    layout(dimension) {\n        this._configuration.observeContainer(dimension);\n        this.render();\n    }\n    focus() {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.focus();\n    }\n    hasTextFocus() {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return false;\n        }\n        return this._modelData.view.isFocused();\n    }\n    hasWidgetFocus() {\n        return this._focusTracker && this._focusTracker.hasFocus();\n    }\n    addContentWidget(widget) {\n        const widgetData = {\n            widget: widget,\n            position: widget.getPosition()\n        };\n        if (this._contentWidgets.hasOwnProperty(widget.getId())) {\n            console.warn('Overwriting a content widget with the same id.');\n        }\n        this._contentWidgets[widget.getId()] = widgetData;\n        if (this._modelData && this._modelData.hasRealView) {\n            this._modelData.view.addContentWidget(widgetData);\n        }\n    }\n    layoutContentWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._contentWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._contentWidgets[widgetId];\n            widgetData.position = widget.getPosition();\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.layoutContentWidget(widgetData);\n            }\n        }\n    }\n    removeContentWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._contentWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._contentWidgets[widgetId];\n            delete this._contentWidgets[widgetId];\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.removeContentWidget(widgetData);\n            }\n        }\n    }\n    addOverlayWidget(widget) {\n        const widgetData = {\n            widget: widget,\n            position: widget.getPosition()\n        };\n        if (this._overlayWidgets.hasOwnProperty(widget.getId())) {\n            console.warn('Overwriting an overlay widget with the same id.');\n        }\n        this._overlayWidgets[widget.getId()] = widgetData;\n        if (this._modelData && this._modelData.hasRealView) {\n            this._modelData.view.addOverlayWidget(widgetData);\n        }\n    }\n    layoutOverlayWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._overlayWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._overlayWidgets[widgetId];\n            widgetData.position = widget.getPosition();\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.layoutOverlayWidget(widgetData);\n            }\n        }\n    }\n    removeOverlayWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._overlayWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._overlayWidgets[widgetId];\n            delete this._overlayWidgets[widgetId];\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.removeOverlayWidget(widgetData);\n            }\n        }\n    }\n    changeViewZones(callback) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.change(callback);\n    }\n    getTargetAtClientPoint(clientX, clientY) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        return this._modelData.view.getTargetAtClientPoint(clientX, clientY);\n    }\n    getScrolledVisiblePosition(rawPosition) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        const position = this._modelData.model.validatePosition(rawPosition);\n        const options = this._configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        const top = CodeEditorWidget._getVerticalOffsetForPosition(this._modelData, position.lineNumber, position.column) - this.getScrollTop();\n        const left = this._modelData.view.getOffsetForColumn(position.lineNumber, position.column) + layoutInfo.glyphMarginWidth + layoutInfo.lineNumbersWidth + layoutInfo.decorationsWidth - this.getScrollLeft();\n        return {\n            top: top,\n            left: left,\n            height: options.get(61 /* EditorOption.lineHeight */)\n        };\n    }\n    getOffsetForColumn(lineNumber, column) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return -1;\n        }\n        return this._modelData.view.getOffsetForColumn(lineNumber, column);\n    }\n    render(forceRedraw = false) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.render(true, forceRedraw);\n    }\n    setAriaOptions(options) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.setAriaOptions(options);\n    }\n    applyFontInfo(target) {\n        applyFontInfo(target, this._configuration.options.get(46 /* EditorOption.fontInfo */));\n    }\n    setBanner(domNode, domNodeHeight) {\n        if (this._bannerDomNode && this._domElement.contains(this._bannerDomNode)) {\n            this._domElement.removeChild(this._bannerDomNode);\n        }\n        this._bannerDomNode = domNode;\n        this._configuration.setReservedHeight(domNode ? domNodeHeight : 0);\n        if (this._bannerDomNode) {\n            this._domElement.prepend(this._bannerDomNode);\n        }\n    }\n    _attachModel(model) {\n        if (!model) {\n            this._modelData = null;\n            return;\n        }\n        const listenersToRemove = [];\n        this._domElement.setAttribute('data-mode-id', model.getLanguageId());\n        this._configuration.setIsDominatedByLongLines(model.isDominatedByLongLines());\n        this._configuration.setModelLineCount(model.getLineCount());\n        model.onBeforeAttached();\n        const viewModel = new ViewModel(this._id, this._configuration, model, DOMLineBreaksComputerFactory.create(), MonospaceLineBreaksComputerFactory.create(this._configuration.options), (callback) => dom.scheduleAtNextAnimationFrame(callback), this.languageConfigurationService, this._themeService);\n        // Someone might destroy the model from under the editor, so prevent any exceptions by setting a null model\n        listenersToRemove.push(model.onWillDispose(() => this.setModel(null)));\n        listenersToRemove.push(viewModel.onEvent((e) => {\n            switch (e.kind) {\n                case 0 /* OutgoingViewModelEventKind.ContentSizeChanged */:\n                    this._onDidContentSizeChange.fire(e);\n                    break;\n                case 1 /* OutgoingViewModelEventKind.FocusChanged */:\n                    this._editorTextFocus.setValue(e.hasFocus);\n                    break;\n                case 2 /* OutgoingViewModelEventKind.ScrollChanged */:\n                    this._onDidScrollChange.fire(e);\n                    break;\n                case 3 /* OutgoingViewModelEventKind.ViewZonesChanged */:\n                    this._onDidChangeViewZones.fire();\n                    break;\n                case 4 /* OutgoingViewModelEventKind.HiddenAreasChanged */:\n                    this._onDidChangeHiddenAreas.fire();\n                    break;\n                case 5 /* OutgoingViewModelEventKind.ReadOnlyEditAttempt */:\n                    this._onDidAttemptReadOnlyEdit.fire();\n                    break;\n                case 6 /* OutgoingViewModelEventKind.CursorStateChanged */: {\n                    if (e.reachedMaxCursorCount) {\n                        this._notificationService.warn(nls.localize('cursors.maximum', \"The number of cursors has been limited to {0}.\", CursorsController.MAX_CURSOR_COUNT));\n                    }\n                    const positions = [];\n                    for (let i = 0, len = e.selections.length; i < len; i++) {\n                        positions[i] = e.selections[i].getPosition();\n                    }\n                    const e1 = {\n                        position: positions[0],\n                        secondaryPositions: positions.slice(1),\n                        reason: e.reason,\n                        source: e.source\n                    };\n                    this._onDidChangeCursorPosition.fire(e1);\n                    const e2 = {\n                        selection: e.selections[0],\n                        secondarySelections: e.selections.slice(1),\n                        modelVersionId: e.modelVersionId,\n                        oldSelections: e.oldSelections,\n                        oldModelVersionId: e.oldModelVersionId,\n                        source: e.source,\n                        reason: e.reason\n                    };\n                    this._onDidChangeCursorSelection.fire(e2);\n                    break;\n                }\n                case 7 /* OutgoingViewModelEventKind.ModelDecorationsChanged */:\n                    this._onDidChangeModelDecorations.fire(e.event);\n                    break;\n                case 8 /* OutgoingViewModelEventKind.ModelLanguageChanged */:\n                    this._domElement.setAttribute('data-mode-id', model.getLanguageId());\n                    this._onDidChangeModelLanguage.fire(e.event);\n                    break;\n                case 9 /* OutgoingViewModelEventKind.ModelLanguageConfigurationChanged */:\n                    this._onDidChangeModelLanguageConfiguration.fire(e.event);\n                    break;\n                case 10 /* OutgoingViewModelEventKind.ModelContentChanged */:\n                    this._onDidChangeModelContent.fire(e.event);\n                    break;\n                case 11 /* OutgoingViewModelEventKind.ModelOptionsChanged */:\n                    this._onDidChangeModelOptions.fire(e.event);\n                    break;\n                case 12 /* OutgoingViewModelEventKind.ModelTokensChanged */:\n                    this._onDidChangeModelTokens.fire(e.event);\n                    break;\n            }\n        }));\n        const [view, hasRealView] = this._createView(viewModel);\n        if (hasRealView) {\n            this._domElement.appendChild(view.domNode.domNode);\n            let keys = Object.keys(this._contentWidgets);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const widgetId = keys[i];\n                view.addContentWidget(this._contentWidgets[widgetId]);\n            }\n            keys = Object.keys(this._overlayWidgets);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const widgetId = keys[i];\n                view.addOverlayWidget(this._overlayWidgets[widgetId]);\n            }\n            view.render(false, true);\n            view.domNode.domNode.setAttribute('data-uri', model.uri.toString());\n        }\n        this._modelData = new ModelData(model, viewModel, view, hasRealView, listenersToRemove);\n    }\n    _createView(viewModel) {\n        let commandDelegate;\n        if (this.isSimpleWidget) {\n            commandDelegate = {\n                paste: (text, pasteOnNewLine, multicursorText, mode) => {\n                    this._paste('keyboard', text, pasteOnNewLine, multicursorText, mode);\n                },\n                type: (text) => {\n                    this._type('keyboard', text);\n                },\n                compositionType: (text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) => {\n                    this._compositionType('keyboard', text, replacePrevCharCnt, replaceNextCharCnt, positionDelta);\n                },\n                startComposition: () => {\n                    this._startComposition();\n                },\n                endComposition: () => {\n                    this._endComposition('keyboard');\n                },\n                cut: () => {\n                    this._cut('keyboard');\n                }\n            };\n        }\n        else {\n            commandDelegate = {\n                paste: (text, pasteOnNewLine, multicursorText, mode) => {\n                    const payload = { text, pasteOnNewLine, multicursorText, mode };\n                    this._commandService.executeCommand(\"paste\" /* editorCommon.Handler.Paste */, payload);\n                },\n                type: (text) => {\n                    const payload = { text };\n                    this._commandService.executeCommand(\"type\" /* editorCommon.Handler.Type */, payload);\n                },\n                compositionType: (text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) => {\n                    // Try if possible to go through the existing `replacePreviousChar` command\n                    if (replaceNextCharCnt || positionDelta) {\n                        // must be handled through the new command\n                        const payload = { text, replacePrevCharCnt, replaceNextCharCnt, positionDelta };\n                        this._commandService.executeCommand(\"compositionType\" /* editorCommon.Handler.CompositionType */, payload);\n                    }\n                    else {\n                        const payload = { text, replaceCharCnt: replacePrevCharCnt };\n                        this._commandService.executeCommand(\"replacePreviousChar\" /* editorCommon.Handler.ReplacePreviousChar */, payload);\n                    }\n                },\n                startComposition: () => {\n                    this._commandService.executeCommand(\"compositionStart\" /* editorCommon.Handler.CompositionStart */, {});\n                },\n                endComposition: () => {\n                    this._commandService.executeCommand(\"compositionEnd\" /* editorCommon.Handler.CompositionEnd */, {});\n                },\n                cut: () => {\n                    this._commandService.executeCommand(\"cut\" /* editorCommon.Handler.Cut */, {});\n                }\n            };\n        }\n        const viewUserInputEvents = new ViewUserInputEvents(viewModel.coordinatesConverter);\n        viewUserInputEvents.onKeyDown = (e) => this._onKeyDown.fire(e);\n        viewUserInputEvents.onKeyUp = (e) => this._onKeyUp.fire(e);\n        viewUserInputEvents.onContextMenu = (e) => this._onContextMenu.fire(e);\n        viewUserInputEvents.onMouseMove = (e) => this._onMouseMove.fire(e);\n        viewUserInputEvents.onMouseLeave = (e) => this._onMouseLeave.fire(e);\n        viewUserInputEvents.onMouseDown = (e) => this._onMouseDown.fire(e);\n        viewUserInputEvents.onMouseUp = (e) => this._onMouseUp.fire(e);\n        viewUserInputEvents.onMouseDrag = (e) => this._onMouseDrag.fire(e);\n        viewUserInputEvents.onMouseDrop = (e) => this._onMouseDrop.fire(e);\n        viewUserInputEvents.onMouseDropCanceled = (e) => this._onMouseDropCanceled.fire(e);\n        viewUserInputEvents.onMouseWheel = (e) => this._onMouseWheel.fire(e);\n        const view = new View(commandDelegate, this._configuration, this._themeService.getColorTheme(), viewModel, viewUserInputEvents, this._overflowWidgetsDomNode);\n        return [view, true];\n    }\n    _postDetachModelCleanup(detachedModel) {\n        detachedModel === null || detachedModel === void 0 ? void 0 : detachedModel.removeAllDecorationsWithOwnerId(this._id);\n    }\n    _detachModel() {\n        if (!this._modelData) {\n            return null;\n        }\n        const model = this._modelData.model;\n        const removeDomNode = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;\n        this._modelData.dispose();\n        this._modelData = null;\n        this._domElement.removeAttribute('data-mode-id');\n        if (removeDomNode && this._domElement.contains(removeDomNode)) {\n            this._domElement.removeChild(removeDomNode);\n        }\n        if (this._bannerDomNode && this._domElement.contains(this._bannerDomNode)) {\n            this._domElement.removeChild(this._bannerDomNode);\n        }\n        return model;\n    }\n    _removeDecorationType(key) {\n        this._codeEditorService.removeDecorationType(key);\n    }\n    hasModel() {\n        return (this._modelData !== null);\n    }\n    showDropIndicatorAt(position) {\n        const newDecorations = [{\n                range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n                options: CodeEditorWidget.dropIntoEditorDecorationOptions\n            }];\n        this._dropIntoEditorDecorations.set(newDecorations);\n        this.revealPosition(position, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    removeDropIndicator() {\n        this._dropIntoEditorDecorations.clear();\n    }\n};\nCodeEditorWidget.dropIntoEditorDecorationOptions = ModelDecorationOptions.register({\n    description: 'workbench-dnd-target',\n    className: 'dnd-target'\n});\nCodeEditorWidget = __decorate([\n    __param(3, IInstantiationService),\n    __param(4, ICodeEditorService),\n    __param(5, ICommandService),\n    __param(6, IContextKeyService),\n    __param(7, IThemeService),\n    __param(8, INotificationService),\n    __param(9, IAccessibilityService),\n    __param(10, ILanguageConfigurationService),\n    __param(11, ILanguageFeaturesService)\n], CodeEditorWidget);\nexport { CodeEditorWidget };\nexport class BooleanEventEmitter extends Disposable {\n    constructor(_emitterOptions) {\n        super();\n        this._emitterOptions = _emitterOptions;\n        this._onDidChangeToTrue = this._register(new Emitter(this._emitterOptions));\n        this.onDidChangeToTrue = this._onDidChangeToTrue.event;\n        this._onDidChangeToFalse = this._register(new Emitter(this._emitterOptions));\n        this.onDidChangeToFalse = this._onDidChangeToFalse.event;\n        this._value = 0 /* BooleanEventValue.NotSet */;\n    }\n    setValue(_value) {\n        const value = (_value ? 2 /* BooleanEventValue.True */ : 1 /* BooleanEventValue.False */);\n        if (this._value === value) {\n            return;\n        }\n        this._value = value;\n        if (this._value === 2 /* BooleanEventValue.True */) {\n            this._onDidChangeToTrue.fire();\n        }\n        else if (this._value === 1 /* BooleanEventValue.False */) {\n            this._onDidChangeToFalse.fire();\n        }\n    }\n}\nclass EditorContextKeysManager extends Disposable {\n    constructor(editor, contextKeyService) {\n        super();\n        this._editor = editor;\n        contextKeyService.createKey('editorId', editor.getId());\n        this._editorSimpleInput = EditorContextKeys.editorSimpleInput.bindTo(contextKeyService);\n        this._editorFocus = EditorContextKeys.focus.bindTo(contextKeyService);\n        this._textInputFocus = EditorContextKeys.textInputFocus.bindTo(contextKeyService);\n        this._editorTextFocus = EditorContextKeys.editorTextFocus.bindTo(contextKeyService);\n        this._editorTabMovesFocus = EditorContextKeys.tabMovesFocus.bindTo(contextKeyService);\n        this._editorReadonly = EditorContextKeys.readOnly.bindTo(contextKeyService);\n        this._inDiffEditor = EditorContextKeys.inDiffEditor.bindTo(contextKeyService);\n        this._editorColumnSelection = EditorContextKeys.columnSelection.bindTo(contextKeyService);\n        this._hasMultipleSelections = EditorContextKeys.hasMultipleSelections.bindTo(contextKeyService);\n        this._hasNonEmptySelection = EditorContextKeys.hasNonEmptySelection.bindTo(contextKeyService);\n        this._canUndo = EditorContextKeys.canUndo.bindTo(contextKeyService);\n        this._canRedo = EditorContextKeys.canRedo.bindTo(contextKeyService);\n        this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig()));\n        this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection()));\n        this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus()));\n        this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus()));\n        this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus()));\n        this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus()));\n        this._register(this._editor.onDidChangeModel(() => this._updateFromModel()));\n        this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel()));\n        this._updateFromConfig();\n        this._updateFromSelection();\n        this._updateFromFocus();\n        this._updateFromModel();\n        this._editorSimpleInput.set(this._editor.isSimpleWidget);\n    }\n    _updateFromConfig() {\n        const options = this._editor.getOptions();\n        this._editorTabMovesFocus.set(options.get(132 /* EditorOption.tabFocusMode */));\n        this._editorReadonly.set(options.get(83 /* EditorOption.readOnly */));\n        this._inDiffEditor.set(options.get(56 /* EditorOption.inDiffEditor */));\n        this._editorColumnSelection.set(options.get(18 /* EditorOption.columnSelection */));\n    }\n    _updateFromSelection() {\n        const selections = this._editor.getSelections();\n        if (!selections) {\n            this._hasMultipleSelections.reset();\n            this._hasNonEmptySelection.reset();\n        }\n        else {\n            this._hasMultipleSelections.set(selections.length > 1);\n            this._hasNonEmptySelection.set(selections.some(s => !s.isEmpty()));\n        }\n    }\n    _updateFromFocus() {\n        this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget);\n        this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget);\n        this._textInputFocus.set(this._editor.hasTextFocus());\n    }\n    _updateFromModel() {\n        const model = this._editor.getModel();\n        this._canUndo.set(Boolean(model && model.canUndo()));\n        this._canRedo.set(Boolean(model && model.canRedo()));\n    }\n}\nexport class EditorModeContext extends Disposable {\n    constructor(_editor, _contextKeyService, _languageFeaturesService) {\n        super();\n        this._editor = _editor;\n        this._contextKeyService = _contextKeyService;\n        this._languageFeaturesService = _languageFeaturesService;\n        this._langId = EditorContextKeys.languageId.bindTo(_contextKeyService);\n        this._hasCompletionItemProvider = EditorContextKeys.hasCompletionItemProvider.bindTo(_contextKeyService);\n        this._hasCodeActionsProvider = EditorContextKeys.hasCodeActionsProvider.bindTo(_contextKeyService);\n        this._hasCodeLensProvider = EditorContextKeys.hasCodeLensProvider.bindTo(_contextKeyService);\n        this._hasDefinitionProvider = EditorContextKeys.hasDefinitionProvider.bindTo(_contextKeyService);\n        this._hasDeclarationProvider = EditorContextKeys.hasDeclarationProvider.bindTo(_contextKeyService);\n        this._hasImplementationProvider = EditorContextKeys.hasImplementationProvider.bindTo(_contextKeyService);\n        this._hasTypeDefinitionProvider = EditorContextKeys.hasTypeDefinitionProvider.bindTo(_contextKeyService);\n        this._hasHoverProvider = EditorContextKeys.hasHoverProvider.bindTo(_contextKeyService);\n        this._hasDocumentHighlightProvider = EditorContextKeys.hasDocumentHighlightProvider.bindTo(_contextKeyService);\n        this._hasDocumentSymbolProvider = EditorContextKeys.hasDocumentSymbolProvider.bindTo(_contextKeyService);\n        this._hasReferenceProvider = EditorContextKeys.hasReferenceProvider.bindTo(_contextKeyService);\n        this._hasRenameProvider = EditorContextKeys.hasRenameProvider.bindTo(_contextKeyService);\n        this._hasSignatureHelpProvider = EditorContextKeys.hasSignatureHelpProvider.bindTo(_contextKeyService);\n        this._hasInlayHintsProvider = EditorContextKeys.hasInlayHintsProvider.bindTo(_contextKeyService);\n        this._hasDocumentFormattingProvider = EditorContextKeys.hasDocumentFormattingProvider.bindTo(_contextKeyService);\n        this._hasDocumentSelectionFormattingProvider = EditorContextKeys.hasDocumentSelectionFormattingProvider.bindTo(_contextKeyService);\n        this._hasMultipleDocumentFormattingProvider = EditorContextKeys.hasMultipleDocumentFormattingProvider.bindTo(_contextKeyService);\n        this._hasMultipleDocumentSelectionFormattingProvider = EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider.bindTo(_contextKeyService);\n        this._isInWalkThrough = EditorContextKeys.isInWalkThroughSnippet.bindTo(_contextKeyService);\n        const update = () => this._update();\n        // update when model/mode changes\n        this._register(_editor.onDidChangeModel(update));\n        this._register(_editor.onDidChangeModelLanguage(update));\n        // update when registries change\n        this._register(_languageFeaturesService.completionProvider.onDidChange(update));\n        this._register(_languageFeaturesService.codeActionProvider.onDidChange(update));\n        this._register(_languageFeaturesService.codeLensProvider.onDidChange(update));\n        this._register(_languageFeaturesService.definitionProvider.onDidChange(update));\n        this._register(_languageFeaturesService.declarationProvider.onDidChange(update));\n        this._register(_languageFeaturesService.implementationProvider.onDidChange(update));\n        this._register(_languageFeaturesService.typeDefinitionProvider.onDidChange(update));\n        this._register(_languageFeaturesService.hoverProvider.onDidChange(update));\n        this._register(_languageFeaturesService.documentHighlightProvider.onDidChange(update));\n        this._register(_languageFeaturesService.documentSymbolProvider.onDidChange(update));\n        this._register(_languageFeaturesService.referenceProvider.onDidChange(update));\n        this._register(_languageFeaturesService.renameProvider.onDidChange(update));\n        this._register(_languageFeaturesService.documentFormattingEditProvider.onDidChange(update));\n        this._register(_languageFeaturesService.documentRangeFormattingEditProvider.onDidChange(update));\n        this._register(_languageFeaturesService.signatureHelpProvider.onDidChange(update));\n        this._register(_languageFeaturesService.inlayHintsProvider.onDidChange(update));\n        update();\n    }\n    dispose() {\n        super.dispose();\n    }\n    reset() {\n        this._contextKeyService.bufferChangeEvents(() => {\n            this._langId.reset();\n            this._hasCompletionItemProvider.reset();\n            this._hasCodeActionsProvider.reset();\n            this._hasCodeLensProvider.reset();\n            this._hasDefinitionProvider.reset();\n            this._hasDeclarationProvider.reset();\n            this._hasImplementationProvider.reset();\n            this._hasTypeDefinitionProvider.reset();\n            this._hasHoverProvider.reset();\n            this._hasDocumentHighlightProvider.reset();\n            this._hasDocumentSymbolProvider.reset();\n            this._hasReferenceProvider.reset();\n            this._hasRenameProvider.reset();\n            this._hasDocumentFormattingProvider.reset();\n            this._hasDocumentSelectionFormattingProvider.reset();\n            this._hasSignatureHelpProvider.reset();\n            this._isInWalkThrough.reset();\n        });\n    }\n    _update() {\n        const model = this._editor.getModel();\n        if (!model) {\n            this.reset();\n            return;\n        }\n        this._contextKeyService.bufferChangeEvents(() => {\n            this._langId.set(model.getLanguageId());\n            this._hasCompletionItemProvider.set(this._languageFeaturesService.completionProvider.has(model));\n            this._hasCodeActionsProvider.set(this._languageFeaturesService.codeActionProvider.has(model));\n            this._hasCodeLensProvider.set(this._languageFeaturesService.codeLensProvider.has(model));\n            this._hasDefinitionProvider.set(this._languageFeaturesService.definitionProvider.has(model));\n            this._hasDeclarationProvider.set(this._languageFeaturesService.declarationProvider.has(model));\n            this._hasImplementationProvider.set(this._languageFeaturesService.implementationProvider.has(model));\n            this._hasTypeDefinitionProvider.set(this._languageFeaturesService.typeDefinitionProvider.has(model));\n            this._hasHoverProvider.set(this._languageFeaturesService.hoverProvider.has(model));\n            this._hasDocumentHighlightProvider.set(this._languageFeaturesService.documentHighlightProvider.has(model));\n            this._hasDocumentSymbolProvider.set(this._languageFeaturesService.documentSymbolProvider.has(model));\n            this._hasReferenceProvider.set(this._languageFeaturesService.referenceProvider.has(model));\n            this._hasRenameProvider.set(this._languageFeaturesService.renameProvider.has(model));\n            this._hasSignatureHelpProvider.set(this._languageFeaturesService.signatureHelpProvider.has(model));\n            this._hasInlayHintsProvider.set(this._languageFeaturesService.inlayHintsProvider.has(model));\n            this._hasDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.has(model) || this._languageFeaturesService.documentRangeFormattingEditProvider.has(model));\n            this._hasDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.has(model));\n            this._hasMultipleDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.all(model).length + this._languageFeaturesService.documentRangeFormattingEditProvider.all(model).length > 1);\n            this._hasMultipleDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.all(model).length > 1);\n            this._isInWalkThrough.set(model.uri.scheme === Schemas.walkThroughSnippet);\n        });\n    }\n}\nclass CodeEditorWidgetFocusTracker extends Disposable {\n    constructor(domElement) {\n        super();\n        this._onChange = this._register(new Emitter());\n        this.onChange = this._onChange.event;\n        this._hasFocus = false;\n        this._domFocusTracker = this._register(dom.trackFocus(domElement));\n        this._register(this._domFocusTracker.onDidFocus(() => {\n            this._hasFocus = true;\n            this._onChange.fire(undefined);\n        }));\n        this._register(this._domFocusTracker.onDidBlur(() => {\n            this._hasFocus = false;\n            this._onChange.fire(undefined);\n        }));\n    }\n    hasFocus() {\n        return this._hasFocus;\n    }\n}\nclass EditorDecorationsCollection {\n    constructor(_editor, decorations) {\n        this._editor = _editor;\n        this._decorationIds = [];\n        this._isChangingDecorations = false;\n        if (Array.isArray(decorations) && decorations.length > 0) {\n            this.set(decorations);\n        }\n    }\n    get length() {\n        return this._decorationIds.length;\n    }\n    onDidChange(listener, thisArgs, disposables) {\n        return this._editor.onDidChangeModelDecorations((e) => {\n            if (this._isChangingDecorations) {\n                return;\n            }\n            listener.call(thisArgs, e);\n        }, disposables);\n    }\n    getRange(index) {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        if (index >= this._decorationIds.length) {\n            return null;\n        }\n        return this._editor.getModel().getDecorationRange(this._decorationIds[index]);\n    }\n    getRanges() {\n        if (!this._editor.hasModel()) {\n            return [];\n        }\n        const model = this._editor.getModel();\n        const result = [];\n        for (const decorationId of this._decorationIds) {\n            const range = model.getDecorationRange(decorationId);\n            if (range) {\n                result.push(range);\n            }\n        }\n        return result;\n    }\n    has(decoration) {\n        return this._decorationIds.includes(decoration.id);\n    }\n    clear() {\n        if (this._decorationIds.length === 0) {\n            // nothing to do\n            return;\n        }\n        this.set([]);\n    }\n    set(newDecorations) {\n        try {\n            this._isChangingDecorations = true;\n            this._editor.changeDecorations((accessor) => {\n                this._decorationIds = accessor.deltaDecorations(this._decorationIds, newDecorations);\n            });\n        }\n        finally {\n            this._isChangingDecorations = false;\n        }\n    }\n}\nconst squigglyStart = encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='`);\nconst squigglyEnd = encodeURIComponent(`'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>`);\nfunction getSquigglySVGData(color) {\n    return squigglyStart + encodeURIComponent(color.toString()) + squigglyEnd;\n}\nconst dotdotdotStart = encodeURIComponent(`<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"3\" width=\"12\"><g fill=\"`);\nconst dotdotdotEnd = encodeURIComponent(`\"><circle cx=\"1\" cy=\"1\" r=\"1\"/><circle cx=\"5\" cy=\"1\" r=\"1\"/><circle cx=\"9\" cy=\"1\" r=\"1\"/></g></svg>`);\nfunction getDotDotDotSVGData(color) {\n    return dotdotdotStart + encodeURIComponent(color.toString()) + dotdotdotEnd;\n}\nregisterThemingParticipant((theme, collector) => {\n    const errorBorderColor = theme.getColor(editorErrorBorder);\n    if (errorBorderColor) {\n        collector.addRule(`.monaco-editor .${\"squiggly-error\" /* ClassName.EditorErrorDecoration */} { border-bottom: 4px double ${errorBorderColor}; }`);\n    }\n    const errorForeground = theme.getColor(editorErrorForeground);\n    if (errorForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-error\" /* ClassName.EditorErrorDecoration */} { background: url(\"data:image/svg+xml,${getSquigglySVGData(errorForeground)}\") repeat-x bottom left; }`);\n    }\n    const errorBackground = theme.getColor(editorErrorBackground);\n    if (errorBackground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-error\" /* ClassName.EditorErrorDecoration */}::before { display: block; content: ''; width: 100%; height: 100%; background: ${errorBackground}; }`);\n    }\n    const warningBorderColor = theme.getColor(editorWarningBorder);\n    if (warningBorderColor) {\n        collector.addRule(`.monaco-editor .${\"squiggly-warning\" /* ClassName.EditorWarningDecoration */} { border-bottom: 4px double ${warningBorderColor}; }`);\n    }\n    const warningForeground = theme.getColor(editorWarningForeground);\n    if (warningForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-warning\" /* ClassName.EditorWarningDecoration */} { background: url(\"data:image/svg+xml,${getSquigglySVGData(warningForeground)}\") repeat-x bottom left; }`);\n    }\n    const warningBackground = theme.getColor(editorWarningBackground);\n    if (warningBackground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-warning\" /* ClassName.EditorWarningDecoration */}::before { display: block; content: ''; width: 100%; height: 100%; background: ${warningBackground}; }`);\n    }\n    const infoBorderColor = theme.getColor(editorInfoBorder);\n    if (infoBorderColor) {\n        collector.addRule(`.monaco-editor .${\"squiggly-info\" /* ClassName.EditorInfoDecoration */} { border-bottom: 4px double ${infoBorderColor}; }`);\n    }\n    const infoForeground = theme.getColor(editorInfoForeground);\n    if (infoForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-info\" /* ClassName.EditorInfoDecoration */} { background: url(\"data:image/svg+xml,${getSquigglySVGData(infoForeground)}\") repeat-x bottom left; }`);\n    }\n    const infoBackground = theme.getColor(editorInfoBackground);\n    if (infoBackground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-info\" /* ClassName.EditorInfoDecoration */}::before { display: block; content: ''; width: 100%; height: 100%; background: ${infoBackground}; }`);\n    }\n    const hintBorderColor = theme.getColor(editorHintBorder);\n    if (hintBorderColor) {\n        collector.addRule(`.monaco-editor .${\"squiggly-hint\" /* ClassName.EditorHintDecoration */} { border-bottom: 2px dotted ${hintBorderColor}; }`);\n    }\n    const hintForeground = theme.getColor(editorHintForeground);\n    if (hintForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-hint\" /* ClassName.EditorHintDecoration */} { background: url(\"data:image/svg+xml,${getDotDotDotSVGData(hintForeground)}\") no-repeat bottom left; }`);\n    }\n    const unnecessaryForeground = theme.getColor(editorUnnecessaryCodeOpacity);\n    if (unnecessaryForeground) {\n        collector.addRule(`.monaco-editor.showUnused .${\"squiggly-inline-unnecessary\" /* ClassName.EditorUnnecessaryInlineDecoration */} { opacity: ${unnecessaryForeground.rgba.a}; }`);\n    }\n    const unnecessaryBorder = theme.getColor(editorUnnecessaryCodeBorder);\n    if (unnecessaryBorder) {\n        collector.addRule(`.monaco-editor.showUnused .${\"squiggly-unnecessary\" /* ClassName.EditorUnnecessaryDecoration */} { border-bottom: 2px dashed ${unnecessaryBorder}; }`);\n    }\n    const deprecatedForeground = theme.getColor(editorForeground) || 'inherit';\n    collector.addRule(`.monaco-editor.showDeprecated .${\"squiggly-inline-deprecated\" /* ClassName.EditorDeprecatedInlineDecoration */} { text-decoration: line-through; text-decoration-color: ${deprecatedForeground}}`);\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { illegalArgument } from './errors.js';\nimport { escapeIcons } from './iconLabels.js';\nimport { escapeRegExpCharacters } from './strings.js';\nexport class MarkdownString {\n    constructor(value = '', isTrustedOrOptions = false) {\n        var _a, _b, _c;\n        this.value = value;\n        if (typeof this.value !== 'string') {\n            throw illegalArgument('value');\n        }\n        if (typeof isTrustedOrOptions === 'boolean') {\n            this.isTrusted = isTrustedOrOptions;\n            this.supportThemeIcons = false;\n            this.supportHtml = false;\n        }\n        else {\n            this.isTrusted = (_a = isTrustedOrOptions.isTrusted) !== null && _a !== void 0 ? _a : undefined;\n            this.supportThemeIcons = (_b = isTrustedOrOptions.supportThemeIcons) !== null && _b !== void 0 ? _b : false;\n            this.supportHtml = (_c = isTrustedOrOptions.supportHtml) !== null && _c !== void 0 ? _c : false;\n        }\n    }\n    appendText(value, newlineStyle = 0 /* MarkdownStringTextNewlineStyle.Paragraph */) {\n        this.value += escapeMarkdownSyntaxTokens(this.supportThemeIcons ? escapeIcons(value) : value)\n            .replace(/([ \\t]+)/g, (_match, g1) => '&nbsp;'.repeat(g1.length))\n            .replace(/\\>/gm, '\\\\>')\n            .replace(/\\n/g, newlineStyle === 1 /* MarkdownStringTextNewlineStyle.Break */ ? '\\\\\\n' : '\\n\\n');\n        return this;\n    }\n    appendMarkdown(value) {\n        this.value += value;\n        return this;\n    }\n    appendCodeblock(langId, code) {\n        this.value += '\\n```';\n        this.value += langId;\n        this.value += '\\n';\n        this.value += code;\n        this.value += '\\n```\\n';\n        return this;\n    }\n    appendLink(target, label, title) {\n        this.value += '[';\n        this.value += this._escape(label, ']');\n        this.value += '](';\n        this.value += this._escape(String(target), ')');\n        if (title) {\n            this.value += ` \"${this._escape(this._escape(title, '\"'), ')')}\"`;\n        }\n        this.value += ')';\n        return this;\n    }\n    _escape(value, ch) {\n        const r = new RegExp(escapeRegExpCharacters(ch), 'g');\n        return value.replace(r, (match, offset) => {\n            if (value.charAt(offset - 1) !== '\\\\') {\n                return `\\\\${match}`;\n            }\n            else {\n                return match;\n            }\n        });\n    }\n}\nexport function isEmptyMarkdownString(oneOrMany) {\n    if (isMarkdownString(oneOrMany)) {\n        return !oneOrMany.value;\n    }\n    else if (Array.isArray(oneOrMany)) {\n        return oneOrMany.every(isEmptyMarkdownString);\n    }\n    else {\n        return true;\n    }\n}\nexport function isMarkdownString(thing) {\n    if (thing instanceof MarkdownString) {\n        return true;\n    }\n    else if (thing && typeof thing === 'object') {\n        return typeof thing.value === 'string'\n            && (typeof thing.isTrusted === 'boolean' || thing.isTrusted === undefined)\n            && (typeof thing.supportThemeIcons === 'boolean' || thing.supportThemeIcons === undefined);\n    }\n    return false;\n}\nexport function escapeMarkdownSyntaxTokens(text) {\n    // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    return text.replace(/[\\\\`*_{}[\\]()#+\\-!]/g, '\\\\$&');\n}\nexport function escapeDoubleQuotes(input) {\n    return input.replace(/\"/g, '&quot;');\n}\nexport function removeMarkdownEscapes(text) {\n    if (!text) {\n        return text;\n    }\n    return text.replace(/\\\\([\\\\`*_{}[\\]()#+\\-.!])/g, '$1');\n}\nexport function parseHrefAndDimensions(href) {\n    const dimensions = [];\n    const splitted = href.split('|').map(s => s.trim());\n    href = splitted[0];\n    const parameters = splitted[1];\n    if (parameters) {\n        const heightFromParams = /height=(\\d+)/.exec(parameters);\n        const widthFromParams = /width=(\\d+)/.exec(parameters);\n        const height = heightFromParams ? heightFromParams[1] : '';\n        const width = widthFromParams ? widthFromParams[1] : '';\n        const widthIsFinite = isFinite(parseInt(width));\n        const heightIsFinite = isFinite(parseInt(height));\n        if (widthIsFinite) {\n            dimensions.push(`width=\"${width}\"`);\n        }\n        if (heightIsFinite) {\n            dimensions.push(`height=\"${height}\"`);\n        }\n    }\n    return { href, dimensions };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Codicon, CSSIcon } from '../../../base/common/codicons.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { isString } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { localize } from '../../../nls.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport * as platform from '../../registry/common/platform.js';\nimport { ThemeIcon } from './themeService.js';\n// icon registry\nexport const Extensions = {\n    IconContribution: 'base.contributions.icons'\n};\nexport var IconContribution;\n(function (IconContribution) {\n    function getDefinition(contribution, registry) {\n        let definition = contribution.defaults;\n        while (ThemeIcon.isThemeIcon(definition)) {\n            const c = iconRegistry.getIcon(definition.id);\n            if (!c) {\n                return undefined;\n            }\n            definition = c.defaults;\n        }\n        return definition;\n    }\n    IconContribution.getDefinition = getDefinition;\n})(IconContribution || (IconContribution = {}));\nexport var IconFontDefinition;\n(function (IconFontDefinition) {\n    function toJSONObject(iconFont) {\n        return {\n            weight: iconFont.weight,\n            style: iconFont.style,\n            src: iconFont.src.map(s => ({ format: s.format, location: s.location.toString() }))\n        };\n    }\n    IconFontDefinition.toJSONObject = toJSONObject;\n    function fromJSONObject(json) {\n        const stringOrUndef = (s) => isString(s) ? s : undefined;\n        if (json && Array.isArray(json.src) && json.src.every((s) => isString(s.format) && isString(s.location))) {\n            return {\n                weight: stringOrUndef(json.weight),\n                style: stringOrUndef(json.style),\n                src: json.src.map((s) => ({ format: s.format, location: URI.parse(s.location) }))\n            };\n        }\n        return undefined;\n    }\n    IconFontDefinition.fromJSONObject = fromJSONObject;\n})(IconFontDefinition || (IconFontDefinition = {}));\nclass IconRegistry {\n    constructor() {\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this.iconSchema = {\n            definitions: {\n                icons: {\n                    type: 'object',\n                    properties: {\n                        fontId: { type: 'string', description: localize('iconDefinition.fontId', 'The id of the font to use. If not set, the font that is defined first is used.') },\n                        fontCharacter: { type: 'string', description: localize('iconDefinition.fontCharacter', 'The font character associated with the icon definition.') }\n                    },\n                    additionalProperties: false,\n                    defaultSnippets: [{ body: { fontCharacter: '\\\\\\\\e030' } }]\n                }\n            },\n            type: 'object',\n            properties: {}\n        };\n        this.iconReferenceSchema = { type: 'string', pattern: `^${CSSIcon.iconNameExpression}$`, enum: [], enumDescriptions: [] };\n        this.iconsById = {};\n        this.iconFontsById = {};\n    }\n    registerIcon(id, defaults, description, deprecationMessage) {\n        const existing = this.iconsById[id];\n        if (existing) {\n            if (description && !existing.description) {\n                existing.description = description;\n                this.iconSchema.properties[id].markdownDescription = `${description} $(${id})`;\n                const enumIndex = this.iconReferenceSchema.enum.indexOf(id);\n                if (enumIndex !== -1) {\n                    this.iconReferenceSchema.enumDescriptions[enumIndex] = description;\n                }\n                this._onDidChange.fire();\n            }\n            return existing;\n        }\n        const iconContribution = { id, description, defaults, deprecationMessage };\n        this.iconsById[id] = iconContribution;\n        const propertySchema = { $ref: '#/definitions/icons' };\n        if (deprecationMessage) {\n            propertySchema.deprecationMessage = deprecationMessage;\n        }\n        if (description) {\n            propertySchema.markdownDescription = `${description}: $(${id})`;\n        }\n        this.iconSchema.properties[id] = propertySchema;\n        this.iconReferenceSchema.enum.push(id);\n        this.iconReferenceSchema.enumDescriptions.push(description || '');\n        this._onDidChange.fire();\n        return { id };\n    }\n    getIcons() {\n        return Object.keys(this.iconsById).map(id => this.iconsById[id]);\n    }\n    getIcon(id) {\n        return this.iconsById[id];\n    }\n    getIconSchema() {\n        return this.iconSchema;\n    }\n    toString() {\n        const sorter = (i1, i2) => {\n            return i1.id.localeCompare(i2.id);\n        };\n        const classNames = (i) => {\n            while (ThemeIcon.isThemeIcon(i.defaults)) {\n                i = this.iconsById[i.defaults.id];\n            }\n            return `codicon codicon-${i ? i.id : ''}`;\n        };\n        const reference = [];\n        reference.push(`| preview     | identifier                        | default codicon ID                | description`);\n        reference.push(`| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |`);\n        const contributions = Object.keys(this.iconsById).map(key => this.iconsById[key]);\n        for (const i of contributions.filter(i => !!i.description).sort(sorter)) {\n            reference.push(`|<i class=\"${classNames(i)}\"></i>|${i.id}|${ThemeIcon.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ''}|`);\n        }\n        reference.push(`| preview     | identifier                        `);\n        reference.push(`| ----------- | --------------------------------- |`);\n        for (const i of contributions.filter(i => !ThemeIcon.isThemeIcon(i.defaults)).sort(sorter)) {\n            reference.push(`|<i class=\"${classNames(i)}\"></i>|${i.id}|`);\n        }\n        return reference.join('\\n');\n    }\n}\nconst iconRegistry = new IconRegistry();\nplatform.Registry.add(Extensions.IconContribution, iconRegistry);\nexport function registerIcon(id, defaults, description, deprecationMessage) {\n    return iconRegistry.registerIcon(id, defaults, description, deprecationMessage);\n}\nexport function getIconRegistry() {\n    return iconRegistry;\n}\nfunction initialize() {\n    for (const icon of Codicon.getAll()) {\n        iconRegistry.registerIcon(icon.id, icon.definition, icon.description);\n    }\n}\ninitialize();\nexport const iconsSchemaId = 'vscode://schemas/icons';\nconst schemaRegistry = platform.Registry.as(JSONExtensions.JSONContribution);\nschemaRegistry.registerSchema(iconsSchemaId, iconRegistry.getIconSchema());\nconst delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(iconsSchemaId), 200);\niconRegistry.onDidChange(() => {\n    if (!delayer.isScheduled()) {\n        delayer.schedule();\n    }\n});\n//setTimeout(_ => console.log(iconRegistry.toString()), 5000);\n// common icons\nexport const widgetClose = registerIcon('widget-close', Codicon.close, localize('widgetClose', 'Icon for the close action in widgets.'));\nexport const gotoPreviousLocation = registerIcon('goto-previous-location', Codicon.arrowUp, localize('previousChangeIcon', 'Icon for goto previous editor location.'));\nexport const gotoNextLocation = registerIcon('goto-next-location', Codicon.arrowDown, localize('nextChangeIcon', 'Icon for goto next editor location.'));\nexport const syncing = ThemeIcon.modify(Codicon.sync, 'spin');\nexport const spinningLoading = ThemeIcon.modify(Codicon.loading, 'spin');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nimport './media/diffReview.css';\nimport * as nls from '../../../nls.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { ActionBar } from '../../../base/browser/ui/actionbar/actionbar.js';\nimport { DomScrollableElement } from '../../../base/browser/ui/scrollbar/scrollableElement.js';\nimport { Action } from '../../../base/common/actions.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { EditorAction, registerEditorAction } from '../editorExtensions.js';\nimport { ICodeEditorService } from '../services/codeEditorService.js';\nimport { EditorFontLigatures } from '../../common/config/editorOptions.js';\nimport { LineTokens } from '../../common/tokens/lineTokens.js';\nimport { Position } from '../../common/core/position.js';\nimport { editorLineNumbers } from '../../common/core/editorColorRegistry.js';\nimport { RenderLineInput, renderViewLine2 as renderViewLine } from '../../common/viewLayout/viewLineRenderer.js';\nimport { ViewLineRenderingData } from '../../common/viewModel.js';\nimport { ContextKeyExpr } from '../../../platform/contextkey/common/contextkey.js';\nimport { scrollbarShadow } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant, ThemeIcon } from '../../../platform/theme/common/themeService.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { registerIcon } from '../../../platform/theme/common/iconRegistry.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nconst DIFF_LINES_PADDING = 3;\nclass DiffEntry {\n    constructor(originalLineStart, originalLineEnd, modifiedLineStart, modifiedLineEnd) {\n        this.originalLineStart = originalLineStart;\n        this.originalLineEnd = originalLineEnd;\n        this.modifiedLineStart = modifiedLineStart;\n        this.modifiedLineEnd = modifiedLineEnd;\n    }\n    getType() {\n        if (this.originalLineStart === 0) {\n            return 1 /* DiffEntryType.Insert */;\n        }\n        if (this.modifiedLineStart === 0) {\n            return 2 /* DiffEntryType.Delete */;\n        }\n        return 0 /* DiffEntryType.Equal */;\n    }\n}\nclass Diff {\n    constructor(entries) {\n        this.entries = entries;\n    }\n}\nconst diffReviewInsertIcon = registerIcon('diff-review-insert', Codicon.add, nls.localize('diffReviewInsertIcon', 'Icon for \\'Insert\\' in diff review.'));\nconst diffReviewRemoveIcon = registerIcon('diff-review-remove', Codicon.remove, nls.localize('diffReviewRemoveIcon', 'Icon for \\'Remove\\' in diff review.'));\nconst diffReviewCloseIcon = registerIcon('diff-review-close', Codicon.close, nls.localize('diffReviewCloseIcon', 'Icon for \\'Close\\' in diff review.'));\nlet DiffReview = class DiffReview extends Disposable {\n    constructor(diffEditor, _languageService) {\n        super();\n        this._languageService = _languageService;\n        this._width = 0;\n        this._diffEditor = diffEditor;\n        this._isVisible = false;\n        this.shadow = createFastDomNode(document.createElement('div'));\n        this.shadow.setClassName('diff-review-shadow');\n        this.actionBarContainer = createFastDomNode(document.createElement('div'));\n        this.actionBarContainer.setClassName('diff-review-actions');\n        this._actionBar = this._register(new ActionBar(this.actionBarContainer.domNode));\n        this._actionBar.push(new Action('diffreview.close', nls.localize('label.close', \"Close\"), 'close-diff-review ' + ThemeIcon.asClassName(diffReviewCloseIcon), true, () => __awaiter(this, void 0, void 0, function* () { return this.hide(); })), { label: false, icon: true });\n        this.domNode = createFastDomNode(document.createElement('div'));\n        this.domNode.setClassName('diff-review monaco-editor-background');\n        this._content = createFastDomNode(document.createElement('div'));\n        this._content.setClassName('diff-review-content');\n        this._content.setAttribute('role', 'code');\n        this.scrollbar = this._register(new DomScrollableElement(this._content.domNode, {}));\n        this.domNode.domNode.appendChild(this.scrollbar.getDomNode());\n        this._register(diffEditor.onDidUpdateDiff(() => {\n            if (!this._isVisible) {\n                return;\n            }\n            this._diffs = this._compute();\n            this._render();\n        }));\n        this._register(diffEditor.getModifiedEditor().onDidChangeCursorPosition(() => {\n            if (!this._isVisible) {\n                return;\n            }\n            this._render();\n        }));\n        this._register(dom.addStandardDisposableListener(this.domNode.domNode, 'click', (e) => {\n            e.preventDefault();\n            const row = dom.findParentWithClass(e.target, 'diff-review-row');\n            if (row) {\n                this._goToRow(row);\n            }\n        }));\n        this._register(dom.addStandardDisposableListener(this.domNode.domNode, 'keydown', (e) => {\n            if (e.equals(18 /* KeyCode.DownArrow */)\n                || e.equals(2048 /* KeyMod.CtrlCmd */ | 18 /* KeyCode.DownArrow */)\n                || e.equals(512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */)) {\n                e.preventDefault();\n                this._goToRow(this._getNextRow());\n            }\n            if (e.equals(16 /* KeyCode.UpArrow */)\n                || e.equals(2048 /* KeyMod.CtrlCmd */ | 16 /* KeyCode.UpArrow */)\n                || e.equals(512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */)) {\n                e.preventDefault();\n                this._goToRow(this._getPrevRow());\n            }\n            if (e.equals(9 /* KeyCode.Escape */)\n                || e.equals(2048 /* KeyMod.CtrlCmd */ | 9 /* KeyCode.Escape */)\n                || e.equals(512 /* KeyMod.Alt */ | 9 /* KeyCode.Escape */)\n                || e.equals(1024 /* KeyMod.Shift */ | 9 /* KeyCode.Escape */)) {\n                e.preventDefault();\n                this.hide();\n            }\n            if (e.equals(10 /* KeyCode.Space */)\n                || e.equals(3 /* KeyCode.Enter */)) {\n                e.preventDefault();\n                this.accept();\n            }\n        }));\n        this._diffs = [];\n        this._currentDiff = null;\n    }\n    prev() {\n        let index = 0;\n        if (!this._isVisible) {\n            this._diffs = this._compute();\n        }\n        if (this._isVisible) {\n            let currentIndex = -1;\n            for (let i = 0, len = this._diffs.length; i < len; i++) {\n                if (this._diffs[i] === this._currentDiff) {\n                    currentIndex = i;\n                    break;\n                }\n            }\n            index = (this._diffs.length + currentIndex - 1);\n        }\n        else {\n            index = this._findDiffIndex(this._diffEditor.getPosition());\n        }\n        if (this._diffs.length === 0) {\n            // Nothing to do\n            return;\n        }\n        index = index % this._diffs.length;\n        const entries = this._diffs[index].entries;\n        this._diffEditor.setPosition(new Position(entries[0].modifiedLineStart, 1));\n        this._diffEditor.setSelection({ startColumn: 1, startLineNumber: entries[0].modifiedLineStart, endColumn: 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, endLineNumber: entries[entries.length - 1].modifiedLineEnd });\n        this._isVisible = true;\n        this._diffEditor.doLayout();\n        this._render();\n        this._goToRow(this._getNextRow());\n    }\n    next() {\n        let index = 0;\n        if (!this._isVisible) {\n            this._diffs = this._compute();\n        }\n        if (this._isVisible) {\n            let currentIndex = -1;\n            for (let i = 0, len = this._diffs.length; i < len; i++) {\n                if (this._diffs[i] === this._currentDiff) {\n                    currentIndex = i;\n                    break;\n                }\n            }\n            index = (currentIndex + 1);\n        }\n        else {\n            index = this._findDiffIndex(this._diffEditor.getPosition());\n        }\n        if (this._diffs.length === 0) {\n            // Nothing to do\n            return;\n        }\n        index = index % this._diffs.length;\n        const entries = this._diffs[index].entries;\n        this._diffEditor.setPosition(new Position(entries[0].modifiedLineStart, 1));\n        this._diffEditor.setSelection({ startColumn: 1, startLineNumber: entries[0].modifiedLineStart, endColumn: 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, endLineNumber: entries[entries.length - 1].modifiedLineEnd });\n        this._isVisible = true;\n        this._diffEditor.doLayout();\n        this._render();\n        this._goToRow(this._getNextRow());\n    }\n    accept() {\n        let jumpToLineNumber = -1;\n        const current = this._getCurrentFocusedRow();\n        if (current) {\n            const lineNumber = parseInt(current.getAttribute('data-line'), 10);\n            if (!isNaN(lineNumber)) {\n                jumpToLineNumber = lineNumber;\n            }\n        }\n        this.hide();\n        if (jumpToLineNumber !== -1) {\n            this._diffEditor.setPosition(new Position(jumpToLineNumber, 1));\n            this._diffEditor.revealPosition(new Position(jumpToLineNumber, 1), 1 /* ScrollType.Immediate */);\n        }\n    }\n    hide() {\n        this._isVisible = false;\n        this._diffEditor.updateOptions({ readOnly: false });\n        this._diffEditor.focus();\n        this._diffEditor.doLayout();\n        this._render();\n    }\n    _getPrevRow() {\n        const current = this._getCurrentFocusedRow();\n        if (!current) {\n            return this._getFirstRow();\n        }\n        if (current.previousElementSibling) {\n            return current.previousElementSibling;\n        }\n        return current;\n    }\n    _getNextRow() {\n        const current = this._getCurrentFocusedRow();\n        if (!current) {\n            return this._getFirstRow();\n        }\n        if (current.nextElementSibling) {\n            return current.nextElementSibling;\n        }\n        return current;\n    }\n    _getFirstRow() {\n        return this.domNode.domNode.querySelector('.diff-review-row');\n    }\n    _getCurrentFocusedRow() {\n        const result = document.activeElement;\n        if (result && /diff-review-row/.test(result.className)) {\n            return result;\n        }\n        return null;\n    }\n    _goToRow(row) {\n        const prev = this._getCurrentFocusedRow();\n        row.tabIndex = 0;\n        row.focus();\n        if (prev && prev !== row) {\n            prev.tabIndex = -1;\n        }\n        this.scrollbar.scanDomNode();\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    layout(top, width, height) {\n        this._width = width;\n        this.shadow.setTop(top - 6);\n        this.shadow.setWidth(width);\n        this.shadow.setHeight(this._isVisible ? 6 : 0);\n        this.domNode.setTop(top);\n        this.domNode.setWidth(width);\n        this.domNode.setHeight(height);\n        this._content.setHeight(height);\n        this._content.setWidth(width);\n        if (this._isVisible) {\n            this.actionBarContainer.setAttribute('aria-hidden', 'false');\n            this.actionBarContainer.setDisplay('block');\n        }\n        else {\n            this.actionBarContainer.setAttribute('aria-hidden', 'true');\n            this.actionBarContainer.setDisplay('none');\n        }\n    }\n    _compute() {\n        const lineChanges = this._diffEditor.getLineChanges();\n        if (!lineChanges || lineChanges.length === 0) {\n            return [];\n        }\n        const originalModel = this._diffEditor.getOriginalEditor().getModel();\n        const modifiedModel = this._diffEditor.getModifiedEditor().getModel();\n        if (!originalModel || !modifiedModel) {\n            return [];\n        }\n        return DiffReview._mergeAdjacent(lineChanges, originalModel.getLineCount(), modifiedModel.getLineCount());\n    }\n    static _mergeAdjacent(lineChanges, originalLineCount, modifiedLineCount) {\n        if (!lineChanges || lineChanges.length === 0) {\n            return [];\n        }\n        const diffs = [];\n        let diffsLength = 0;\n        for (let i = 0, len = lineChanges.length; i < len; i++) {\n            const lineChange = lineChanges[i];\n            const originalStart = lineChange.originalStartLineNumber;\n            const originalEnd = lineChange.originalEndLineNumber;\n            const modifiedStart = lineChange.modifiedStartLineNumber;\n            const modifiedEnd = lineChange.modifiedEndLineNumber;\n            const r = [];\n            let rLength = 0;\n            // Emit before anchors\n            {\n                const originalEqualAbove = (originalEnd === 0 ? originalStart : originalStart - 1);\n                const modifiedEqualAbove = (modifiedEnd === 0 ? modifiedStart : modifiedStart - 1);\n                // Make sure we don't step into the previous diff\n                let minOriginal = 1;\n                let minModified = 1;\n                if (i > 0) {\n                    const prevLineChange = lineChanges[i - 1];\n                    if (prevLineChange.originalEndLineNumber === 0) {\n                        minOriginal = prevLineChange.originalStartLineNumber + 1;\n                    }\n                    else {\n                        minOriginal = prevLineChange.originalEndLineNumber + 1;\n                    }\n                    if (prevLineChange.modifiedEndLineNumber === 0) {\n                        minModified = prevLineChange.modifiedStartLineNumber + 1;\n                    }\n                    else {\n                        minModified = prevLineChange.modifiedEndLineNumber + 1;\n                    }\n                }\n                let fromOriginal = originalEqualAbove - DIFF_LINES_PADDING + 1;\n                let fromModified = modifiedEqualAbove - DIFF_LINES_PADDING + 1;\n                if (fromOriginal < minOriginal) {\n                    const delta = minOriginal - fromOriginal;\n                    fromOriginal = fromOriginal + delta;\n                    fromModified = fromModified + delta;\n                }\n                if (fromModified < minModified) {\n                    const delta = minModified - fromModified;\n                    fromOriginal = fromOriginal + delta;\n                    fromModified = fromModified + delta;\n                }\n                r[rLength++] = new DiffEntry(fromOriginal, originalEqualAbove, fromModified, modifiedEqualAbove);\n            }\n            // Emit deleted lines\n            {\n                if (originalEnd !== 0) {\n                    r[rLength++] = new DiffEntry(originalStart, originalEnd, 0, 0);\n                }\n            }\n            // Emit inserted lines\n            {\n                if (modifiedEnd !== 0) {\n                    r[rLength++] = new DiffEntry(0, 0, modifiedStart, modifiedEnd);\n                }\n            }\n            // Emit after anchors\n            {\n                const originalEqualBelow = (originalEnd === 0 ? originalStart + 1 : originalEnd + 1);\n                const modifiedEqualBelow = (modifiedEnd === 0 ? modifiedStart + 1 : modifiedEnd + 1);\n                // Make sure we don't step into the next diff\n                let maxOriginal = originalLineCount;\n                let maxModified = modifiedLineCount;\n                if (i + 1 < len) {\n                    const nextLineChange = lineChanges[i + 1];\n                    if (nextLineChange.originalEndLineNumber === 0) {\n                        maxOriginal = nextLineChange.originalStartLineNumber;\n                    }\n                    else {\n                        maxOriginal = nextLineChange.originalStartLineNumber - 1;\n                    }\n                    if (nextLineChange.modifiedEndLineNumber === 0) {\n                        maxModified = nextLineChange.modifiedStartLineNumber;\n                    }\n                    else {\n                        maxModified = nextLineChange.modifiedStartLineNumber - 1;\n                    }\n                }\n                let toOriginal = originalEqualBelow + DIFF_LINES_PADDING - 1;\n                let toModified = modifiedEqualBelow + DIFF_LINES_PADDING - 1;\n                if (toOriginal > maxOriginal) {\n                    const delta = maxOriginal - toOriginal;\n                    toOriginal = toOriginal + delta;\n                    toModified = toModified + delta;\n                }\n                if (toModified > maxModified) {\n                    const delta = maxModified - toModified;\n                    toOriginal = toOriginal + delta;\n                    toModified = toModified + delta;\n                }\n                r[rLength++] = new DiffEntry(originalEqualBelow, toOriginal, modifiedEqualBelow, toModified);\n            }\n            diffs[diffsLength++] = new Diff(r);\n        }\n        // Merge adjacent diffs\n        let curr = diffs[0].entries;\n        const r = [];\n        let rLength = 0;\n        for (let i = 1, len = diffs.length; i < len; i++) {\n            const thisDiff = diffs[i].entries;\n            const currLast = curr[curr.length - 1];\n            const thisFirst = thisDiff[0];\n            if (currLast.getType() === 0 /* DiffEntryType.Equal */\n                && thisFirst.getType() === 0 /* DiffEntryType.Equal */\n                && thisFirst.originalLineStart <= currLast.originalLineEnd) {\n                // We are dealing with equal lines that overlap\n                curr[curr.length - 1] = new DiffEntry(currLast.originalLineStart, thisFirst.originalLineEnd, currLast.modifiedLineStart, thisFirst.modifiedLineEnd);\n                curr = curr.concat(thisDiff.slice(1));\n                continue;\n            }\n            r[rLength++] = new Diff(curr);\n            curr = thisDiff;\n        }\n        r[rLength++] = new Diff(curr);\n        return r;\n    }\n    _findDiffIndex(pos) {\n        const lineNumber = pos.lineNumber;\n        for (let i = 0, len = this._diffs.length; i < len; i++) {\n            const diff = this._diffs[i].entries;\n            const lastModifiedLine = diff[diff.length - 1].modifiedLineEnd;\n            if (lineNumber <= lastModifiedLine) {\n                return i;\n            }\n        }\n        return 0;\n    }\n    _render() {\n        const originalOptions = this._diffEditor.getOriginalEditor().getOptions();\n        const modifiedOptions = this._diffEditor.getModifiedEditor().getOptions();\n        const originalModel = this._diffEditor.getOriginalEditor().getModel();\n        const modifiedModel = this._diffEditor.getModifiedEditor().getModel();\n        const originalModelOpts = originalModel.getOptions();\n        const modifiedModelOpts = modifiedModel.getOptions();\n        if (!this._isVisible || !originalModel || !modifiedModel) {\n            dom.clearNode(this._content.domNode);\n            this._currentDiff = null;\n            this.scrollbar.scanDomNode();\n            return;\n        }\n        this._diffEditor.updateOptions({ readOnly: true });\n        const diffIndex = this._findDiffIndex(this._diffEditor.getPosition());\n        if (this._diffs[diffIndex] === this._currentDiff) {\n            return;\n        }\n        this._currentDiff = this._diffs[diffIndex];\n        const diffs = this._diffs[diffIndex].entries;\n        const container = document.createElement('div');\n        container.className = 'diff-review-table';\n        container.setAttribute('role', 'list');\n        container.setAttribute('aria-label', 'Difference review. Use \"Stage | Unstage | Revert Selected Ranges\" commands');\n        applyFontInfo(container, modifiedOptions.get(46 /* EditorOption.fontInfo */));\n        let minOriginalLine = 0;\n        let maxOriginalLine = 0;\n        let minModifiedLine = 0;\n        let maxModifiedLine = 0;\n        for (let i = 0, len = diffs.length; i < len; i++) {\n            const diffEntry = diffs[i];\n            const originalLineStart = diffEntry.originalLineStart;\n            const originalLineEnd = diffEntry.originalLineEnd;\n            const modifiedLineStart = diffEntry.modifiedLineStart;\n            const modifiedLineEnd = diffEntry.modifiedLineEnd;\n            if (originalLineStart !== 0 && ((minOriginalLine === 0 || originalLineStart < minOriginalLine))) {\n                minOriginalLine = originalLineStart;\n            }\n            if (originalLineEnd !== 0 && ((maxOriginalLine === 0 || originalLineEnd > maxOriginalLine))) {\n                maxOriginalLine = originalLineEnd;\n            }\n            if (modifiedLineStart !== 0 && ((minModifiedLine === 0 || modifiedLineStart < minModifiedLine))) {\n                minModifiedLine = modifiedLineStart;\n            }\n            if (modifiedLineEnd !== 0 && ((maxModifiedLine === 0 || modifiedLineEnd > maxModifiedLine))) {\n                maxModifiedLine = modifiedLineEnd;\n            }\n        }\n        const header = document.createElement('div');\n        header.className = 'diff-review-row';\n        const cell = document.createElement('div');\n        cell.className = 'diff-review-cell diff-review-summary';\n        const originalChangedLinesCnt = maxOriginalLine - minOriginalLine + 1;\n        const modifiedChangedLinesCnt = maxModifiedLine - minModifiedLine + 1;\n        cell.appendChild(document.createTextNode(`${diffIndex + 1}/${this._diffs.length}: @@ -${minOriginalLine},${originalChangedLinesCnt} +${minModifiedLine},${modifiedChangedLinesCnt} @@`));\n        header.setAttribute('data-line', String(minModifiedLine));\n        const getAriaLines = (lines) => {\n            if (lines === 0) {\n                return nls.localize('no_lines_changed', \"no lines changed\");\n            }\n            else if (lines === 1) {\n                return nls.localize('one_line_changed', \"1 line changed\");\n            }\n            else {\n                return nls.localize('more_lines_changed', \"{0} lines changed\", lines);\n            }\n        };\n        const originalChangedLinesCntAria = getAriaLines(originalChangedLinesCnt);\n        const modifiedChangedLinesCntAria = getAriaLines(modifiedChangedLinesCnt);\n        header.setAttribute('aria-label', nls.localize({\n            key: 'header',\n            comment: [\n                'This is the ARIA label for a git diff header.',\n                'A git diff header looks like this: @@ -154,12 +159,39 @@.',\n                'That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.',\n                'Variables 0 and 1 refer to the diff index out of total number of diffs.',\n                'Variables 2 and 4 will be numbers (a line number).',\n                'Variables 3 and 5 will be \"no lines changed\", \"1 line changed\" or \"X lines changed\", localized separately.'\n            ]\n        }, \"Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}\", (diffIndex + 1), this._diffs.length, minOriginalLine, originalChangedLinesCntAria, minModifiedLine, modifiedChangedLinesCntAria));\n        header.appendChild(cell);\n        // @@ -504,7 +517,7 @@\n        header.setAttribute('role', 'listitem');\n        container.appendChild(header);\n        const lineHeight = modifiedOptions.get(61 /* EditorOption.lineHeight */);\n        let modLine = minModifiedLine;\n        for (let i = 0, len = diffs.length; i < len; i++) {\n            const diffEntry = diffs[i];\n            DiffReview._renderSection(container, diffEntry, modLine, lineHeight, this._width, originalOptions, originalModel, originalModelOpts, modifiedOptions, modifiedModel, modifiedModelOpts, this._languageService.languageIdCodec);\n            if (diffEntry.modifiedLineStart !== 0) {\n                modLine = diffEntry.modifiedLineEnd;\n            }\n        }\n        dom.clearNode(this._content.domNode);\n        this._content.domNode.appendChild(container);\n        this.scrollbar.scanDomNode();\n    }\n    static _renderSection(dest, diffEntry, modLine, lineHeight, width, originalOptions, originalModel, originalModelOpts, modifiedOptions, modifiedModel, modifiedModelOpts, languageIdCodec) {\n        const type = diffEntry.getType();\n        let rowClassName = 'diff-review-row';\n        let lineNumbersExtraClassName = '';\n        const spacerClassName = 'diff-review-spacer';\n        let spacerIcon = null;\n        switch (type) {\n            case 1 /* DiffEntryType.Insert */:\n                rowClassName = 'diff-review-row line-insert';\n                lineNumbersExtraClassName = ' char-insert';\n                spacerIcon = diffReviewInsertIcon;\n                break;\n            case 2 /* DiffEntryType.Delete */:\n                rowClassName = 'diff-review-row line-delete';\n                lineNumbersExtraClassName = ' char-delete';\n                spacerIcon = diffReviewRemoveIcon;\n                break;\n        }\n        const originalLineStart = diffEntry.originalLineStart;\n        const originalLineEnd = diffEntry.originalLineEnd;\n        const modifiedLineStart = diffEntry.modifiedLineStart;\n        const modifiedLineEnd = diffEntry.modifiedLineEnd;\n        const cnt = Math.max(modifiedLineEnd - modifiedLineStart, originalLineEnd - originalLineStart);\n        const originalLayoutInfo = originalOptions.get(133 /* EditorOption.layoutInfo */);\n        const originalLineNumbersWidth = originalLayoutInfo.glyphMarginWidth + originalLayoutInfo.lineNumbersWidth;\n        const modifiedLayoutInfo = modifiedOptions.get(133 /* EditorOption.layoutInfo */);\n        const modifiedLineNumbersWidth = 10 + modifiedLayoutInfo.glyphMarginWidth + modifiedLayoutInfo.lineNumbersWidth;\n        for (let i = 0; i <= cnt; i++) {\n            const originalLine = (originalLineStart === 0 ? 0 : originalLineStart + i);\n            const modifiedLine = (modifiedLineStart === 0 ? 0 : modifiedLineStart + i);\n            const row = document.createElement('div');\n            row.style.minWidth = width + 'px';\n            row.className = rowClassName;\n            row.setAttribute('role', 'listitem');\n            if (modifiedLine !== 0) {\n                modLine = modifiedLine;\n            }\n            row.setAttribute('data-line', String(modLine));\n            const cell = document.createElement('div');\n            cell.className = 'diff-review-cell';\n            cell.style.height = `${lineHeight}px`;\n            row.appendChild(cell);\n            const originalLineNumber = document.createElement('span');\n            originalLineNumber.style.width = (originalLineNumbersWidth + 'px');\n            originalLineNumber.style.minWidth = (originalLineNumbersWidth + 'px');\n            originalLineNumber.className = 'diff-review-line-number' + lineNumbersExtraClassName;\n            if (originalLine !== 0) {\n                originalLineNumber.appendChild(document.createTextNode(String(originalLine)));\n            }\n            else {\n                originalLineNumber.innerText = '\\u00a0';\n            }\n            cell.appendChild(originalLineNumber);\n            const modifiedLineNumber = document.createElement('span');\n            modifiedLineNumber.style.width = (modifiedLineNumbersWidth + 'px');\n            modifiedLineNumber.style.minWidth = (modifiedLineNumbersWidth + 'px');\n            modifiedLineNumber.style.paddingRight = '10px';\n            modifiedLineNumber.className = 'diff-review-line-number' + lineNumbersExtraClassName;\n            if (modifiedLine !== 0) {\n                modifiedLineNumber.appendChild(document.createTextNode(String(modifiedLine)));\n            }\n            else {\n                modifiedLineNumber.innerText = '\\u00a0';\n            }\n            cell.appendChild(modifiedLineNumber);\n            const spacer = document.createElement('span');\n            spacer.className = spacerClassName;\n            if (spacerIcon) {\n                const spacerCodicon = document.createElement('span');\n                spacerCodicon.className = ThemeIcon.asClassName(spacerIcon);\n                spacerCodicon.innerText = '\\u00a0\\u00a0';\n                spacer.appendChild(spacerCodicon);\n            }\n            else {\n                spacer.innerText = '\\u00a0\\u00a0';\n            }\n            cell.appendChild(spacer);\n            let lineContent;\n            if (modifiedLine !== 0) {\n                let html = this._renderLine(modifiedModel, modifiedOptions, modifiedModelOpts.tabSize, modifiedLine, languageIdCodec);\n                if (DiffReview._ttPolicy) {\n                    html = DiffReview._ttPolicy.createHTML(html);\n                }\n                cell.insertAdjacentHTML('beforeend', html);\n                lineContent = modifiedModel.getLineContent(modifiedLine);\n            }\n            else {\n                let html = this._renderLine(originalModel, originalOptions, originalModelOpts.tabSize, originalLine, languageIdCodec);\n                if (DiffReview._ttPolicy) {\n                    html = DiffReview._ttPolicy.createHTML(html);\n                }\n                cell.insertAdjacentHTML('beforeend', html);\n                lineContent = originalModel.getLineContent(originalLine);\n            }\n            if (lineContent.length === 0) {\n                lineContent = nls.localize('blankLine', \"blank\");\n            }\n            let ariaLabel = '';\n            switch (type) {\n                case 0 /* DiffEntryType.Equal */:\n                    if (originalLine === modifiedLine) {\n                        ariaLabel = nls.localize({ key: 'unchangedLine', comment: ['The placeholders are contents of the line and should not be translated.'] }, \"{0} unchanged line {1}\", lineContent, originalLine);\n                    }\n                    else {\n                        ariaLabel = nls.localize('equalLine', \"{0} original line {1} modified line {2}\", lineContent, originalLine, modifiedLine);\n                    }\n                    break;\n                case 1 /* DiffEntryType.Insert */:\n                    ariaLabel = nls.localize('insertLine', \"+ {0} modified line {1}\", lineContent, modifiedLine);\n                    break;\n                case 2 /* DiffEntryType.Delete */:\n                    ariaLabel = nls.localize('deleteLine', \"- {0} original line {1}\", lineContent, originalLine);\n                    break;\n            }\n            row.setAttribute('aria-label', ariaLabel);\n            dest.appendChild(row);\n        }\n    }\n    static _renderLine(model, options, tabSize, lineNumber, languageIdCodec) {\n        const lineContent = model.getLineContent(lineNumber);\n        const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n        const lineTokens = LineTokens.createEmpty(lineContent, languageIdCodec);\n        const isBasicASCII = ViewLineRenderingData.isBasicASCII(lineContent, model.mightContainNonBasicASCII());\n        const containsRTL = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII, model.mightContainRTL());\n        const r = renderViewLine(new RenderLineInput((fontInfo.isMonospace && !options.get(29 /* EditorOption.disableMonospaceOptimizations */)), fontInfo.canUseHalfwidthRightwardsArrow, lineContent, false, isBasicASCII, containsRTL, 0, lineTokens, [], tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, options.get(107 /* EditorOption.stopRenderingLineAfter */), options.get(90 /* EditorOption.renderWhitespace */), options.get(85 /* EditorOption.renderControlCharacters */), options.get(47 /* EditorOption.fontLigatures */) !== EditorFontLigatures.OFF, null));\n        return r.html;\n    }\n};\nDiffReview._ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('diffReview', { createHTML: value => value });\nDiffReview = __decorate([\n    __param(1, ILanguageService)\n], DiffReview);\nexport { DiffReview };\n// theming\nregisterThemingParticipant((theme, collector) => {\n    const lineNumbers = theme.getColor(editorLineNumbers);\n    if (lineNumbers) {\n        collector.addRule(`.monaco-diff-editor .diff-review-line-number { color: ${lineNumbers}; }`);\n    }\n    const shadow = theme.getColor(scrollbarShadow);\n    if (shadow) {\n        collector.addRule(`.monaco-diff-editor .diff-review-shadow { box-shadow: ${shadow} 0 -6px 6px -6px inset; }`);\n    }\n});\nclass DiffReviewNext extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.diffReview.next',\n            label: nls.localize('editor.action.diffReview.next', \"Go to Next Difference\"),\n            alias: 'Go to Next Difference',\n            precondition: ContextKeyExpr.has('isInDiffEditor'),\n            kbOpts: {\n                kbExpr: null,\n                primary: 65 /* KeyCode.F7 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(accessor, editor) {\n        const diffEditor = findFocusedDiffEditor(accessor);\n        if (diffEditor) {\n            diffEditor.diffReviewNext();\n        }\n    }\n}\nclass DiffReviewPrev extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.diffReview.prev',\n            label: nls.localize('editor.action.diffReview.prev', \"Go to Previous Difference\"),\n            alias: 'Go to Previous Difference',\n            precondition: ContextKeyExpr.has('isInDiffEditor'),\n            kbOpts: {\n                kbExpr: null,\n                primary: 1024 /* KeyMod.Shift */ | 65 /* KeyCode.F7 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(accessor, editor) {\n        const diffEditor = findFocusedDiffEditor(accessor);\n        if (diffEditor) {\n            diffEditor.diffReviewPrev();\n        }\n    }\n}\nfunction findFocusedDiffEditor(accessor) {\n    const codeEditorService = accessor.get(ICodeEditorService);\n    const diffEditors = codeEditorService.listDiffEditors();\n    const activeCodeEditor = codeEditorService.getActiveCodeEditor();\n    if (!activeCodeEditor) {\n        return null;\n    }\n    for (let i = 0, len = diffEditors.length; i < len; i++) {\n        const diffEditor = diffEditors[i];\n        if (diffEditor.getModifiedEditor().getId() === activeCodeEditor.getId() || diffEditor.getOriginalEditor().getId() === activeCodeEditor.getId()) {\n            return diffEditor;\n        }\n    }\n    return null;\n}\nregisterEditorAction(DiffReviewNext);\nregisterEditorAction(DiffReviewPrev);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as nls from '../../../nls.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { Action } from '../../../base/common/actions.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Range } from '../../common/core/range.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nexport class InlineDiffMargin extends Disposable {\n    constructor(_viewZoneId, _marginDomNode, editor, diff, _contextMenuService, _clipboardService) {\n        super();\n        this._viewZoneId = _viewZoneId;\n        this._marginDomNode = _marginDomNode;\n        this.editor = editor;\n        this.diff = diff;\n        this._contextMenuService = _contextMenuService;\n        this._clipboardService = _clipboardService;\n        this._visibility = false;\n        // make sure the diff margin shows above overlay.\n        this._marginDomNode.style.zIndex = '10';\n        this._diffActions = document.createElement('div');\n        this._diffActions.className = Codicon.lightBulb.classNames + ' lightbulb-glyph';\n        this._diffActions.style.position = 'absolute';\n        const lineHeight = editor.getOption(61 /* EditorOption.lineHeight */);\n        const lineFeed = editor.getModel().getEOL();\n        this._diffActions.style.right = '0px';\n        this._diffActions.style.visibility = 'hidden';\n        this._diffActions.style.height = `${lineHeight}px`;\n        this._diffActions.style.lineHeight = `${lineHeight}px`;\n        this._marginDomNode.appendChild(this._diffActions);\n        const actions = [];\n        const isDeletion = diff.modifiedEndLineNumber === 0;\n        // default action\n        actions.push(new Action('diff.clipboard.copyDeletedContent', isDeletion\n            ? (diff.originalEndLineNumber > diff.modifiedStartLineNumber\n                ? nls.localize('diff.clipboard.copyDeletedLinesContent.label', \"Copy deleted lines\")\n                : nls.localize('diff.clipboard.copyDeletedLinesContent.single.label', \"Copy deleted line\"))\n            : (diff.originalEndLineNumber > diff.modifiedStartLineNumber\n                ? nls.localize('diff.clipboard.copyChangedLinesContent.label', \"Copy changed lines\")\n                : nls.localize('diff.clipboard.copyChangedLinesContent.single.label', \"Copy changed line\")), undefined, true, () => __awaiter(this, void 0, void 0, function* () {\n            const range = new Range(diff.originalStartLineNumber, 1, diff.originalEndLineNumber + 1, 1);\n            const deletedText = diff.originalModel.getValueInRange(range);\n            yield this._clipboardService.writeText(deletedText);\n        })));\n        let currentLineNumberOffset = 0;\n        let copyLineAction = undefined;\n        if (diff.originalEndLineNumber > diff.modifiedStartLineNumber) {\n            copyLineAction = new Action('diff.clipboard.copyDeletedLineContent', isDeletion\n                ? nls.localize('diff.clipboard.copyDeletedLineContent.label', \"Copy deleted line ({0})\", diff.originalStartLineNumber)\n                : nls.localize('diff.clipboard.copyChangedLineContent.label', \"Copy changed line ({0})\", diff.originalStartLineNumber), undefined, true, () => __awaiter(this, void 0, void 0, function* () {\n                const lineContent = diff.originalModel.getLineContent(diff.originalStartLineNumber + currentLineNumberOffset);\n                if (lineContent === '') {\n                    // empty line\n                    const eof = diff.originalModel.getEndOfLineSequence();\n                    yield this._clipboardService.writeText(eof === 0 /* EndOfLineSequence.LF */ ? '\\n' : '\\r\\n');\n                }\n                else {\n                    yield this._clipboardService.writeText(lineContent);\n                }\n            }));\n            actions.push(copyLineAction);\n        }\n        const readOnly = editor.getOption(83 /* EditorOption.readOnly */);\n        if (!readOnly) {\n            actions.push(new Action('diff.inline.revertChange', nls.localize('diff.inline.revertChange.label', \"Revert this change\"), undefined, true, () => __awaiter(this, void 0, void 0, function* () {\n                const range = new Range(diff.originalStartLineNumber, 1, diff.originalEndLineNumber, diff.originalModel.getLineMaxColumn(diff.originalEndLineNumber));\n                const deletedText = diff.originalModel.getValueInRange(range);\n                if (diff.modifiedEndLineNumber === 0) {\n                    // deletion only\n                    const column = editor.getModel().getLineMaxColumn(diff.modifiedStartLineNumber);\n                    editor.executeEdits('diffEditor', [\n                        {\n                            range: new Range(diff.modifiedStartLineNumber, column, diff.modifiedStartLineNumber, column),\n                            text: lineFeed + deletedText\n                        }\n                    ]);\n                }\n                else {\n                    const column = editor.getModel().getLineMaxColumn(diff.modifiedEndLineNumber);\n                    editor.executeEdits('diffEditor', [\n                        {\n                            range: new Range(diff.modifiedStartLineNumber, 1, diff.modifiedEndLineNumber, column),\n                            text: deletedText\n                        }\n                    ]);\n                }\n            })));\n        }\n        const showContextMenu = (x, y) => {\n            this._contextMenuService.showContextMenu({\n                getAnchor: () => {\n                    return {\n                        x,\n                        y\n                    };\n                },\n                getActions: () => {\n                    if (copyLineAction) {\n                        copyLineAction.label =\n                            isDeletion\n                                ? nls.localize('diff.clipboard.copyDeletedLineContent.label', \"Copy deleted line ({0})\", diff.originalStartLineNumber + currentLineNumberOffset)\n                                : nls.localize('diff.clipboard.copyChangedLineContent.label', \"Copy changed line ({0})\", diff.originalStartLineNumber + currentLineNumberOffset);\n                    }\n                    return actions;\n                },\n                autoSelectFirstItem: true\n            });\n        };\n        this._register(dom.addStandardDisposableListener(this._diffActions, 'mousedown', e => {\n            const { top, height } = dom.getDomNodePagePosition(this._diffActions);\n            const pad = Math.floor(lineHeight / 3);\n            e.preventDefault();\n            showContextMenu(e.posx, top + height + pad);\n        }));\n        this._register(editor.onMouseMove((e) => {\n            if (e.target.type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */ || e.target.type === 5 /* MouseTargetType.GUTTER_VIEW_ZONE */) {\n                const viewZoneId = e.target.detail.viewZoneId;\n                if (viewZoneId === this._viewZoneId) {\n                    this.visibility = true;\n                    currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);\n                }\n                else {\n                    this.visibility = false;\n                }\n            }\n            else {\n                this.visibility = false;\n            }\n        }));\n        this._register(editor.onMouseDown((e) => {\n            if (!e.event.rightButton) {\n                return;\n            }\n            if (e.target.type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */ || e.target.type === 5 /* MouseTargetType.GUTTER_VIEW_ZONE */) {\n                const viewZoneId = e.target.detail.viewZoneId;\n                if (viewZoneId === this._viewZoneId) {\n                    e.event.preventDefault();\n                    currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);\n                    showContextMenu(e.event.posx, e.event.posy + lineHeight);\n                }\n            }\n        }));\n    }\n    get visibility() {\n        return this._visibility;\n    }\n    set visibility(_visibility) {\n        if (this._visibility !== _visibility) {\n            this._visibility = _visibility;\n            if (_visibility) {\n                this._diffActions.style.visibility = 'visible';\n            }\n            else {\n                this._diffActions.style.visibility = 'hidden';\n            }\n        }\n    }\n    _updateLightBulbPosition(marginDomNode, y, lineHeight) {\n        const { top } = dom.getDomNodePagePosition(marginDomNode);\n        const offset = y - top;\n        const lineNumberOffset = Math.floor(offset / lineHeight);\n        const newTop = lineNumberOffset * lineHeight;\n        this._diffActions.style.top = `${newTop}px`;\n        if (this.diff.viewLineCounts) {\n            let acc = 0;\n            for (let i = 0; i < this.diff.viewLineCounts.length; i++) {\n                acc += this.diff.viewLineCounts[i];\n                if (lineNumberOffset < acc) {\n                    return i;\n                }\n            }\n        }\n        return lineNumberOffset;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IClipboardService = createDecorator('clipboardService');\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IProgressService = createDecorator('progressService');\nexport const emptyProgressRunner = Object.freeze({\n    total() { },\n    worked() { },\n    done() { }\n});\nexport class Progress {\n    constructor(callback) {\n        this.callback = callback;\n    }\n    report(item) {\n        this._value = item;\n        this.callback(this._value);\n    }\n}\nProgress.None = Object.freeze({ report() { } });\nexport const IEditorProgressService = createDecorator('editorProgressService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar _a;\nimport './media/diffEditor.css';\nimport * as nls from '../../../nls.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport * as assert from '../../../base/common/assert.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { Sash } from '../../../base/browser/ui/sash/sash.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { StableEditorScrollState } from '../stableEditorScroll.js';\nimport { ICodeEditorService } from '../services/codeEditorService.js';\nimport { CodeEditorWidget } from './codeEditorWidget.js';\nimport { DiffReview } from './diffReview.js';\nimport { EditorOptions, EditorFontLigatures, stringSet as validateStringSetOption, boolean as validateBooleanOption, clampedInt } from '../../common/config/editorOptions.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as editorCommon from '../../common/editorCommon.js';\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorker.js';\nimport { OverviewRulerZone } from '../../common/viewModel/overviewZoneManager.js';\nimport { LineDecoration } from '../../common/viewLayout/lineDecorations.js';\nimport { RenderLineInput, renderViewLine } from '../../common/viewLayout/viewLineRenderer.js';\nimport { InlineDecoration, ViewLineRenderingData } from '../../common/viewModel.js';\nimport { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { INotificationService } from '../../../platform/notification/common/notification.js';\nimport { defaultInsertColor, defaultRemoveColor, diffBorder, diffInserted, diffInsertedOutline, diffRemoved, diffRemovedOutline, scrollbarShadow, scrollbarSliderBackground, scrollbarSliderHoverBackground, scrollbarSliderActiveBackground, diffDiagonalFill, diffInsertedLineGutter, diffRemovedLineGutter, diffInsertedLine, diffRemovedLine, diffOverviewRulerInserted, diffOverviewRulerRemoved } from '../../../platform/theme/common/colorRegistry.js';\nimport { IThemeService, getThemeTypeSelector, registerThemingParticipant, ThemeIcon } from '../../../platform/theme/common/themeService.js';\nimport { IContextMenuService } from '../../../platform/contextview/browser/contextView.js';\nimport { InlineDiffMargin } from './inlineDiffMargin.js';\nimport { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';\nimport { EditorExtensionsRegistry } from '../editorExtensions.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { IEditorProgressService } from '../../../platform/progress/common/progress.js';\nimport { ElementSizeObserver } from '../config/elementSizeObserver.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { registerIcon } from '../../../platform/theme/common/iconRegistry.js';\nimport { isHighContrast } from '../../../platform/theme/common/theme.js';\nclass VisualEditorState {\n    constructor(_contextMenuService, _clipboardService) {\n        this._contextMenuService = _contextMenuService;\n        this._clipboardService = _clipboardService;\n        this._zones = [];\n        this._inlineDiffMargins = [];\n        this._zonesMap = {};\n        this._decorations = [];\n    }\n    getForeignViewZones(allViewZones) {\n        return allViewZones.filter((z) => !this._zonesMap[String(z.id)]);\n    }\n    clean(editor) {\n        // (1) View zones\n        if (this._zones.length > 0) {\n            editor.changeViewZones((viewChangeAccessor) => {\n                for (const zoneId of this._zones) {\n                    viewChangeAccessor.removeZone(zoneId);\n                }\n            });\n        }\n        this._zones = [];\n        this._zonesMap = {};\n        // (2) Model decorations\n        editor.changeDecorations((changeAccessor) => {\n            this._decorations = changeAccessor.deltaDecorations(this._decorations, []);\n        });\n    }\n    apply(editor, overviewRuler, newDecorations, restoreScrollState) {\n        const scrollState = restoreScrollState ? StableEditorScrollState.capture(editor) : null;\n        // view zones\n        editor.changeViewZones((viewChangeAccessor) => {\n            var _a;\n            for (const zoneId of this._zones) {\n                viewChangeAccessor.removeZone(zoneId);\n            }\n            for (const inlineDiffMargin of this._inlineDiffMargins) {\n                inlineDiffMargin.dispose();\n            }\n            this._zones = [];\n            this._zonesMap = {};\n            this._inlineDiffMargins = [];\n            for (let i = 0, length = newDecorations.zones.length; i < length; i++) {\n                const viewZone = newDecorations.zones[i];\n                viewZone.suppressMouseDown = true;\n                const zoneId = viewChangeAccessor.addZone(viewZone);\n                this._zones.push(zoneId);\n                this._zonesMap[String(zoneId)] = true;\n                if (newDecorations.zones[i].diff && viewZone.marginDomNode) {\n                    viewZone.suppressMouseDown = false;\n                    if (((_a = newDecorations.zones[i].diff) === null || _a === void 0 ? void 0 : _a.originalModel.getValueLength()) !== 0) {\n                        // do not contribute diff margin actions for newly created files\n                        this._inlineDiffMargins.push(new InlineDiffMargin(zoneId, viewZone.marginDomNode, editor, newDecorations.zones[i].diff, this._contextMenuService, this._clipboardService));\n                    }\n                }\n            }\n        });\n        scrollState === null || scrollState === void 0 ? void 0 : scrollState.restore(editor);\n        // decorations\n        editor.changeDecorations((changeAccessor) => {\n            this._decorations = changeAccessor.deltaDecorations(this._decorations, newDecorations.decorations);\n        });\n        // overview ruler\n        overviewRuler === null || overviewRuler === void 0 ? void 0 : overviewRuler.setZones(newDecorations.overviewZones);\n    }\n}\nlet DIFF_EDITOR_ID = 0;\nconst diffInsertIcon = registerIcon('diff-insert', Codicon.add, nls.localize('diffInsertIcon', 'Line decoration for inserts in the diff editor.'));\nconst diffRemoveIcon = registerIcon('diff-remove', Codicon.remove, nls.localize('diffRemoveIcon', 'Line decoration for removals in the diff editor.'));\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('diffEditorWidget', { createHTML: value => value });\nlet DiffEditorWidget = class DiffEditorWidget extends Disposable {\n    constructor(domElement, options, codeEditorWidgetOptions, clipboardService, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, _editorProgressService) {\n        super();\n        this._editorProgressService = _editorProgressService;\n        this._onDidDispose = this._register(new Emitter());\n        this.onDidDispose = this._onDidDispose.event;\n        this._onDidUpdateDiff = this._register(new Emitter());\n        this.onDidUpdateDiff = this._onDidUpdateDiff.event;\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this._lastOriginalWarning = null;\n        this._lastModifiedWarning = null;\n        this._editorWorkerService = editorWorkerService;\n        this._codeEditorService = codeEditorService;\n        this._contextKeyService = this._register(contextKeyService.createScoped(domElement));\n        this._instantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));\n        this._contextKeyService.createKey('isInDiffEditor', true);\n        this._themeService = themeService;\n        this._notificationService = notificationService;\n        this._id = (++DIFF_EDITOR_ID);\n        this._state = 0 /* editorBrowser.DiffEditorState.Idle */;\n        this._updatingDiffProgress = null;\n        this._domElement = domElement;\n        options = options || {};\n        this._options = validateDiffEditorOptions(options, {\n            enableSplitViewResizing: true,\n            renderSideBySide: true,\n            renderMarginRevertIcon: true,\n            maxComputationTime: 5000,\n            maxFileSize: 50,\n            ignoreTrimWhitespace: true,\n            renderIndicators: true,\n            originalEditable: false,\n            diffCodeLens: false,\n            renderOverviewRuler: true,\n            diffWordWrap: 'inherit'\n        });\n        if (typeof options.isInEmbeddedEditor !== 'undefined') {\n            this._contextKeyService.createKey('isInEmbeddedDiffEditor', options.isInEmbeddedEditor);\n        }\n        else {\n            this._contextKeyService.createKey('isInEmbeddedDiffEditor', false);\n        }\n        this._updateDecorationsRunner = this._register(new RunOnceScheduler(() => this._updateDecorations(), 0));\n        this._containerDomElement = document.createElement('div');\n        this._containerDomElement.className = DiffEditorWidget._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide);\n        this._containerDomElement.style.position = 'relative';\n        this._containerDomElement.style.height = '100%';\n        this._domElement.appendChild(this._containerDomElement);\n        this._overviewViewportDomElement = createFastDomNode(document.createElement('div'));\n        this._overviewViewportDomElement.setClassName('diffViewport');\n        this._overviewViewportDomElement.setPosition('absolute');\n        this._overviewDomElement = document.createElement('div');\n        this._overviewDomElement.className = 'diffOverview';\n        this._overviewDomElement.style.position = 'absolute';\n        this._overviewDomElement.appendChild(this._overviewViewportDomElement.domNode);\n        this._register(dom.addStandardDisposableListener(this._overviewDomElement, dom.EventType.POINTER_DOWN, (e) => {\n            this._modifiedEditor.delegateVerticalScrollbarPointerDown(e);\n        }));\n        if (this._options.renderOverviewRuler) {\n            this._containerDomElement.appendChild(this._overviewDomElement);\n        }\n        // Create left side\n        this._originalDomNode = document.createElement('div');\n        this._originalDomNode.className = 'editor original';\n        this._originalDomNode.style.position = 'absolute';\n        this._originalDomNode.style.height = '100%';\n        this._containerDomElement.appendChild(this._originalDomNode);\n        // Create right side\n        this._modifiedDomNode = document.createElement('div');\n        this._modifiedDomNode.className = 'editor modified';\n        this._modifiedDomNode.style.position = 'absolute';\n        this._modifiedDomNode.style.height = '100%';\n        this._containerDomElement.appendChild(this._modifiedDomNode);\n        this._beginUpdateDecorationsTimeout = -1;\n        this._currentlyChangingViewZones = false;\n        this._diffComputationToken = 0;\n        this._originalEditorState = new VisualEditorState(contextMenuService, clipboardService);\n        this._modifiedEditorState = new VisualEditorState(contextMenuService, clipboardService);\n        this._isVisible = true;\n        this._isHandlingScrollEvent = false;\n        this._elementSizeObserver = this._register(new ElementSizeObserver(this._containerDomElement, options.dimension));\n        this._register(this._elementSizeObserver.onDidChange(() => this._onDidContainerSizeChanged()));\n        if (options.automaticLayout) {\n            this._elementSizeObserver.startObserving();\n        }\n        this._diffComputationResult = null;\n        this._originalEditor = this._createLeftHandSideEditor(options, codeEditorWidgetOptions.originalEditor || {});\n        this._modifiedEditor = this._createRightHandSideEditor(options, codeEditorWidgetOptions.modifiedEditor || {});\n        this._originalOverviewRuler = null;\n        this._modifiedOverviewRuler = null;\n        this._reviewPane = instantiationService.createInstance(DiffReview, this);\n        this._containerDomElement.appendChild(this._reviewPane.domNode.domNode);\n        this._containerDomElement.appendChild(this._reviewPane.shadow.domNode);\n        this._containerDomElement.appendChild(this._reviewPane.actionBarContainer.domNode);\n        if (this._options.renderSideBySide) {\n            this._setStrategy(new DiffEditorWidgetSideBySide(this._createDataSource(), this._options.enableSplitViewResizing));\n        }\n        else {\n            this._setStrategy(new DiffEditorWidgetInline(this._createDataSource(), this._options.enableSplitViewResizing));\n        }\n        this._register(themeService.onDidColorThemeChange(t => {\n            if (this._strategy && this._strategy.applyColors(t)) {\n                this._updateDecorationsRunner.schedule();\n            }\n            this._containerDomElement.className = DiffEditorWidget._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide);\n        }));\n        const contributions = EditorExtensionsRegistry.getDiffEditorContributions();\n        for (const desc of contributions) {\n            try {\n                this._register(instantiationService.createInstance(desc.ctor, this));\n            }\n            catch (err) {\n                onUnexpectedError(err);\n            }\n        }\n        this._codeEditorService.addDiffEditor(this);\n    }\n    _setState(newState) {\n        if (this._state === newState) {\n            return;\n        }\n        this._state = newState;\n        if (this._updatingDiffProgress) {\n            this._updatingDiffProgress.done();\n            this._updatingDiffProgress = null;\n        }\n        if (this._state === 1 /* editorBrowser.DiffEditorState.ComputingDiff */) {\n            this._updatingDiffProgress = this._editorProgressService.show(true, 1000);\n        }\n    }\n    diffReviewNext() {\n        this._reviewPane.next();\n    }\n    diffReviewPrev() {\n        this._reviewPane.prev();\n    }\n    static _getClassName(theme, renderSideBySide) {\n        let result = 'monaco-diff-editor monaco-editor-background ';\n        if (renderSideBySide) {\n            result += 'side-by-side ';\n        }\n        result += getThemeTypeSelector(theme.type);\n        return result;\n    }\n    _disposeOverviewRulers() {\n        if (this._originalOverviewRuler) {\n            this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());\n            this._originalOverviewRuler.dispose();\n            this._originalOverviewRuler = null;\n        }\n        if (this._modifiedOverviewRuler) {\n            this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());\n            this._modifiedOverviewRuler.dispose();\n            this._modifiedOverviewRuler = null;\n        }\n    }\n    _createOverviewRulers() {\n        if (!this._options.renderOverviewRuler) {\n            return;\n        }\n        assert.ok(!this._originalOverviewRuler && !this._modifiedOverviewRuler);\n        if (this._originalEditor.hasModel()) {\n            this._originalOverviewRuler = this._originalEditor.createOverviewRuler('original diffOverviewRuler');\n            this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode());\n        }\n        if (this._modifiedEditor.hasModel()) {\n            this._modifiedOverviewRuler = this._modifiedEditor.createOverviewRuler('modified diffOverviewRuler');\n            this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode());\n        }\n        this._layoutOverviewRulers();\n    }\n    _createLeftHandSideEditor(options, codeEditorWidgetOptions) {\n        const editor = this._createInnerEditor(this._instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(options), codeEditorWidgetOptions);\n        this._register(editor.onDidScrollChange((e) => {\n            if (this._isHandlingScrollEvent) {\n                return;\n            }\n            if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {\n                return;\n            }\n            this._isHandlingScrollEvent = true;\n            this._modifiedEditor.setScrollPosition({\n                scrollLeft: e.scrollLeft,\n                scrollTop: e.scrollTop\n            });\n            this._isHandlingScrollEvent = false;\n            this._layoutOverviewViewport();\n        }));\n        this._register(editor.onDidChangeViewZones(() => {\n            this._onViewZonesChanged();\n        }));\n        this._register(editor.onDidChangeConfiguration((e) => {\n            if (!editor.getModel()) {\n                return;\n            }\n            if (e.hasChanged(46 /* EditorOption.fontInfo */)) {\n                this._updateDecorationsRunner.schedule();\n            }\n            if (e.hasChanged(134 /* EditorOption.wrappingInfo */)) {\n                this._updateDecorationsRunner.cancel();\n                this._updateDecorations();\n            }\n        }));\n        this._register(editor.onDidChangeHiddenAreas(() => {\n            this._updateDecorationsRunner.cancel();\n            this._updateDecorations();\n        }));\n        this._register(editor.onDidChangeModelContent(() => {\n            if (this._isVisible) {\n                this._beginUpdateDecorationsSoon();\n            }\n        }));\n        const isInDiffLeftEditorKey = this._contextKeyService.createKey('isInDiffLeftEditor', editor.hasWidgetFocus());\n        this._register(editor.onDidFocusEditorWidget(() => isInDiffLeftEditorKey.set(true)));\n        this._register(editor.onDidBlurEditorWidget(() => isInDiffLeftEditorKey.set(false)));\n        this._register(editor.onDidContentSizeChange(e => {\n            const width = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + DiffEditorWidget.ONE_OVERVIEW_WIDTH;\n            const height = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());\n            this._onDidContentSizeChange.fire({\n                contentHeight: height,\n                contentWidth: width,\n                contentHeightChanged: e.contentHeightChanged,\n                contentWidthChanged: e.contentWidthChanged\n            });\n        }));\n        return editor;\n    }\n    _createRightHandSideEditor(options, codeEditorWidgetOptions) {\n        const editor = this._createInnerEditor(this._instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(options), codeEditorWidgetOptions);\n        this._register(editor.onDidScrollChange((e) => {\n            if (this._isHandlingScrollEvent) {\n                return;\n            }\n            if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {\n                return;\n            }\n            this._isHandlingScrollEvent = true;\n            this._originalEditor.setScrollPosition({\n                scrollLeft: e.scrollLeft,\n                scrollTop: e.scrollTop\n            });\n            this._isHandlingScrollEvent = false;\n            this._layoutOverviewViewport();\n        }));\n        this._register(editor.onDidChangeViewZones(() => {\n            this._onViewZonesChanged();\n        }));\n        this._register(editor.onDidChangeConfiguration((e) => {\n            if (!editor.getModel()) {\n                return;\n            }\n            if (e.hasChanged(46 /* EditorOption.fontInfo */)) {\n                this._updateDecorationsRunner.schedule();\n            }\n            if (e.hasChanged(134 /* EditorOption.wrappingInfo */)) {\n                this._updateDecorationsRunner.cancel();\n                this._updateDecorations();\n            }\n        }));\n        this._register(editor.onDidChangeHiddenAreas(() => {\n            this._updateDecorationsRunner.cancel();\n            this._updateDecorations();\n        }));\n        this._register(editor.onDidChangeModelContent(() => {\n            if (this._isVisible) {\n                this._beginUpdateDecorationsSoon();\n            }\n        }));\n        this._register(editor.onDidChangeModelOptions((e) => {\n            if (e.tabSize) {\n                this._updateDecorationsRunner.schedule();\n            }\n        }));\n        const isInDiffRightEditorKey = this._contextKeyService.createKey('isInDiffRightEditor', editor.hasWidgetFocus());\n        this._register(editor.onDidFocusEditorWidget(() => isInDiffRightEditorKey.set(true)));\n        this._register(editor.onDidBlurEditorWidget(() => isInDiffRightEditorKey.set(false)));\n        this._register(editor.onDidContentSizeChange(e => {\n            const width = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + DiffEditorWidget.ONE_OVERVIEW_WIDTH;\n            const height = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());\n            this._onDidContentSizeChange.fire({\n                contentHeight: height,\n                contentWidth: width,\n                contentHeightChanged: e.contentHeightChanged,\n                contentWidthChanged: e.contentWidthChanged\n            });\n        }));\n        // Revert change when an arrow is clicked.\n        this._register(editor.onMouseDown(event => {\n            var _a, _b;\n            if (!event.event.rightButton && event.target.position && ((_a = event.target.element) === null || _a === void 0 ? void 0 : _a.className.includes('arrow-revert-change'))) {\n                const lineNumber = event.target.position.lineNumber;\n                const change = (_b = this._diffComputationResult) === null || _b === void 0 ? void 0 : _b.changes.find(c => c.modifiedStartLineNumber === lineNumber - 1 || c.modifiedStartLineNumber === lineNumber);\n                if (change) {\n                    this.revertChange(change);\n                }\n                event.event.stopPropagation();\n                this._updateDecorations();\n                return;\n            }\n        }));\n        return editor;\n    }\n    /**\n     * Reverts a change in the modified editor.\n     */\n    revertChange(change) {\n        const editor = this._modifiedEditor;\n        const original = this._originalEditor.getModel();\n        const modified = this._modifiedEditor.getModel();\n        if (!original || !modified || !editor) {\n            return;\n        }\n        const originalRange = change.originalEndLineNumber > 0 ? new Range(change.originalStartLineNumber, 1, change.originalEndLineNumber, original.getLineMaxColumn(change.originalEndLineNumber)) : null;\n        const originalContent = originalRange ? original.getValueInRange(originalRange) : null;\n        const newRange = change.modifiedEndLineNumber > 0 ? new Range(change.modifiedStartLineNumber, 1, change.modifiedEndLineNumber, modified.getLineMaxColumn(change.modifiedEndLineNumber)) : null;\n        const eol = modified.getEOL();\n        if (change.originalEndLineNumber === 0 && newRange) {\n            // Insert change.\n            // To revert: delete the new content and a linebreak (if possible)\n            let range = newRange;\n            if (change.modifiedStartLineNumber > 1) {\n                // Try to include a linebreak from before.\n                range = newRange.setStartPosition(change.modifiedStartLineNumber - 1, modified.getLineMaxColumn(change.modifiedStartLineNumber - 1));\n            }\n            else if (change.modifiedEndLineNumber < modified.getLineCount()) {\n                // Try to include the linebreak from after.\n                range = newRange.setEndPosition(change.modifiedEndLineNumber + 1, 1);\n            }\n            editor.executeEdits('diffEditor', [{\n                    range,\n                    text: '',\n                }]);\n        }\n        else if (change.modifiedEndLineNumber === 0 && originalContent !== null) {\n            // Delete change.\n            // To revert: insert the old content and a linebreak.\n            const insertAt = change.modifiedStartLineNumber < modified.getLineCount() ? new Position(change.modifiedStartLineNumber + 1, 1) : new Position(change.modifiedStartLineNumber, modified.getLineMaxColumn(change.modifiedStartLineNumber));\n            editor.executeEdits('diffEditor', [{\n                    range: Range.fromPositions(insertAt, insertAt),\n                    text: change.modifiedStartLineNumber < modified.getLineCount() ? originalContent + eol : eol + originalContent,\n                }]);\n        }\n        else if (newRange && originalContent !== null) {\n            // Modified change.\n            editor.executeEdits('diffEditor', [{\n                    range: newRange,\n                    text: originalContent,\n                }]);\n        }\n    }\n    _createInnerEditor(instantiationService, container, options, editorWidgetOptions) {\n        return instantiationService.createInstance(CodeEditorWidget, container, options, editorWidgetOptions);\n    }\n    dispose() {\n        this._codeEditorService.removeDiffEditor(this);\n        if (this._beginUpdateDecorationsTimeout !== -1) {\n            window.clearTimeout(this._beginUpdateDecorationsTimeout);\n            this._beginUpdateDecorationsTimeout = -1;\n        }\n        this._cleanViewZonesAndDecorations();\n        if (this._originalOverviewRuler) {\n            this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());\n            this._originalOverviewRuler.dispose();\n        }\n        if (this._modifiedOverviewRuler) {\n            this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());\n            this._modifiedOverviewRuler.dispose();\n        }\n        this._overviewDomElement.removeChild(this._overviewViewportDomElement.domNode);\n        if (this._options.renderOverviewRuler) {\n            this._containerDomElement.removeChild(this._overviewDomElement);\n        }\n        this._containerDomElement.removeChild(this._originalDomNode);\n        this._originalEditor.dispose();\n        this._containerDomElement.removeChild(this._modifiedDomNode);\n        this._modifiedEditor.dispose();\n        this._strategy.dispose();\n        this._containerDomElement.removeChild(this._reviewPane.domNode.domNode);\n        this._containerDomElement.removeChild(this._reviewPane.shadow.domNode);\n        this._containerDomElement.removeChild(this._reviewPane.actionBarContainer.domNode);\n        this._reviewPane.dispose();\n        this._domElement.removeChild(this._containerDomElement);\n        this._onDidDispose.fire();\n        super.dispose();\n    }\n    //------------ begin IDiffEditor methods\n    getId() {\n        return this.getEditorType() + ':' + this._id;\n    }\n    getEditorType() {\n        return editorCommon.EditorType.IDiffEditor;\n    }\n    getLineChanges() {\n        if (!this._diffComputationResult) {\n            return null;\n        }\n        return this._diffComputationResult.changes;\n    }\n    getOriginalEditor() {\n        return this._originalEditor;\n    }\n    getModifiedEditor() {\n        return this._modifiedEditor;\n    }\n    updateOptions(_newOptions) {\n        const newOptions = validateDiffEditorOptions(_newOptions, this._options);\n        const changed = changedDiffEditorOptions(this._options, newOptions);\n        this._options = newOptions;\n        const beginUpdateDecorations = (changed.ignoreTrimWhitespace || changed.renderIndicators || changed.renderMarginRevertIcon);\n        const beginUpdateDecorationsSoon = (this._isVisible && (changed.maxComputationTime || changed.maxFileSize));\n        if (beginUpdateDecorations) {\n            this._beginUpdateDecorations();\n        }\n        else if (beginUpdateDecorationsSoon) {\n            this._beginUpdateDecorationsSoon();\n        }\n        this._modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(_newOptions));\n        this._originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(_newOptions));\n        // enableSplitViewResizing\n        this._strategy.setEnableSplitViewResizing(this._options.enableSplitViewResizing);\n        // renderSideBySide\n        if (changed.renderSideBySide) {\n            if (this._options.renderSideBySide) {\n                this._setStrategy(new DiffEditorWidgetSideBySide(this._createDataSource(), this._options.enableSplitViewResizing));\n            }\n            else {\n                this._setStrategy(new DiffEditorWidgetInline(this._createDataSource(), this._options.enableSplitViewResizing));\n            }\n            // Update class name\n            this._containerDomElement.className = DiffEditorWidget._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide);\n        }\n        // renderOverviewRuler\n        if (changed.renderOverviewRuler) {\n            if (this._options.renderOverviewRuler) {\n                this._containerDomElement.appendChild(this._overviewDomElement);\n            }\n            else {\n                this._containerDomElement.removeChild(this._overviewDomElement);\n            }\n        }\n    }\n    getModel() {\n        return {\n            original: this._originalEditor.getModel(),\n            modified: this._modifiedEditor.getModel()\n        };\n    }\n    setModel(model) {\n        // Guard us against partial null model\n        if (model && (!model.original || !model.modified)) {\n            throw new Error(!model.original ? 'DiffEditorWidget.setModel: Original model is null' : 'DiffEditorWidget.setModel: Modified model is null');\n        }\n        // Remove all view zones & decorations\n        this._cleanViewZonesAndDecorations();\n        this._disposeOverviewRulers();\n        // Update code editor models\n        this._originalEditor.setModel(model ? model.original : null);\n        this._modifiedEditor.setModel(model ? model.modified : null);\n        this._updateDecorationsRunner.cancel();\n        // this.originalEditor.onDidChangeModelOptions\n        if (model) {\n            this._originalEditor.setScrollTop(0);\n            this._modifiedEditor.setScrollTop(0);\n        }\n        // Disable any diff computations that will come in\n        this._diffComputationResult = null;\n        this._diffComputationToken++;\n        this._setState(0 /* editorBrowser.DiffEditorState.Idle */);\n        if (model) {\n            this._createOverviewRulers();\n            // Begin comparing\n            this._beginUpdateDecorations();\n        }\n        this._layoutOverviewViewport();\n    }\n    getContainerDomNode() {\n        return this._domElement;\n    }\n    getVisibleColumnFromPosition(position) {\n        return this._modifiedEditor.getVisibleColumnFromPosition(position);\n    }\n    getPosition() {\n        return this._modifiedEditor.getPosition();\n    }\n    setPosition(position, source = 'api') {\n        this._modifiedEditor.setPosition(position, source);\n    }\n    revealLine(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealLine(lineNumber, scrollType);\n    }\n    revealLineInCenter(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealLineInCenter(lineNumber, scrollType);\n    }\n    revealLineInCenterIfOutsideViewport(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealLineInCenterIfOutsideViewport(lineNumber, scrollType);\n    }\n    revealLineNearTop(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealLineNearTop(lineNumber, scrollType);\n    }\n    revealPosition(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealPosition(position, scrollType);\n    }\n    revealPositionInCenter(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealPositionInCenter(position, scrollType);\n    }\n    revealPositionInCenterIfOutsideViewport(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealPositionInCenterIfOutsideViewport(position, scrollType);\n    }\n    revealPositionNearTop(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealPositionNearTop(position, scrollType);\n    }\n    getSelection() {\n        return this._modifiedEditor.getSelection();\n    }\n    getSelections() {\n        return this._modifiedEditor.getSelections();\n    }\n    setSelection(something, source = 'api') {\n        this._modifiedEditor.setSelection(something, source);\n    }\n    setSelections(ranges, source = 'api') {\n        this._modifiedEditor.setSelections(ranges, source);\n    }\n    revealLines(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealLines(startLineNumber, endLineNumber, scrollType);\n    }\n    revealLinesInCenter(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealLinesInCenter(startLineNumber, endLineNumber, scrollType);\n    }\n    revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType);\n    }\n    revealLinesNearTop(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealLinesNearTop(startLineNumber, endLineNumber, scrollType);\n    }\n    revealRange(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */, revealVerticalInCenter = false, revealHorizontal = true) {\n        this._modifiedEditor.revealRange(range, scrollType, revealVerticalInCenter, revealHorizontal);\n    }\n    revealRangeInCenter(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealRangeInCenter(range, scrollType);\n    }\n    revealRangeInCenterIfOutsideViewport(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealRangeInCenterIfOutsideViewport(range, scrollType);\n    }\n    revealRangeNearTop(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealRangeNearTop(range, scrollType);\n    }\n    revealRangeNearTopIfOutsideViewport(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealRangeNearTopIfOutsideViewport(range, scrollType);\n    }\n    revealRangeAtTop(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._modifiedEditor.revealRangeAtTop(range, scrollType);\n    }\n    getSupportedActions() {\n        return this._modifiedEditor.getSupportedActions();\n    }\n    saveViewState() {\n        const originalViewState = this._originalEditor.saveViewState();\n        const modifiedViewState = this._modifiedEditor.saveViewState();\n        return {\n            original: originalViewState,\n            modified: modifiedViewState\n        };\n    }\n    restoreViewState(s) {\n        if (s && s.original && s.modified) {\n            const diffEditorState = s;\n            this._originalEditor.restoreViewState(diffEditorState.original);\n            this._modifiedEditor.restoreViewState(diffEditorState.modified);\n        }\n    }\n    layout(dimension) {\n        this._elementSizeObserver.observe(dimension);\n    }\n    focus() {\n        this._modifiedEditor.focus();\n    }\n    hasTextFocus() {\n        return this._originalEditor.hasTextFocus() || this._modifiedEditor.hasTextFocus();\n    }\n    trigger(source, handlerId, payload) {\n        this._modifiedEditor.trigger(source, handlerId, payload);\n    }\n    createDecorationsCollection(decorations) {\n        return this._modifiedEditor.createDecorationsCollection(decorations);\n    }\n    changeDecorations(callback) {\n        return this._modifiedEditor.changeDecorations(callback);\n    }\n    //------------ end IDiffEditor methods\n    //------------ begin layouting methods\n    _onDidContainerSizeChanged() {\n        this._doLayout();\n    }\n    _getReviewHeight() {\n        return this._reviewPane.isVisible() ? this._elementSizeObserver.getHeight() : 0;\n    }\n    _layoutOverviewRulers() {\n        if (!this._options.renderOverviewRuler) {\n            return;\n        }\n        if (!this._originalOverviewRuler || !this._modifiedOverviewRuler) {\n            return;\n        }\n        const height = this._elementSizeObserver.getHeight();\n        const reviewHeight = this._getReviewHeight();\n        const freeSpace = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * DiffEditorWidget.ONE_OVERVIEW_WIDTH;\n        const layoutInfo = this._modifiedEditor.getLayoutInfo();\n        if (layoutInfo) {\n            this._originalOverviewRuler.setLayout({\n                top: 0,\n                width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,\n                right: freeSpace + DiffEditorWidget.ONE_OVERVIEW_WIDTH,\n                height: (height - reviewHeight)\n            });\n            this._modifiedOverviewRuler.setLayout({\n                top: 0,\n                right: 0,\n                width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,\n                height: (height - reviewHeight)\n            });\n        }\n    }\n    //------------ end layouting methods\n    _onViewZonesChanged() {\n        if (this._currentlyChangingViewZones) {\n            return;\n        }\n        this._updateDecorationsRunner.schedule();\n    }\n    _beginUpdateDecorationsSoon() {\n        // Clear previous timeout if necessary\n        if (this._beginUpdateDecorationsTimeout !== -1) {\n            window.clearTimeout(this._beginUpdateDecorationsTimeout);\n            this._beginUpdateDecorationsTimeout = -1;\n        }\n        this._beginUpdateDecorationsTimeout = window.setTimeout(() => this._beginUpdateDecorations(), DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY);\n    }\n    static _equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return (a.toString() === b.toString());\n    }\n    _beginUpdateDecorations() {\n        this._beginUpdateDecorationsTimeout = -1;\n        const currentOriginalModel = this._originalEditor.getModel();\n        const currentModifiedModel = this._modifiedEditor.getModel();\n        if (!currentOriginalModel || !currentModifiedModel) {\n            return;\n        }\n        // Prevent old diff requests to come if a new request has been initiated\n        // The best method would be to call cancel on the Promise, but this is not\n        // yet supported, so using tokens for now.\n        this._diffComputationToken++;\n        const currentToken = this._diffComputationToken;\n        const diffLimit = this._options.maxFileSize * 1024 * 1024; // MB\n        const canSyncModelForDiff = (model) => {\n            const bufferTextLength = model.getValueLength();\n            return (diffLimit === 0 || bufferTextLength <= diffLimit);\n        };\n        if (!canSyncModelForDiff(currentOriginalModel) || !canSyncModelForDiff(currentModifiedModel)) {\n            if (!DiffEditorWidget._equals(currentOriginalModel.uri, this._lastOriginalWarning)\n                || !DiffEditorWidget._equals(currentModifiedModel.uri, this._lastModifiedWarning)) {\n                this._lastOriginalWarning = currentOriginalModel.uri;\n                this._lastModifiedWarning = currentModifiedModel.uri;\n                this._notificationService.warn(nls.localize(\"diff.tooLarge\", \"Cannot compare files because one file is too large.\"));\n            }\n            return;\n        }\n        this._setState(1 /* editorBrowser.DiffEditorState.ComputingDiff */);\n        this._editorWorkerService.computeDiff(currentOriginalModel.uri, currentModifiedModel.uri, this._options.ignoreTrimWhitespace, this._options.maxComputationTime).then((result) => {\n            if (currentToken === this._diffComputationToken\n                && currentOriginalModel === this._originalEditor.getModel()\n                && currentModifiedModel === this._modifiedEditor.getModel()) {\n                this._setState(2 /* editorBrowser.DiffEditorState.DiffComputed */);\n                this._diffComputationResult = result;\n                this._updateDecorationsRunner.schedule();\n                this._onDidUpdateDiff.fire();\n            }\n        }, (error) => {\n            if (currentToken === this._diffComputationToken\n                && currentOriginalModel === this._originalEditor.getModel()\n                && currentModifiedModel === this._modifiedEditor.getModel()) {\n                this._setState(2 /* editorBrowser.DiffEditorState.DiffComputed */);\n                this._diffComputationResult = null;\n                this._updateDecorationsRunner.schedule();\n            }\n        });\n    }\n    _cleanViewZonesAndDecorations() {\n        this._originalEditorState.clean(this._originalEditor);\n        this._modifiedEditorState.clean(this._modifiedEditor);\n    }\n    _updateDecorations() {\n        if (!this._originalEditor.getModel() || !this._modifiedEditor.getModel()) {\n            return;\n        }\n        const lineChanges = (this._diffComputationResult ? this._diffComputationResult.changes : []);\n        const foreignOriginal = this._originalEditorState.getForeignViewZones(this._originalEditor.getWhitespaces());\n        const foreignModified = this._modifiedEditorState.getForeignViewZones(this._modifiedEditor.getWhitespaces());\n        const diffDecorations = this._strategy.getEditorsDiffDecorations(lineChanges, this._options.ignoreTrimWhitespace, this._options.renderIndicators, this._options.renderMarginRevertIcon, foreignOriginal, foreignModified);\n        try {\n            this._currentlyChangingViewZones = true;\n            this._originalEditorState.apply(this._originalEditor, this._originalOverviewRuler, diffDecorations.original, false);\n            this._modifiedEditorState.apply(this._modifiedEditor, this._modifiedOverviewRuler, diffDecorations.modified, true);\n        }\n        finally {\n            this._currentlyChangingViewZones = false;\n        }\n    }\n    _adjustOptionsForSubEditor(options) {\n        const clonedOptions = Object.assign({}, options);\n        clonedOptions.inDiffEditor = true;\n        clonedOptions.automaticLayout = false;\n        // Clone scrollbar options before changing them\n        clonedOptions.scrollbar = Object.assign({}, (clonedOptions.scrollbar || {}));\n        clonedOptions.scrollbar.vertical = 'visible';\n        clonedOptions.folding = false;\n        clonedOptions.codeLens = this._options.diffCodeLens;\n        clonedOptions.fixedOverflowWidgets = true;\n        // clonedOptions.lineDecorationsWidth = '2ch';\n        // Clone minimap options before changing them\n        clonedOptions.minimap = Object.assign({}, (clonedOptions.minimap || {}));\n        clonedOptions.minimap.enabled = false;\n        return clonedOptions;\n    }\n    _adjustOptionsForLeftHandSide(options) {\n        const result = this._adjustOptionsForSubEditor(options);\n        if (!this._options.renderSideBySide) {\n            // never wrap hidden editor\n            result.wordWrapOverride1 = 'off';\n            result.wordWrapOverride2 = 'off';\n        }\n        else {\n            result.wordWrapOverride1 = this._options.diffWordWrap;\n        }\n        if (options.originalAriaLabel) {\n            result.ariaLabel = options.originalAriaLabel;\n        }\n        result.readOnly = !this._options.originalEditable;\n        result.dropIntoEditor = { enabled: !result.readOnly };\n        result.extraEditorClassName = 'original-in-monaco-diff-editor';\n        return Object.assign(Object.assign({}, result), { dimension: {\n                height: 0,\n                width: 0\n            } });\n    }\n    _adjustOptionsForRightHandSide(options) {\n        const result = this._adjustOptionsForSubEditor(options);\n        if (options.modifiedAriaLabel) {\n            result.ariaLabel = options.modifiedAriaLabel;\n        }\n        result.wordWrapOverride1 = this._options.diffWordWrap;\n        result.revealHorizontalRightPadding = EditorOptions.revealHorizontalRightPadding.defaultValue + DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;\n        result.scrollbar.verticalHasArrows = false;\n        result.extraEditorClassName = 'modified-in-monaco-diff-editor';\n        return Object.assign(Object.assign({}, result), { dimension: {\n                height: 0,\n                width: 0\n            } });\n    }\n    doLayout() {\n        this._elementSizeObserver.observe();\n        this._doLayout();\n    }\n    _doLayout() {\n        const width = this._elementSizeObserver.getWidth();\n        const height = this._elementSizeObserver.getHeight();\n        const reviewHeight = this._getReviewHeight();\n        const splitPoint = this._strategy.layout();\n        this._originalDomNode.style.width = splitPoint + 'px';\n        this._originalDomNode.style.left = '0px';\n        this._modifiedDomNode.style.width = (width - splitPoint) + 'px';\n        this._modifiedDomNode.style.left = splitPoint + 'px';\n        this._overviewDomElement.style.top = '0px';\n        this._overviewDomElement.style.height = (height - reviewHeight) + 'px';\n        this._overviewDomElement.style.width = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH + 'px';\n        this._overviewDomElement.style.left = (width - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH) + 'px';\n        this._overviewViewportDomElement.setWidth(DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH);\n        this._overviewViewportDomElement.setHeight(30);\n        this._originalEditor.layout({ width: splitPoint, height: (height - reviewHeight) });\n        this._modifiedEditor.layout({ width: width - splitPoint - (this._options.renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), height: (height - reviewHeight) });\n        if (this._originalOverviewRuler || this._modifiedOverviewRuler) {\n            this._layoutOverviewRulers();\n        }\n        this._reviewPane.layout(height - reviewHeight, width, reviewHeight);\n        this._layoutOverviewViewport();\n    }\n    _layoutOverviewViewport() {\n        const layout = this._computeOverviewViewport();\n        if (!layout) {\n            this._overviewViewportDomElement.setTop(0);\n            this._overviewViewportDomElement.setHeight(0);\n        }\n        else {\n            this._overviewViewportDomElement.setTop(layout.top);\n            this._overviewViewportDomElement.setHeight(layout.height);\n        }\n    }\n    _computeOverviewViewport() {\n        const layoutInfo = this._modifiedEditor.getLayoutInfo();\n        if (!layoutInfo) {\n            return null;\n        }\n        const scrollTop = this._modifiedEditor.getScrollTop();\n        const scrollHeight = this._modifiedEditor.getScrollHeight();\n        const computedAvailableSize = Math.max(0, layoutInfo.height);\n        const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * 0);\n        const computedRatio = scrollHeight > 0 ? (computedRepresentableSize / scrollHeight) : 0;\n        const computedSliderSize = Math.max(0, Math.floor(layoutInfo.height * computedRatio));\n        const computedSliderPosition = Math.floor(scrollTop * computedRatio);\n        return {\n            height: computedSliderSize,\n            top: computedSliderPosition\n        };\n    }\n    _createDataSource() {\n        return {\n            getWidth: () => {\n                return this._elementSizeObserver.getWidth();\n            },\n            getHeight: () => {\n                return (this._elementSizeObserver.getHeight() - this._getReviewHeight());\n            },\n            getOptions: () => {\n                return {\n                    renderOverviewRuler: this._options.renderOverviewRuler\n                };\n            },\n            getContainerDomNode: () => {\n                return this._containerDomElement;\n            },\n            relayoutEditors: () => {\n                this._doLayout();\n            },\n            getOriginalEditor: () => {\n                return this._originalEditor;\n            },\n            getModifiedEditor: () => {\n                return this._modifiedEditor;\n            }\n        };\n    }\n    _setStrategy(newStrategy) {\n        if (this._strategy) {\n            this._strategy.dispose();\n        }\n        this._strategy = newStrategy;\n        newStrategy.applyColors(this._themeService.getColorTheme());\n        if (this._diffComputationResult) {\n            this._updateDecorations();\n        }\n        // Just do a layout, the strategy might need it\n        this._doLayout();\n    }\n    _getLineChangeAtOrBeforeLineNumber(lineNumber, startLineNumberExtractor) {\n        const lineChanges = (this._diffComputationResult ? this._diffComputationResult.changes : []);\n        if (lineChanges.length === 0 || lineNumber < startLineNumberExtractor(lineChanges[0])) {\n            // There are no changes or `lineNumber` is before the first change\n            return null;\n        }\n        let min = 0;\n        let max = lineChanges.length - 1;\n        while (min < max) {\n            const mid = Math.floor((min + max) / 2);\n            const midStart = startLineNumberExtractor(lineChanges[mid]);\n            const midEnd = (mid + 1 <= max ? startLineNumberExtractor(lineChanges[mid + 1]) : 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n            if (lineNumber < midStart) {\n                max = mid - 1;\n            }\n            else if (lineNumber >= midEnd) {\n                min = mid + 1;\n            }\n            else {\n                // HIT!\n                min = mid;\n                max = mid;\n            }\n        }\n        return lineChanges[min];\n    }\n    _getEquivalentLineForOriginalLineNumber(lineNumber) {\n        const lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, (lineChange) => lineChange.originalStartLineNumber);\n        if (!lineChange) {\n            return lineNumber;\n        }\n        const originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);\n        const modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);\n        const lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);\n        const lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);\n        const delta = lineNumber - originalEquivalentLineNumber;\n        if (delta <= lineChangeOriginalLength) {\n            return modifiedEquivalentLineNumber + Math.min(delta, lineChangeModifiedLength);\n        }\n        return modifiedEquivalentLineNumber + lineChangeModifiedLength - lineChangeOriginalLength + delta;\n    }\n    _getEquivalentLineForModifiedLineNumber(lineNumber) {\n        const lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, (lineChange) => lineChange.modifiedStartLineNumber);\n        if (!lineChange) {\n            return lineNumber;\n        }\n        const originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);\n        const modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);\n        const lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);\n        const lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);\n        const delta = lineNumber - modifiedEquivalentLineNumber;\n        if (delta <= lineChangeModifiedLength) {\n            return originalEquivalentLineNumber + Math.min(delta, lineChangeOriginalLength);\n        }\n        return originalEquivalentLineNumber + lineChangeOriginalLength - lineChangeModifiedLength + delta;\n    }\n    getDiffLineInformationForOriginal(lineNumber) {\n        if (!this._diffComputationResult) {\n            // Cannot answer that which I don't know\n            return null;\n        }\n        return {\n            equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(lineNumber)\n        };\n    }\n    getDiffLineInformationForModified(lineNumber) {\n        if (!this._diffComputationResult) {\n            // Cannot answer that which I don't know\n            return null;\n        }\n        return {\n            equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(lineNumber)\n        };\n    }\n};\nDiffEditorWidget.ONE_OVERVIEW_WIDTH = 15;\nDiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;\nDiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY = 200; // ms\nDiffEditorWidget = __decorate([\n    __param(3, IClipboardService),\n    __param(4, IEditorWorkerService),\n    __param(5, IContextKeyService),\n    __param(6, IInstantiationService),\n    __param(7, ICodeEditorService),\n    __param(8, IThemeService),\n    __param(9, INotificationService),\n    __param(10, IContextMenuService),\n    __param(11, IEditorProgressService)\n], DiffEditorWidget);\nexport { DiffEditorWidget };\nclass DiffEditorWidgetStyle extends Disposable {\n    constructor(dataSource) {\n        super();\n        this._dataSource = dataSource;\n        this._insertColor = null;\n        this._removeColor = null;\n    }\n    applyColors(theme) {\n        const newInsertColor = theme.getColor(diffOverviewRulerInserted) || (theme.getColor(diffInserted) || defaultInsertColor).transparent(2);\n        const newRemoveColor = theme.getColor(diffOverviewRulerRemoved) || (theme.getColor(diffRemoved) || defaultRemoveColor).transparent(2);\n        const hasChanges = !newInsertColor.equals(this._insertColor) || !newRemoveColor.equals(this._removeColor);\n        this._insertColor = newInsertColor;\n        this._removeColor = newRemoveColor;\n        return hasChanges;\n    }\n    getEditorsDiffDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, renderMarginRevertIcon, originalWhitespaces, modifiedWhitespaces) {\n        // Get view zones\n        modifiedWhitespaces = modifiedWhitespaces.sort((a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        originalWhitespaces = originalWhitespaces.sort((a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        const zones = this._getViewZones(lineChanges, originalWhitespaces, modifiedWhitespaces, renderIndicators);\n        // Get decorations & overview ruler zones\n        const originalDecorations = this._getOriginalEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators);\n        const modifiedDecorations = this._getModifiedEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators, renderMarginRevertIcon);\n        return {\n            original: {\n                decorations: originalDecorations.decorations,\n                overviewZones: originalDecorations.overviewZones,\n                zones: zones.original\n            },\n            modified: {\n                decorations: modifiedDecorations.decorations,\n                overviewZones: modifiedDecorations.overviewZones,\n                zones: zones.modified\n            }\n        };\n    }\n}\nclass ForeignViewZonesIterator {\n    constructor(source) {\n        this._source = source;\n        this._index = -1;\n        this.current = null;\n        this.advance();\n    }\n    advance() {\n        this._index++;\n        if (this._index < this._source.length) {\n            this.current = this._source[this._index];\n        }\n        else {\n            this.current = null;\n        }\n    }\n}\nclass ViewZonesComputer {\n    constructor(_lineChanges, _originalForeignVZ, _modifiedForeignVZ, _originalEditor, _modifiedEditor) {\n        this._lineChanges = _lineChanges;\n        this._originalForeignVZ = _originalForeignVZ;\n        this._modifiedForeignVZ = _modifiedForeignVZ;\n        this._originalEditor = _originalEditor;\n        this._modifiedEditor = _modifiedEditor;\n    }\n    static _getViewLineCount(editor, startLineNumber, endLineNumber) {\n        const model = editor.getModel();\n        const viewModel = editor._getViewModel();\n        if (model && viewModel) {\n            const viewRange = getViewRange(model, viewModel, startLineNumber, endLineNumber);\n            return (viewRange.endLineNumber - viewRange.startLineNumber + 1);\n        }\n        return (endLineNumber - startLineNumber + 1);\n    }\n    getViewZones() {\n        const originalLineHeight = this._originalEditor.getOption(61 /* EditorOption.lineHeight */);\n        const modifiedLineHeight = this._modifiedEditor.getOption(61 /* EditorOption.lineHeight */);\n        const originalHasWrapping = (this._originalEditor.getOption(134 /* EditorOption.wrappingInfo */).wrappingColumn !== -1);\n        const modifiedHasWrapping = (this._modifiedEditor.getOption(134 /* EditorOption.wrappingInfo */).wrappingColumn !== -1);\n        const hasWrapping = (originalHasWrapping || modifiedHasWrapping);\n        const originalModel = this._originalEditor.getModel();\n        const originalCoordinatesConverter = this._originalEditor._getViewModel().coordinatesConverter;\n        const modifiedCoordinatesConverter = this._modifiedEditor._getViewModel().coordinatesConverter;\n        const result = {\n            original: [],\n            modified: []\n        };\n        let lineChangeModifiedLength = 0;\n        let lineChangeOriginalLength = 0;\n        let originalEquivalentLineNumber = 0;\n        let modifiedEquivalentLineNumber = 0;\n        let originalEndEquivalentLineNumber = 0;\n        let modifiedEndEquivalentLineNumber = 0;\n        const sortMyViewZones = (a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        };\n        const addAndCombineIfPossible = (destination, item) => {\n            if (item.domNode === null && destination.length > 0) {\n                const lastItem = destination[destination.length - 1];\n                if (lastItem.afterLineNumber === item.afterLineNumber && lastItem.domNode === null) {\n                    lastItem.heightInLines += item.heightInLines;\n                    return;\n                }\n            }\n            destination.push(item);\n        };\n        const modifiedForeignVZ = new ForeignViewZonesIterator(this._modifiedForeignVZ);\n        const originalForeignVZ = new ForeignViewZonesIterator(this._originalForeignVZ);\n        let lastOriginalLineNumber = 1;\n        let lastModifiedLineNumber = 1;\n        // In order to include foreign view zones after the last line change, the for loop will iterate once more after the end of the `lineChanges` array\n        for (let i = 0, length = this._lineChanges.length; i <= length; i++) {\n            const lineChange = (i < length ? this._lineChanges[i] : null);\n            if (lineChange !== null) {\n                originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);\n                modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);\n                lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? ViewZonesComputer._getViewLineCount(this._originalEditor, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber) : 0);\n                lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? ViewZonesComputer._getViewLineCount(this._modifiedEditor, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber) : 0);\n                originalEndEquivalentLineNumber = Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);\n                modifiedEndEquivalentLineNumber = Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);\n            }\n            else {\n                // Increase to very large value to get the producing tests of foreign view zones running\n                originalEquivalentLineNumber += 10000000 + lineChangeOriginalLength;\n                modifiedEquivalentLineNumber += 10000000 + lineChangeModifiedLength;\n                originalEndEquivalentLineNumber = originalEquivalentLineNumber;\n                modifiedEndEquivalentLineNumber = modifiedEquivalentLineNumber;\n            }\n            // Each step produces view zones, and after producing them, we try to cancel them out, to avoid empty-empty view zone cases\n            let stepOriginal = [];\n            let stepModified = [];\n            // ---------------------------- PRODUCE VIEW ZONES\n            // [PRODUCE] View zones due to line mapping differences (equal lines but wrapped differently)\n            if (hasWrapping) {\n                let count;\n                if (lineChange) {\n                    if (lineChange.originalEndLineNumber > 0) {\n                        count = lineChange.originalStartLineNumber - lastOriginalLineNumber;\n                    }\n                    else {\n                        count = lineChange.modifiedStartLineNumber - lastModifiedLineNumber;\n                    }\n                }\n                else {\n                    // `lastOriginalLineNumber` has not been looked at yet\n                    count = originalModel.getLineCount() - lastOriginalLineNumber + 1;\n                }\n                for (let i = 0; i < count; i++) {\n                    const originalLineNumber = lastOriginalLineNumber + i;\n                    const modifiedLineNumber = lastModifiedLineNumber + i;\n                    const originalViewLineCount = originalCoordinatesConverter.getModelLineViewLineCount(originalLineNumber);\n                    const modifiedViewLineCount = modifiedCoordinatesConverter.getModelLineViewLineCount(modifiedLineNumber);\n                    if (originalViewLineCount < modifiedViewLineCount) {\n                        stepOriginal.push({\n                            afterLineNumber: originalLineNumber,\n                            heightInLines: modifiedViewLineCount - originalViewLineCount,\n                            domNode: null,\n                            marginDomNode: null\n                        });\n                    }\n                    else if (originalViewLineCount > modifiedViewLineCount) {\n                        stepModified.push({\n                            afterLineNumber: modifiedLineNumber,\n                            heightInLines: originalViewLineCount - modifiedViewLineCount,\n                            domNode: null,\n                            marginDomNode: null\n                        });\n                    }\n                }\n                if (lineChange) {\n                    lastOriginalLineNumber = (lineChange.originalEndLineNumber > 0 ? lineChange.originalEndLineNumber : lineChange.originalStartLineNumber) + 1;\n                    lastModifiedLineNumber = (lineChange.modifiedEndLineNumber > 0 ? lineChange.modifiedEndLineNumber : lineChange.modifiedStartLineNumber) + 1;\n                }\n            }\n            // [PRODUCE] View zone(s) in original-side due to foreign view zone(s) in modified-side\n            while (modifiedForeignVZ.current && modifiedForeignVZ.current.afterLineNumber <= modifiedEndEquivalentLineNumber) {\n                let viewZoneLineNumber;\n                if (modifiedForeignVZ.current.afterLineNumber <= modifiedEquivalentLineNumber) {\n                    viewZoneLineNumber = originalEquivalentLineNumber - modifiedEquivalentLineNumber + modifiedForeignVZ.current.afterLineNumber;\n                }\n                else {\n                    viewZoneLineNumber = originalEndEquivalentLineNumber;\n                }\n                let marginDomNode = null;\n                if (lineChange && lineChange.modifiedStartLineNumber <= modifiedForeignVZ.current.afterLineNumber && modifiedForeignVZ.current.afterLineNumber <= lineChange.modifiedEndLineNumber) {\n                    marginDomNode = this._createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion();\n                }\n                stepOriginal.push({\n                    afterLineNumber: viewZoneLineNumber,\n                    heightInLines: modifiedForeignVZ.current.height / modifiedLineHeight,\n                    domNode: null,\n                    marginDomNode: marginDomNode\n                });\n                modifiedForeignVZ.advance();\n            }\n            // [PRODUCE] View zone(s) in modified-side due to foreign view zone(s) in original-side\n            while (originalForeignVZ.current && originalForeignVZ.current.afterLineNumber <= originalEndEquivalentLineNumber) {\n                let viewZoneLineNumber;\n                if (originalForeignVZ.current.afterLineNumber <= originalEquivalentLineNumber) {\n                    viewZoneLineNumber = modifiedEquivalentLineNumber - originalEquivalentLineNumber + originalForeignVZ.current.afterLineNumber;\n                }\n                else {\n                    viewZoneLineNumber = modifiedEndEquivalentLineNumber;\n                }\n                stepModified.push({\n                    afterLineNumber: viewZoneLineNumber,\n                    heightInLines: originalForeignVZ.current.height / originalLineHeight,\n                    domNode: null\n                });\n                originalForeignVZ.advance();\n            }\n            if (lineChange !== null && isChangeOrInsert(lineChange)) {\n                const r = this._produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);\n                if (r) {\n                    stepOriginal.push(r);\n                }\n            }\n            if (lineChange !== null && isChangeOrDelete(lineChange)) {\n                const r = this._produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);\n                if (r) {\n                    stepModified.push(r);\n                }\n            }\n            // ---------------------------- END PRODUCE VIEW ZONES\n            // ---------------------------- EMIT MINIMAL VIEW ZONES\n            // [CANCEL & EMIT] Try to cancel view zones out\n            let stepOriginalIndex = 0;\n            let stepModifiedIndex = 0;\n            stepOriginal = stepOriginal.sort(sortMyViewZones);\n            stepModified = stepModified.sort(sortMyViewZones);\n            while (stepOriginalIndex < stepOriginal.length && stepModifiedIndex < stepModified.length) {\n                const original = stepOriginal[stepOriginalIndex];\n                const modified = stepModified[stepModifiedIndex];\n                const originalDelta = original.afterLineNumber - originalEquivalentLineNumber;\n                const modifiedDelta = modified.afterLineNumber - modifiedEquivalentLineNumber;\n                if (originalDelta < modifiedDelta) {\n                    addAndCombineIfPossible(result.original, original);\n                    stepOriginalIndex++;\n                }\n                else if (modifiedDelta < originalDelta) {\n                    addAndCombineIfPossible(result.modified, modified);\n                    stepModifiedIndex++;\n                }\n                else if (original.shouldNotShrink) {\n                    addAndCombineIfPossible(result.original, original);\n                    stepOriginalIndex++;\n                }\n                else if (modified.shouldNotShrink) {\n                    addAndCombineIfPossible(result.modified, modified);\n                    stepModifiedIndex++;\n                }\n                else {\n                    if (original.heightInLines >= modified.heightInLines) {\n                        // modified view zone gets removed\n                        original.heightInLines -= modified.heightInLines;\n                        stepModifiedIndex++;\n                    }\n                    else {\n                        // original view zone gets removed\n                        modified.heightInLines -= original.heightInLines;\n                        stepOriginalIndex++;\n                    }\n                }\n            }\n            // [EMIT] Remaining original view zones\n            while (stepOriginalIndex < stepOriginal.length) {\n                addAndCombineIfPossible(result.original, stepOriginal[stepOriginalIndex]);\n                stepOriginalIndex++;\n            }\n            // [EMIT] Remaining modified view zones\n            while (stepModifiedIndex < stepModified.length) {\n                addAndCombineIfPossible(result.modified, stepModified[stepModifiedIndex]);\n                stepModifiedIndex++;\n            }\n            // ---------------------------- END EMIT MINIMAL VIEW ZONES\n        }\n        return {\n            original: ViewZonesComputer._ensureDomNodes(result.original),\n            modified: ViewZonesComputer._ensureDomNodes(result.modified),\n        };\n    }\n    static _ensureDomNodes(zones) {\n        return zones.map((z) => {\n            if (!z.domNode) {\n                z.domNode = createFakeLinesDiv();\n            }\n            return z;\n        });\n    }\n}\nfunction createDecoration(startLineNumber, startColumn, endLineNumber, endColumn, options) {\n    return {\n        range: new Range(startLineNumber, startColumn, endLineNumber, endColumn),\n        options: options\n    };\n}\nconst DECORATIONS = {\n    arrowRevertChange: ModelDecorationOptions.register({\n        description: 'diff-editor-arrow-revert-change',\n        glyphMarginClassName: 'arrow-revert-change ' + ThemeIcon.asClassName(Codicon.arrowRight),\n    }),\n    charDelete: ModelDecorationOptions.register({\n        description: 'diff-editor-char-delete',\n        className: 'char-delete'\n    }),\n    charDeleteWholeLine: ModelDecorationOptions.register({\n        description: 'diff-editor-char-delete-whole-line',\n        className: 'char-delete',\n        isWholeLine: true\n    }),\n    charInsert: ModelDecorationOptions.register({\n        description: 'diff-editor-char-insert',\n        className: 'char-insert'\n    }),\n    charInsertWholeLine: ModelDecorationOptions.register({\n        description: 'diff-editor-char-insert-whole-line',\n        className: 'char-insert',\n        isWholeLine: true\n    }),\n    lineInsert: ModelDecorationOptions.register({\n        description: 'diff-editor-line-insert',\n        className: 'line-insert',\n        marginClassName: 'gutter-insert',\n        isWholeLine: true\n    }),\n    lineInsertWithSign: ModelDecorationOptions.register({\n        description: 'diff-editor-line-insert-with-sign',\n        className: 'line-insert',\n        linesDecorationsClassName: 'insert-sign ' + ThemeIcon.asClassName(diffInsertIcon),\n        marginClassName: 'gutter-insert',\n        isWholeLine: true\n    }),\n    lineDelete: ModelDecorationOptions.register({\n        description: 'diff-editor-line-delete',\n        className: 'line-delete',\n        marginClassName: 'gutter-delete',\n        isWholeLine: true\n    }),\n    lineDeleteWithSign: ModelDecorationOptions.register({\n        description: 'diff-editor-line-delete-with-sign',\n        className: 'line-delete',\n        linesDecorationsClassName: 'delete-sign ' + ThemeIcon.asClassName(diffRemoveIcon),\n        marginClassName: 'gutter-delete',\n        isWholeLine: true\n    }),\n    lineDeleteMargin: ModelDecorationOptions.register({\n        description: 'diff-editor-line-delete-margin',\n        marginClassName: 'gutter-delete',\n    })\n};\nclass DiffEditorWidgetSideBySide extends DiffEditorWidgetStyle {\n    constructor(dataSource, enableSplitViewResizing) {\n        super(dataSource);\n        this._disableSash = (enableSplitViewResizing === false);\n        this._sashRatio = null;\n        this._sashPosition = null;\n        this._startSashPosition = null;\n        this._sash = this._register(new Sash(this._dataSource.getContainerDomNode(), this, { orientation: 0 /* Orientation.VERTICAL */ }));\n        if (this._disableSash) {\n            this._sash.state = 0 /* SashState.Disabled */;\n        }\n        this._sash.onDidStart(() => this._onSashDragStart());\n        this._sash.onDidChange((e) => this._onSashDrag(e));\n        this._sash.onDidEnd(() => this._onSashDragEnd());\n        this._sash.onDidReset(() => this._onSashReset());\n    }\n    setEnableSplitViewResizing(enableSplitViewResizing) {\n        const newDisableSash = (enableSplitViewResizing === false);\n        if (this._disableSash !== newDisableSash) {\n            this._disableSash = newDisableSash;\n            this._sash.state = this._disableSash ? 0 /* SashState.Disabled */ : 3 /* SashState.Enabled */;\n        }\n    }\n    layout(sashRatio = this._sashRatio) {\n        const w = this._dataSource.getWidth();\n        const contentWidth = w - (this._dataSource.getOptions().renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);\n        let sashPosition = Math.floor((sashRatio || 0.5) * contentWidth);\n        const midPoint = Math.floor(0.5 * contentWidth);\n        sashPosition = this._disableSash ? midPoint : sashPosition || midPoint;\n        if (contentWidth > DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH * 2) {\n            if (sashPosition < DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {\n                sashPosition = DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;\n            }\n            if (sashPosition > contentWidth - DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {\n                sashPosition = contentWidth - DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;\n            }\n        }\n        else {\n            sashPosition = midPoint;\n        }\n        if (this._sashPosition !== sashPosition) {\n            this._sashPosition = sashPosition;\n        }\n        this._sash.layout();\n        return this._sashPosition;\n    }\n    _onSashDragStart() {\n        this._startSashPosition = this._sashPosition;\n    }\n    _onSashDrag(e) {\n        const w = this._dataSource.getWidth();\n        const contentWidth = w - (this._dataSource.getOptions().renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);\n        const sashPosition = this.layout((this._startSashPosition + (e.currentX - e.startX)) / contentWidth);\n        this._sashRatio = sashPosition / contentWidth;\n        this._dataSource.relayoutEditors();\n    }\n    _onSashDragEnd() {\n        this._sash.layout();\n    }\n    _onSashReset() {\n        this._sashRatio = 0.5;\n        this._dataSource.relayoutEditors();\n        this._sash.layout();\n    }\n    getVerticalSashTop(sash) {\n        return 0;\n    }\n    getVerticalSashLeft(sash) {\n        return this._sashPosition;\n    }\n    getVerticalSashHeight(sash) {\n        return this._dataSource.getHeight();\n    }\n    _getViewZones(lineChanges, originalForeignVZ, modifiedForeignVZ) {\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const c = new SideBySideViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);\n        return c.getViewZones();\n    }\n    _getOriginalEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators) {\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const overviewZoneColor = String(this._removeColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const originalModel = originalEditor.getModel();\n        const originalViewModel = originalEditor._getViewModel();\n        for (const lineChange of lineChanges) {\n            if (isChangeOrDelete(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),\n                    options: (renderIndicators ? DECORATIONS.lineDeleteWithSign : DECORATIONS.lineDelete)\n                });\n                if (!isChangeOrInsert(lineChange) || !lineChange.charChanges) {\n                    result.decorations.push(createDecoration(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, DECORATIONS.charDeleteWholeLine));\n                }\n                const viewRange = getViewRange(originalModel, originalViewModel, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, /*use endLineNumber*/ 0, overviewZoneColor));\n                if (lineChange.charChanges) {\n                    for (const charChange of lineChange.charChanges) {\n                        if (isCharChangeOrDelete(charChange)) {\n                            if (ignoreTrimWhitespace) {\n                                for (let lineNumber = charChange.originalStartLineNumber; lineNumber <= charChange.originalEndLineNumber; lineNumber++) {\n                                    let startColumn;\n                                    let endColumn;\n                                    if (lineNumber === charChange.originalStartLineNumber) {\n                                        startColumn = charChange.originalStartColumn;\n                                    }\n                                    else {\n                                        startColumn = originalModel.getLineFirstNonWhitespaceColumn(lineNumber);\n                                    }\n                                    if (lineNumber === charChange.originalEndLineNumber) {\n                                        endColumn = charChange.originalEndColumn;\n                                    }\n                                    else {\n                                        endColumn = originalModel.getLineLastNonWhitespaceColumn(lineNumber);\n                                    }\n                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charDelete));\n                                }\n                            }\n                            else {\n                                result.decorations.push(createDecoration(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn, DECORATIONS.charDelete));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    _getModifiedEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators, renderMarginRevertIcon) {\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const overviewZoneColor = String(this._insertColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const modifiedModel = modifiedEditor.getModel();\n        const modifiedViewModel = modifiedEditor._getViewModel();\n        for (const lineChange of lineChanges) {\n            // Arrows for reverting changes.\n            if (renderMarginRevertIcon) {\n                if (lineChange.modifiedEndLineNumber > 0) {\n                    result.decorations.push({\n                        range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedStartLineNumber, 1),\n                        options: DECORATIONS.arrowRevertChange\n                    });\n                }\n                else {\n                    const viewZone = zones.modified.find(z => z.afterLineNumber === lineChange.modifiedStartLineNumber);\n                    if (viewZone) {\n                        viewZone.marginDomNode = createViewZoneMarginArrow();\n                    }\n                }\n            }\n            if (isChangeOrInsert(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),\n                    options: (renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert)\n                });\n                if (!isChangeOrDelete(lineChange) || !lineChange.charChanges) {\n                    result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, DECORATIONS.charInsertWholeLine));\n                }\n                const viewRange = getViewRange(modifiedModel, modifiedViewModel, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, /*use endLineNumber*/ 0, overviewZoneColor));\n                if (lineChange.charChanges) {\n                    for (const charChange of lineChange.charChanges) {\n                        if (isCharChangeOrInsert(charChange)) {\n                            if (ignoreTrimWhitespace) {\n                                for (let lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {\n                                    let startColumn;\n                                    let endColumn;\n                                    if (lineNumber === charChange.modifiedStartLineNumber) {\n                                        startColumn = charChange.modifiedStartColumn;\n                                    }\n                                    else {\n                                        startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);\n                                    }\n                                    if (lineNumber === charChange.modifiedEndLineNumber) {\n                                        endColumn = charChange.modifiedEndColumn;\n                                    }\n                                    else {\n                                        endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);\n                                    }\n                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));\n                                }\n                            }\n                            else {\n                                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nDiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH = 100;\nclass SideBySideViewZonesComputer extends ViewZonesComputer {\n    constructor(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {\n        super(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);\n    }\n    _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {\n        return null;\n    }\n    _produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        if (lineChangeModifiedLength > lineChangeOriginalLength) {\n            return {\n                afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),\n                heightInLines: (lineChangeModifiedLength - lineChangeOriginalLength),\n                domNode: null\n            };\n        }\n        return null;\n    }\n    _produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        if (lineChangeOriginalLength > lineChangeModifiedLength) {\n            return {\n                afterLineNumber: Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber),\n                heightInLines: (lineChangeOriginalLength - lineChangeModifiedLength),\n                domNode: null\n            };\n        }\n        return null;\n    }\n}\nclass DiffEditorWidgetInline extends DiffEditorWidgetStyle {\n    constructor(dataSource, enableSplitViewResizing) {\n        super(dataSource);\n        this._decorationsLeft = dataSource.getOriginalEditor().getLayoutInfo().decorationsLeft;\n        this._register(dataSource.getOriginalEditor().onDidLayoutChange((layoutInfo) => {\n            if (this._decorationsLeft !== layoutInfo.decorationsLeft) {\n                this._decorationsLeft = layoutInfo.decorationsLeft;\n                dataSource.relayoutEditors();\n            }\n        }));\n    }\n    setEnableSplitViewResizing(enableSplitViewResizing) {\n        // Nothing to do..\n    }\n    _getViewZones(lineChanges, originalForeignVZ, modifiedForeignVZ, renderIndicators) {\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const computer = new InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators);\n        return computer.getViewZones();\n    }\n    _getOriginalEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators) {\n        const overviewZoneColor = String(this._removeColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const originalModel = originalEditor.getModel();\n        const originalViewModel = originalEditor._getViewModel();\n        let zoneIndex = 0;\n        for (const lineChange of lineChanges) {\n            // Add overview zones in the overview ruler\n            if (isChangeOrDelete(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),\n                    options: DECORATIONS.lineDeleteMargin\n                });\n                while (zoneIndex < zones.modified.length) {\n                    const zone = zones.modified[zoneIndex];\n                    if (zone.diff && zone.diff.originalStartLineNumber >= lineChange.originalStartLineNumber) {\n                        break;\n                    }\n                    zoneIndex++;\n                }\n                let zoneHeightInLines = 0;\n                if (zoneIndex < zones.modified.length) {\n                    const zone = zones.modified[zoneIndex];\n                    if (zone.diff\n                        && zone.diff.originalStartLineNumber === lineChange.originalStartLineNumber\n                        && zone.diff.originalEndLineNumber === lineChange.originalEndLineNumber\n                        && zone.diff.modifiedStartLineNumber === lineChange.modifiedStartLineNumber\n                        && zone.diff.modifiedEndLineNumber === lineChange.modifiedEndLineNumber) {\n                        zoneHeightInLines = zone.heightInLines;\n                    }\n                }\n                const viewRange = getViewRange(originalModel, originalViewModel, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, zoneHeightInLines, overviewZoneColor));\n            }\n        }\n        return result;\n    }\n    _getModifiedEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators, renderMarginRevertIcon) {\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const overviewZoneColor = String(this._insertColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const modifiedModel = modifiedEditor.getModel();\n        const modifiedViewModel = modifiedEditor._getViewModel();\n        for (const lineChange of lineChanges) {\n            // Add decorations & overview zones\n            if (isChangeOrInsert(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),\n                    options: (renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert)\n                });\n                const viewRange = getViewRange(modifiedModel, modifiedViewModel, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, /*use endLineNumber*/ 0, overviewZoneColor));\n                if (lineChange.charChanges) {\n                    for (const charChange of lineChange.charChanges) {\n                        if (isCharChangeOrInsert(charChange)) {\n                            if (ignoreTrimWhitespace) {\n                                for (let lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {\n                                    let startColumn;\n                                    let endColumn;\n                                    if (lineNumber === charChange.modifiedStartLineNumber) {\n                                        startColumn = charChange.modifiedStartColumn;\n                                    }\n                                    else {\n                                        startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);\n                                    }\n                                    if (lineNumber === charChange.modifiedEndLineNumber) {\n                                        endColumn = charChange.modifiedEndColumn;\n                                    }\n                                    else {\n                                        endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);\n                                    }\n                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));\n                                }\n                            }\n                            else {\n                                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));\n                            }\n                        }\n                    }\n                }\n                else {\n                    result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, DECORATIONS.charInsertWholeLine));\n                }\n            }\n        }\n        return result;\n    }\n    layout() {\n        // An editor should not be smaller than 5px\n        return Math.max(5, this._decorationsLeft);\n    }\n}\nclass InlineViewZonesComputer extends ViewZonesComputer {\n    constructor(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {\n        super(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);\n        this._originalModel = originalEditor.getModel();\n        this._renderIndicators = renderIndicators;\n        this._pendingLineChange = [];\n        this._pendingViewZones = [];\n        this._lineBreaksComputer = this._modifiedEditor._getViewModel().createLineBreaksComputer();\n    }\n    getViewZones() {\n        const result = super.getViewZones();\n        this._finalize(result);\n        return result;\n    }\n    _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {\n        const result = document.createElement('div');\n        result.className = 'inline-added-margin-view-zone';\n        return result;\n    }\n    _produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        const marginDomNode = document.createElement('div');\n        marginDomNode.className = 'inline-added-margin-view-zone';\n        return {\n            afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),\n            heightInLines: lineChangeModifiedLength,\n            domNode: document.createElement('div'),\n            marginDomNode: marginDomNode\n        };\n    }\n    _produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        const domNode = document.createElement('div');\n        domNode.className = `view-lines line-delete ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`;\n        const marginDomNode = document.createElement('div');\n        marginDomNode.className = 'inline-deleted-margin-view-zone';\n        const viewZone = {\n            shouldNotShrink: true,\n            afterLineNumber: (lineChange.modifiedEndLineNumber === 0 ? lineChange.modifiedStartLineNumber : lineChange.modifiedStartLineNumber - 1),\n            heightInLines: lineChangeOriginalLength,\n            minWidthInPx: 0,\n            domNode: domNode,\n            marginDomNode: marginDomNode,\n            diff: {\n                originalStartLineNumber: lineChange.originalStartLineNumber,\n                originalEndLineNumber: lineChange.originalEndLineNumber,\n                modifiedStartLineNumber: lineChange.modifiedStartLineNumber,\n                modifiedEndLineNumber: lineChange.modifiedEndLineNumber,\n                originalModel: this._originalModel,\n                viewLineCounts: null,\n            }\n        };\n        for (let lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {\n            this._lineBreaksComputer.addRequest(this._originalModel.getLineContent(lineNumber), null, null);\n        }\n        this._pendingLineChange.push(lineChange);\n        this._pendingViewZones.push(viewZone);\n        return viewZone;\n    }\n    _finalize(result) {\n        const modifiedEditorOptions = this._modifiedEditor.getOptions();\n        const tabSize = this._modifiedEditor.getModel().getOptions().tabSize;\n        const fontInfo = modifiedEditorOptions.get(46 /* EditorOption.fontInfo */);\n        const disableMonospaceOptimizations = modifiedEditorOptions.get(29 /* EditorOption.disableMonospaceOptimizations */);\n        const typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        const scrollBeyondLastColumn = modifiedEditorOptions.get(95 /* EditorOption.scrollBeyondLastColumn */);\n        const mightContainNonBasicASCII = this._originalModel.mightContainNonBasicASCII();\n        const mightContainRTL = this._originalModel.mightContainRTL();\n        const lineHeight = modifiedEditorOptions.get(61 /* EditorOption.lineHeight */);\n        const layoutInfo = modifiedEditorOptions.get(133 /* EditorOption.layoutInfo */);\n        const lineDecorationsWidth = layoutInfo.decorationsWidth;\n        const stopRenderingLineAfter = modifiedEditorOptions.get(107 /* EditorOption.stopRenderingLineAfter */);\n        const renderWhitespace = modifiedEditorOptions.get(90 /* EditorOption.renderWhitespace */);\n        const renderControlCharacters = modifiedEditorOptions.get(85 /* EditorOption.renderControlCharacters */);\n        const fontLigatures = modifiedEditorOptions.get(47 /* EditorOption.fontLigatures */);\n        const lineBreaks = this._lineBreaksComputer.finalize();\n        let lineBreakIndex = 0;\n        for (let i = 0; i < this._pendingLineChange.length; i++) {\n            const lineChange = this._pendingLineChange[i];\n            const viewZone = this._pendingViewZones[i];\n            const domNode = viewZone.domNode;\n            applyFontInfo(domNode, fontInfo);\n            const marginDomNode = viewZone.marginDomNode;\n            applyFontInfo(marginDomNode, fontInfo);\n            const decorations = [];\n            if (lineChange.charChanges) {\n                for (const charChange of lineChange.charChanges) {\n                    if (isCharChangeOrDelete(charChange)) {\n                        decorations.push(new InlineDecoration(new Range(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn), 'char-delete', 0 /* InlineDecorationType.Regular */));\n                    }\n                }\n            }\n            const hasCharChanges = (decorations.length > 0);\n            const sb = createStringBuilder(10000);\n            let maxCharsPerLine = 0;\n            let renderedLineCount = 0;\n            let viewLineCounts = null;\n            for (let lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {\n                const lineIndex = lineNumber - lineChange.originalStartLineNumber;\n                const lineTokens = this._originalModel.tokenization.getLineTokens(lineNumber);\n                const lineContent = lineTokens.getLineContent();\n                const lineBreakData = lineBreaks[lineBreakIndex++];\n                const actualDecorations = LineDecoration.filter(decorations, lineNumber, 1, lineContent.length + 1);\n                if (lineBreakData) {\n                    let lastBreakOffset = 0;\n                    for (const breakOffset of lineBreakData.breakOffsets) {\n                        const viewLineTokens = lineTokens.sliceAndInflate(lastBreakOffset, breakOffset, 0);\n                        const viewLineContent = lineContent.substring(lastBreakOffset, breakOffset);\n                        maxCharsPerLine = Math.max(maxCharsPerLine, this._renderOriginalLine(renderedLineCount++, viewLineContent, viewLineTokens, LineDecoration.extractWrapped(actualDecorations, lastBreakOffset, breakOffset), hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode));\n                        lastBreakOffset = breakOffset;\n                    }\n                    if (!viewLineCounts) {\n                        viewLineCounts = [];\n                    }\n                    // make sure all lines before this one have an entry in `viewLineCounts`\n                    while (viewLineCounts.length < lineIndex) {\n                        viewLineCounts[viewLineCounts.length] = 1;\n                    }\n                    viewLineCounts[lineIndex] = lineBreakData.breakOffsets.length;\n                    viewZone.heightInLines += (lineBreakData.breakOffsets.length - 1);\n                    const marginDomNode2 = document.createElement('div');\n                    marginDomNode2.className = 'gutter-delete';\n                    result.original.push({\n                        afterLineNumber: lineNumber,\n                        afterColumn: 0,\n                        heightInLines: lineBreakData.breakOffsets.length - 1,\n                        domNode: createFakeLinesDiv(),\n                        marginDomNode: marginDomNode2\n                    });\n                }\n                else {\n                    maxCharsPerLine = Math.max(maxCharsPerLine, this._renderOriginalLine(renderedLineCount++, lineContent, lineTokens, actualDecorations, hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode));\n                }\n            }\n            maxCharsPerLine += scrollBeyondLastColumn;\n            const html = sb.build();\n            const trustedhtml = ttPolicy ? ttPolicy.createHTML(html) : html;\n            domNode.innerHTML = trustedhtml;\n            viewZone.minWidthInPx = (maxCharsPerLine * typicalHalfwidthCharacterWidth);\n            if (viewLineCounts) {\n                // make sure all lines have an entry in `viewLineCounts`\n                const cnt = lineChange.originalEndLineNumber - lineChange.originalStartLineNumber;\n                while (viewLineCounts.length <= cnt) {\n                    viewLineCounts[viewLineCounts.length] = 1;\n                }\n            }\n            viewZone.diff.viewLineCounts = viewLineCounts;\n        }\n        result.original.sort((a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n    }\n    _renderOriginalLine(renderedLineCount, lineContent, lineTokens, decorations, hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode) {\n        sb.appendASCIIString('<div class=\"view-line');\n        if (!hasCharChanges) {\n            // No char changes\n            sb.appendASCIIString(' char-delete');\n        }\n        sb.appendASCIIString('\" style=\"top:');\n        sb.appendASCIIString(String(renderedLineCount * lineHeight));\n        sb.appendASCIIString('px;width:1000000px;\">');\n        const isBasicASCII = ViewLineRenderingData.isBasicASCII(lineContent, mightContainNonBasicASCII);\n        const containsRTL = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII, mightContainRTL);\n        const output = renderViewLine(new RenderLineInput((fontInfo.isMonospace && !disableMonospaceOptimizations), fontInfo.canUseHalfwidthRightwardsArrow, lineContent, false, isBasicASCII, containsRTL, 0, lineTokens, decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== EditorFontLigatures.OFF, null // Send no selections, original line cannot be selected\n        ), sb);\n        sb.appendASCIIString('</div>');\n        if (this._renderIndicators) {\n            const marginElement = document.createElement('div');\n            marginElement.className = `delete-sign ${ThemeIcon.asClassName(diffRemoveIcon)}`;\n            marginElement.setAttribute('style', `position:absolute;top:${renderedLineCount * lineHeight}px;width:${lineDecorationsWidth}px;height:${lineHeight}px;right:0;`);\n            marginDomNode.appendChild(marginElement);\n        }\n        return output.characterMapping.getHorizontalOffset(output.characterMapping.length);\n    }\n}\nfunction validateDiffWordWrap(value, defaultValue) {\n    return validateStringSetOption(value, defaultValue, ['off', 'on', 'inherit']);\n}\nfunction isChangeOrInsert(lineChange) {\n    return lineChange.modifiedEndLineNumber > 0;\n}\nfunction isChangeOrDelete(lineChange) {\n    return lineChange.originalEndLineNumber > 0;\n}\nfunction isCharChangeOrInsert(charChange) {\n    if (charChange.modifiedStartLineNumber === charChange.modifiedEndLineNumber) {\n        return charChange.modifiedEndColumn - charChange.modifiedStartColumn > 0;\n    }\n    return charChange.modifiedEndLineNumber - charChange.modifiedStartLineNumber > 0;\n}\nfunction isCharChangeOrDelete(charChange) {\n    if (charChange.originalStartLineNumber === charChange.originalEndLineNumber) {\n        return charChange.originalEndColumn - charChange.originalStartColumn > 0;\n    }\n    return charChange.originalEndLineNumber - charChange.originalStartLineNumber > 0;\n}\nfunction createFakeLinesDiv() {\n    const r = document.createElement('div');\n    r.className = 'diagonal-fill';\n    return r;\n}\nfunction createViewZoneMarginArrow() {\n    const arrow = document.createElement('div');\n    arrow.className = 'arrow-revert-change ' + ThemeIcon.asClassName(Codicon.arrowRight);\n    return dom.$('div', {}, arrow);\n}\nfunction getViewRange(model, viewModel, startLineNumber, endLineNumber) {\n    const lineCount = model.getLineCount();\n    startLineNumber = Math.min(lineCount, Math.max(1, startLineNumber));\n    endLineNumber = Math.min(lineCount, Math.max(1, endLineNumber));\n    return viewModel.coordinatesConverter.convertModelRangeToViewRange(new Range(startLineNumber, model.getLineMinColumn(startLineNumber), endLineNumber, model.getLineMaxColumn(endLineNumber)));\n}\nfunction validateDiffEditorOptions(options, defaults) {\n    return {\n        enableSplitViewResizing: validateBooleanOption(options.enableSplitViewResizing, defaults.enableSplitViewResizing),\n        renderSideBySide: validateBooleanOption(options.renderSideBySide, defaults.renderSideBySide),\n        renderMarginRevertIcon: validateBooleanOption(options.renderMarginRevertIcon, defaults.renderMarginRevertIcon),\n        maxComputationTime: clampedInt(options.maxComputationTime, defaults.maxComputationTime, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),\n        maxFileSize: clampedInt(options.maxFileSize, defaults.maxFileSize, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */),\n        ignoreTrimWhitespace: validateBooleanOption(options.ignoreTrimWhitespace, defaults.ignoreTrimWhitespace),\n        renderIndicators: validateBooleanOption(options.renderIndicators, defaults.renderIndicators),\n        originalEditable: validateBooleanOption(options.originalEditable, defaults.originalEditable),\n        diffCodeLens: validateBooleanOption(options.diffCodeLens, defaults.diffCodeLens),\n        renderOverviewRuler: validateBooleanOption(options.renderOverviewRuler, defaults.renderOverviewRuler),\n        diffWordWrap: validateDiffWordWrap(options.diffWordWrap, defaults.diffWordWrap),\n    };\n}\nfunction changedDiffEditorOptions(a, b) {\n    return {\n        enableSplitViewResizing: (a.enableSplitViewResizing !== b.enableSplitViewResizing),\n        renderSideBySide: (a.renderSideBySide !== b.renderSideBySide),\n        renderMarginRevertIcon: (a.renderMarginRevertIcon !== b.renderMarginRevertIcon),\n        maxComputationTime: (a.maxComputationTime !== b.maxComputationTime),\n        maxFileSize: (a.maxFileSize !== b.maxFileSize),\n        ignoreTrimWhitespace: (a.ignoreTrimWhitespace !== b.ignoreTrimWhitespace),\n        renderIndicators: (a.renderIndicators !== b.renderIndicators),\n        originalEditable: (a.originalEditable !== b.originalEditable),\n        diffCodeLens: (a.diffCodeLens !== b.diffCodeLens),\n        renderOverviewRuler: (a.renderOverviewRuler !== b.renderOverviewRuler),\n        diffWordWrap: (a.diffWordWrap !== b.diffWordWrap),\n    };\n}\nregisterThemingParticipant((theme, collector) => {\n    const added = theme.getColor(diffInserted);\n    if (added) {\n        collector.addRule(`.monaco-editor .char-insert, .monaco-diff-editor .char-insert { background-color: ${added}; }`);\n    }\n    const lineAdded = theme.getColor(diffInsertedLine) || added;\n    if (lineAdded) {\n        collector.addRule(`.monaco-editor .line-insert, .monaco-diff-editor .line-insert { background-color: ${lineAdded}; }`);\n    }\n    const gutterAdded = theme.getColor(diffInsertedLineGutter) || lineAdded;\n    if (gutterAdded) {\n        collector.addRule(`.monaco-editor .inline-added-margin-view-zone { background-color: ${gutterAdded}; }`);\n        collector.addRule(`.monaco-editor .gutter-insert, .monaco-diff-editor .gutter-insert { background-color: ${gutterAdded}; }`);\n    }\n    const removed = theme.getColor(diffRemoved);\n    if (removed) {\n        collector.addRule(`.monaco-editor .char-delete, .monaco-diff-editor .char-delete { background-color: ${removed}; }`);\n    }\n    const lineRemoved = theme.getColor(diffRemovedLine) || removed;\n    if (lineRemoved) {\n        collector.addRule(`.monaco-editor .line-delete, .monaco-diff-editor .line-delete { background-color: ${lineRemoved}; }`);\n    }\n    const gutterRemoved = theme.getColor(diffRemovedLineGutter) || lineRemoved;\n    if (gutterRemoved) {\n        collector.addRule(`.monaco-editor .inline-deleted-margin-view-zone { background-color: ${gutterRemoved}; }`);\n        collector.addRule(`.monaco-editor .gutter-delete, .monaco-diff-editor .gutter-delete { background-color: ${gutterRemoved}; }`);\n    }\n    const addedOutline = theme.getColor(diffInsertedOutline);\n    if (addedOutline) {\n        collector.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px ${isHighContrast(theme.type) ? 'dashed' : 'solid'} ${addedOutline}; }`);\n    }\n    const removedOutline = theme.getColor(diffRemovedOutline);\n    if (removedOutline) {\n        collector.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px ${isHighContrast(theme.type) ? 'dashed' : 'solid'} ${removedOutline}; }`);\n    }\n    const shadow = theme.getColor(scrollbarShadow);\n    if (shadow) {\n        collector.addRule(`.monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px ${shadow}; }`);\n    }\n    const border = theme.getColor(diffBorder);\n    if (border) {\n        collector.addRule(`.monaco-diff-editor.side-by-side .editor.modified { border-left: 1px solid ${border}; }`);\n    }\n    const scrollbarSliderBackgroundColor = theme.getColor(scrollbarSliderBackground);\n    if (scrollbarSliderBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-diff-editor .diffViewport {\n\t\t\t\tbackground: ${scrollbarSliderBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const scrollbarSliderHoverBackgroundColor = theme.getColor(scrollbarSliderHoverBackground);\n    if (scrollbarSliderHoverBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-diff-editor .diffViewport:hover {\n\t\t\t\tbackground: ${scrollbarSliderHoverBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const scrollbarSliderActiveBackgroundColor = theme.getColor(scrollbarSliderActiveBackground);\n    if (scrollbarSliderActiveBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-diff-editor .diffViewport:active {\n\t\t\t\tbackground: ${scrollbarSliderActiveBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const diffDiagonalFillColor = theme.getColor(diffDiagonalFill);\n    collector.addRule(`\n\t.monaco-editor .diagonal-fill {\n\t\tbackground-image: linear-gradient(\n\t\t\t-45deg,\n\t\t\t${diffDiagonalFillColor} 12.5%,\n\t\t\t#0000 12.5%, #0000 50%,\n\t\t\t${diffDiagonalFillColor} 50%, ${diffDiagonalFillColor} 62.5%,\n\t\t\t#0000 62.5%, #0000 100%\n\t\t);\n\t\tbackground-size: 8px 8px;\n\t}\n\t`);\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport Severity from '../../../base/common/severity.js';\nimport * as nls from '../../../nls.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\nconst DEBUG = false;\nfunction getResourceLabel(resource) {\n    return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\n}\nlet stackElementCounter = 0;\nclass ResourceStackElement {\n    constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\n        this.id = (++stackElementCounter);\n        this.type = 0 /* UndoRedoElementType.Resource */;\n        this.actual = actual;\n        this.label = actual.label;\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n        this.resourceLabel = resourceLabel;\n        this.strResource = strResource;\n        this.resourceLabels = [this.resourceLabel];\n        this.strResources = [this.strResource];\n        this.groupId = groupId;\n        this.groupOrder = groupOrder;\n        this.sourceId = sourceId;\n        this.sourceOrder = sourceOrder;\n        this.isValid = true;\n    }\n    setValid(isValid) {\n        this.isValid = isValid;\n    }\n    toString() {\n        return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? '  VALID' : 'INVALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n    }\n}\nclass ResourceReasonPair {\n    constructor(resourceLabel, reason) {\n        this.resourceLabel = resourceLabel;\n        this.reason = reason;\n    }\n}\nclass RemovedResources {\n    constructor() {\n        this.elements = new Map();\n    }\n    createMessage() {\n        const externalRemoval = [];\n        const noParallelUniverses = [];\n        for (const [, element] of this.elements) {\n            const dest = (element.reason === 0 /* RemovedResourceReason.ExternalRemoval */\n                ? externalRemoval\n                : noParallelUniverses);\n            dest.push(element.resourceLabel);\n        }\n        const messages = [];\n        if (externalRemoval.length > 0) {\n            messages.push(nls.localize({ key: 'externalRemoval', comment: ['{0} is a list of filenames'] }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\n        }\n        if (noParallelUniverses.length > 0) {\n            messages.push(nls.localize({ key: 'noParallelUniverses', comment: ['{0} is a list of filenames'] }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\n        }\n        return messages.join('\\n');\n    }\n    get size() {\n        return this.elements.size;\n    }\n    has(strResource) {\n        return this.elements.has(strResource);\n    }\n    set(strResource, value) {\n        this.elements.set(strResource, value);\n    }\n    delete(strResource) {\n        return this.elements.delete(strResource);\n    }\n}\nclass WorkspaceStackElement {\n    constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\n        this.id = (++stackElementCounter);\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this.actual = actual;\n        this.label = actual.label;\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n        this.resourceLabels = resourceLabels;\n        this.strResources = strResources;\n        this.groupId = groupId;\n        this.groupOrder = groupOrder;\n        this.sourceId = sourceId;\n        this.sourceOrder = sourceOrder;\n        this.removedResources = null;\n        this.invalidatedResources = null;\n    }\n    canSplit() {\n        return (typeof this.actual.split === 'function');\n    }\n    removeResource(resourceLabel, strResource, reason) {\n        if (!this.removedResources) {\n            this.removedResources = new RemovedResources();\n        }\n        if (!this.removedResources.has(strResource)) {\n            this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\n        }\n    }\n    setValid(resourceLabel, strResource, isValid) {\n        if (isValid) {\n            if (this.invalidatedResources) {\n                this.invalidatedResources.delete(strResource);\n                if (this.invalidatedResources.size === 0) {\n                    this.invalidatedResources = null;\n                }\n            }\n        }\n        else {\n            if (!this.invalidatedResources) {\n                this.invalidatedResources = new RemovedResources();\n            }\n            if (!this.invalidatedResources.has(strResource)) {\n                this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0 /* RemovedResourceReason.ExternalRemoval */));\n            }\n        }\n    }\n    toString() {\n        return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? 'INVALID' : '  VALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n    }\n}\nclass ResourceEditStack {\n    constructor(resourceLabel, strResource) {\n        this.resourceLabel = resourceLabel;\n        this.strResource = strResource;\n        this._past = [];\n        this._future = [];\n        this.locked = false;\n        this.versionId = 1;\n    }\n    dispose() {\n        for (const element of this._past) {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        for (const element of this._future) {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        this.versionId++;\n    }\n    toString() {\n        const result = [];\n        result.push(`* ${this.strResource}:`);\n        for (let i = 0; i < this._past.length; i++) {\n            result.push(`   * [UNDO] ${this._past[i]}`);\n        }\n        for (let i = this._future.length - 1; i >= 0; i--) {\n            result.push(`   * [REDO] ${this._future[i]}`);\n        }\n        return result.join('\\n');\n    }\n    flushAllElements() {\n        this._past = [];\n        this._future = [];\n        this.versionId++;\n    }\n    _setElementValidFlag(element, isValid) {\n        if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n            element.setValid(this.resourceLabel, this.strResource, isValid);\n        }\n        else {\n            element.setValid(isValid);\n        }\n    }\n    setElementsValidFlag(isValid, filter) {\n        for (const element of this._past) {\n            if (filter(element.actual)) {\n                this._setElementValidFlag(element, isValid);\n            }\n        }\n        for (const element of this._future) {\n            if (filter(element.actual)) {\n                this._setElementValidFlag(element, isValid);\n            }\n        }\n    }\n    pushElement(element) {\n        // remove the future\n        for (const futureElement of this._future) {\n            if (futureElement.type === 1 /* UndoRedoElementType.Workspace */) {\n                futureElement.removeResource(this.resourceLabel, this.strResource, 1 /* RemovedResourceReason.NoParallelUniverses */);\n            }\n        }\n        this._future = [];\n        this._past.push(element);\n        this.versionId++;\n    }\n    createSnapshot(resource) {\n        const elements = [];\n        for (let i = 0, len = this._past.length; i < len; i++) {\n            elements.push(this._past[i].id);\n        }\n        for (let i = this._future.length - 1; i >= 0; i--) {\n            elements.push(this._future[i].id);\n        }\n        return new ResourceEditStackSnapshot(resource, elements);\n    }\n    restoreSnapshot(snapshot) {\n        const snapshotLength = snapshot.elements.length;\n        let isOK = true;\n        let snapshotIndex = 0;\n        let removePastAfter = -1;\n        for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\n            const element = this._past[i];\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n                isOK = false;\n                removePastAfter = 0;\n            }\n            if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        let removeFutureBefore = -1;\n        for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\n            const element = this._future[i];\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n                isOK = false;\n                removeFutureBefore = i;\n            }\n            if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        if (removePastAfter !== -1) {\n            this._past = this._past.slice(0, removePastAfter);\n        }\n        if (removeFutureBefore !== -1) {\n            this._future = this._future.slice(removeFutureBefore + 1);\n        }\n        this.versionId++;\n    }\n    getElements() {\n        const past = [];\n        const future = [];\n        for (const element of this._past) {\n            past.push(element.actual);\n        }\n        for (const element of this._future) {\n            future.push(element.actual);\n        }\n        return { past, future };\n    }\n    getClosestPastElement() {\n        if (this._past.length === 0) {\n            return null;\n        }\n        return this._past[this._past.length - 1];\n    }\n    getSecondClosestPastElement() {\n        if (this._past.length < 2) {\n            return null;\n        }\n        return this._past[this._past.length - 2];\n    }\n    getClosestFutureElement() {\n        if (this._future.length === 0) {\n            return null;\n        }\n        return this._future[this._future.length - 1];\n    }\n    hasPastElements() {\n        return (this._past.length > 0);\n    }\n    hasFutureElements() {\n        return (this._future.length > 0);\n    }\n    splitPastWorkspaceElement(toRemove, individualMap) {\n        for (let j = this._past.length - 1; j >= 0; j--) {\n            if (this._past[j] === toRemove) {\n                if (individualMap.has(this.strResource)) {\n                    // gets replaced\n                    this._past[j] = individualMap.get(this.strResource);\n                }\n                else {\n                    // gets deleted\n                    this._past.splice(j, 1);\n                }\n                break;\n            }\n        }\n        this.versionId++;\n    }\n    splitFutureWorkspaceElement(toRemove, individualMap) {\n        for (let j = this._future.length - 1; j >= 0; j--) {\n            if (this._future[j] === toRemove) {\n                if (individualMap.has(this.strResource)) {\n                    // gets replaced\n                    this._future[j] = individualMap.get(this.strResource);\n                }\n                else {\n                    // gets deleted\n                    this._future.splice(j, 1);\n                }\n                break;\n            }\n        }\n        this.versionId++;\n    }\n    moveBackward(element) {\n        this._past.pop();\n        this._future.push(element);\n        this.versionId++;\n    }\n    moveForward(element) {\n        this._future.pop();\n        this._past.push(element);\n        this.versionId++;\n    }\n}\nclass EditStackSnapshot {\n    constructor(editStacks) {\n        this.editStacks = editStacks;\n        this._versionIds = [];\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\n            this._versionIds[i] = this.editStacks[i].versionId;\n        }\n    }\n    isValid() {\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\n            if (this._versionIds[i] !== this.editStacks[i].versionId) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nconst missingEditStack = new ResourceEditStack('', '');\nmissingEditStack.locked = true;\nlet UndoRedoService = class UndoRedoService {\n    constructor(_dialogService, _notificationService) {\n        this._dialogService = _dialogService;\n        this._notificationService = _notificationService;\n        this._editStacks = new Map();\n        this._uriComparisonKeyComputers = [];\n    }\n    getUriComparisonKey(resource) {\n        for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\n            if (uriComparisonKeyComputer[0] === resource.scheme) {\n                return uriComparisonKeyComputer[1].getComparisonKey(resource);\n            }\n        }\n        return resource.toString();\n    }\n    _print(label) {\n        console.log(`------------------------------------`);\n        console.log(`AFTER ${label}: `);\n        const str = [];\n        for (const element of this._editStacks) {\n            str.push(element[1].toString());\n        }\n        console.log(str.join('\\n'));\n    }\n    pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {\n        if (element.type === 0 /* UndoRedoElementType.Resource */) {\n            const resourceLabel = getResourceLabel(element.resource);\n            const strResource = this.getUriComparisonKey(element.resource);\n            this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\n        }\n        else {\n            const seen = new Set();\n            const resourceLabels = [];\n            const strResources = [];\n            for (const resource of element.resources) {\n                const resourceLabel = getResourceLabel(resource);\n                const strResource = this.getUriComparisonKey(resource);\n                if (seen.has(strResource)) {\n                    continue;\n                }\n                seen.add(strResource);\n                resourceLabels.push(resourceLabel);\n                strResources.push(strResource);\n            }\n            if (resourceLabels.length === 1) {\n                this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\n            }\n            else {\n                this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\n            }\n        }\n        if (DEBUG) {\n            this._print('pushElement');\n        }\n    }\n    _pushElement(element) {\n        for (let i = 0, len = element.strResources.length; i < len; i++) {\n            const resourceLabel = element.resourceLabels[i];\n            const strResource = element.strResources[i];\n            let editStack;\n            if (this._editStacks.has(strResource)) {\n                editStack = this._editStacks.get(strResource);\n            }\n            else {\n                editStack = new ResourceEditStack(resourceLabel, strResource);\n                this._editStacks.set(strResource, editStack);\n            }\n            editStack.pushElement(element);\n        }\n    }\n    getLastElement(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            if (editStack.hasFutureElements()) {\n                return null;\n            }\n            const closestPastElement = editStack.getClosestPastElement();\n            return closestPastElement ? closestPastElement.actual : null;\n        }\n        return null;\n    }\n    _splitPastWorkspaceElement(toRemove, ignoreResources) {\n        const individualArr = toRemove.actual.split();\n        const individualMap = new Map();\n        for (const _element of individualArr) {\n            const resourceLabel = getResourceLabel(_element.resource);\n            const strResource = this.getUriComparisonKey(_element.resource);\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n            individualMap.set(element.strResource, element);\n        }\n        for (const strResource of toRemove.strResources) {\n            if (ignoreResources && ignoreResources.has(strResource)) {\n                continue;\n            }\n            const editStack = this._editStacks.get(strResource);\n            editStack.splitPastWorkspaceElement(toRemove, individualMap);\n        }\n    }\n    _splitFutureWorkspaceElement(toRemove, ignoreResources) {\n        const individualArr = toRemove.actual.split();\n        const individualMap = new Map();\n        for (const _element of individualArr) {\n            const resourceLabel = getResourceLabel(_element.resource);\n            const strResource = this.getUriComparisonKey(_element.resource);\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n            individualMap.set(element.strResource, element);\n        }\n        for (const strResource of toRemove.strResources) {\n            if (ignoreResources && ignoreResources.has(strResource)) {\n                continue;\n            }\n            const editStack = this._editStacks.get(strResource);\n            editStack.splitFutureWorkspaceElement(toRemove, individualMap);\n        }\n    }\n    removeElements(resource) {\n        const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.dispose();\n            this._editStacks.delete(strResource);\n        }\n        if (DEBUG) {\n            this._print('removeElements');\n        }\n    }\n    setElementsValidFlag(resource, isValid, filter) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.setElementsValidFlag(isValid, filter);\n        }\n        if (DEBUG) {\n            this._print('setElementsValidFlag');\n        }\n    }\n    createSnapshot(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.createSnapshot(resource);\n        }\n        return new ResourceEditStackSnapshot(resource, []);\n    }\n    restoreSnapshot(snapshot) {\n        const strResource = this.getUriComparisonKey(snapshot.resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.restoreSnapshot(snapshot);\n            if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\n                // the edit stack is now empty, just remove it entirely\n                editStack.dispose();\n                this._editStacks.delete(strResource);\n            }\n        }\n        if (DEBUG) {\n            this._print('restoreSnapshot');\n        }\n    }\n    getElements(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.getElements();\n        }\n        return { past: [], future: [] };\n    }\n    _findClosestUndoElementWithSource(sourceId) {\n        if (!sourceId) {\n            return [null, null];\n        }\n        // find an element with the sourceId and with the highest sourceOrder ready to be undone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestPastElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.sourceId === sourceId) {\n                if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    canUndo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? true : false;\n        }\n        const strResource = this.getUriComparisonKey(resourceOrSource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.hasPastElements();\n        }\n        return false;\n    }\n    _onError(err, element) {\n        onUnexpectedError(err);\n        // An error occurred while undoing or redoing => drop the undo/redo stack for all affected resources\n        for (const strResource of element.strResources) {\n            this.removeElements(strResource);\n        }\n        this._notificationService.error(err);\n    }\n    _acquireLocks(editStackSnapshot) {\n        // first, check if all locks can be acquired\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                throw new Error('Cannot acquire edit stack lock');\n            }\n        }\n        // can acquire all locks\n        for (const editStack of editStackSnapshot.editStacks) {\n            editStack.locked = true;\n        }\n        return () => {\n            // release all locks\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.locked = false;\n            }\n        };\n    }\n    _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\n        const releaseLocks = this._acquireLocks(editStackSnapshot);\n        let result;\n        try {\n            result = invoke();\n        }\n        catch (err) {\n            releaseLocks();\n            cleanup.dispose();\n            return this._onError(err, element);\n        }\n        if (result) {\n            // result is Promise<void>\n            return result.then(() => {\n                releaseLocks();\n                cleanup.dispose();\n                return continuation();\n            }, (err) => {\n                releaseLocks();\n                cleanup.dispose();\n                return this._onError(err, element);\n            });\n        }\n        else {\n            // result is void\n            releaseLocks();\n            cleanup.dispose();\n            return continuation();\n        }\n    }\n    _invokeWorkspacePrepare(element) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof element.actual.prepareUndoRedo === 'undefined') {\n                return Disposable.None;\n            }\n            const result = element.actual.prepareUndoRedo();\n            if (typeof result === 'undefined') {\n                return Disposable.None;\n            }\n            return result;\n        });\n    }\n    _invokeResourcePrepare(element, callback) {\n        if (element.actual.type !== 1 /* UndoRedoElementType.Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {\n            // no preparation needed\n            return callback(Disposable.None);\n        }\n        const r = element.actual.prepareUndoRedo();\n        if (!r) {\n            // nothing to clean up\n            return callback(Disposable.None);\n        }\n        if (isDisposable(r)) {\n            return callback(r);\n        }\n        return r.then((disposable) => {\n            return callback(disposable);\n        });\n    }\n    _getAffectedEditStacks(element) {\n        const affectedEditStacks = [];\n        for (const strResource of element.strResources) {\n            affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\n        }\n        return new EditStackSnapshot(affectedEditStacks);\n    }\n    _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\n        if (element.canSplit()) {\n            this._splitPastWorkspaceElement(element, ignoreResources);\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError(this._undo(strResource, 0, true));\n        }\n        else {\n            // Cannot safely split this workspace element => flush all undo/redo stacks\n            for (const strResource of element.strResources) {\n                this.removeElements(strResource);\n            }\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError();\n        }\n    }\n    _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n        if (element.removedResources) {\n            return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n        }\n        if (checkInvalidatedResources && element.invalidatedResources) {\n            return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n        }\n        // this must be the last past element in all the impacted resources!\n        const cannotUndoDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.getClosestPastElement() !== element) {\n                cannotUndoDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotUndoDueToResources.length > 0) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\n        }\n        const cannotLockDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                cannotLockDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotLockDueToResources.length > 0) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n        }\n        // check if new stack elements were added in the meantime...\n        if (!editStackSnapshot.isValid()) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n        }\n        return null;\n    }\n    _workspaceUndo(strResource, element, undoConfirmed) {\n        const affectedEditStacks = this._getAffectedEditStacks(element);\n        const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\n        if (verificationError) {\n            return verificationError.returnValue;\n        }\n        return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\n    }\n    _isPartOfUndoGroup(element) {\n        if (!element.groupId) {\n            return false;\n        }\n        // check that there is at least another element with the same groupId ready to be undone\n        for (const [, editStack] of this._editStacks) {\n            const pastElement = editStack.getClosestPastElement();\n            if (!pastElement) {\n                continue;\n            }\n            if (pastElement === element) {\n                const secondPastElement = editStack.getSecondClosestPastElement();\n                if (secondPastElement && secondPastElement.groupId === element.groupId) {\n                    // there is another element with the same group id in the same stack!\n                    return true;\n                }\n            }\n            if (pastElement.groupId === element.groupId) {\n                // there is another element with the same group id in another stack!\n                return true;\n            }\n        }\n        return false;\n    }\n    _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\n                // this element can be split\n                const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label), [\n                    nls.localize({ key: 'ok', comment: ['{0} denotes a number that is > 1'] }, \"Undo in {0} Files\", editStackSnapshot.editStacks.length),\n                    nls.localize('nok', \"Undo this File\"),\n                    nls.localize('cancel', \"Cancel\"),\n                ], {\n                    cancelId: 2\n                });\n                if (result.choice === 2) {\n                    // choice: cancel\n                    return;\n                }\n                if (result.choice === 1) {\n                    // choice: undo this file\n                    this._splitPastWorkspaceElement(element, null);\n                    return this._undo(strResource, 0, true);\n                }\n                // choice: undo in all files\n                // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\n                const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/ false);\n                if (verificationError1) {\n                    return verificationError1.returnValue;\n                }\n                undoConfirmed = true;\n            }\n            // prepare\n            let cleanup;\n            try {\n                cleanup = yield this._invokeWorkspacePrepare(element);\n            }\n            catch (err) {\n                return this._onError(err, element);\n            }\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n            const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\n            if (verificationError2) {\n                cleanup.dispose();\n                return verificationError2.returnValue;\n            }\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.moveBackward(element);\n            }\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n        });\n    }\n    _resourceUndo(editStack, element, undoConfirmed) {\n        if (!element.isValid) {\n            // invalid element => immediately flush edit stack!\n            editStack.flushAllElements();\n            return;\n        }\n        if (editStack.locked) {\n            const message = nls.localize({ key: 'cannotResourceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\n            this._notificationService.warn(message);\n            return;\n        }\n        return this._invokeResourcePrepare(element, (cleanup) => {\n            editStack.moveBackward(element);\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n        });\n    }\n    _findClosestUndoElementInGroup(groupId) {\n        if (!groupId) {\n            return [null, null];\n        }\n        // find another element with the same groupId and with the highest groupOrder ready to be undone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestPastElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.groupId === groupId) {\n                if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    _continueUndoInGroup(groupId, undoConfirmed) {\n        if (!groupId) {\n            return;\n        }\n        const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\n        if (matchedStrResource) {\n            return this._undo(matchedStrResource, 0, undoConfirmed);\n        }\n    }\n    undo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\n        }\n        if (typeof resourceOrSource === 'string') {\n            return this._undo(resourceOrSource, 0, false);\n        }\n        return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\n    }\n    _undo(strResource, sourceId = 0, undoConfirmed) {\n        if (!this._editStacks.has(strResource)) {\n            return;\n        }\n        const editStack = this._editStacks.get(strResource);\n        const element = editStack.getClosestPastElement();\n        if (!element) {\n            return;\n        }\n        if (element.groupId) {\n            // this element is a part of a group, we need to make sure undoing in a group is in order\n            const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\n            if (element !== matchedElement && matchedStrResource) {\n                // there is an element in the same group that should be undone before this one\n                return this._undo(matchedStrResource, sourceId, undoConfirmed);\n            }\n        }\n        const shouldPromptForConfirmation = (element.sourceId !== sourceId || element.confirmBeforeUndo);\n        if (shouldPromptForConfirmation && !undoConfirmed) {\n            // Hit a different source or the element asks for prompt before undo, prompt for confirmation\n            return this._confirmAndContinueUndo(strResource, sourceId, element);\n        }\n        try {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                return this._workspaceUndo(strResource, element, undoConfirmed);\n            }\n            else {\n                return this._resourceUndo(editStack, element, undoConfirmed);\n            }\n        }\n        finally {\n            if (DEBUG) {\n                this._print('undo');\n            }\n        }\n    }\n    _confirmAndContinueUndo(strResource, sourceId, element) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label), [\n                nls.localize('confirmDifferentSource.yes', \"Yes\"),\n                nls.localize('confirmDifferentSource.no', \"No\"),\n            ], {\n                cancelId: 1\n            });\n            if (result.choice === 1) {\n                // choice: cancel\n                return;\n            }\n            // choice: undo\n            return this._undo(strResource, sourceId, true);\n        });\n    }\n    _findClosestRedoElementWithSource(sourceId) {\n        if (!sourceId) {\n            return [null, null];\n        }\n        // find an element with sourceId and with the lowest sourceOrder ready to be redone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestFutureElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.sourceId === sourceId) {\n                if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    canRedo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? true : false;\n        }\n        const strResource = this.getUriComparisonKey(resourceOrSource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.hasFutureElements();\n        }\n        return false;\n    }\n    _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\n        if (element.canSplit()) {\n            this._splitFutureWorkspaceElement(element, ignoreResources);\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError(this._redo(strResource));\n        }\n        else {\n            // Cannot safely split this workspace element => flush all undo/redo stacks\n            for (const strResource of element.strResources) {\n                this.removeElements(strResource);\n            }\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError();\n        }\n    }\n    _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n        if (element.removedResources) {\n            return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n        }\n        if (checkInvalidatedResources && element.invalidatedResources) {\n            return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n        }\n        // this must be the last future element in all the impacted resources!\n        const cannotRedoDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.getClosestFutureElement() !== element) {\n                cannotRedoDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotRedoDueToResources.length > 0) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\n        }\n        const cannotLockDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                cannotLockDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotLockDueToResources.length > 0) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n        }\n        // check if new stack elements were added in the meantime...\n        if (!editStackSnapshot.isValid()) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n        }\n        return null;\n    }\n    _workspaceRedo(strResource, element) {\n        const affectedEditStacks = this._getAffectedEditStacks(element);\n        const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\n        if (verificationError) {\n            return verificationError.returnValue;\n        }\n        return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\n    }\n    _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // prepare\n            let cleanup;\n            try {\n                cleanup = yield this._invokeWorkspacePrepare(element);\n            }\n            catch (err) {\n                return this._onError(err, element);\n            }\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n            const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\n            if (verificationError) {\n                cleanup.dispose();\n                return verificationError.returnValue;\n            }\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.moveForward(element);\n            }\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\n        });\n    }\n    _resourceRedo(editStack, element) {\n        if (!element.isValid) {\n            // invalid element => immediately flush edit stack!\n            editStack.flushAllElements();\n            return;\n        }\n        if (editStack.locked) {\n            const message = nls.localize({ key: 'cannotResourceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\n            this._notificationService.warn(message);\n            return;\n        }\n        return this._invokeResourcePrepare(element, (cleanup) => {\n            editStack.moveForward(element);\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\n        });\n    }\n    _findClosestRedoElementInGroup(groupId) {\n        if (!groupId) {\n            return [null, null];\n        }\n        // find another element with the same groupId and with the lowest groupOrder ready to be redone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestFutureElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.groupId === groupId) {\n                if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    _continueRedoInGroup(groupId) {\n        if (!groupId) {\n            return;\n        }\n        const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\n        if (matchedStrResource) {\n            return this._redo(matchedStrResource);\n        }\n    }\n    redo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? this._redo(matchedStrResource) : undefined;\n        }\n        if (typeof resourceOrSource === 'string') {\n            return this._redo(resourceOrSource);\n        }\n        return this._redo(this.getUriComparisonKey(resourceOrSource));\n    }\n    _redo(strResource) {\n        if (!this._editStacks.has(strResource)) {\n            return;\n        }\n        const editStack = this._editStacks.get(strResource);\n        const element = editStack.getClosestFutureElement();\n        if (!element) {\n            return;\n        }\n        if (element.groupId) {\n            // this element is a part of a group, we need to make sure redoing in a group is in order\n            const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\n            if (element !== matchedElement && matchedStrResource) {\n                // there is an element in the same group that should be redone before this one\n                return this._redo(matchedStrResource);\n            }\n        }\n        try {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                return this._workspaceRedo(strResource, element);\n            }\n            else {\n                return this._resourceRedo(editStack, element);\n            }\n        }\n        finally {\n            if (DEBUG) {\n                this._print('redo');\n            }\n        }\n    }\n};\nUndoRedoService = __decorate([\n    __param(0, IDialogService),\n    __param(1, INotificationService)\n], UndoRedoService);\nexport { UndoRedoService };\nclass WorkspaceVerificationError {\n    constructor(returnValue) {\n        this.returnValue = returnValue;\n    }\n}\nregisterSingleton(IUndoRedoService, UndoRedoService);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BrowserFeatures } from '../../canIUse.js';\nimport * as DOM from '../../dom.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../common/lifecycle.js';\nimport * as platform from '../../../common/platform.js';\nimport { Range } from '../../../common/range.js';\nimport './contextview.css';\nexport var LayoutAnchorMode;\n(function (LayoutAnchorMode) {\n    LayoutAnchorMode[LayoutAnchorMode[\"AVOID\"] = 0] = \"AVOID\";\n    LayoutAnchorMode[LayoutAnchorMode[\"ALIGN\"] = 1] = \"ALIGN\";\n})(LayoutAnchorMode || (LayoutAnchorMode = {}));\n/**\n * Lays out a one dimensional view next to an anchor in a viewport.\n *\n * @returns The view offset within the viewport.\n */\nexport function layout(viewportSize, viewSize, anchor) {\n    const layoutAfterAnchorBoundary = anchor.mode === LayoutAnchorMode.ALIGN ? anchor.offset : anchor.offset + anchor.size;\n    const layoutBeforeAnchorBoundary = anchor.mode === LayoutAnchorMode.ALIGN ? anchor.offset + anchor.size : anchor.offset;\n    if (anchor.position === 0 /* LayoutAnchorPosition.Before */) {\n        if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {\n            return layoutAfterAnchorBoundary; // happy case, lay it out after the anchor\n        }\n        if (viewSize <= layoutBeforeAnchorBoundary) {\n            return layoutBeforeAnchorBoundary - viewSize; // ok case, lay it out before the anchor\n        }\n        return Math.max(viewportSize - viewSize, 0); // sad case, lay it over the anchor\n    }\n    else {\n        if (viewSize <= layoutBeforeAnchorBoundary) {\n            return layoutBeforeAnchorBoundary - viewSize; // happy case, lay it out before the anchor\n        }\n        if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {\n            return layoutAfterAnchorBoundary; // ok case, lay it out after the anchor\n        }\n        return 0; // sad case, lay it over the anchor\n    }\n}\nexport class ContextView extends Disposable {\n    constructor(container, domPosition) {\n        super();\n        this.container = null;\n        this.delegate = null;\n        this.toDisposeOnClean = Disposable.None;\n        this.toDisposeOnSetContainer = Disposable.None;\n        this.shadowRoot = null;\n        this.shadowRootHostElement = null;\n        this.view = DOM.$('.context-view');\n        this.useFixedPosition = false;\n        this.useShadowDOM = false;\n        DOM.hide(this.view);\n        this.setContainer(container, domPosition);\n        this._register(toDisposable(() => this.setContainer(null, 1 /* ContextViewDOMPosition.ABSOLUTE */)));\n    }\n    setContainer(container, domPosition) {\n        var _a;\n        if (this.container) {\n            this.toDisposeOnSetContainer.dispose();\n            if (this.shadowRoot) {\n                this.shadowRoot.removeChild(this.view);\n                this.shadowRoot = null;\n                (_a = this.shadowRootHostElement) === null || _a === void 0 ? void 0 : _a.remove();\n                this.shadowRootHostElement = null;\n            }\n            else {\n                this.container.removeChild(this.view);\n            }\n            this.container = null;\n        }\n        if (container) {\n            this.container = container;\n            this.useFixedPosition = domPosition !== 1 /* ContextViewDOMPosition.ABSOLUTE */;\n            this.useShadowDOM = domPosition === 3 /* ContextViewDOMPosition.FIXED_SHADOW */;\n            if (this.useShadowDOM) {\n                this.shadowRootHostElement = DOM.$('.shadow-root-host');\n                this.container.appendChild(this.shadowRootHostElement);\n                this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: 'open' });\n                const style = document.createElement('style');\n                style.textContent = SHADOW_ROOT_CSS;\n                this.shadowRoot.appendChild(style);\n                this.shadowRoot.appendChild(this.view);\n                this.shadowRoot.appendChild(DOM.$('slot'));\n            }\n            else {\n                this.container.appendChild(this.view);\n            }\n            const toDisposeOnSetContainer = new DisposableStore();\n            ContextView.BUBBLE_UP_EVENTS.forEach(event => {\n                toDisposeOnSetContainer.add(DOM.addStandardDisposableListener(this.container, event, (e) => {\n                    this.onDOMEvent(e, false);\n                }));\n            });\n            ContextView.BUBBLE_DOWN_EVENTS.forEach(event => {\n                toDisposeOnSetContainer.add(DOM.addStandardDisposableListener(this.container, event, (e) => {\n                    this.onDOMEvent(e, true);\n                }, true));\n            });\n            this.toDisposeOnSetContainer = toDisposeOnSetContainer;\n        }\n    }\n    show(delegate) {\n        var _a, _b;\n        if (this.isVisible()) {\n            this.hide();\n        }\n        // Show static box\n        DOM.clearNode(this.view);\n        this.view.className = 'context-view';\n        this.view.style.top = '0px';\n        this.view.style.left = '0px';\n        this.view.style.zIndex = '2575';\n        this.view.style.position = this.useFixedPosition ? 'fixed' : 'absolute';\n        DOM.show(this.view);\n        // Render content\n        this.toDisposeOnClean = delegate.render(this.view) || Disposable.None;\n        // Set active delegate\n        this.delegate = delegate;\n        // Layout\n        this.doLayout();\n        // Focus\n        (_b = (_a = this.delegate).focus) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    getViewElement() {\n        return this.view;\n    }\n    layout() {\n        if (!this.isVisible()) {\n            return;\n        }\n        if (this.delegate.canRelayout === false && !(platform.isIOS && BrowserFeatures.pointerEvents)) {\n            this.hide();\n            return;\n        }\n        if (this.delegate.layout) {\n            this.delegate.layout();\n        }\n        this.doLayout();\n    }\n    doLayout() {\n        // Check that we still have a delegate - this.delegate.layout may have hidden\n        if (!this.isVisible()) {\n            return;\n        }\n        // Get anchor\n        const anchor = this.delegate.getAnchor();\n        // Compute around\n        let around;\n        // Get the element's position and size (to anchor the view)\n        if (DOM.isHTMLElement(anchor)) {\n            const elementPosition = DOM.getDomNodePagePosition(anchor);\n            // In areas where zoom is applied to the element or its ancestors, we need to adjust the size of the element\n            // e.g. The title bar has counter zoom behavior meaning it applies the inverse of zoom level.\n            // Window Zoom Level: 1.5, Title Bar Zoom: 1/1.5, Size Multiplier: 1.5\n            const zoom = DOM.getDomNodeZoomLevel(anchor);\n            around = {\n                top: elementPosition.top * zoom,\n                left: elementPosition.left * zoom,\n                width: elementPosition.width * zoom,\n                height: elementPosition.height * zoom\n            };\n        }\n        else {\n            around = {\n                top: anchor.y,\n                left: anchor.x,\n                width: anchor.width || 1,\n                height: anchor.height || 2\n            };\n        }\n        const viewSizeWidth = DOM.getTotalWidth(this.view);\n        const viewSizeHeight = DOM.getTotalHeight(this.view);\n        const anchorPosition = this.delegate.anchorPosition || 0 /* AnchorPosition.BELOW */;\n        const anchorAlignment = this.delegate.anchorAlignment || 0 /* AnchorAlignment.LEFT */;\n        const anchorAxisAlignment = this.delegate.anchorAxisAlignment || 0 /* AnchorAxisAlignment.VERTICAL */;\n        let top;\n        let left;\n        if (anchorAxisAlignment === 0 /* AnchorAxisAlignment.VERTICAL */) {\n            const verticalAnchor = { offset: around.top - window.pageYOffset, size: around.height, position: anchorPosition === 0 /* AnchorPosition.BELOW */ ? 0 /* LayoutAnchorPosition.Before */ : 1 /* LayoutAnchorPosition.After */ };\n            const horizontalAnchor = { offset: around.left, size: around.width, position: anchorAlignment === 0 /* AnchorAlignment.LEFT */ ? 0 /* LayoutAnchorPosition.Before */ : 1 /* LayoutAnchorPosition.After */, mode: LayoutAnchorMode.ALIGN };\n            top = layout(window.innerHeight, viewSizeHeight, verticalAnchor) + window.pageYOffset;\n            // if view intersects vertically with anchor,  we must avoid the anchor\n            if (Range.intersects({ start: top, end: top + viewSizeHeight }, { start: verticalAnchor.offset, end: verticalAnchor.offset + verticalAnchor.size })) {\n                horizontalAnchor.mode = LayoutAnchorMode.AVOID;\n            }\n            left = layout(window.innerWidth, viewSizeWidth, horizontalAnchor);\n        }\n        else {\n            const horizontalAnchor = { offset: around.left, size: around.width, position: anchorAlignment === 0 /* AnchorAlignment.LEFT */ ? 0 /* LayoutAnchorPosition.Before */ : 1 /* LayoutAnchorPosition.After */ };\n            const verticalAnchor = { offset: around.top, size: around.height, position: anchorPosition === 0 /* AnchorPosition.BELOW */ ? 0 /* LayoutAnchorPosition.Before */ : 1 /* LayoutAnchorPosition.After */, mode: LayoutAnchorMode.ALIGN };\n            left = layout(window.innerWidth, viewSizeWidth, horizontalAnchor);\n            // if view intersects horizontally with anchor, we must avoid the anchor\n            if (Range.intersects({ start: left, end: left + viewSizeWidth }, { start: horizontalAnchor.offset, end: horizontalAnchor.offset + horizontalAnchor.size })) {\n                verticalAnchor.mode = LayoutAnchorMode.AVOID;\n            }\n            top = layout(window.innerHeight, viewSizeHeight, verticalAnchor) + window.pageYOffset;\n        }\n        this.view.classList.remove('top', 'bottom', 'left', 'right');\n        this.view.classList.add(anchorPosition === 0 /* AnchorPosition.BELOW */ ? 'bottom' : 'top');\n        this.view.classList.add(anchorAlignment === 0 /* AnchorAlignment.LEFT */ ? 'left' : 'right');\n        this.view.classList.toggle('fixed', this.useFixedPosition);\n        const containerPosition = DOM.getDomNodePagePosition(this.container);\n        this.view.style.top = `${top - (this.useFixedPosition ? DOM.getDomNodePagePosition(this.view).top : containerPosition.top)}px`;\n        this.view.style.left = `${left - (this.useFixedPosition ? DOM.getDomNodePagePosition(this.view).left : containerPosition.left)}px`;\n        this.view.style.width = 'initial';\n    }\n    hide(data) {\n        const delegate = this.delegate;\n        this.delegate = null;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.onHide) {\n            delegate.onHide(data);\n        }\n        this.toDisposeOnClean.dispose();\n        DOM.hide(this.view);\n    }\n    isVisible() {\n        return !!this.delegate;\n    }\n    onDOMEvent(e, onCapture) {\n        if (this.delegate) {\n            if (this.delegate.onDOMEvent) {\n                this.delegate.onDOMEvent(e, document.activeElement);\n            }\n            else if (onCapture && !DOM.isAncestor(e.target, this.container)) {\n                this.hide();\n            }\n        }\n    }\n    dispose() {\n        this.hide();\n        super.dispose();\n    }\n}\nContextView.BUBBLE_UP_EVENTS = ['click', 'keydown', 'focus', 'blur'];\nContextView.BUBBLE_DOWN_EVENTS = ['click'];\nconst SHADOW_ROOT_CSS = /* css */ `\n\t:host {\n\t\tall: initial; /* 1st rule so subsequent properties are reset. */\n\t}\n\n\t@font-face {\n\t\tfont-family: \"codicon\";\n\t\tfont-display: block;\n\t\tsrc: url(\"./codicon.ttf?5d4d76ab2ce5108968ad644d591a16a6\") format(\"truetype\");\n\t}\n\n\t.codicon[class*='codicon-'] {\n\t\tfont: normal normal normal 16px/1 codicon;\n\t\tdisplay: inline-block;\n\t\ttext-decoration: none;\n\t\ttext-rendering: auto;\n\t\ttext-align: center;\n\t\t-webkit-font-smoothing: antialiased;\n\t\t-moz-osx-font-smoothing: grayscale;\n\t\tuser-select: none;\n\t\t-webkit-user-select: none;\n\t\t-ms-user-select: none;\n\t}\n\n\t:host {\n\t\tfont-family: -apple-system, BlinkMacSystemFont, \"Segoe WPC\", \"Segoe UI\", \"HelveticaNeue-Light\", system-ui, \"Ubuntu\", \"Droid Sans\", sans-serif;\n\t}\n\n\t:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }\n\t:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, \"PingFang SC\", \"Hiragino Sans GB\", sans-serif; }\n\t:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, \"PingFang TC\", sans-serif; }\n\t:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, \"Hiragino Kaku Gothic Pro\", sans-serif; }\n\t:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, \"Nanum Gothic\", \"Apple SD Gothic Neo\", \"AppleGothic\", sans-serif; }\n\n\t:host-context(.windows) { font-family: \"Segoe WPC\", \"Segoe UI\", sans-serif; }\n\t:host-context(.windows:lang(zh-Hans)) { font-family: \"Segoe WPC\", \"Segoe UI\", \"Microsoft YaHei\", sans-serif; }\n\t:host-context(.windows:lang(zh-Hant)) { font-family: \"Segoe WPC\", \"Segoe UI\", \"Microsoft Jhenghei\", sans-serif; }\n\t:host-context(.windows:lang(ja)) { font-family: \"Segoe WPC\", \"Segoe UI\", \"Yu Gothic UI\", \"Meiryo UI\", sans-serif; }\n\t:host-context(.windows:lang(ko)) { font-family: \"Segoe WPC\", \"Segoe UI\", \"Malgun Gothic\", \"Dotom\", sans-serif; }\n\n\t:host-context(.linux) { font-family: system-ui, \"Ubuntu\", \"Droid Sans\", sans-serif; }\n\t:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, \"Ubuntu\", \"Droid Sans\", \"Source Han Sans SC\", \"Source Han Sans CN\", \"Source Han Sans\", sans-serif; }\n\t:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, \"Ubuntu\", \"Droid Sans\", \"Source Han Sans TC\", \"Source Han Sans TW\", \"Source Han Sans\", sans-serif; }\n\t:host-context(.linux:lang(ja)) { font-family: system-ui, \"Ubuntu\", \"Droid Sans\", \"Source Han Sans J\", \"Source Han Sans JP\", \"Source Han Sans\", sans-serif; }\n\t:host-context(.linux:lang(ko)) { font-family: system-ui, \"Ubuntu\", \"Droid Sans\", \"Source Han Sans K\", \"Source Han Sans JR\", \"Source Han Sans\", \"UnDotum\", \"FBaekmuk Gulim\", sans-serif; }\n`;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ContextView } from '../../../base/browser/ui/contextview/contextview.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nlet ContextViewService = class ContextViewService extends Disposable {\n    constructor(layoutService) {\n        super();\n        this.layoutService = layoutService;\n        this.currentViewDisposable = Disposable.None;\n        this.container = layoutService.hasContainer ? layoutService.container : null;\n        this.contextView = this._register(new ContextView(this.container, 1 /* ContextViewDOMPosition.ABSOLUTE */));\n        this.layout();\n        this._register(layoutService.onDidLayout(() => this.layout()));\n    }\n    // ContextView\n    setContainer(container, domPosition) {\n        this.contextView.setContainer(container, domPosition || 1 /* ContextViewDOMPosition.ABSOLUTE */);\n    }\n    showContextView(delegate, container, shadowRoot) {\n        if (container) {\n            if (container !== this.container || this.shadowRoot !== shadowRoot) {\n                this.container = container;\n                this.setContainer(container, shadowRoot ? 3 /* ContextViewDOMPosition.FIXED_SHADOW */ : 2 /* ContextViewDOMPosition.FIXED */);\n            }\n        }\n        else {\n            if (this.layoutService.hasContainer && this.container !== this.layoutService.container) {\n                this.container = this.layoutService.container;\n                this.setContainer(this.container, 1 /* ContextViewDOMPosition.ABSOLUTE */);\n            }\n        }\n        this.shadowRoot = shadowRoot;\n        this.contextView.show(delegate);\n        const disposable = toDisposable(() => {\n            if (this.currentViewDisposable === disposable) {\n                this.hideContextView();\n            }\n        });\n        this.currentViewDisposable = disposable;\n        return disposable;\n    }\n    getContextViewElement() {\n        return this.contextView.getViewElement();\n    }\n    layout() {\n        this.contextView.layout();\n    }\n    hideContextView(data) {\n        this.contextView.hide(data);\n    }\n};\nContextViewService = __decorate([\n    __param(0, ILayoutService)\n], ContextViewService);\nexport { ContextViewService };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isFirefox } from '../../browser.js';\nimport { EventType as TouchEventType, Gesture } from '../../touch.js';\nimport { $, addDisposableListener, append, clearNode, createStyleSheet, Dimension, EventHelper, EventType, getActiveElement, isAncestor, isInShadowDOM } from '../../dom.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { StandardMouseEvent } from '../../mouseEvent.js';\nimport { ActionBar } from '../actionbar/actionbar.js';\nimport { ActionViewItem, BaseActionViewItem } from '../actionbar/actionViewItems.js';\nimport { formatRule } from '../codicons/codiconStyles.js';\nimport { layout } from '../contextview/contextview.js';\nimport { DomScrollableElement } from '../scrollbar/scrollableElement.js';\nimport { EmptySubmenuAction, Separator, SubmenuAction } from '../../../common/actions.js';\nimport { RunOnceScheduler } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { stripIcons } from '../../../common/iconLabels.js';\nimport { DisposableStore } from '../../../common/lifecycle.js';\nimport { isLinux, isMacintosh } from '../../../common/platform.js';\nimport * as strings from '../../../common/strings.js';\nexport const MENU_MNEMONIC_REGEX = /\\(&([^\\s&])\\)|(^|[^&])&([^\\s&])/;\nexport const MENU_ESCAPED_MNEMONIC_REGEX = /(&amp;)?(&amp;)([^\\s&])/g;\nexport var Direction;\n(function (Direction) {\n    Direction[Direction[\"Right\"] = 0] = \"Right\";\n    Direction[Direction[\"Left\"] = 1] = \"Left\";\n})(Direction || (Direction = {}));\nexport class Menu extends ActionBar {\n    constructor(container, actions, options = {}) {\n        container.classList.add('monaco-menu-container');\n        container.setAttribute('role', 'presentation');\n        const menuElement = document.createElement('div');\n        menuElement.classList.add('monaco-menu');\n        menuElement.setAttribute('role', 'presentation');\n        super(menuElement, {\n            orientation: 1 /* ActionsOrientation.VERTICAL */,\n            actionViewItemProvider: action => this.doGetActionViewItem(action, options, parentData),\n            context: options.context,\n            actionRunner: options.actionRunner,\n            ariaLabel: options.ariaLabel,\n            ariaRole: 'menu',\n            focusOnlyEnabledItems: true,\n            triggerKeys: { keys: [3 /* KeyCode.Enter */, ...(isMacintosh || isLinux ? [10 /* KeyCode.Space */] : [])], keyDown: true }\n        });\n        this.menuElement = menuElement;\n        this.actionsList.tabIndex = 0;\n        this.menuDisposables = this._register(new DisposableStore());\n        this.initializeOrUpdateStyleSheet(container, {});\n        this._register(Gesture.addTarget(menuElement));\n        addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {\n            const event = new StandardKeyboardEvent(e);\n            // Stop tab navigation of menus\n            if (event.equals(2 /* KeyCode.Tab */)) {\n                e.preventDefault();\n            }\n        });\n        if (options.enableMnemonics) {\n            this.menuDisposables.add(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {\n                const key = e.key.toLocaleLowerCase();\n                if (this.mnemonics.has(key)) {\n                    EventHelper.stop(e, true);\n                    const actions = this.mnemonics.get(key);\n                    if (actions.length === 1) {\n                        if (actions[0] instanceof SubmenuMenuActionViewItem && actions[0].container) {\n                            this.focusItemByElement(actions[0].container);\n                        }\n                        actions[0].onClick(e);\n                    }\n                    if (actions.length > 1) {\n                        const action = actions.shift();\n                        if (action && action.container) {\n                            this.focusItemByElement(action.container);\n                            actions.push(action);\n                        }\n                        this.mnemonics.set(key, actions);\n                    }\n                }\n            }));\n        }\n        if (isLinux) {\n            this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, e => {\n                const event = new StandardKeyboardEvent(e);\n                if (event.equals(14 /* KeyCode.Home */) || event.equals(11 /* KeyCode.PageUp */)) {\n                    this.focusedItem = this.viewItems.length - 1;\n                    this.focusNext();\n                    EventHelper.stop(e, true);\n                }\n                else if (event.equals(13 /* KeyCode.End */) || event.equals(12 /* KeyCode.PageDown */)) {\n                    this.focusedItem = 0;\n                    this.focusPrevious();\n                    EventHelper.stop(e, true);\n                }\n            }));\n        }\n        this._register(addDisposableListener(this.domNode, EventType.MOUSE_OUT, e => {\n            const relatedTarget = e.relatedTarget;\n            if (!isAncestor(relatedTarget, this.domNode)) {\n                this.focusedItem = undefined;\n                this.updateFocus();\n                e.stopPropagation();\n            }\n        }));\n        this._register(addDisposableListener(this.actionsList, EventType.MOUSE_OVER, e => {\n            let target = e.target;\n            if (!target || !isAncestor(target, this.actionsList) || target === this.actionsList) {\n                return;\n            }\n            while (target.parentElement !== this.actionsList && target.parentElement !== null) {\n                target = target.parentElement;\n            }\n            if (target.classList.contains('action-item')) {\n                const lastFocusedItem = this.focusedItem;\n                this.setFocusedItem(target);\n                if (lastFocusedItem !== this.focusedItem) {\n                    this.updateFocus();\n                }\n            }\n        }));\n        // Support touch on actions list to focus items (needed for submenus)\n        this._register(Gesture.addTarget(this.actionsList));\n        this._register(addDisposableListener(this.actionsList, TouchEventType.Tap, e => {\n            let target = e.initialTarget;\n            if (!target || !isAncestor(target, this.actionsList) || target === this.actionsList) {\n                return;\n            }\n            while (target.parentElement !== this.actionsList && target.parentElement !== null) {\n                target = target.parentElement;\n            }\n            if (target.classList.contains('action-item')) {\n                const lastFocusedItem = this.focusedItem;\n                this.setFocusedItem(target);\n                if (lastFocusedItem !== this.focusedItem) {\n                    this.updateFocus();\n                }\n            }\n        }));\n        const parentData = {\n            parent: this\n        };\n        this.mnemonics = new Map();\n        // Scroll Logic\n        this.scrollableElement = this._register(new DomScrollableElement(menuElement, {\n            alwaysConsumeMouseWheel: true,\n            horizontal: 2 /* ScrollbarVisibility.Hidden */,\n            vertical: 3 /* ScrollbarVisibility.Visible */,\n            verticalScrollbarSize: 7,\n            handleMouseWheel: true,\n            useShadows: true\n        }));\n        const scrollElement = this.scrollableElement.getDomNode();\n        scrollElement.style.position = '';\n        // Support scroll on menu drag\n        this._register(addDisposableListener(menuElement, TouchEventType.Change, e => {\n            EventHelper.stop(e, true);\n            const scrollTop = this.scrollableElement.getScrollPosition().scrollTop;\n            this.scrollableElement.setScrollPosition({ scrollTop: scrollTop - e.translationY });\n        }));\n        this._register(addDisposableListener(scrollElement, EventType.MOUSE_UP, e => {\n            // Absorb clicks in menu dead space https://github.com/microsoft/vscode/issues/63575\n            // We do this on the scroll element so the scroll bar doesn't dismiss the menu either\n            e.preventDefault();\n        }));\n        menuElement.style.maxHeight = `${Math.max(10, window.innerHeight - container.getBoundingClientRect().top - 35)}px`;\n        actions = actions.filter(a => {\n            var _a;\n            if ((_a = options.submenuIds) === null || _a === void 0 ? void 0 : _a.has(a.id)) {\n                console.warn(`Found submenu cycle: ${a.id}`);\n                return false;\n            }\n            return true;\n        });\n        this.push(actions, { icon: true, label: true, isMenu: true });\n        container.appendChild(this.scrollableElement.getDomNode());\n        this.scrollableElement.scanDomNode();\n        this.viewItems.filter(item => !(item instanceof MenuSeparatorActionViewItem)).forEach((item, index, array) => {\n            item.updatePositionInSet(index + 1, array.length);\n        });\n    }\n    initializeOrUpdateStyleSheet(container, style) {\n        if (!this.styleSheet) {\n            if (isInShadowDOM(container)) {\n                this.styleSheet = createStyleSheet(container);\n            }\n            else {\n                if (!Menu.globalStyleSheet) {\n                    Menu.globalStyleSheet = createStyleSheet();\n                }\n                this.styleSheet = Menu.globalStyleSheet;\n            }\n        }\n        this.styleSheet.textContent = getMenuWidgetCSS(style, isInShadowDOM(container));\n    }\n    style(style) {\n        const container = this.getContainer();\n        this.initializeOrUpdateStyleSheet(container, style);\n        const fgColor = style.foregroundColor ? `${style.foregroundColor}` : '';\n        const bgColor = style.backgroundColor ? `${style.backgroundColor}` : '';\n        const border = style.borderColor ? `1px solid ${style.borderColor}` : '';\n        const borderRadius = '5px';\n        const shadow = style.shadowColor ? `0 2px 8px ${style.shadowColor}` : '';\n        container.style.outline = border;\n        container.style.borderRadius = borderRadius;\n        container.style.color = fgColor;\n        container.style.backgroundColor = bgColor;\n        container.style.boxShadow = shadow;\n        if (this.viewItems) {\n            this.viewItems.forEach(item => {\n                if (item instanceof BaseMenuActionViewItem || item instanceof MenuSeparatorActionViewItem) {\n                    item.style(style);\n                }\n            });\n        }\n    }\n    getContainer() {\n        return this.scrollableElement.getDomNode();\n    }\n    get onScroll() {\n        return this.scrollableElement.onScroll;\n    }\n    focusItemByElement(element) {\n        const lastFocusedItem = this.focusedItem;\n        this.setFocusedItem(element);\n        if (lastFocusedItem !== this.focusedItem) {\n            this.updateFocus();\n        }\n    }\n    setFocusedItem(element) {\n        for (let i = 0; i < this.actionsList.children.length; i++) {\n            const elem = this.actionsList.children[i];\n            if (element === elem) {\n                this.focusedItem = i;\n                break;\n            }\n        }\n    }\n    updateFocus(fromRight) {\n        super.updateFocus(fromRight, true, true);\n        if (typeof this.focusedItem !== 'undefined') {\n            // Workaround for #80047 caused by an issue in chromium\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=414283\n            // When that's fixed, just call this.scrollableElement.scanDomNode()\n            this.scrollableElement.setScrollPosition({\n                scrollTop: Math.round(this.menuElement.scrollTop)\n            });\n        }\n    }\n    doGetActionViewItem(action, options, parentData) {\n        if (action instanceof Separator) {\n            return new MenuSeparatorActionViewItem(options.context, action, { icon: true });\n        }\n        else if (action instanceof SubmenuAction) {\n            const menuActionViewItem = new SubmenuMenuActionViewItem(action, action.actions, parentData, Object.assign(Object.assign({}, options), { submenuIds: new Set([...(options.submenuIds || []), action.id]) }));\n            if (options.enableMnemonics) {\n                const mnemonic = menuActionViewItem.getMnemonic();\n                if (mnemonic && menuActionViewItem.isEnabled()) {\n                    let actionViewItems = [];\n                    if (this.mnemonics.has(mnemonic)) {\n                        actionViewItems = this.mnemonics.get(mnemonic);\n                    }\n                    actionViewItems.push(menuActionViewItem);\n                    this.mnemonics.set(mnemonic, actionViewItems);\n                }\n            }\n            return menuActionViewItem;\n        }\n        else {\n            const menuItemOptions = { enableMnemonics: options.enableMnemonics, useEventAsContext: options.useEventAsContext };\n            if (options.getKeyBinding) {\n                const keybinding = options.getKeyBinding(action);\n                if (keybinding) {\n                    const keybindingLabel = keybinding.getLabel();\n                    if (keybindingLabel) {\n                        menuItemOptions.keybinding = keybindingLabel;\n                    }\n                }\n            }\n            const menuActionViewItem = new BaseMenuActionViewItem(options.context, action, menuItemOptions);\n            if (options.enableMnemonics) {\n                const mnemonic = menuActionViewItem.getMnemonic();\n                if (mnemonic && menuActionViewItem.isEnabled()) {\n                    let actionViewItems = [];\n                    if (this.mnemonics.has(mnemonic)) {\n                        actionViewItems = this.mnemonics.get(mnemonic);\n                    }\n                    actionViewItems.push(menuActionViewItem);\n                    this.mnemonics.set(mnemonic, actionViewItems);\n                }\n            }\n            return menuActionViewItem;\n        }\n    }\n}\nclass BaseMenuActionViewItem extends BaseActionViewItem {\n    constructor(ctx, action, options = {}) {\n        options.isMenu = true;\n        super(action, action, options);\n        this.options = options;\n        this.options.icon = options.icon !== undefined ? options.icon : false;\n        this.options.label = options.label !== undefined ? options.label : true;\n        this.cssClass = '';\n        // Set mnemonic\n        if (this.options.label && options.enableMnemonics) {\n            const label = this.getAction().label;\n            if (label) {\n                const matches = MENU_MNEMONIC_REGEX.exec(label);\n                if (matches) {\n                    this.mnemonic = (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase();\n                }\n            }\n        }\n        // Add mouse up listener later to avoid accidental clicks\n        this.runOnceToEnableMouseUp = new RunOnceScheduler(() => {\n            if (!this.element) {\n                return;\n            }\n            this._register(addDisposableListener(this.element, EventType.MOUSE_UP, e => {\n                // removed default prevention as it conflicts\n                // with BaseActionViewItem #101537\n                // add back if issues arise and link new issue\n                EventHelper.stop(e, true);\n                // See https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Interact_with_the_clipboard\n                // > Writing to the clipboard\n                // > You can use the \"cut\" and \"copy\" commands without any special\n                // permission if you are using them in a short-lived event handler\n                // for a user action (for example, a click handler).\n                // => to get the Copy and Paste context menu actions working on Firefox,\n                // there should be no timeout here\n                if (isFirefox) {\n                    const mouseEvent = new StandardMouseEvent(e);\n                    // Allowing right click to trigger the event causes the issue described below,\n                    // but since the solution below does not work in FF, we must disable right click\n                    if (mouseEvent.rightButton) {\n                        return;\n                    }\n                    this.onClick(e);\n                }\n                // In all other cases, set timeout to allow context menu cancellation to trigger\n                // otherwise the action will destroy the menu and a second context menu\n                // will still trigger for right click.\n                else {\n                    setTimeout(() => {\n                        this.onClick(e);\n                    }, 0);\n                }\n            }));\n            this._register(addDisposableListener(this.element, EventType.CONTEXT_MENU, e => {\n                EventHelper.stop(e, true);\n            }));\n        }, 100);\n        this._register(this.runOnceToEnableMouseUp);\n    }\n    render(container) {\n        super.render(container);\n        if (!this.element) {\n            return;\n        }\n        this.container = container;\n        this.item = append(this.element, $('a.action-menu-item'));\n        if (this._action.id === Separator.ID) {\n            // A separator is a presentation item\n            this.item.setAttribute('role', 'presentation');\n        }\n        else {\n            this.item.setAttribute('role', 'menuitem');\n            if (this.mnemonic) {\n                this.item.setAttribute('aria-keyshortcuts', `${this.mnemonic}`);\n            }\n        }\n        this.check = append(this.item, $('span.menu-item-check' + Codicon.menuSelection.cssSelector));\n        this.check.setAttribute('role', 'none');\n        this.label = append(this.item, $('span.action-label'));\n        if (this.options.label && this.options.keybinding) {\n            append(this.item, $('span.keybinding')).textContent = this.options.keybinding;\n        }\n        // Adds mouse up listener to actually run the action\n        this.runOnceToEnableMouseUp.schedule();\n        this.updateClass();\n        this.updateLabel();\n        this.updateTooltip();\n        this.updateEnabled();\n        this.updateChecked();\n    }\n    blur() {\n        super.blur();\n        this.applyStyle();\n    }\n    focus() {\n        super.focus();\n        if (this.item) {\n            this.item.focus();\n        }\n        this.applyStyle();\n    }\n    updatePositionInSet(pos, setSize) {\n        if (this.item) {\n            this.item.setAttribute('aria-posinset', `${pos}`);\n            this.item.setAttribute('aria-setsize', `${setSize}`);\n        }\n    }\n    updateLabel() {\n        var _a;\n        if (!this.label) {\n            return;\n        }\n        if (this.options.label) {\n            clearNode(this.label);\n            let label = stripIcons(this.getAction().label);\n            if (label) {\n                const cleanLabel = cleanMnemonic(label);\n                if (!this.options.enableMnemonics) {\n                    label = cleanLabel;\n                }\n                this.label.setAttribute('aria-label', cleanLabel.replace(/&&/g, '&'));\n                const matches = MENU_MNEMONIC_REGEX.exec(label);\n                if (matches) {\n                    label = strings.escape(label);\n                    // This is global, reset it\n                    MENU_ESCAPED_MNEMONIC_REGEX.lastIndex = 0;\n                    let escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);\n                    // We can't use negative lookbehind so if we match our negative and skip\n                    while (escMatch && escMatch[1]) {\n                        escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);\n                    }\n                    const replaceDoubleEscapes = (str) => str.replace(/&amp;&amp;/g, '&amp;');\n                    if (escMatch) {\n                        this.label.append(strings.ltrim(replaceDoubleEscapes(label.substr(0, escMatch.index)), ' '), $('u', { 'aria-hidden': 'true' }, escMatch[3]), strings.rtrim(replaceDoubleEscapes(label.substr(escMatch.index + escMatch[0].length)), ' '));\n                    }\n                    else {\n                        this.label.innerText = replaceDoubleEscapes(label).trim();\n                    }\n                    (_a = this.item) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-keyshortcuts', (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase());\n                }\n                else {\n                    this.label.innerText = label.replace(/&&/g, '&').trim();\n                }\n            }\n        }\n    }\n    updateTooltip() {\n        // menus should function like native menus and they do not have tooltips\n    }\n    updateClass() {\n        if (this.cssClass && this.item) {\n            this.item.classList.remove(...this.cssClass.split(' '));\n        }\n        if (this.options.icon && this.label) {\n            this.cssClass = this.getAction().class || '';\n            this.label.classList.add('icon');\n            if (this.cssClass) {\n                this.label.classList.add(...this.cssClass.split(' '));\n            }\n            this.updateEnabled();\n        }\n        else if (this.label) {\n            this.label.classList.remove('icon');\n        }\n    }\n    updateEnabled() {\n        if (this.getAction().enabled) {\n            if (this.element) {\n                this.element.classList.remove('disabled');\n                this.element.removeAttribute('aria-disabled');\n            }\n            if (this.item) {\n                this.item.classList.remove('disabled');\n                this.item.removeAttribute('aria-disabled');\n                this.item.tabIndex = 0;\n            }\n        }\n        else {\n            if (this.element) {\n                this.element.classList.add('disabled');\n                this.element.setAttribute('aria-disabled', 'true');\n            }\n            if (this.item) {\n                this.item.classList.add('disabled');\n                this.item.setAttribute('aria-disabled', 'true');\n            }\n        }\n    }\n    updateChecked() {\n        if (!this.item) {\n            return;\n        }\n        const checked = this.getAction().checked;\n        this.item.classList.toggle('checked', !!checked);\n        if (checked !== undefined) {\n            this.item.setAttribute('role', 'menuitemcheckbox');\n            this.item.setAttribute('aria-checked', checked ? 'true' : 'false');\n        }\n        else {\n            this.item.setAttribute('role', 'menuitem');\n            this.item.setAttribute('aria-checked', '');\n        }\n    }\n    getMnemonic() {\n        return this.mnemonic;\n    }\n    applyStyle() {\n        if (!this.menuStyle) {\n            return;\n        }\n        const isSelected = this.element && this.element.classList.contains('focused');\n        const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;\n        const bgColor = isSelected && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : undefined;\n        const outline = isSelected && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : '';\n        const outlineOffset = isSelected && this.menuStyle.selectionBorderColor ? `-1px` : '';\n        if (this.item) {\n            this.item.style.color = fgColor ? fgColor.toString() : '';\n            this.item.style.backgroundColor = bgColor ? bgColor.toString() : '';\n            this.item.style.outline = outline;\n            this.item.style.outlineOffset = outlineOffset;\n        }\n        if (this.check) {\n            this.check.style.color = fgColor ? fgColor.toString() : '';\n        }\n    }\n    style(style) {\n        this.menuStyle = style;\n        this.applyStyle();\n    }\n}\nclass SubmenuMenuActionViewItem extends BaseMenuActionViewItem {\n    constructor(action, submenuActions, parentData, submenuOptions) {\n        super(action, action, submenuOptions);\n        this.submenuActions = submenuActions;\n        this.parentData = parentData;\n        this.submenuOptions = submenuOptions;\n        this.mysubmenu = null;\n        this.submenuDisposables = this._register(new DisposableStore());\n        this.mouseOver = false;\n        this.expandDirection = submenuOptions && submenuOptions.expandDirection !== undefined ? submenuOptions.expandDirection : Direction.Right;\n        this.showScheduler = new RunOnceScheduler(() => {\n            if (this.mouseOver) {\n                this.cleanupExistingSubmenu(false);\n                this.createSubmenu(false);\n            }\n        }, 250);\n        this.hideScheduler = new RunOnceScheduler(() => {\n            if (this.element && (!isAncestor(getActiveElement(), this.element) && this.parentData.submenu === this.mysubmenu)) {\n                this.parentData.parent.focus(false);\n                this.cleanupExistingSubmenu(true);\n            }\n        }, 750);\n    }\n    render(container) {\n        super.render(container);\n        if (!this.element) {\n            return;\n        }\n        if (this.item) {\n            this.item.classList.add('monaco-submenu-item');\n            this.item.tabIndex = 0;\n            this.item.setAttribute('aria-haspopup', 'true');\n            this.updateAriaExpanded('false');\n            this.submenuIndicator = append(this.item, $('span.submenu-indicator' + Codicon.menuSubmenu.cssSelector));\n            this.submenuIndicator.setAttribute('aria-hidden', 'true');\n        }\n        this._register(addDisposableListener(this.element, EventType.KEY_UP, e => {\n            const event = new StandardKeyboardEvent(e);\n            if (event.equals(17 /* KeyCode.RightArrow */) || event.equals(3 /* KeyCode.Enter */)) {\n                EventHelper.stop(e, true);\n                this.createSubmenu(true);\n            }\n        }));\n        this._register(addDisposableListener(this.element, EventType.KEY_DOWN, e => {\n            const event = new StandardKeyboardEvent(e);\n            if (getActiveElement() === this.item) {\n                if (event.equals(17 /* KeyCode.RightArrow */) || event.equals(3 /* KeyCode.Enter */)) {\n                    EventHelper.stop(e, true);\n                }\n            }\n        }));\n        this._register(addDisposableListener(this.element, EventType.MOUSE_OVER, e => {\n            if (!this.mouseOver) {\n                this.mouseOver = true;\n                this.showScheduler.schedule();\n            }\n        }));\n        this._register(addDisposableListener(this.element, EventType.MOUSE_LEAVE, e => {\n            this.mouseOver = false;\n        }));\n        this._register(addDisposableListener(this.element, EventType.FOCUS_OUT, e => {\n            if (this.element && !isAncestor(getActiveElement(), this.element)) {\n                this.hideScheduler.schedule();\n            }\n        }));\n        this._register(this.parentData.parent.onScroll(() => {\n            if (this.parentData.submenu === this.mysubmenu) {\n                this.parentData.parent.focus(false);\n                this.cleanupExistingSubmenu(true);\n            }\n        }));\n    }\n    updateEnabled() {\n        // override on submenu entry\n        // native menus do not observe enablement on sumbenus\n        // we mimic that behavior\n    }\n    onClick(e) {\n        // stop clicking from trying to run an action\n        EventHelper.stop(e, true);\n        this.cleanupExistingSubmenu(false);\n        this.createSubmenu(true);\n    }\n    cleanupExistingSubmenu(force) {\n        if (this.parentData.submenu && (force || (this.parentData.submenu !== this.mysubmenu))) {\n            // disposal may throw if the submenu has already been removed\n            try {\n                this.parentData.submenu.dispose();\n            }\n            catch (_a) { }\n            this.parentData.submenu = undefined;\n            this.updateAriaExpanded('false');\n            if (this.submenuContainer) {\n                this.submenuDisposables.clear();\n                this.submenuContainer = undefined;\n            }\n        }\n    }\n    calculateSubmenuMenuLayout(windowDimensions, submenu, entry, expandDirection) {\n        const ret = { top: 0, left: 0 };\n        // Start with horizontal\n        ret.left = layout(windowDimensions.width, submenu.width, { position: expandDirection === Direction.Right ? 0 /* LayoutAnchorPosition.Before */ : 1 /* LayoutAnchorPosition.After */, offset: entry.left, size: entry.width });\n        // We don't have enough room to layout the menu fully, so we are overlapping the menu\n        if (ret.left >= entry.left && ret.left < entry.left + entry.width) {\n            if (entry.left + 10 + submenu.width <= windowDimensions.width) {\n                ret.left = entry.left + 10;\n            }\n            entry.top += 10;\n            entry.height = 0;\n        }\n        // Now that we have a horizontal position, try layout vertically\n        ret.top = layout(windowDimensions.height, submenu.height, { position: 0 /* LayoutAnchorPosition.Before */, offset: entry.top, size: 0 });\n        // We didn't have enough room below, but we did above, so we shift down to align the menu\n        if (ret.top + submenu.height === entry.top && ret.top + entry.height + submenu.height <= windowDimensions.height) {\n            ret.top += entry.height;\n        }\n        return ret;\n    }\n    createSubmenu(selectFirstItem = true) {\n        if (!this.element) {\n            return;\n        }\n        if (!this.parentData.submenu) {\n            this.updateAriaExpanded('true');\n            this.submenuContainer = append(this.element, $('div.monaco-submenu'));\n            this.submenuContainer.classList.add('menubar-menu-items-holder', 'context-view');\n            // Set the top value of the menu container before construction\n            // This allows the menu constructor to calculate the proper max height\n            const computedStyles = getComputedStyle(this.parentData.parent.domNode);\n            const paddingTop = parseFloat(computedStyles.paddingTop || '0') || 0;\n            // this.submenuContainer.style.top = `${this.element.offsetTop - this.parentData.parent.scrollOffset - paddingTop}px`;\n            this.submenuContainer.style.zIndex = '1';\n            this.submenuContainer.style.position = 'fixed';\n            this.submenuContainer.style.top = '0';\n            this.submenuContainer.style.left = '0';\n            this.parentData.submenu = new Menu(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new EmptySubmenuAction()], this.submenuOptions);\n            if (this.menuStyle) {\n                this.parentData.submenu.style(this.menuStyle);\n            }\n            // layout submenu\n            const entryBox = this.element.getBoundingClientRect();\n            const entryBoxUpdated = {\n                top: entryBox.top - paddingTop,\n                left: entryBox.left,\n                height: entryBox.height + 2 * paddingTop,\n                width: entryBox.width\n            };\n            const viewBox = this.submenuContainer.getBoundingClientRect();\n            const { top, left } = this.calculateSubmenuMenuLayout(new Dimension(window.innerWidth, window.innerHeight), Dimension.lift(viewBox), entryBoxUpdated, this.expandDirection);\n            // subtract offsets caused by transform parent\n            this.submenuContainer.style.left = `${left - viewBox.left}px`;\n            this.submenuContainer.style.top = `${top - viewBox.top}px`;\n            this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_UP, e => {\n                const event = new StandardKeyboardEvent(e);\n                if (event.equals(15 /* KeyCode.LeftArrow */)) {\n                    EventHelper.stop(e, true);\n                    this.parentData.parent.focus();\n                    this.cleanupExistingSubmenu(true);\n                }\n            }));\n            this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_DOWN, e => {\n                const event = new StandardKeyboardEvent(e);\n                if (event.equals(15 /* KeyCode.LeftArrow */)) {\n                    EventHelper.stop(e, true);\n                }\n            }));\n            this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {\n                this.parentData.parent.focus();\n                this.cleanupExistingSubmenu(true);\n            }));\n            this.parentData.submenu.focus(selectFirstItem);\n            this.mysubmenu = this.parentData.submenu;\n        }\n        else {\n            this.parentData.submenu.focus(false);\n        }\n    }\n    updateAriaExpanded(value) {\n        var _a;\n        if (this.item) {\n            (_a = this.item) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-expanded', value);\n        }\n    }\n    applyStyle() {\n        var _a;\n        super.applyStyle();\n        if (!this.menuStyle) {\n            return;\n        }\n        const isSelected = this.element && this.element.classList.contains('focused');\n        const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;\n        if (this.submenuIndicator) {\n            this.submenuIndicator.style.color = fgColor ? `${fgColor}` : '';\n        }\n        (_a = this.parentData.submenu) === null || _a === void 0 ? void 0 : _a.style(this.menuStyle);\n    }\n    dispose() {\n        super.dispose();\n        this.hideScheduler.dispose();\n        if (this.mysubmenu) {\n            this.mysubmenu.dispose();\n            this.mysubmenu = null;\n        }\n        if (this.submenuContainer) {\n            this.submenuContainer = undefined;\n        }\n    }\n}\nclass MenuSeparatorActionViewItem extends ActionViewItem {\n    style(style) {\n        if (this.label) {\n            this.label.style.borderBottomColor = style.separatorColor ? `${style.separatorColor}` : '';\n        }\n    }\n}\nexport function cleanMnemonic(label) {\n    const regex = MENU_MNEMONIC_REGEX;\n    const matches = regex.exec(label);\n    if (!matches) {\n        return label;\n    }\n    const mnemonicInText = !matches[1];\n    return label.replace(regex, mnemonicInText ? '$2$3' : '').trim();\n}\nfunction getMenuWidgetCSS(style, isForShadowDom) {\n    let result = /* css */ `\n.monaco-menu {\n\tfont-size: 13px;\n\tborder-radius: 5px;\n\tmin-width: 160px;\n}\n\n${formatRule(Codicon.menuSelection)}\n${formatRule(Codicon.menuSubmenu)}\n\n.monaco-menu .monaco-action-bar {\n\ttext-align: right;\n\toverflow: hidden;\n\twhite-space: nowrap;\n}\n\n.monaco-menu .monaco-action-bar .actions-container {\n\tdisplay: flex;\n\tmargin: 0 auto;\n\tpadding: 0;\n\twidth: 100%;\n\tjustify-content: flex-end;\n}\n\n.monaco-menu .monaco-action-bar.vertical .actions-container {\n\tdisplay: inline-block;\n}\n\n.monaco-menu .monaco-action-bar.reverse .actions-container {\n\tflex-direction: row-reverse;\n}\n\n.monaco-menu .monaco-action-bar .action-item {\n\tcursor: pointer;\n\tdisplay: inline-block;\n\ttransition: transform 50ms ease;\n\tposition: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */\n}\n\n.monaco-menu .monaco-action-bar .action-item.disabled {\n\tcursor: default;\n}\n\n.monaco-menu .monaco-action-bar.animated .action-item.active {\n\ttransform: scale(1.272019649, 1.272019649); /* 1.272019649 = √φ */\n}\n\n.monaco-menu .monaco-action-bar .action-item .icon,\n.monaco-menu .monaco-action-bar .action-item .codicon {\n\tdisplay: inline-block;\n}\n\n.monaco-menu .monaco-action-bar .action-item .codicon {\n\tdisplay: flex;\n\talign-items: center;\n}\n\n.monaco-menu .monaco-action-bar .action-label {\n\tfont-size: 11px;\n\tmargin-right: 4px;\n}\n\n.monaco-menu .monaco-action-bar .action-item.disabled .action-label,\n.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {\n\tcolor: var(--vscode-disabledForeground);\n}\n\n/* Vertical actions */\n\n.monaco-menu .monaco-action-bar.vertical {\n\ttext-align: left;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tdisplay: block;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tdisplay: block;\n\tborder-bottom: 1px solid var(--vscode-menu-separatorBackground);\n\tpadding-top: 1px;\n\tpadding: 30px;\n}\n\n.monaco-menu .secondary-actions .monaco-action-bar .action-label {\n\tmargin-left: 6px;\n}\n\n/* Action Items */\n.monaco-menu .monaco-action-bar .action-item.select-container {\n\toverflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */\n\tflex: 1;\n\tmax-width: 170px;\n\tmin-width: 60px;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tmargin-right: 10px;\n}\n\n.monaco-menu .monaco-action-bar.vertical {\n\tmargin-left: 0;\n\toverflow: visible;\n}\n\n.monaco-menu .monaco-action-bar.vertical .actions-container {\n\tdisplay: block;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tpadding: 0;\n\ttransform: none;\n\tdisplay: flex;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item.active {\n\ttransform: none;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item {\n\tflex: 1 1 auto;\n\tdisplay: flex;\n\theight: 2em;\n\talign-items: center;\n\tposition: relative;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item:hover .keybinding,\n.monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .keybinding {\n\topacity: unset;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label {\n\tflex: 1 1 auto;\n\ttext-decoration: none;\n\tpadding: 0 1em;\n\tbackground: none;\n\tfont-size: 12px;\n\tline-height: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .keybinding,\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\tdisplay: inline-block;\n\tflex: 2 1 auto;\n\tpadding: 0 1em;\n\ttext-align: right;\n\tfont-size: 12px;\n\tline-height: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\theight: 100%;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {\n\tfont-size: 16px !important;\n\tdisplay: flex;\n\talign-items: center;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {\n\tmargin-left: auto;\n\tmargin-right: -20px;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,\n.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {\n\topacity: 0.4;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tmargin: 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tposition: static;\n\toverflow: visible;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {\n\tposition: absolute;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\twidth: 100%;\n\theight: 0px !important;\n\topacity: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {\n\tpadding: 0.7em 1em 0.1em 1em;\n\tfont-weight: bold;\n\topacity: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:hover {\n\tcolor: inherit;\n}\n\n.monaco-menu .monaco-action-bar.vertical .menu-item-check {\n\tposition: absolute;\n\tvisibility: hidden;\n\twidth: 1em;\n\theight: 100%;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {\n\tvisibility: visible;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Context Menu */\n\n.context-view.monaco-menu-container {\n\toutline: 0;\n\tborder: none;\n\tanimation: fadeIn 0.083s linear;\n\t-webkit-app-region: no-drag;\n}\n\n.context-view.monaco-menu-container :focus,\n.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,\n.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {\n\toutline: 0;\n}\n\n.hc-black .context-view.monaco-menu-container,\n.hc-light .context-view.monaco-menu-container,\n:host-context(.hc-black) .context-view.monaco-menu-container,\n:host-context(.hc-light) .context-view.monaco-menu-container {\n\tbox-shadow: none;\n}\n\n.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused,\n.hc-light .monaco-menu .monaco-action-bar.vertical .action-item.focused,\n:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused,\n:host-context(.hc-light) .monaco-menu .monaco-action-bar.vertical .action-item.focused {\n\tbackground: none;\n}\n\n/* Vertical Action Bar Styles */\n\n.monaco-menu .monaco-action-bar.vertical {\n\tpadding: .6em 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item {\n\theight: 2em;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),\n.monaco-menu .monaco-action-bar.vertical .keybinding {\n\tfont-size: inherit;\n\tpadding: 0 2em;\n}\n\n.monaco-menu .monaco-action-bar.vertical .menu-item-check {\n\tfont-size: inherit;\n\twidth: 2em;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tfont-size: inherit;\n\tmargin: 5px 0 !important;\n\tpadding: 0;\n\tborder-radius: 0;\n}\n\n.linux .monaco-menu .monaco-action-bar.vertical .action-label.separator,\n:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tmargin-left: 0;\n\tmargin-right: 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\tfont-size: 60%;\n\tpadding: 0 1.8em;\n}\n\n.linux .monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\theight: 100%;\n\tmask-size: 10px 10px;\n\t-webkit-mask-size: 10px 10px;\n}\n\n.monaco-menu .action-item {\n\tcursor: default;\n}`;\n    if (isForShadowDom) {\n        // Only define scrollbar styles when used inside shadow dom,\n        // otherwise leave their styling to the global workbench styling.\n        result += `\n\t\t\t/* Arrows */\n\t\t\t.monaco-scrollable-element > .scrollbar > .scra {\n\t\t\t\tcursor: pointer;\n\t\t\t\tfont-size: 11px !important;\n\t\t\t}\n\n\t\t\t.monaco-scrollable-element > .visible {\n\t\t\t\topacity: 1;\n\n\t\t\t\t/* Background rule added for IE9 - to allow clicks on dom node */\n\t\t\t\tbackground:rgba(0,0,0,0);\n\n\t\t\t\ttransition: opacity 100ms linear;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .invisible {\n\t\t\t\topacity: 0;\n\t\t\t\tpointer-events: none;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .invisible.fade {\n\t\t\t\ttransition: opacity 800ms linear;\n\t\t\t}\n\n\t\t\t/* Scrollable Content Inset Shadow */\n\t\t\t.monaco-scrollable-element > .shadow {\n\t\t\t\tposition: absolute;\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .shadow.top {\n\t\t\t\tdisplay: block;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 3px;\n\t\t\t\theight: 3px;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .shadow.left {\n\t\t\t\tdisplay: block;\n\t\t\t\ttop: 3px;\n\t\t\t\tleft: 0;\n\t\t\t\theight: 100%;\n\t\t\t\twidth: 3px;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .shadow.top-left-corner {\n\t\t\t\tdisplay: block;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 0;\n\t\t\t\theight: 3px;\n\t\t\t\twidth: 3px;\n\t\t\t}\n\t\t`;\n        // Scrollbars\n        const scrollbarShadowColor = style.scrollbarShadow;\n        if (scrollbarShadowColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .shadow.top {\n\t\t\t\t\tbox-shadow: ${scrollbarShadowColor} 0 6px 6px -6px inset;\n\t\t\t\t}\n\n\t\t\t\t.monaco-scrollable-element > .shadow.left {\n\t\t\t\t\tbox-shadow: ${scrollbarShadowColor} 6px 0 6px -6px inset;\n\t\t\t\t}\n\n\t\t\t\t.monaco-scrollable-element > .shadow.top.left {\n\t\t\t\t\tbox-shadow: ${scrollbarShadowColor} 6px 6px 6px -6px inset;\n\t\t\t\t}\n\t\t\t`;\n        }\n        const scrollbarSliderBackgroundColor = style.scrollbarSliderBackground;\n        if (scrollbarSliderBackgroundColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .scrollbar > .slider {\n\t\t\t\t\tbackground: ${scrollbarSliderBackgroundColor};\n\t\t\t\t}\n\t\t\t`;\n        }\n        const scrollbarSliderHoverBackgroundColor = style.scrollbarSliderHoverBackground;\n        if (scrollbarSliderHoverBackgroundColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .scrollbar > .slider:hover {\n\t\t\t\t\tbackground: ${scrollbarSliderHoverBackgroundColor};\n\t\t\t\t}\n\t\t\t`;\n        }\n        const scrollbarSliderActiveBackgroundColor = style.scrollbarSliderActiveBackground;\n        if (scrollbarSliderActiveBackgroundColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .scrollbar > .slider.active {\n\t\t\t\t\tbackground: ${scrollbarSliderActiveBackgroundColor};\n\t\t\t\t}\n\t\t\t`;\n        }\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { activeContrastBorder, badgeBackground, badgeForeground, contrastBorder, inputActiveOptionBackground, inputActiveOptionBorder, inputActiveOptionForeground, inputBackground, inputBorder, inputForeground, inputValidationErrorBackground, inputValidationErrorBorder, inputValidationErrorForeground, inputValidationInfoBackground, inputValidationInfoBorder, inputValidationInfoForeground, inputValidationWarningBackground, inputValidationWarningBorder, inputValidationWarningForeground, listActiveSelectionBackground, listActiveSelectionForeground, listActiveSelectionIconForeground, listDropBackground, listFilterWidgetBackground, listFilterWidgetNoMatchesOutline, listFilterWidgetOutline, listFocusBackground, listFocusForeground, listFocusOutline, listHoverBackground, listHoverForeground, listInactiveFocusBackground, listInactiveFocusOutline, listInactiveSelectionBackground, listInactiveSelectionForeground, listInactiveSelectionIconForeground, menuBackground, menuBorder, menuForeground, menuSelectionBackground, menuSelectionBorder, menuSelectionForeground, menuSeparatorBackground, resolveColorValue, scrollbarShadow, scrollbarSliderActiveBackground, scrollbarSliderBackground, scrollbarSliderHoverBackground, tableColumnsBorder, tableOddRowsBackgroundColor, treeIndentGuidesStroke, widgetShadow, listFocusAndSelectionOutline, listFilterWidgetShadow } from './colorRegistry.js';\nexport function computeStyles(theme, styleMap) {\n    const styles = Object.create(null);\n    for (const key in styleMap) {\n        const value = styleMap[key];\n        if (value) {\n            styles[key] = resolveColorValue(value, theme);\n        }\n    }\n    return styles;\n}\nexport function attachStyler(themeService, styleMap, widgetOrCallback) {\n    function applyStyles() {\n        const styles = computeStyles(themeService.getColorTheme(), styleMap);\n        if (typeof widgetOrCallback === 'function') {\n            widgetOrCallback(styles);\n        }\n        else {\n            widgetOrCallback.style(styles);\n        }\n    }\n    applyStyles();\n    return themeService.onDidColorThemeChange(applyStyles);\n}\nexport function attachBadgeStyler(widget, themeService, style) {\n    return attachStyler(themeService, {\n        badgeBackground: (style === null || style === void 0 ? void 0 : style.badgeBackground) || badgeBackground,\n        badgeForeground: (style === null || style === void 0 ? void 0 : style.badgeForeground) || badgeForeground,\n        badgeBorder: contrastBorder\n    }, widget);\n}\nexport function attachListStyler(widget, themeService, overrides) {\n    return attachStyler(themeService, Object.assign(Object.assign({}, defaultListStyles), (overrides || {})), widget);\n}\nexport const defaultListStyles = {\n    listFocusBackground,\n    listFocusForeground,\n    listFocusOutline,\n    listActiveSelectionBackground,\n    listActiveSelectionForeground,\n    listActiveSelectionIconForeground,\n    listFocusAndSelectionOutline,\n    listFocusAndSelectionBackground: listActiveSelectionBackground,\n    listFocusAndSelectionForeground: listActiveSelectionForeground,\n    listInactiveSelectionBackground,\n    listInactiveSelectionIconForeground,\n    listInactiveSelectionForeground,\n    listInactiveFocusBackground,\n    listInactiveFocusOutline,\n    listHoverBackground,\n    listHoverForeground,\n    listDropBackground,\n    listSelectionOutline: activeContrastBorder,\n    listHoverOutline: activeContrastBorder,\n    listFilterWidgetBackground,\n    listFilterWidgetOutline,\n    listFilterWidgetNoMatchesOutline,\n    listFilterWidgetShadow,\n    treeIndentGuidesStroke,\n    tableColumnsBorder,\n    tableOddRowsBackgroundColor,\n    inputActiveOptionBorder,\n    inputActiveOptionForeground,\n    inputActiveOptionBackground,\n    inputBackground,\n    inputForeground,\n    inputBorder,\n    inputValidationInfoBackground,\n    inputValidationInfoForeground,\n    inputValidationInfoBorder,\n    inputValidationWarningBackground,\n    inputValidationWarningForeground,\n    inputValidationWarningBorder,\n    inputValidationErrorBackground,\n    inputValidationErrorForeground,\n    inputValidationErrorBorder,\n};\nexport const defaultMenuStyles = {\n    shadowColor: widgetShadow,\n    borderColor: menuBorder,\n    foregroundColor: menuForeground,\n    backgroundColor: menuBackground,\n    selectionForegroundColor: menuSelectionForeground,\n    selectionBackgroundColor: menuSelectionBackground,\n    selectionBorderColor: menuSelectionBorder,\n    separatorColor: menuSeparatorBackground,\n    scrollbarShadow: scrollbarShadow,\n    scrollbarSliderBackground: scrollbarSliderBackground,\n    scrollbarSliderHoverBackground: scrollbarSliderHoverBackground,\n    scrollbarSliderActiveBackground: scrollbarSliderActiveBackground\n};\nexport function attachMenuStyler(widget, themeService, style) {\n    return attachStyler(themeService, Object.assign(Object.assign({}, defaultMenuStyles), style), widget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, dispose } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as errors from '../../../base/common/errors.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { IModelService } from './model.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { SemanticTokensProviderStyling, toMultilineTokens2 } from './semanticTokensProviderStyling.js';\nimport { getDocumentSemanticTokens, hasDocumentSemanticTokensProvider, isSemanticTokens, isSemanticTokensEdits } from './getSemanticTokens.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { ILanguageFeatureDebounceService } from './languageFeatureDebounce.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { ILanguageFeaturesService } from './languageFeatures.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nfunction computeModelSha1(model) {\n    // compute the sha1\n    const shaComputer = new StringSHA1();\n    const snapshot = model.createSnapshot();\n    let text;\n    while ((text = snapshot.read())) {\n        shaComputer.update(text);\n    }\n    return shaComputer.digest();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._languageSelection = null;\n        this._languageSelectionListener = null;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    _disposeLanguageSelection() {\n        if (this._languageSelectionListener) {\n            this._languageSelectionListener.dispose();\n            this._languageSelectionListener = null;\n        }\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n        this._disposeLanguageSelection();\n    }\n    setLanguage(languageSelection) {\n        this._disposeLanguageSelection();\n        this._languageSelection = languageSelection;\n        this._languageSelectionListener = this._languageSelection.onDidChange(() => this.model.setMode(languageSelection.languageId));\n        this.model.setMode(languageSelection.languageId);\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    constructor(_configurationService, _resourcePropertiesService, _themeService, _logService, _undoRedoService, _languageService, _languageConfigurationService, _languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._themeService = _themeService;\n        this._logService = _logService;\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._languageFeatureDebounceService = _languageFeatureDebounceService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._semanticStyling = this._register(new SemanticStyling(this._themeService, this._languageService, this._logService));\n        this._register(this._configurationService.onDidChangeConfiguration(() => this._updateModelOptions()));\n        this._updateModelOptions();\n        this._register(new SemanticColoringFeature(this._semanticStyling, this, this._themeService, this._configurationService, this._languageFeatureDebounceService, languageFeaturesService));\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        var _a;\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = tabSize;\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = parsedIndentSize;\n            }\n            if (indentSize < 1) {\n                indentSize = 1;\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (((_a = config.editor) === null || _a === void 0 ? void 0 : _a.bracketPairColorization) && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled,\n                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* platform.OperatingSystem.Linux */ || platform.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(language, resource, isForSimpleWidget) {\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions() {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageId, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageId, resource, isForSimpleWidget);\n        const model = new TextModel(value, languageId, options, resource, this._undoRedoService, this._languageService, this._languageConfigurationService);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1IsEqual = (computeModelSha1(model) === disposedModelData.sha1);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection.languageId, resource, isForSimpleWidget);\n            this.setMode(modelData.model, languageSelection);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    setMode(model, languageSelection) {\n        if (!languageSelection) {\n            return;\n        }\n        const modelData = this._models[MODEL_ID(model.uri)];\n        if (!modelData) {\n            return;\n        }\n        modelData.setLanguage(languageSelection);\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    getSemanticTokensProviderStyling(provider) {\n        return this._semanticStyling.get(provider);\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.vscodeUserData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && heapSize > maxMemory) {\n            // the undo stack for this file would never fit in the configured memory, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, computeModelSha1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n};\nModelService.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;\nModelService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IThemeService),\n    __param(3, ILogService),\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, ILanguageFeatureDebounceService),\n    __param(8, ILanguageFeaturesService)\n], ModelService);\nexport { ModelService };\nexport const SEMANTIC_HIGHLIGHTING_SETTING_ID = 'editor.semanticHighlighting';\nexport function isSemanticColoringEnabled(model, themeService, configurationService) {\n    var _a;\n    const setting = (_a = configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, { overrideIdentifier: model.getLanguageId(), resource: model.uri })) === null || _a === void 0 ? void 0 : _a.enabled;\n    if (typeof setting === 'boolean') {\n        return setting;\n    }\n    return themeService.getColorTheme().semanticHighlighting;\n}\nlet SemanticColoringFeature = class SemanticColoringFeature extends Disposable {\n    constructor(semanticStyling, modelService, themeService, configurationService, languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this._watchers = Object.create(null);\n        this._semanticStyling = semanticStyling;\n        const register = (model) => {\n            this._watchers[model.uri.toString()] = new ModelSemanticColoring(model, this._semanticStyling, themeService, languageFeatureDebounceService, languageFeaturesService);\n        };\n        const deregister = (model, modelSemanticColoring) => {\n            modelSemanticColoring.dispose();\n            delete this._watchers[model.uri.toString()];\n        };\n        const handleSettingOrThemeChange = () => {\n            for (const model of modelService.getModels()) {\n                const curr = this._watchers[model.uri.toString()];\n                if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n                    if (!curr) {\n                        register(model);\n                    }\n                }\n                else {\n                    if (curr) {\n                        deregister(model, curr);\n                    }\n                }\n            }\n        };\n        this._register(modelService.onModelAdded((model) => {\n            if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n                register(model);\n            }\n        }));\n        this._register(modelService.onModelRemoved((model) => {\n            const curr = this._watchers[model.uri.toString()];\n            if (curr) {\n                deregister(model, curr);\n            }\n        }));\n        this._register(configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {\n                handleSettingOrThemeChange();\n            }\n        }));\n        this._register(themeService.onDidColorThemeChange(handleSettingOrThemeChange));\n    }\n    dispose() {\n        // Dispose all watchers\n        for (const watcher of Object.values(this._watchers)) {\n            watcher.dispose();\n        }\n        super.dispose();\n    }\n};\nSemanticColoringFeature = __decorate([\n    __param(1, IModelService),\n    __param(2, IThemeService),\n    __param(3, IConfigurationService),\n    __param(4, ILanguageFeatureDebounceService),\n    __param(5, ILanguageFeaturesService)\n], SemanticColoringFeature);\nclass SemanticStyling extends Disposable {\n    constructor(_themeService, _languageService, _logService) {\n        super();\n        this._themeService = _themeService;\n        this._languageService = _languageService;\n        this._logService = _logService;\n        this._caches = new WeakMap();\n        this._register(this._themeService.onDidColorThemeChange(() => {\n            this._caches = new WeakMap();\n        }));\n    }\n    get(provider) {\n        if (!this._caches.has(provider)) {\n            this._caches.set(provider, new SemanticTokensProviderStyling(provider.getLegend(), this._themeService, this._languageService, this._logService));\n        }\n        return this._caches.get(provider);\n    }\n}\nclass SemanticTokensResponse {\n    constructor(provider, resultId, data) {\n        this.provider = provider;\n        this.resultId = resultId;\n        this.data = data;\n    }\n    dispose() {\n        this.provider.releaseDocumentSemanticTokens(this.resultId);\n    }\n}\nlet ModelSemanticColoring = class ModelSemanticColoring extends Disposable {\n    constructor(model, stylingProvider, themeService, languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this._isDisposed = false;\n        this._model = model;\n        this._semanticStyling = stylingProvider;\n        this._provider = languageFeaturesService.documentSemanticTokensProvider;\n        this._debounceInformation = languageFeatureDebounceService.for(this._provider, 'DocumentSemanticTokens', { min: ModelSemanticColoring.REQUEST_MIN_DELAY, max: ModelSemanticColoring.REQUEST_MAX_DELAY });\n        this._fetchDocumentSemanticTokens = this._register(new RunOnceScheduler(() => this._fetchDocumentSemanticTokensNow(), ModelSemanticColoring.REQUEST_MIN_DELAY));\n        this._currentDocumentResponse = null;\n        this._currentDocumentRequestCancellationTokenSource = null;\n        this._documentProvidersChangeListeners = [];\n        this._register(this._model.onDidChangeContent(() => {\n            if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n                this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n            }\n        }));\n        this._register(this._model.onDidChangeLanguage(() => {\n            // clear any outstanding state\n            if (this._currentDocumentResponse) {\n                this._currentDocumentResponse.dispose();\n                this._currentDocumentResponse = null;\n            }\n            if (this._currentDocumentRequestCancellationTokenSource) {\n                this._currentDocumentRequestCancellationTokenSource.cancel();\n                this._currentDocumentRequestCancellationTokenSource = null;\n            }\n            this._setDocumentSemanticTokens(null, null, null, []);\n            this._fetchDocumentSemanticTokens.schedule(0);\n        }));\n        const bindDocumentChangeListeners = () => {\n            dispose(this._documentProvidersChangeListeners);\n            this._documentProvidersChangeListeners = [];\n            for (const provider of this._provider.all(model)) {\n                if (typeof provider.onDidChange === 'function') {\n                    this._documentProvidersChangeListeners.push(provider.onDidChange(() => this._fetchDocumentSemanticTokens.schedule(0)));\n                }\n            }\n        };\n        bindDocumentChangeListeners();\n        this._register(this._provider.onDidChange(() => {\n            bindDocumentChangeListeners();\n            this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n        }));\n        this._register(themeService.onDidColorThemeChange(_ => {\n            // clear out existing tokens\n            this._setDocumentSemanticTokens(null, null, null, []);\n            this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n        }));\n        this._fetchDocumentSemanticTokens.schedule(0);\n    }\n    dispose() {\n        if (this._currentDocumentResponse) {\n            this._currentDocumentResponse.dispose();\n            this._currentDocumentResponse = null;\n        }\n        if (this._currentDocumentRequestCancellationTokenSource) {\n            this._currentDocumentRequestCancellationTokenSource.cancel();\n            this._currentDocumentRequestCancellationTokenSource = null;\n        }\n        this._setDocumentSemanticTokens(null, null, null, []);\n        this._isDisposed = true;\n        super.dispose();\n    }\n    _fetchDocumentSemanticTokensNow() {\n        if (this._currentDocumentRequestCancellationTokenSource) {\n            // there is already a request running, let it finish...\n            return;\n        }\n        if (!hasDocumentSemanticTokensProvider(this._provider, this._model)) {\n            // there is no provider\n            if (this._currentDocumentResponse) {\n                // there are semantic tokens set\n                this._model.tokenization.setSemanticTokens(null, false);\n            }\n            return;\n        }\n        const cancellationTokenSource = new CancellationTokenSource();\n        const lastProvider = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null;\n        const lastResultId = this._currentDocumentResponse ? this._currentDocumentResponse.resultId || null : null;\n        const request = getDocumentSemanticTokens(this._provider, this._model, lastProvider, lastResultId, cancellationTokenSource.token);\n        this._currentDocumentRequestCancellationTokenSource = cancellationTokenSource;\n        const pendingChanges = [];\n        const contentChangeListener = this._model.onDidChangeContent((e) => {\n            pendingChanges.push(e);\n        });\n        const sw = new StopWatch(false);\n        request.then((res) => {\n            this._debounceInformation.update(this._model, sw.elapsed());\n            this._currentDocumentRequestCancellationTokenSource = null;\n            contentChangeListener.dispose();\n            if (!res) {\n                this._setDocumentSemanticTokens(null, null, null, pendingChanges);\n            }\n            else {\n                const { provider, tokens } = res;\n                const styling = this._semanticStyling.get(provider);\n                this._setDocumentSemanticTokens(provider, tokens || null, styling, pendingChanges);\n            }\n        }, (err) => {\n            const isExpectedError = err && (errors.isCancellationError(err) || (typeof err.message === 'string' && err.message.indexOf('busy') !== -1));\n            if (!isExpectedError) {\n                errors.onUnexpectedError(err);\n            }\n            // Semantic tokens eats up all errors and considers errors to mean that the result is temporarily not available\n            // The API does not have a special error kind to express this...\n            this._currentDocumentRequestCancellationTokenSource = null;\n            contentChangeListener.dispose();\n            if (pendingChanges.length > 0) {\n                // More changes occurred while the request was running\n                if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n                    this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n                }\n            }\n        });\n    }\n    static _copy(src, srcOffset, dest, destOffset, length) {\n        // protect against overflows\n        length = Math.min(length, dest.length - destOffset, src.length - srcOffset);\n        for (let i = 0; i < length; i++) {\n            dest[destOffset + i] = src[srcOffset + i];\n        }\n    }\n    _setDocumentSemanticTokens(provider, tokens, styling, pendingChanges) {\n        const currentResponse = this._currentDocumentResponse;\n        const rescheduleIfNeeded = () => {\n            if (pendingChanges.length > 0 && !this._fetchDocumentSemanticTokens.isScheduled()) {\n                this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n            }\n        };\n        if (this._currentDocumentResponse) {\n            this._currentDocumentResponse.dispose();\n            this._currentDocumentResponse = null;\n        }\n        if (this._isDisposed) {\n            // disposed!\n            if (provider && tokens) {\n                provider.releaseDocumentSemanticTokens(tokens.resultId);\n            }\n            return;\n        }\n        if (!provider || !styling) {\n            this._model.tokenization.setSemanticTokens(null, false);\n            return;\n        }\n        if (!tokens) {\n            this._model.tokenization.setSemanticTokens(null, true);\n            rescheduleIfNeeded();\n            return;\n        }\n        if (isSemanticTokensEdits(tokens)) {\n            if (!currentResponse) {\n                // not possible!\n                this._model.tokenization.setSemanticTokens(null, true);\n                return;\n            }\n            if (tokens.edits.length === 0) {\n                // nothing to do!\n                tokens = {\n                    resultId: tokens.resultId,\n                    data: currentResponse.data\n                };\n            }\n            else {\n                let deltaLength = 0;\n                for (const edit of tokens.edits) {\n                    deltaLength += (edit.data ? edit.data.length : 0) - edit.deleteCount;\n                }\n                const srcData = currentResponse.data;\n                const destData = new Uint32Array(srcData.length + deltaLength);\n                let srcLastStart = srcData.length;\n                let destLastStart = destData.length;\n                for (let i = tokens.edits.length - 1; i >= 0; i--) {\n                    const edit = tokens.edits[i];\n                    if (edit.start > srcData.length) {\n                        styling.warnInvalidEditStart(currentResponse.resultId, tokens.resultId, i, edit.start, srcData.length);\n                        // The edits are invalid and there's no way to recover\n                        this._model.tokenization.setSemanticTokens(null, true);\n                        return;\n                    }\n                    const copyCount = srcLastStart - (edit.start + edit.deleteCount);\n                    if (copyCount > 0) {\n                        ModelSemanticColoring._copy(srcData, srcLastStart - copyCount, destData, destLastStart - copyCount, copyCount);\n                        destLastStart -= copyCount;\n                    }\n                    if (edit.data) {\n                        ModelSemanticColoring._copy(edit.data, 0, destData, destLastStart - edit.data.length, edit.data.length);\n                        destLastStart -= edit.data.length;\n                    }\n                    srcLastStart = edit.start;\n                }\n                if (srcLastStart > 0) {\n                    ModelSemanticColoring._copy(srcData, 0, destData, 0, srcLastStart);\n                }\n                tokens = {\n                    resultId: tokens.resultId,\n                    data: destData\n                };\n            }\n        }\n        if (isSemanticTokens(tokens)) {\n            this._currentDocumentResponse = new SemanticTokensResponse(provider, tokens.resultId, tokens.data);\n            const result = toMultilineTokens2(tokens, styling, this._model.getLanguageId());\n            // Adjust incoming semantic tokens\n            if (pendingChanges.length > 0) {\n                // More changes occurred while the request was running\n                // We need to:\n                // 1. Adjust incoming semantic tokens\n                // 2. Request them again\n                for (const change of pendingChanges) {\n                    for (const area of result) {\n                        for (const singleChange of change.changes) {\n                            area.applyEdit(singleChange.range, singleChange.text);\n                        }\n                    }\n                }\n            }\n            this._model.tokenization.setSemanticTokens(result, true);\n        }\n        else {\n            this._model.tokenization.setSemanticTokens(null, true);\n        }\n        rescheduleIfNeeded();\n    }\n};\nModelSemanticColoring.REQUEST_MIN_DELAY = 300;\nModelSemanticColoring.REQUEST_MAX_DELAY = 2000;\nModelSemanticColoring = __decorate([\n    __param(2, IThemeService),\n    __param(3, ILanguageFeatureDebounceService),\n    __param(4, ILanguageFeaturesService)\n], ModelSemanticColoring);\nexport { ModelSemanticColoring };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as DOM from './dom.js';\nexport function renderText(text, options = {}) {\n    const element = createElement(options);\n    element.textContent = text;\n    return element;\n}\nexport function renderFormattedText(formattedText, options = {}) {\n    const element = createElement(options);\n    _renderFormattedText(element, parseFormattedText(formattedText, !!options.renderCodeSegments), options.actionHandler, options.renderCodeSegments);\n    return element;\n}\nexport function createElement(options) {\n    const tagName = options.inline ? 'span' : 'div';\n    const element = document.createElement(tagName);\n    if (options.className) {\n        element.className = options.className;\n    }\n    return element;\n}\nclass StringStream {\n    constructor(source) {\n        this.source = source;\n        this.index = 0;\n    }\n    eos() {\n        return this.index >= this.source.length;\n    }\n    next() {\n        const next = this.peek();\n        this.advance();\n        return next;\n    }\n    peek() {\n        return this.source[this.index];\n    }\n    advance() {\n        this.index++;\n    }\n}\nfunction _renderFormattedText(element, treeNode, actionHandler, renderCodeSegments) {\n    let child;\n    if (treeNode.type === 2 /* FormatType.Text */) {\n        child = document.createTextNode(treeNode.content || '');\n    }\n    else if (treeNode.type === 3 /* FormatType.Bold */) {\n        child = document.createElement('b');\n    }\n    else if (treeNode.type === 4 /* FormatType.Italics */) {\n        child = document.createElement('i');\n    }\n    else if (treeNode.type === 7 /* FormatType.Code */ && renderCodeSegments) {\n        child = document.createElement('code');\n    }\n    else if (treeNode.type === 5 /* FormatType.Action */ && actionHandler) {\n        const a = document.createElement('a');\n        actionHandler.disposables.add(DOM.addStandardDisposableListener(a, 'click', (event) => {\n            actionHandler.callback(String(treeNode.index), event);\n        }));\n        child = a;\n    }\n    else if (treeNode.type === 8 /* FormatType.NewLine */) {\n        child = document.createElement('br');\n    }\n    else if (treeNode.type === 1 /* FormatType.Root */) {\n        child = element;\n    }\n    if (child && element !== child) {\n        element.appendChild(child);\n    }\n    if (child && Array.isArray(treeNode.children)) {\n        treeNode.children.forEach((nodeChild) => {\n            _renderFormattedText(child, nodeChild, actionHandler, renderCodeSegments);\n        });\n    }\n}\nfunction parseFormattedText(content, parseCodeSegments) {\n    const root = {\n        type: 1 /* FormatType.Root */,\n        children: []\n    };\n    let actionViewItemIndex = 0;\n    let current = root;\n    const stack = [];\n    const stream = new StringStream(content);\n    while (!stream.eos()) {\n        let next = stream.next();\n        const isEscapedFormatType = (next === '\\\\' && formatTagType(stream.peek(), parseCodeSegments) !== 0 /* FormatType.Invalid */);\n        if (isEscapedFormatType) {\n            next = stream.next(); // unread the backslash if it escapes a format tag type\n        }\n        if (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {\n            stream.advance();\n            if (current.type === 2 /* FormatType.Text */) {\n                current = stack.pop();\n            }\n            const type = formatTagType(next, parseCodeSegments);\n            if (current.type === type || (current.type === 5 /* FormatType.Action */ && type === 6 /* FormatType.ActionClose */)) {\n                current = stack.pop();\n            }\n            else {\n                const newCurrent = {\n                    type: type,\n                    children: []\n                };\n                if (type === 5 /* FormatType.Action */) {\n                    newCurrent.index = actionViewItemIndex;\n                    actionViewItemIndex++;\n                }\n                current.children.push(newCurrent);\n                stack.push(current);\n                current = newCurrent;\n            }\n        }\n        else if (next === '\\n') {\n            if (current.type === 2 /* FormatType.Text */) {\n                current = stack.pop();\n            }\n            current.children.push({\n                type: 8 /* FormatType.NewLine */\n            });\n        }\n        else {\n            if (current.type !== 2 /* FormatType.Text */) {\n                const textCurrent = {\n                    type: 2 /* FormatType.Text */,\n                    content: next\n                };\n                current.children.push(textCurrent);\n                stack.push(current);\n                current = textCurrent;\n            }\n            else {\n                current.content += next;\n            }\n        }\n    }\n    if (current.type === 2 /* FormatType.Text */) {\n        current = stack.pop();\n    }\n    if (stack.length) {\n        // incorrectly formatted string literal\n    }\n    return root;\n}\nfunction isFormatTag(char, supportCodeSegments) {\n    return formatTagType(char, supportCodeSegments) !== 0 /* FormatType.Invalid */;\n}\nfunction formatTagType(char, supportCodeSegments) {\n    switch (char) {\n        case '*':\n            return 3 /* FormatType.Bold */;\n        case '_':\n            return 4 /* FormatType.Italics */;\n        case '[':\n            return 5 /* FormatType.Action */;\n        case ']':\n            return 6 /* FormatType.ActionClose */;\n        case '`':\n            return supportCodeSegments ? 7 /* FormatType.Code */ : 0 /* FormatType.Invalid */;\n        default:\n            return 0 /* FormatType.Invalid */;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../dom.js';\nimport { renderLabelWithIcons } from '../iconLabel/iconLabels.js';\nimport * as objects from '../../../common/objects.js';\n/**\n * A widget which can render a label with substring highlights, often\n * originating from a filter function like the fuzzy matcher.\n */\nexport class HighlightedLabel {\n    /**\n     * Create a new {@link HighlightedLabel}.\n     *\n     * @param container The parent container to append to.\n     */\n    constructor(container, options) {\n        var _a;\n        this.text = '';\n        this.title = '';\n        this.highlights = [];\n        this.didEverRender = false;\n        this.supportIcons = (_a = options === null || options === void 0 ? void 0 : options.supportIcons) !== null && _a !== void 0 ? _a : false;\n        this.domNode = dom.append(container, dom.$('span.monaco-highlighted-label'));\n    }\n    /**\n     * The label's DOM node.\n     */\n    get element() {\n        return this.domNode;\n    }\n    /**\n     * Set the label and highlights.\n     *\n     * @param text The label to display.\n     * @param highlights The ranges to highlight.\n     * @param title An optional title for the hover tooltip.\n     * @param escapeNewLines Whether to escape new lines.\n     * @returns\n     */\n    set(text, highlights = [], title = '', escapeNewLines) {\n        if (!text) {\n            text = '';\n        }\n        if (escapeNewLines) {\n            // adjusts highlights inplace\n            text = HighlightedLabel.escapeNewLines(text, highlights);\n        }\n        if (this.didEverRender && this.text === text && this.title === title && objects.equals(this.highlights, highlights)) {\n            return;\n        }\n        this.text = text;\n        this.title = title;\n        this.highlights = highlights;\n        this.render();\n    }\n    render() {\n        const children = [];\n        let pos = 0;\n        for (const highlight of this.highlights) {\n            if (highlight.end === highlight.start) {\n                continue;\n            }\n            if (pos < highlight.start) {\n                const substring = this.text.substring(pos, highlight.start);\n                children.push(dom.$('span', undefined, ...this.supportIcons ? renderLabelWithIcons(substring) : [substring]));\n                pos = highlight.end;\n            }\n            const substring = this.text.substring(highlight.start, highlight.end);\n            const element = dom.$('span.highlight', undefined, ...this.supportIcons ? renderLabelWithIcons(substring) : [substring]);\n            if (highlight.extraClasses) {\n                element.classList.add(...highlight.extraClasses);\n            }\n            children.push(element);\n            pos = highlight.end;\n        }\n        if (pos < this.text.length) {\n            const substring = this.text.substring(pos);\n            children.push(dom.$('span', undefined, ...this.supportIcons ? renderLabelWithIcons(substring) : [substring]));\n        }\n        dom.reset(this.domNode, ...children);\n        if (this.title) {\n            this.domNode.title = this.title;\n        }\n        else {\n            this.domNode.removeAttribute('title');\n        }\n        this.didEverRender = true;\n    }\n    static escapeNewLines(text, highlights) {\n        let total = 0;\n        let extra = 0;\n        return text.replace(/\\r\\n|\\r|\\n/g, (match, offset) => {\n            extra = match === '\\r\\n' ? -1 : 0;\n            offset += total;\n            for (const highlight of highlights) {\n                if (highlight.end <= offset) {\n                    continue;\n                }\n                if (highlight.start >= offset) {\n                    highlight.start += extra;\n                }\n                if (highlight.end >= offset) {\n                    highlight.end += extra;\n                }\n            }\n            total += extra;\n            return '\\u23CE';\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as dom from '../../../browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../browser/keyboardEvent.js';\nimport { ActionBar } from '../../../browser/ui/actionbar/actionbar.js';\nimport { Button } from '../../../browser/ui/button/button.js';\nimport { CountBadge } from '../../../browser/ui/countBadge/countBadge.js';\nimport { renderLabelWithIcons } from '../../../browser/ui/iconLabel/iconLabels.js';\nimport { ProgressBar } from '../../../browser/ui/progressbar/progressbar.js';\nimport { Action } from '../../../common/actions.js';\nimport { equals } from '../../../common/arrays.js';\nimport { TimeoutTimer } from '../../../common/async.js';\nimport { CancellationToken } from '../../../common/cancellation.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { Emitter } from '../../../common/event.js';\nimport { Disposable, DisposableStore, dispose } from '../../../common/lifecycle.js';\nimport { isIOS } from '../../../common/platform.js';\nimport Severity from '../../../common/severity.js';\nimport { withNullAsUndefined } from '../../../common/types.js';\nimport { getIconClass } from './quickInputUtils.js';\nimport { ItemActivation, NO_KEY_MODS, QuickInputHideReason } from '../common/quickInput.js';\nimport './media/quickInput.css';\nimport { localize } from '../../../../nls.js';\nimport { QuickInputBox } from './quickInputBox.js';\nimport { QuickInputList, QuickInputListFocus } from './quickInputList.js';\nconst $ = dom.$;\nconst backButton = {\n    iconClass: Codicon.quickInputBack.classNames,\n    tooltip: localize('quickInput.back', \"Back\"),\n    handle: -1 // TODO\n};\nclass QuickInput extends Disposable {\n    constructor(ui) {\n        super();\n        this.ui = ui;\n        this.visible = false;\n        this._enabled = true;\n        this._busy = false;\n        this._ignoreFocusOut = false;\n        this._buttons = [];\n        this.noValidationMessage = QuickInput.noPromptMessage;\n        this._severity = Severity.Ignore;\n        this.buttonsUpdated = false;\n        this.onDidTriggerButtonEmitter = this._register(new Emitter());\n        this.onDidHideEmitter = this._register(new Emitter());\n        this.onDisposeEmitter = this._register(new Emitter());\n        this.visibleDisposables = this._register(new DisposableStore());\n        this.onDidHide = this.onDidHideEmitter.event;\n    }\n    get title() {\n        return this._title;\n    }\n    set title(title) {\n        this._title = title;\n        this.update();\n    }\n    get description() {\n        return this._description;\n    }\n    set description(description) {\n        this._description = description;\n        this.update();\n    }\n    get step() {\n        return this._steps;\n    }\n    set step(step) {\n        this._steps = step;\n        this.update();\n    }\n    get totalSteps() {\n        return this._totalSteps;\n    }\n    set totalSteps(totalSteps) {\n        this._totalSteps = totalSteps;\n        this.update();\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(enabled) {\n        this._enabled = enabled;\n        this.update();\n    }\n    get contextKey() {\n        return this._contextKey;\n    }\n    set contextKey(contextKey) {\n        this._contextKey = contextKey;\n        this.update();\n    }\n    get busy() {\n        return this._busy;\n    }\n    set busy(busy) {\n        this._busy = busy;\n        this.update();\n    }\n    get ignoreFocusOut() {\n        return this._ignoreFocusOut;\n    }\n    set ignoreFocusOut(ignoreFocusOut) {\n        const shouldUpdate = this._ignoreFocusOut !== ignoreFocusOut && !isIOS;\n        this._ignoreFocusOut = ignoreFocusOut && !isIOS;\n        if (shouldUpdate) {\n            this.update();\n        }\n    }\n    get buttons() {\n        return this._buttons;\n    }\n    set buttons(buttons) {\n        this._buttons = buttons;\n        this.buttonsUpdated = true;\n        this.update();\n    }\n    get validationMessage() {\n        return this._validationMessage;\n    }\n    set validationMessage(validationMessage) {\n        this._validationMessage = validationMessage;\n        this.update();\n    }\n    get severity() {\n        return this._severity;\n    }\n    set severity(severity) {\n        this._severity = severity;\n        this.update();\n    }\n    show() {\n        if (this.visible) {\n            return;\n        }\n        this.visibleDisposables.add(this.ui.onDidTriggerButton(button => {\n            if (this.buttons.indexOf(button) !== -1) {\n                this.onDidTriggerButtonEmitter.fire(button);\n            }\n        }));\n        this.ui.show(this);\n        // update properties in the controller that get reset in the ui.show() call\n        this.visible = true;\n        // This ensures the message/prompt gets rendered\n        this._lastValidationMessage = undefined;\n        // This ensures the input box has the right severity applied\n        this._lastSeverity = undefined;\n        if (this.buttons.length) {\n            // if there are buttons, the ui.show() clears them out of the UI so we should\n            // rerender them.\n            this.buttonsUpdated = true;\n        }\n        this.update();\n    }\n    hide() {\n        if (!this.visible) {\n            return;\n        }\n        this.ui.hide();\n    }\n    didHide(reason = QuickInputHideReason.Other) {\n        this.visible = false;\n        this.visibleDisposables.clear();\n        this.onDidHideEmitter.fire({ reason });\n    }\n    update() {\n        if (!this.visible) {\n            return;\n        }\n        const title = this.getTitle();\n        if (title && this.ui.title.textContent !== title) {\n            this.ui.title.textContent = title;\n        }\n        else if (!title && this.ui.title.innerHTML !== '&nbsp;') {\n            this.ui.title.innerText = '\\u00a0';\n        }\n        const description = this.getDescription();\n        if (this.ui.description1.textContent !== description) {\n            this.ui.description1.textContent = description;\n        }\n        if (this.ui.description2.textContent !== description) {\n            this.ui.description2.textContent = description;\n        }\n        if (this.busy && !this.busyDelay) {\n            this.busyDelay = new TimeoutTimer();\n            this.busyDelay.setIfNotSet(() => {\n                if (this.visible) {\n                    this.ui.progressBar.infinite();\n                }\n            }, 800);\n        }\n        if (!this.busy && this.busyDelay) {\n            this.ui.progressBar.stop();\n            this.busyDelay.cancel();\n            this.busyDelay = undefined;\n        }\n        if (this.buttonsUpdated) {\n            this.buttonsUpdated = false;\n            this.ui.leftActionBar.clear();\n            const leftButtons = this.buttons.filter(button => button === backButton);\n            this.ui.leftActionBar.push(leftButtons.map((button, index) => {\n                const action = new Action(`id-${index}`, '', button.iconClass || getIconClass(button.iconPath), true, () => __awaiter(this, void 0, void 0, function* () {\n                    this.onDidTriggerButtonEmitter.fire(button);\n                }));\n                action.tooltip = button.tooltip || '';\n                return action;\n            }), { icon: true, label: false });\n            this.ui.rightActionBar.clear();\n            const rightButtons = this.buttons.filter(button => button !== backButton);\n            this.ui.rightActionBar.push(rightButtons.map((button, index) => {\n                const action = new Action(`id-${index}`, '', button.iconClass || getIconClass(button.iconPath), true, () => __awaiter(this, void 0, void 0, function* () {\n                    this.onDidTriggerButtonEmitter.fire(button);\n                }));\n                action.tooltip = button.tooltip || '';\n                return action;\n            }), { icon: true, label: false });\n        }\n        this.ui.ignoreFocusOut = this.ignoreFocusOut;\n        this.ui.setEnabled(this.enabled);\n        this.ui.setContextKey(this.contextKey);\n        const validationMessage = this.validationMessage || this.noValidationMessage;\n        if (this._lastValidationMessage !== validationMessage) {\n            this._lastValidationMessage = validationMessage;\n            dom.reset(this.ui.message, ...renderLabelWithIcons(validationMessage));\n        }\n        if (this._lastSeverity !== this.severity) {\n            this._lastSeverity = this.severity;\n            this.showMessageDecoration(this.severity);\n        }\n    }\n    getTitle() {\n        if (this.title && this.step) {\n            return `${this.title} (${this.getSteps()})`;\n        }\n        if (this.title) {\n            return this.title;\n        }\n        if (this.step) {\n            return this.getSteps();\n        }\n        return '';\n    }\n    getDescription() {\n        return this.description || '';\n    }\n    getSteps() {\n        if (this.step && this.totalSteps) {\n            return localize('quickInput.steps', \"{0}/{1}\", this.step, this.totalSteps);\n        }\n        if (this.step) {\n            return String(this.step);\n        }\n        return '';\n    }\n    showMessageDecoration(severity) {\n        this.ui.inputBox.showDecoration(severity);\n        if (severity !== Severity.Ignore) {\n            const styles = this.ui.inputBox.stylesForType(severity);\n            this.ui.message.style.color = styles.foreground ? `${styles.foreground}` : '';\n            this.ui.message.style.backgroundColor = styles.background ? `${styles.background}` : '';\n            this.ui.message.style.border = styles.border ? `1px solid ${styles.border}` : '';\n            this.ui.message.style.marginBottom = '-2px';\n        }\n        else {\n            this.ui.message.style.color = '';\n            this.ui.message.style.backgroundColor = '';\n            this.ui.message.style.border = '';\n            this.ui.message.style.marginBottom = '';\n        }\n    }\n    dispose() {\n        this.hide();\n        this.onDisposeEmitter.fire();\n        super.dispose();\n    }\n}\nQuickInput.noPromptMessage = localize('inputModeEntry', \"Press 'Enter' to confirm your input or 'Escape' to cancel\");\nclass QuickPick extends QuickInput {\n    constructor() {\n        super(...arguments);\n        this._value = '';\n        this.onDidChangeValueEmitter = this._register(new Emitter());\n        this.onWillAcceptEmitter = this._register(new Emitter());\n        this.onDidAcceptEmitter = this._register(new Emitter());\n        this.onDidCustomEmitter = this._register(new Emitter());\n        this._items = [];\n        this.itemsUpdated = false;\n        this._canSelectMany = false;\n        this._canAcceptInBackground = false;\n        this._matchOnDescription = false;\n        this._matchOnDetail = false;\n        this._matchOnLabel = true;\n        this._matchOnLabelMode = 'fuzzy';\n        this._sortByLabel = true;\n        this._autoFocusOnList = true;\n        this._keepScrollPosition = false;\n        this._itemActivation = this.ui.isScreenReaderOptimized() ? ItemActivation.NONE /* https://github.com/microsoft/vscode/issues/57501 */ : ItemActivation.FIRST;\n        this._activeItems = [];\n        this.activeItemsUpdated = false;\n        this.activeItemsToConfirm = [];\n        this.onDidChangeActiveEmitter = this._register(new Emitter());\n        this._selectedItems = [];\n        this.selectedItemsUpdated = false;\n        this.selectedItemsToConfirm = [];\n        this.onDidChangeSelectionEmitter = this._register(new Emitter());\n        this.onDidTriggerItemButtonEmitter = this._register(new Emitter());\n        this.valueSelectionUpdated = true;\n        this._ok = 'default';\n        this._customButton = false;\n        this.filterValue = (value) => value;\n        this.onDidChangeValue = this.onDidChangeValueEmitter.event;\n        this.onWillAccept = this.onWillAcceptEmitter.event;\n        this.onDidAccept = this.onDidAcceptEmitter.event;\n        this.onDidChangeActive = this.onDidChangeActiveEmitter.event;\n        this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;\n        this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;\n    }\n    get quickNavigate() {\n        return this._quickNavigate;\n    }\n    set quickNavigate(quickNavigate) {\n        this._quickNavigate = quickNavigate;\n        this.update();\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this.doSetValue(value);\n    }\n    doSetValue(value, skipUpdate) {\n        if (this._value !== value) {\n            this._value = value;\n            if (!skipUpdate) {\n                this.update();\n            }\n            if (this.visible) {\n                const didFilter = this.ui.list.filter(this.filterValue(this._value));\n                if (didFilter) {\n                    this.trySelectFirst();\n                }\n            }\n            this.onDidChangeValueEmitter.fire(this._value);\n        }\n    }\n    set ariaLabel(ariaLabel) {\n        this._ariaLabel = ariaLabel;\n        this.update();\n    }\n    get ariaLabel() {\n        return this._ariaLabel;\n    }\n    get placeholder() {\n        return this._placeholder;\n    }\n    set placeholder(placeholder) {\n        this._placeholder = placeholder;\n        this.update();\n    }\n    get items() {\n        return this._items;\n    }\n    get scrollTop() {\n        return this.ui.list.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.ui.list.scrollTop = scrollTop;\n    }\n    set items(items) {\n        this._items = items;\n        this.itemsUpdated = true;\n        this.update();\n    }\n    get canSelectMany() {\n        return this._canSelectMany;\n    }\n    set canSelectMany(canSelectMany) {\n        this._canSelectMany = canSelectMany;\n        this.update();\n    }\n    get canAcceptInBackground() {\n        return this._canAcceptInBackground;\n    }\n    set canAcceptInBackground(canAcceptInBackground) {\n        this._canAcceptInBackground = canAcceptInBackground;\n    }\n    get matchOnDescription() {\n        return this._matchOnDescription;\n    }\n    set matchOnDescription(matchOnDescription) {\n        this._matchOnDescription = matchOnDescription;\n        this.update();\n    }\n    get matchOnDetail() {\n        return this._matchOnDetail;\n    }\n    set matchOnDetail(matchOnDetail) {\n        this._matchOnDetail = matchOnDetail;\n        this.update();\n    }\n    get matchOnLabel() {\n        return this._matchOnLabel;\n    }\n    set matchOnLabel(matchOnLabel) {\n        this._matchOnLabel = matchOnLabel;\n        this.update();\n    }\n    get matchOnLabelMode() {\n        return this._matchOnLabelMode;\n    }\n    set matchOnLabelMode(matchOnLabelMode) {\n        this._matchOnLabelMode = matchOnLabelMode;\n        this.update();\n    }\n    get sortByLabel() {\n        return this._sortByLabel;\n    }\n    set sortByLabel(sortByLabel) {\n        this._sortByLabel = sortByLabel;\n        this.update();\n    }\n    get autoFocusOnList() {\n        return this._autoFocusOnList;\n    }\n    set autoFocusOnList(autoFocusOnList) {\n        this._autoFocusOnList = autoFocusOnList;\n        this.update();\n    }\n    get keepScrollPosition() {\n        return this._keepScrollPosition;\n    }\n    set keepScrollPosition(keepScrollPosition) {\n        this._keepScrollPosition = keepScrollPosition;\n    }\n    get itemActivation() {\n        return this._itemActivation;\n    }\n    set itemActivation(itemActivation) {\n        this._itemActivation = itemActivation;\n    }\n    get activeItems() {\n        return this._activeItems;\n    }\n    set activeItems(activeItems) {\n        this._activeItems = activeItems;\n        this.activeItemsUpdated = true;\n        this.update();\n    }\n    get selectedItems() {\n        return this._selectedItems;\n    }\n    set selectedItems(selectedItems) {\n        this._selectedItems = selectedItems;\n        this.selectedItemsUpdated = true;\n        this.update();\n    }\n    get keyMods() {\n        if (this._quickNavigate) {\n            // Disable keyMods when quick navigate is enabled\n            // because in this model the interaction is purely\n            // keyboard driven and Ctrl/Alt are typically\n            // pressed and hold during this interaction.\n            return NO_KEY_MODS;\n        }\n        return this.ui.keyMods;\n    }\n    set valueSelection(valueSelection) {\n        this._valueSelection = valueSelection;\n        this.valueSelectionUpdated = true;\n        this.update();\n    }\n    get customButton() {\n        return this._customButton;\n    }\n    set customButton(showCustomButton) {\n        this._customButton = showCustomButton;\n        this.update();\n    }\n    get customLabel() {\n        return this._customButtonLabel;\n    }\n    set customLabel(label) {\n        this._customButtonLabel = label;\n        this.update();\n    }\n    get customHover() {\n        return this._customButtonHover;\n    }\n    set customHover(hover) {\n        this._customButtonHover = hover;\n        this.update();\n    }\n    get ok() {\n        return this._ok;\n    }\n    set ok(showOkButton) {\n        this._ok = showOkButton;\n        this.update();\n    }\n    get hideInput() {\n        return !!this._hideInput;\n    }\n    set hideInput(hideInput) {\n        this._hideInput = hideInput;\n        this.update();\n    }\n    trySelectFirst() {\n        if (this.autoFocusOnList) {\n            if (!this.canSelectMany) {\n                this.ui.list.focus(QuickInputListFocus.First);\n            }\n        }\n    }\n    show() {\n        if (!this.visible) {\n            this.visibleDisposables.add(this.ui.inputBox.onDidChange(value => {\n                this.doSetValue(value, true /* skip update since this originates from the UI */);\n            }));\n            this.visibleDisposables.add(this.ui.inputBox.onMouseDown(event => {\n                if (!this.autoFocusOnList) {\n                    this.ui.list.clearFocus();\n                }\n            }));\n            this.visibleDisposables.add((this._hideInput ? this.ui.list : this.ui.inputBox).onKeyDown((event) => {\n                switch (event.keyCode) {\n                    case 18 /* KeyCode.DownArrow */:\n                        this.ui.list.focus(QuickInputListFocus.Next);\n                        if (this.canSelectMany) {\n                            this.ui.list.domFocus();\n                        }\n                        dom.EventHelper.stop(event, true);\n                        break;\n                    case 16 /* KeyCode.UpArrow */:\n                        if (this.ui.list.getFocusedElements().length) {\n                            this.ui.list.focus(QuickInputListFocus.Previous);\n                        }\n                        else {\n                            this.ui.list.focus(QuickInputListFocus.Last);\n                        }\n                        if (this.canSelectMany) {\n                            this.ui.list.domFocus();\n                        }\n                        dom.EventHelper.stop(event, true);\n                        break;\n                    case 12 /* KeyCode.PageDown */:\n                        this.ui.list.focus(QuickInputListFocus.NextPage);\n                        if (this.canSelectMany) {\n                            this.ui.list.domFocus();\n                        }\n                        dom.EventHelper.stop(event, true);\n                        break;\n                    case 11 /* KeyCode.PageUp */:\n                        this.ui.list.focus(QuickInputListFocus.PreviousPage);\n                        if (this.canSelectMany) {\n                            this.ui.list.domFocus();\n                        }\n                        dom.EventHelper.stop(event, true);\n                        break;\n                    case 17 /* KeyCode.RightArrow */:\n                        if (!this._canAcceptInBackground) {\n                            return; // needs to be enabled\n                        }\n                        if (!this.ui.inputBox.isSelectionAtEnd()) {\n                            return; // ensure input box selection at end\n                        }\n                        if (this.activeItems[0]) {\n                            this._selectedItems = [this.activeItems[0]];\n                            this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                            this.handleAccept(true);\n                        }\n                        break;\n                    case 14 /* KeyCode.Home */:\n                        if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {\n                            this.ui.list.focus(QuickInputListFocus.First);\n                            dom.EventHelper.stop(event, true);\n                        }\n                        break;\n                    case 13 /* KeyCode.End */:\n                        if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {\n                            this.ui.list.focus(QuickInputListFocus.Last);\n                            dom.EventHelper.stop(event, true);\n                        }\n                        break;\n                }\n            }));\n            this.visibleDisposables.add(this.ui.onDidAccept(() => {\n                if (this.canSelectMany) {\n                    // if there are no checked elements, it means that an onDidChangeSelection never fired to overwrite\n                    // `_selectedItems`. In that case, we should emit one with an empty array to ensure that\n                    // `.selectedItems` is up to date.\n                    if (!this.ui.list.getCheckedElements().length) {\n                        this._selectedItems = [];\n                        this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                    }\n                }\n                else if (this.activeItems[0]) {\n                    // For single-select, we set `selectedItems` to the item that was accepted.\n                    this._selectedItems = [this.activeItems[0]];\n                    this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                }\n                this.handleAccept(false);\n            }));\n            this.visibleDisposables.add(this.ui.onDidCustom(() => {\n                this.onDidCustomEmitter.fire();\n            }));\n            this.visibleDisposables.add(this.ui.list.onDidChangeFocus(focusedItems => {\n                if (this.activeItemsUpdated) {\n                    return; // Expect another event.\n                }\n                if (this.activeItemsToConfirm !== this._activeItems && equals(focusedItems, this._activeItems, (a, b) => a === b)) {\n                    return;\n                }\n                this._activeItems = focusedItems;\n                this.onDidChangeActiveEmitter.fire(focusedItems);\n            }));\n            this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: selectedItems, event }) => {\n                if (this.canSelectMany) {\n                    if (selectedItems.length) {\n                        this.ui.list.setSelectedElements([]);\n                    }\n                    return;\n                }\n                if (this.selectedItemsToConfirm !== this._selectedItems && equals(selectedItems, this._selectedItems, (a, b) => a === b)) {\n                    return;\n                }\n                this._selectedItems = selectedItems;\n                this.onDidChangeSelectionEmitter.fire(selectedItems);\n                if (selectedItems.length) {\n                    this.handleAccept(event instanceof MouseEvent && event.button === 1 /* mouse middle click */);\n                }\n            }));\n            this.visibleDisposables.add(this.ui.list.onChangedCheckedElements(checkedItems => {\n                if (!this.canSelectMany) {\n                    return;\n                }\n                if (this.selectedItemsToConfirm !== this._selectedItems && equals(checkedItems, this._selectedItems, (a, b) => a === b)) {\n                    return;\n                }\n                this._selectedItems = checkedItems;\n                this.onDidChangeSelectionEmitter.fire(checkedItems);\n            }));\n            this.visibleDisposables.add(this.ui.list.onButtonTriggered(event => this.onDidTriggerItemButtonEmitter.fire(event)));\n            this.visibleDisposables.add(this.registerQuickNavigation());\n            this.valueSelectionUpdated = true;\n        }\n        super.show(); // TODO: Why have show() bubble up while update() trickles down? (Could move setComboboxAccessibility() here.)\n    }\n    handleAccept(inBackground) {\n        // Figure out veto via `onWillAccept` event\n        let veto = false;\n        this.onWillAcceptEmitter.fire({ veto: () => veto = true });\n        // Continue with `onDidAccept` if no veto\n        if (!veto) {\n            this.onDidAcceptEmitter.fire({ inBackground });\n        }\n    }\n    registerQuickNavigation() {\n        return dom.addDisposableListener(this.ui.container, dom.EventType.KEY_UP, e => {\n            if (this.canSelectMany || !this._quickNavigate) {\n                return;\n            }\n            const keyboardEvent = new StandardKeyboardEvent(e);\n            const keyCode = keyboardEvent.keyCode;\n            // Select element when keys are pressed that signal it\n            const quickNavKeys = this._quickNavigate.keybindings;\n            const wasTriggerKeyPressed = quickNavKeys.some(k => {\n                const [firstPart, chordPart] = k.getParts();\n                if (chordPart) {\n                    return false;\n                }\n                if (firstPart.shiftKey && keyCode === 4 /* KeyCode.Shift */) {\n                    if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {\n                        return false; // this is an optimistic check for the shift key being used to navigate back in quick input\n                    }\n                    return true;\n                }\n                if (firstPart.altKey && keyCode === 6 /* KeyCode.Alt */) {\n                    return true;\n                }\n                if (firstPart.ctrlKey && keyCode === 5 /* KeyCode.Ctrl */) {\n                    return true;\n                }\n                if (firstPart.metaKey && keyCode === 57 /* KeyCode.Meta */) {\n                    return true;\n                }\n                return false;\n            });\n            if (wasTriggerKeyPressed) {\n                if (this.activeItems[0]) {\n                    this._selectedItems = [this.activeItems[0]];\n                    this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                    this.handleAccept(false);\n                }\n                // Unset quick navigate after press. It is only valid once\n                // and should not result in any behaviour change afterwards\n                // if the picker remains open because there was no active item\n                this._quickNavigate = undefined;\n            }\n        });\n    }\n    update() {\n        if (!this.visible) {\n            return;\n        }\n        // store the scrollTop before it is reset\n        const scrollTopBefore = this.keepScrollPosition ? this.scrollTop : 0;\n        const hideInput = !!this._hideInput && this._items.length > 0;\n        this.ui.container.classList.toggle('hidden-input', hideInput && !this.description);\n        const visibilities = {\n            title: !!this.title || !!this.step || !!this.buttons.length,\n            description: !!this.description,\n            checkAll: this.canSelectMany && !this._hideCheckAll,\n            checkBox: this.canSelectMany,\n            inputBox: !hideInput,\n            progressBar: !hideInput,\n            visibleCount: true,\n            count: this.canSelectMany,\n            ok: this.ok === 'default' ? this.canSelectMany : this.ok,\n            list: true,\n            message: !!this.validationMessage,\n            customButton: this.customButton\n        };\n        this.ui.setVisibilities(visibilities);\n        super.update();\n        if (this.ui.inputBox.value !== this.value) {\n            this.ui.inputBox.value = this.value;\n        }\n        if (this.valueSelectionUpdated) {\n            this.valueSelectionUpdated = false;\n            this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] });\n        }\n        if (this.ui.inputBox.placeholder !== (this.placeholder || '')) {\n            this.ui.inputBox.placeholder = (this.placeholder || '');\n        }\n        let ariaLabel = this.ariaLabel;\n        if (!ariaLabel) {\n            ariaLabel = this.placeholder || QuickPick.DEFAULT_ARIA_LABEL;\n            // If we have a title, include it in the aria label.\n            if (this.title) {\n                ariaLabel += ` - ${this.title}`;\n            }\n        }\n        if (this.ui.inputBox.ariaLabel !== ariaLabel) {\n            this.ui.inputBox.ariaLabel = ariaLabel;\n        }\n        this.ui.list.matchOnDescription = this.matchOnDescription;\n        this.ui.list.matchOnDetail = this.matchOnDetail;\n        this.ui.list.matchOnLabel = this.matchOnLabel;\n        this.ui.list.matchOnLabelMode = this.matchOnLabelMode;\n        this.ui.list.sortByLabel = this.sortByLabel;\n        if (this.itemsUpdated) {\n            this.itemsUpdated = false;\n            this.ui.list.setElements(this.items);\n            this.ui.list.filter(this.filterValue(this.ui.inputBox.value));\n            this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked();\n            this.ui.visibleCount.setCount(this.ui.list.getVisibleCount());\n            this.ui.count.setCount(this.ui.list.getCheckedCount());\n            switch (this._itemActivation) {\n                case ItemActivation.NONE:\n                    this._itemActivation = ItemActivation.FIRST; // only valid once, then unset\n                    break;\n                case ItemActivation.SECOND:\n                    this.ui.list.focus(QuickInputListFocus.Second);\n                    this._itemActivation = ItemActivation.FIRST; // only valid once, then unset\n                    break;\n                case ItemActivation.LAST:\n                    this.ui.list.focus(QuickInputListFocus.Last);\n                    this._itemActivation = ItemActivation.FIRST; // only valid once, then unset\n                    break;\n                default:\n                    this.trySelectFirst();\n                    break;\n            }\n        }\n        if (this.ui.container.classList.contains('show-checkboxes') !== !!this.canSelectMany) {\n            if (this.canSelectMany) {\n                this.ui.list.clearFocus();\n            }\n            else {\n                this.trySelectFirst();\n            }\n        }\n        if (this.activeItemsUpdated) {\n            this.activeItemsUpdated = false;\n            this.activeItemsToConfirm = this._activeItems;\n            this.ui.list.setFocusedElements(this.activeItems);\n            if (this.activeItemsToConfirm === this._activeItems) {\n                this.activeItemsToConfirm = null;\n            }\n        }\n        if (this.selectedItemsUpdated) {\n            this.selectedItemsUpdated = false;\n            this.selectedItemsToConfirm = this._selectedItems;\n            if (this.canSelectMany) {\n                this.ui.list.setCheckedElements(this.selectedItems);\n            }\n            else {\n                this.ui.list.setSelectedElements(this.selectedItems);\n            }\n            if (this.selectedItemsToConfirm === this._selectedItems) {\n                this.selectedItemsToConfirm = null;\n            }\n        }\n        this.ui.customButton.label = this.customLabel || '';\n        this.ui.customButton.element.title = this.customHover || '';\n        this.ui.setComboboxAccessibility(true);\n        if (!visibilities.inputBox) {\n            // we need to move focus into the tree to detect keybindings\n            // properly when the input box is not visible (quick nav)\n            this.ui.list.domFocus();\n            // Focus the first element in the list if multiselect is enabled\n            if (this.canSelectMany) {\n                this.ui.list.focus(QuickInputListFocus.First);\n            }\n        }\n        // Set the scroll position to what it was before updating the items\n        if (this.keepScrollPosition) {\n            this.scrollTop = scrollTopBefore;\n        }\n    }\n}\nQuickPick.DEFAULT_ARIA_LABEL = localize('quickInputBox.ariaLabel', \"Type to narrow down results.\");\nexport class QuickInputController extends Disposable {\n    constructor(options) {\n        super();\n        this.options = options;\n        this.comboboxAccessibility = false;\n        this.enabled = true;\n        this.onDidAcceptEmitter = this._register(new Emitter());\n        this.onDidCustomEmitter = this._register(new Emitter());\n        this.onDidTriggerButtonEmitter = this._register(new Emitter());\n        this.keyMods = { ctrlCmd: false, alt: false };\n        this.controller = null;\n        this.onShowEmitter = this._register(new Emitter());\n        this.onShow = this.onShowEmitter.event;\n        this.onHideEmitter = this._register(new Emitter());\n        this.onHide = this.onHideEmitter.event;\n        this.idPrefix = options.idPrefix;\n        this.parentElement = options.container;\n        this.styles = options.styles;\n        this.registerKeyModsListeners();\n    }\n    registerKeyModsListeners() {\n        const listener = (e) => {\n            this.keyMods.ctrlCmd = e.ctrlKey || e.metaKey;\n            this.keyMods.alt = e.altKey;\n        };\n        this._register(dom.addDisposableListener(window, dom.EventType.KEY_DOWN, listener, true));\n        this._register(dom.addDisposableListener(window, dom.EventType.KEY_UP, listener, true));\n        this._register(dom.addDisposableListener(window, dom.EventType.MOUSE_DOWN, listener, true));\n    }\n    getUI() {\n        if (this.ui) {\n            return this.ui;\n        }\n        const container = dom.append(this.parentElement, $('.quick-input-widget.show-file-icons'));\n        container.tabIndex = -1;\n        container.style.display = 'none';\n        const styleSheet = dom.createStyleSheet(container);\n        const titleBar = dom.append(container, $('.quick-input-titlebar'));\n        const leftActionBar = this._register(new ActionBar(titleBar));\n        leftActionBar.domNode.classList.add('quick-input-left-action-bar');\n        const title = dom.append(titleBar, $('.quick-input-title'));\n        const rightActionBar = this._register(new ActionBar(titleBar));\n        rightActionBar.domNode.classList.add('quick-input-right-action-bar');\n        const description1 = dom.append(container, $('.quick-input-description'));\n        const headerContainer = dom.append(container, $('.quick-input-header'));\n        const checkAll = dom.append(headerContainer, $('input.quick-input-check-all'));\n        checkAll.type = 'checkbox';\n        checkAll.setAttribute('aria-label', localize('quickInput.checkAll', \"Toggle all checkboxes\"));\n        this._register(dom.addStandardDisposableListener(checkAll, dom.EventType.CHANGE, e => {\n            const checked = checkAll.checked;\n            list.setAllVisibleChecked(checked);\n        }));\n        this._register(dom.addDisposableListener(checkAll, dom.EventType.CLICK, e => {\n            if (e.x || e.y) { // Avoid 'click' triggered by 'space'...\n                inputBox.setFocus();\n            }\n        }));\n        const description2 = dom.append(headerContainer, $('.quick-input-description'));\n        const extraContainer = dom.append(headerContainer, $('.quick-input-and-message'));\n        const filterContainer = dom.append(extraContainer, $('.quick-input-filter'));\n        const inputBox = this._register(new QuickInputBox(filterContainer));\n        inputBox.setAttribute('aria-describedby', `${this.idPrefix}message`);\n        const visibleCountContainer = dom.append(filterContainer, $('.quick-input-visible-count'));\n        visibleCountContainer.setAttribute('aria-live', 'polite');\n        visibleCountContainer.setAttribute('aria-atomic', 'true');\n        const visibleCount = new CountBadge(visibleCountContainer, { countFormat: localize({ key: 'quickInput.visibleCount', comment: ['This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers.'] }, \"{0} Results\") });\n        const countContainer = dom.append(filterContainer, $('.quick-input-count'));\n        countContainer.setAttribute('aria-live', 'polite');\n        const count = new CountBadge(countContainer, { countFormat: localize({ key: 'quickInput.countSelected', comment: ['This tells the user how many items are selected in a list of items to select from. The items can be anything.'] }, \"{0} Selected\") });\n        const okContainer = dom.append(headerContainer, $('.quick-input-action'));\n        const ok = new Button(okContainer);\n        ok.label = localize('ok', \"OK\");\n        this._register(ok.onDidClick(e => {\n            this.onDidAcceptEmitter.fire();\n        }));\n        const customButtonContainer = dom.append(headerContainer, $('.quick-input-action'));\n        const customButton = new Button(customButtonContainer);\n        customButton.label = localize('custom', \"Custom\");\n        this._register(customButton.onDidClick(e => {\n            this.onDidCustomEmitter.fire();\n        }));\n        const message = dom.append(extraContainer, $(`#${this.idPrefix}message.quick-input-message`));\n        const list = this._register(new QuickInputList(container, this.idPrefix + 'list', this.options));\n        this._register(list.onChangedAllVisibleChecked(checked => {\n            checkAll.checked = checked;\n        }));\n        this._register(list.onChangedVisibleCount(c => {\n            visibleCount.setCount(c);\n        }));\n        this._register(list.onChangedCheckedCount(c => {\n            count.setCount(c);\n        }));\n        this._register(list.onLeave(() => {\n            // Defer to avoid the input field reacting to the triggering key.\n            setTimeout(() => {\n                inputBox.setFocus();\n                if (this.controller instanceof QuickPick && this.controller.canSelectMany) {\n                    list.clearFocus();\n                }\n            }, 0);\n        }));\n        this._register(list.onDidChangeFocus(() => {\n            if (this.comboboxAccessibility) {\n                this.getUI().inputBox.setAttribute('aria-activedescendant', this.getUI().list.getActiveDescendant() || '');\n            }\n        }));\n        const progressBar = new ProgressBar(container);\n        progressBar.getContainer().classList.add('quick-input-progress');\n        const focusTracker = dom.trackFocus(container);\n        this._register(focusTracker);\n        this._register(dom.addDisposableListener(container, dom.EventType.FOCUS, e => {\n            this.previousFocusElement = e.relatedTarget instanceof HTMLElement ? e.relatedTarget : undefined;\n        }, true));\n        this._register(focusTracker.onDidBlur(() => {\n            if (!this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut()) {\n                this.hide(QuickInputHideReason.Blur);\n            }\n            this.previousFocusElement = undefined;\n        }));\n        this._register(dom.addDisposableListener(container, dom.EventType.FOCUS, (e) => {\n            inputBox.setFocus();\n        }));\n        this._register(dom.addDisposableListener(container, dom.EventType.KEY_DOWN, (e) => {\n            const event = new StandardKeyboardEvent(e);\n            switch (event.keyCode) {\n                case 3 /* KeyCode.Enter */:\n                    dom.EventHelper.stop(e, true);\n                    this.onDidAcceptEmitter.fire();\n                    break;\n                case 9 /* KeyCode.Escape */:\n                    dom.EventHelper.stop(e, true);\n                    this.hide(QuickInputHideReason.Gesture);\n                    break;\n                case 2 /* KeyCode.Tab */:\n                    if (!event.altKey && !event.ctrlKey && !event.metaKey) {\n                        const selectors = ['.action-label.codicon'];\n                        if (container.classList.contains('show-checkboxes')) {\n                            selectors.push('input');\n                        }\n                        else {\n                            selectors.push('input[type=text]');\n                        }\n                        if (this.getUI().list.isDisplayed()) {\n                            selectors.push('.monaco-list');\n                        }\n                        const stops = container.querySelectorAll(selectors.join(', '));\n                        if (event.shiftKey && event.target === stops[0]) {\n                            dom.EventHelper.stop(e, true);\n                            stops[stops.length - 1].focus();\n                        }\n                        else if (!event.shiftKey && event.target === stops[stops.length - 1]) {\n                            dom.EventHelper.stop(e, true);\n                            stops[0].focus();\n                        }\n                    }\n                    break;\n            }\n        }));\n        this.ui = {\n            container,\n            styleSheet,\n            leftActionBar,\n            titleBar,\n            title,\n            description1,\n            description2,\n            rightActionBar,\n            checkAll,\n            filterContainer,\n            inputBox,\n            visibleCountContainer,\n            visibleCount,\n            countContainer,\n            count,\n            okContainer,\n            ok,\n            message,\n            customButtonContainer,\n            customButton,\n            list,\n            progressBar,\n            onDidAccept: this.onDidAcceptEmitter.event,\n            onDidCustom: this.onDidCustomEmitter.event,\n            onDidTriggerButton: this.onDidTriggerButtonEmitter.event,\n            ignoreFocusOut: false,\n            keyMods: this.keyMods,\n            isScreenReaderOptimized: () => this.options.isScreenReaderOptimized(),\n            show: controller => this.show(controller),\n            hide: () => this.hide(),\n            setVisibilities: visibilities => this.setVisibilities(visibilities),\n            setComboboxAccessibility: enabled => this.setComboboxAccessibility(enabled),\n            setEnabled: enabled => this.setEnabled(enabled),\n            setContextKey: contextKey => this.options.setContextKey(contextKey),\n        };\n        this.updateStyles();\n        return this.ui;\n    }\n    pick(picks, options = {}, token = CancellationToken.None) {\n        return new Promise((doResolve, reject) => {\n            let resolve = (result) => {\n                var _a;\n                resolve = doResolve;\n                (_a = options.onKeyMods) === null || _a === void 0 ? void 0 : _a.call(options, input.keyMods);\n                doResolve(result);\n            };\n            if (token.isCancellationRequested) {\n                resolve(undefined);\n                return;\n            }\n            const input = this.createQuickPick();\n            let activeItem;\n            const disposables = [\n                input,\n                input.onDidAccept(() => {\n                    if (input.canSelectMany) {\n                        resolve(input.selectedItems.slice());\n                        input.hide();\n                    }\n                    else {\n                        const result = input.activeItems[0];\n                        if (result) {\n                            resolve(result);\n                            input.hide();\n                        }\n                    }\n                }),\n                input.onDidChangeActive(items => {\n                    const focused = items[0];\n                    if (focused && options.onDidFocus) {\n                        options.onDidFocus(focused);\n                    }\n                }),\n                input.onDidChangeSelection(items => {\n                    if (!input.canSelectMany) {\n                        const result = items[0];\n                        if (result) {\n                            resolve(result);\n                            input.hide();\n                        }\n                    }\n                }),\n                input.onDidTriggerItemButton(event => options.onDidTriggerItemButton && options.onDidTriggerItemButton(Object.assign(Object.assign({}, event), { removeItem: () => {\n                        const index = input.items.indexOf(event.item);\n                        if (index !== -1) {\n                            const items = input.items.slice();\n                            const removed = items.splice(index, 1);\n                            const activeItems = input.activeItems.filter(activeItem => activeItem !== removed[0]);\n                            const keepScrollPositionBefore = input.keepScrollPosition;\n                            input.keepScrollPosition = true;\n                            input.items = items;\n                            if (activeItems) {\n                                input.activeItems = activeItems;\n                            }\n                            input.keepScrollPosition = keepScrollPositionBefore;\n                        }\n                    } }))),\n                input.onDidChangeValue(value => {\n                    if (activeItem && !value && (input.activeItems.length !== 1 || input.activeItems[0] !== activeItem)) {\n                        input.activeItems = [activeItem];\n                    }\n                }),\n                token.onCancellationRequested(() => {\n                    input.hide();\n                }),\n                input.onDidHide(() => {\n                    dispose(disposables);\n                    resolve(undefined);\n                }),\n            ];\n            input.title = options.title;\n            input.canSelectMany = !!options.canPickMany;\n            input.placeholder = options.placeHolder;\n            input.ignoreFocusOut = !!options.ignoreFocusLost;\n            input.matchOnDescription = !!options.matchOnDescription;\n            input.matchOnDetail = !!options.matchOnDetail;\n            input.matchOnLabel = (options.matchOnLabel === undefined) || options.matchOnLabel; // default to true\n            input.autoFocusOnList = (options.autoFocusOnList === undefined) || options.autoFocusOnList; // default to true\n            input.quickNavigate = options.quickNavigate;\n            input.hideInput = !!options.hideInput;\n            input.contextKey = options.contextKey;\n            input.busy = true;\n            Promise.all([picks, options.activeItem])\n                .then(([items, _activeItem]) => {\n                activeItem = _activeItem;\n                input.busy = false;\n                input.items = items;\n                if (input.canSelectMany) {\n                    input.selectedItems = items.filter(item => item.type !== 'separator' && item.picked);\n                }\n                if (activeItem) {\n                    input.activeItems = [activeItem];\n                }\n            });\n            input.show();\n            Promise.resolve(picks).then(undefined, err => {\n                reject(err);\n                input.hide();\n            });\n        });\n    }\n    createQuickPick() {\n        const ui = this.getUI();\n        return new QuickPick(ui);\n    }\n    show(controller) {\n        const ui = this.getUI();\n        this.onShowEmitter.fire();\n        const oldController = this.controller;\n        this.controller = controller;\n        if (oldController) {\n            oldController.didHide();\n        }\n        this.setEnabled(true);\n        ui.leftActionBar.clear();\n        ui.title.textContent = '';\n        ui.description1.textContent = '';\n        ui.description2.textContent = '';\n        ui.rightActionBar.clear();\n        ui.checkAll.checked = false;\n        // ui.inputBox.value = ''; Avoid triggering an event.\n        ui.inputBox.placeholder = '';\n        ui.inputBox.password = false;\n        ui.inputBox.showDecoration(Severity.Ignore);\n        ui.visibleCount.setCount(0);\n        ui.count.setCount(0);\n        dom.reset(ui.message);\n        ui.progressBar.stop();\n        ui.list.setElements([]);\n        ui.list.matchOnDescription = false;\n        ui.list.matchOnDetail = false;\n        ui.list.matchOnLabel = true;\n        ui.list.sortByLabel = true;\n        ui.ignoreFocusOut = false;\n        this.setComboboxAccessibility(false);\n        ui.inputBox.ariaLabel = '';\n        const backKeybindingLabel = this.options.backKeybindingLabel();\n        backButton.tooltip = backKeybindingLabel ? localize('quickInput.backWithKeybinding', \"Back ({0})\", backKeybindingLabel) : localize('quickInput.back', \"Back\");\n        ui.container.style.display = '';\n        this.updateLayout();\n        ui.inputBox.setFocus();\n    }\n    setVisibilities(visibilities) {\n        const ui = this.getUI();\n        ui.title.style.display = visibilities.title ? '' : 'none';\n        ui.description1.style.display = visibilities.description && (visibilities.inputBox || visibilities.checkAll) ? '' : 'none';\n        ui.description2.style.display = visibilities.description && !(visibilities.inputBox || visibilities.checkAll) ? '' : 'none';\n        ui.checkAll.style.display = visibilities.checkAll ? '' : 'none';\n        ui.filterContainer.style.display = visibilities.inputBox ? '' : 'none';\n        ui.visibleCountContainer.style.display = visibilities.visibleCount ? '' : 'none';\n        ui.countContainer.style.display = visibilities.count ? '' : 'none';\n        ui.okContainer.style.display = visibilities.ok ? '' : 'none';\n        ui.customButtonContainer.style.display = visibilities.customButton ? '' : 'none';\n        ui.message.style.display = visibilities.message ? '' : 'none';\n        ui.progressBar.getContainer().style.display = visibilities.progressBar ? '' : 'none';\n        ui.list.display(!!visibilities.list);\n        ui.container.classList[visibilities.checkBox ? 'add' : 'remove']('show-checkboxes');\n        this.updateLayout(); // TODO\n    }\n    setComboboxAccessibility(enabled) {\n        if (enabled !== this.comboboxAccessibility) {\n            const ui = this.getUI();\n            this.comboboxAccessibility = enabled;\n            if (this.comboboxAccessibility) {\n                ui.inputBox.setAttribute('role', 'combobox');\n                ui.inputBox.setAttribute('aria-haspopup', 'true');\n                ui.inputBox.setAttribute('aria-autocomplete', 'list');\n                ui.inputBox.setAttribute('aria-activedescendant', ui.list.getActiveDescendant() || '');\n            }\n            else {\n                ui.inputBox.removeAttribute('role');\n                ui.inputBox.removeAttribute('aria-haspopup');\n                ui.inputBox.removeAttribute('aria-autocomplete');\n                ui.inputBox.removeAttribute('aria-activedescendant');\n            }\n        }\n    }\n    setEnabled(enabled) {\n        if (enabled !== this.enabled) {\n            this.enabled = enabled;\n            for (const item of this.getUI().leftActionBar.viewItems) {\n                item.getAction().enabled = enabled;\n            }\n            for (const item of this.getUI().rightActionBar.viewItems) {\n                item.getAction().enabled = enabled;\n            }\n            this.getUI().checkAll.disabled = !enabled;\n            // this.getUI().inputBox.enabled = enabled; Avoid loosing focus.\n            this.getUI().ok.enabled = enabled;\n            this.getUI().list.enabled = enabled;\n        }\n    }\n    hide(reason) {\n        var _a;\n        const controller = this.controller;\n        if (controller) {\n            const focusChanged = !((_a = this.ui) === null || _a === void 0 ? void 0 : _a.container.contains(document.activeElement));\n            this.controller = null;\n            this.onHideEmitter.fire();\n            this.getUI().container.style.display = 'none';\n            if (!focusChanged) {\n                let currentElement = this.previousFocusElement;\n                while (currentElement && !currentElement.offsetParent) {\n                    currentElement = withNullAsUndefined(currentElement.parentElement);\n                }\n                if (currentElement === null || currentElement === void 0 ? void 0 : currentElement.offsetParent) {\n                    currentElement.focus();\n                    this.previousFocusElement = undefined;\n                }\n                else {\n                    this.options.returnFocus();\n                }\n            }\n            controller.didHide(reason);\n        }\n    }\n    layout(dimension, titleBarOffset) {\n        this.dimension = dimension;\n        this.titleBarOffset = titleBarOffset;\n        this.updateLayout();\n    }\n    updateLayout() {\n        if (this.ui) {\n            this.ui.container.style.top = `${this.titleBarOffset}px`;\n            const style = this.ui.container.style;\n            const width = Math.min(this.dimension.width * 0.62 /* golden cut */, QuickInputController.MAX_WIDTH);\n            style.width = width + 'px';\n            style.marginLeft = '-' + (width / 2) + 'px';\n            this.ui.inputBox.layout();\n            this.ui.list.layout(this.dimension && this.dimension.height * 0.4);\n        }\n    }\n    applyStyles(styles) {\n        this.styles = styles;\n        this.updateStyles();\n    }\n    updateStyles() {\n        if (this.ui) {\n            const { quickInputTitleBackground, quickInputBackground, quickInputForeground, contrastBorder, widgetShadow, } = this.styles.widget;\n            this.ui.titleBar.style.backgroundColor = quickInputTitleBackground ? quickInputTitleBackground.toString() : '';\n            this.ui.container.style.backgroundColor = quickInputBackground ? quickInputBackground.toString() : '';\n            this.ui.container.style.color = quickInputForeground ? quickInputForeground.toString() : '';\n            this.ui.container.style.border = contrastBorder ? `1px solid ${contrastBorder}` : '';\n            this.ui.container.style.boxShadow = widgetShadow ? `0 0 8px 2px ${widgetShadow}` : '';\n            this.ui.inputBox.style(this.styles.inputBox);\n            this.ui.count.style(this.styles.countBadge);\n            this.ui.ok.style(this.styles.button);\n            this.ui.customButton.style(this.styles.button);\n            this.ui.progressBar.style(this.styles.progressBar);\n            this.ui.list.style(this.styles.list);\n            const content = [];\n            if (this.styles.list.pickerGroupBorder) {\n                content.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.list.pickerGroupBorder}; }`);\n            }\n            if (this.styles.list.pickerGroupForeground) {\n                content.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.list.pickerGroupForeground}; }`);\n            }\n            if (this.styles.keybindingLabel.keybindingLabelBackground ||\n                this.styles.keybindingLabel.keybindingLabelBorder ||\n                this.styles.keybindingLabel.keybindingLabelBottomBorder ||\n                this.styles.keybindingLabel.keybindingLabelShadow ||\n                this.styles.keybindingLabel.keybindingLabelForeground) {\n                content.push('.quick-input-list .monaco-keybinding > .monaco-keybinding-key {');\n                if (this.styles.keybindingLabel.keybindingLabelBackground) {\n                    content.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelBorder) {\n                    // Order matters here. `border-color` must come before `border-bottom-color`.\n                    content.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelBottomBorder) {\n                    content.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelShadow) {\n                    content.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelForeground) {\n                    content.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`);\n                }\n                content.push('}');\n            }\n            const newStyles = content.join('\\n');\n            if (newStyles !== this.ui.styleSheet.textContent) {\n                this.ui.styleSheet.textContent = newStyles;\n            }\n        }\n    }\n}\nQuickInputController.MAX_WIDTH = 600; // Max total width of quick input widget\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CombinedSpliceable {\n    constructor(spliceables) {\n        this.spliceables = spliceables;\n    }\n    splice(start, deleteCount, elements) {\n        this.spliceables.forEach(s => s.splice(start, deleteCount, elements));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ListError extends Error {\n    constructor(user, message) {\n        super(`ListError [${user}] ${message}`);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/range.js';\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\nexport function groupIntersect(range, groups) {\n    const result = [];\n    for (const r of groups) {\n        if (range.start >= r.range.end) {\n            continue;\n        }\n        if (range.end < r.range.start) {\n            break;\n        }\n        const intersection = Range.intersect(range, r.range);\n        if (Range.isEmpty(intersection)) {\n            continue;\n        }\n        result.push({\n            range: intersection,\n            size: r.size\n        });\n    }\n    return result;\n}\n/**\n * Shifts a range by that `much`.\n */\nexport function shift({ start, end }, much) {\n    return { start: start + much, end: end + much };\n}\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\nexport function consolidate(groups) {\n    const result = [];\n    let previousGroup = null;\n    for (const group of groups) {\n        const start = group.range.start;\n        const end = group.range.end;\n        const size = group.size;\n        if (previousGroup && size === previousGroup.size) {\n            previousGroup.range.end = end;\n            continue;\n        }\n        previousGroup = { range: { start, end }, size };\n        result.push(previousGroup);\n    }\n    return result;\n}\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\nfunction concat(...groups) {\n    return consolidate(groups.reduce((r, g) => r.concat(g), []));\n}\nexport class RangeMap {\n    constructor() {\n        this.groups = [];\n        this._size = 0;\n    }\n    splice(index, deleteCount, items = []) {\n        const diff = items.length - deleteCount;\n        const before = groupIntersect({ start: 0, end: index }, this.groups);\n        const after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\n            .map(g => ({ range: shift(g.range, diff), size: g.size }));\n        const middle = items.map((item, i) => ({\n            range: { start: index + i, end: index + i + 1 },\n            size: item.size\n        }));\n        this.groups = concat(before, middle, after);\n        this._size = this.groups.reduce((t, g) => t + (g.size * (g.range.end - g.range.start)), 0);\n    }\n    /**\n     * Returns the number of items in the range map.\n     */\n    get count() {\n        const len = this.groups.length;\n        if (!len) {\n            return 0;\n        }\n        return this.groups[len - 1].range.end;\n    }\n    /**\n     * Returns the sum of the sizes of all items in the range map.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Returns the index of the item at the given position.\n     */\n    indexAt(position) {\n        if (position < 0) {\n            return -1;\n        }\n        let index = 0;\n        let size = 0;\n        for (const group of this.groups) {\n            const count = group.range.end - group.range.start;\n            const newSize = size + (count * group.size);\n            if (position < newSize) {\n                return index + Math.floor((position - size) / group.size);\n            }\n            index += count;\n            size = newSize;\n        }\n        return index;\n    }\n    /**\n     * Returns the index of the item right after the item at the\n     * index of the given position.\n     */\n    indexAfter(position) {\n        return Math.min(this.indexAt(position) + 1, this.count);\n    }\n    /**\n     * Returns the start position of the item at the given index.\n     */\n    positionAt(index) {\n        if (index < 0) {\n            return -1;\n        }\n        let position = 0;\n        let count = 0;\n        for (const group of this.groups) {\n            const groupCount = group.range.end - group.range.start;\n            const newCount = count + groupCount;\n            if (index < newCount) {\n                return position + ((index - count) * group.size);\n            }\n            position += groupCount * group.size;\n            count = newCount;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $ } from '../../dom.js';\nfunction removeFromParent(element) {\n    var _a;\n    try {\n        (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(element);\n    }\n    catch (e) {\n        // this will throw if this happens due to a blur event, nasty business\n    }\n}\nexport class RowCache {\n    constructor(renderers) {\n        this.renderers = renderers;\n        this.cache = new Map();\n    }\n    /**\n     * Returns a row either by creating a new one or reusing\n     * a previously released row which shares the same templateId.\n     */\n    alloc(templateId) {\n        let result = this.getTemplateCache(templateId).pop();\n        if (!result) {\n            const domNode = $('.monaco-list-row');\n            const renderer = this.getRenderer(templateId);\n            const templateData = renderer.renderTemplate(domNode);\n            result = { domNode, templateId, templateData };\n        }\n        return result;\n    }\n    /**\n     * Releases the row for eventual reuse.\n     */\n    release(row) {\n        if (!row) {\n            return;\n        }\n        this.releaseRow(row);\n    }\n    releaseRow(row) {\n        const { domNode, templateId } = row;\n        if (domNode) {\n            domNode.classList.remove('scrolling');\n            removeFromParent(domNode);\n        }\n        const cache = this.getTemplateCache(templateId);\n        cache.push(row);\n    }\n    getTemplateCache(templateId) {\n        let result = this.cache.get(templateId);\n        if (!result) {\n            result = [];\n            this.cache.set(templateId, result);\n        }\n        return result;\n    }\n    dispose() {\n        this.cache.forEach((cachedRows, templateId) => {\n            for (const cachedRow of cachedRows) {\n                const renderer = this.getRenderer(templateId);\n                renderer.disposeTemplate(cachedRow.templateData);\n                cachedRow.templateData = null;\n            }\n        });\n        this.cache.clear();\n    }\n    getRenderer(templateId) {\n        const renderer = this.renderers.get(templateId);\n        if (!renderer) {\n            throw new Error(`No renderer found for ${templateId}`);\n        }\n        return renderer;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { isFirefox } from '../../browser.js';\nimport { DataTransfers, StaticDND } from '../../dnd.js';\nimport { $, addDisposableListener, animate, getContentHeight, getContentWidth, getTopLeftOffset, scheduleAtNextAnimationFrame } from '../../dom.js';\nimport { DomEmitter } from '../../event.js';\nimport { EventType as TouchEventType, Gesture } from '../../touch.js';\nimport { SmoothScrollableElement } from '../scrollbar/scrollableElement.js';\nimport { distinct, equals } from '../../../common/arrays.js';\nimport { Delayer, disposableTimeout } from '../../../common/async.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Disposable, DisposableStore, dispose, toDisposable } from '../../../common/lifecycle.js';\nimport { Range } from '../../../common/range.js';\nimport { Scrollable } from '../../../common/scrollable.js';\nimport { RangeMap, shift } from './rangeMap.js';\nimport { RowCache } from './rowCache.js';\nconst DefaultOptions = {\n    useShadows: true,\n    verticalScrollMode: 1 /* ScrollbarVisibility.Auto */,\n    setRowLineHeight: true,\n    setRowHeight: true,\n    supportDynamicHeights: false,\n    dnd: {\n        getDragElements(e) { return [e]; },\n        getDragURI() { return null; },\n        onDragStart() { },\n        onDragOver() { return false; },\n        drop() { }\n    },\n    horizontalScrolling: false,\n    transformOptimization: true,\n    alwaysConsumeMouseWheel: true,\n};\nexport class ElementsDragAndDropData {\n    constructor(elements) {\n        this.elements = elements;\n    }\n    update() { }\n    getData() {\n        return this.elements;\n    }\n}\nexport class ExternalElementsDragAndDropData {\n    constructor(elements) {\n        this.elements = elements;\n    }\n    update() { }\n    getData() {\n        return this.elements;\n    }\n}\nexport class NativeDragAndDropData {\n    constructor() {\n        this.types = [];\n        this.files = [];\n    }\n    update(dataTransfer) {\n        if (dataTransfer.types) {\n            this.types.splice(0, this.types.length, ...dataTransfer.types);\n        }\n        if (dataTransfer.files) {\n            this.files.splice(0, this.files.length);\n            for (let i = 0; i < dataTransfer.files.length; i++) {\n                const file = dataTransfer.files.item(i);\n                if (file && (file.size || file.type)) {\n                    this.files.push(file);\n                }\n            }\n        }\n    }\n    getData() {\n        return {\n            types: this.types,\n            files: this.files\n        };\n    }\n}\nfunction equalsDragFeedback(f1, f2) {\n    if (Array.isArray(f1) && Array.isArray(f2)) {\n        return equals(f1, f2);\n    }\n    return f1 === f2;\n}\nclass ListViewAccessibilityProvider {\n    constructor(accessibilityProvider) {\n        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getSetSize) {\n            this.getSetSize = accessibilityProvider.getSetSize.bind(accessibilityProvider);\n        }\n        else {\n            this.getSetSize = (e, i, l) => l;\n        }\n        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getPosInSet) {\n            this.getPosInSet = accessibilityProvider.getPosInSet.bind(accessibilityProvider);\n        }\n        else {\n            this.getPosInSet = (e, i) => i + 1;\n        }\n        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getRole) {\n            this.getRole = accessibilityProvider.getRole.bind(accessibilityProvider);\n        }\n        else {\n            this.getRole = _ => 'listitem';\n        }\n        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.isChecked) {\n            this.isChecked = accessibilityProvider.isChecked.bind(accessibilityProvider);\n        }\n        else {\n            this.isChecked = _ => undefined;\n        }\n    }\n}\n/**\n * The {@link ListView} is a virtual scrolling engine.\n *\n * Given that it only renders elements within its viewport, it can hold large\n * collections of elements and stay very performant. The performance bottleneck\n * usually lies within the user's rendering code for each element.\n *\n * @remarks It is a low-level widget, not meant to be used directly. Refer to the\n * List widget instead.\n */\nexport class ListView {\n    constructor(container, virtualDelegate, renderers, options = DefaultOptions) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        this.virtualDelegate = virtualDelegate;\n        this.domId = `list_id_${++ListView.InstanceCount}`;\n        this.renderers = new Map();\n        this.renderWidth = 0;\n        this._scrollHeight = 0;\n        this.scrollableElementUpdateDisposable = null;\n        this.scrollableElementWidthDelayer = new Delayer(50);\n        this.splicing = false;\n        this.dragOverAnimationStopDisposable = Disposable.None;\n        this.dragOverMouseY = 0;\n        this.canDrop = false;\n        this.currentDragFeedbackDisposable = Disposable.None;\n        this.onDragLeaveTimeout = Disposable.None;\n        this.disposables = new DisposableStore();\n        this._onDidChangeContentHeight = new Emitter();\n        this._horizontalScrolling = false;\n        if (options.horizontalScrolling && options.supportDynamicHeights) {\n            throw new Error('Horizontal scrolling and dynamic heights not supported simultaneously');\n        }\n        this.items = [];\n        this.itemId = 0;\n        this.rangeMap = new RangeMap();\n        for (const renderer of renderers) {\n            this.renderers.set(renderer.templateId, renderer);\n        }\n        this.cache = this.disposables.add(new RowCache(this.renderers));\n        this.lastRenderTop = 0;\n        this.lastRenderHeight = 0;\n        this.domNode = document.createElement('div');\n        this.domNode.className = 'monaco-list';\n        this.domNode.classList.add(this.domId);\n        this.domNode.tabIndex = 0;\n        this.domNode.classList.toggle('mouse-support', typeof options.mouseSupport === 'boolean' ? options.mouseSupport : true);\n        this._horizontalScrolling = (_a = options.horizontalScrolling) !== null && _a !== void 0 ? _a : DefaultOptions.horizontalScrolling;\n        this.domNode.classList.toggle('horizontal-scrolling', this._horizontalScrolling);\n        this.additionalScrollHeight = typeof options.additionalScrollHeight === 'undefined' ? 0 : options.additionalScrollHeight;\n        this.accessibilityProvider = new ListViewAccessibilityProvider(options.accessibilityProvider);\n        this.rowsContainer = document.createElement('div');\n        this.rowsContainer.className = 'monaco-list-rows';\n        const transformOptimization = (_b = options.transformOptimization) !== null && _b !== void 0 ? _b : DefaultOptions.transformOptimization;\n        if (transformOptimization) {\n            this.rowsContainer.style.transform = 'translate3d(0px, 0px, 0px)';\n        }\n        this.disposables.add(Gesture.addTarget(this.rowsContainer));\n        this.scrollable = new Scrollable({\n            forceIntegerValues: true,\n            smoothScrollDuration: ((_c = options.smoothScrolling) !== null && _c !== void 0 ? _c : false) ? 125 : 0,\n            scheduleAtNextAnimationFrame: cb => scheduleAtNextAnimationFrame(cb)\n        });\n        this.scrollableElement = this.disposables.add(new SmoothScrollableElement(this.rowsContainer, {\n            alwaysConsumeMouseWheel: (_d = options.alwaysConsumeMouseWheel) !== null && _d !== void 0 ? _d : DefaultOptions.alwaysConsumeMouseWheel,\n            horizontal: 1 /* ScrollbarVisibility.Auto */,\n            vertical: (_e = options.verticalScrollMode) !== null && _e !== void 0 ? _e : DefaultOptions.verticalScrollMode,\n            useShadows: (_f = options.useShadows) !== null && _f !== void 0 ? _f : DefaultOptions.useShadows,\n            mouseWheelScrollSensitivity: options.mouseWheelScrollSensitivity,\n            fastScrollSensitivity: options.fastScrollSensitivity\n        }, this.scrollable));\n        this.domNode.appendChild(this.scrollableElement.getDomNode());\n        container.appendChild(this.domNode);\n        this.scrollableElement.onScroll(this.onScroll, this, this.disposables);\n        this.disposables.add(addDisposableListener(this.rowsContainer, TouchEventType.Change, e => this.onTouchChange(e)));\n        // Prevent the monaco-scrollable-element from scrolling\n        // https://github.com/microsoft/vscode/issues/44181\n        this.disposables.add(addDisposableListener(this.scrollableElement.getDomNode(), 'scroll', e => e.target.scrollTop = 0));\n        this.disposables.add(addDisposableListener(this.domNode, 'dragover', e => this.onDragOver(this.toDragEvent(e))));\n        this.disposables.add(addDisposableListener(this.domNode, 'drop', e => this.onDrop(this.toDragEvent(e))));\n        this.disposables.add(addDisposableListener(this.domNode, 'dragleave', e => this.onDragLeave(this.toDragEvent(e))));\n        this.disposables.add(addDisposableListener(this.domNode, 'dragend', e => this.onDragEnd(e)));\n        this.setRowLineHeight = (_g = options.setRowLineHeight) !== null && _g !== void 0 ? _g : DefaultOptions.setRowLineHeight;\n        this.setRowHeight = (_h = options.setRowHeight) !== null && _h !== void 0 ? _h : DefaultOptions.setRowHeight;\n        this.supportDynamicHeights = (_j = options.supportDynamicHeights) !== null && _j !== void 0 ? _j : DefaultOptions.supportDynamicHeights;\n        this.dnd = (_k = options.dnd) !== null && _k !== void 0 ? _k : DefaultOptions.dnd;\n        this.layout();\n    }\n    get contentHeight() { return this.rangeMap.size; }\n    get horizontalScrolling() { return this._horizontalScrolling; }\n    set horizontalScrolling(value) {\n        if (value === this._horizontalScrolling) {\n            return;\n        }\n        if (value && this.supportDynamicHeights) {\n            throw new Error('Horizontal scrolling and dynamic heights not supported simultaneously');\n        }\n        this._horizontalScrolling = value;\n        this.domNode.classList.toggle('horizontal-scrolling', this._horizontalScrolling);\n        if (this._horizontalScrolling) {\n            for (const item of this.items) {\n                this.measureItemWidth(item);\n            }\n            this.updateScrollWidth();\n            this.scrollableElement.setScrollDimensions({ width: getContentWidth(this.domNode) });\n            this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;\n        }\n        else {\n            this.scrollableElementWidthDelayer.cancel();\n            this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth });\n            this.rowsContainer.style.width = '';\n        }\n    }\n    updateOptions(options) {\n        if (options.additionalScrollHeight !== undefined) {\n            this.additionalScrollHeight = options.additionalScrollHeight;\n            this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight });\n        }\n        if (options.smoothScrolling !== undefined) {\n            this.scrollable.setSmoothScrollDuration(options.smoothScrolling ? 125 : 0);\n        }\n        if (options.horizontalScrolling !== undefined) {\n            this.horizontalScrolling = options.horizontalScrolling;\n        }\n        if (options.mouseWheelScrollSensitivity !== undefined) {\n            this.scrollableElement.updateOptions({ mouseWheelScrollSensitivity: options.mouseWheelScrollSensitivity });\n        }\n        if (options.fastScrollSensitivity !== undefined) {\n            this.scrollableElement.updateOptions({ fastScrollSensitivity: options.fastScrollSensitivity });\n        }\n    }\n    splice(start, deleteCount, elements = []) {\n        if (this.splicing) {\n            throw new Error('Can\\'t run recursive splices.');\n        }\n        this.splicing = true;\n        try {\n            return this._splice(start, deleteCount, elements);\n        }\n        finally {\n            this.splicing = false;\n            this._onDidChangeContentHeight.fire(this.contentHeight);\n        }\n    }\n    _splice(start, deleteCount, elements = []) {\n        const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);\n        const deleteRange = { start, end: start + deleteCount };\n        const removeRange = Range.intersect(previousRenderRange, deleteRange);\n        // try to reuse rows, avoid removing them from DOM\n        const rowsToDispose = new Map();\n        for (let i = removeRange.end - 1; i >= removeRange.start; i--) {\n            const item = this.items[i];\n            item.dragStartDisposable.dispose();\n            item.checkedDisposable.dispose();\n            if (item.row) {\n                let rows = rowsToDispose.get(item.templateId);\n                if (!rows) {\n                    rows = [];\n                    rowsToDispose.set(item.templateId, rows);\n                }\n                const renderer = this.renderers.get(item.templateId);\n                if (renderer && renderer.disposeElement) {\n                    renderer.disposeElement(item.element, i, item.row.templateData, item.size);\n                }\n                rows.push(item.row);\n            }\n            item.row = null;\n        }\n        const previousRestRange = { start: start + deleteCount, end: this.items.length };\n        const previousRenderedRestRange = Range.intersect(previousRestRange, previousRenderRange);\n        const previousUnrenderedRestRanges = Range.relativeComplement(previousRestRange, previousRenderRange);\n        const inserted = elements.map(element => ({\n            id: String(this.itemId++),\n            element,\n            templateId: this.virtualDelegate.getTemplateId(element),\n            size: this.virtualDelegate.getHeight(element),\n            width: undefined,\n            hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(element),\n            lastDynamicHeightWidth: undefined,\n            row: null,\n            uri: undefined,\n            dropTarget: false,\n            dragStartDisposable: Disposable.None,\n            checkedDisposable: Disposable.None\n        }));\n        let deleted;\n        // TODO@joao: improve this optimization to catch even more cases\n        if (start === 0 && deleteCount >= this.items.length) {\n            this.rangeMap = new RangeMap();\n            this.rangeMap.splice(0, 0, inserted);\n            deleted = this.items;\n            this.items = inserted;\n        }\n        else {\n            this.rangeMap.splice(start, deleteCount, inserted);\n            deleted = this.items.splice(start, deleteCount, ...inserted);\n        }\n        const delta = elements.length - deleteCount;\n        const renderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);\n        const renderedRestRange = shift(previousRenderedRestRange, delta);\n        const updateRange = Range.intersect(renderRange, renderedRestRange);\n        for (let i = updateRange.start; i < updateRange.end; i++) {\n            this.updateItemInDOM(this.items[i], i);\n        }\n        const removeRanges = Range.relativeComplement(renderedRestRange, renderRange);\n        for (const range of removeRanges) {\n            for (let i = range.start; i < range.end; i++) {\n                this.removeItemFromDOM(i);\n            }\n        }\n        const unrenderedRestRanges = previousUnrenderedRestRanges.map(r => shift(r, delta));\n        const elementsRange = { start, end: start + elements.length };\n        const insertRanges = [elementsRange, ...unrenderedRestRanges].map(r => Range.intersect(renderRange, r));\n        const beforeElement = this.getNextToLastElement(insertRanges);\n        for (const range of insertRanges) {\n            for (let i = range.start; i < range.end; i++) {\n                const item = this.items[i];\n                const rows = rowsToDispose.get(item.templateId);\n                const row = rows === null || rows === void 0 ? void 0 : rows.pop();\n                this.insertItemInDOM(i, beforeElement, row);\n            }\n        }\n        for (const rows of rowsToDispose.values()) {\n            for (const row of rows) {\n                this.cache.release(row);\n            }\n        }\n        this.eventuallyUpdateScrollDimensions();\n        if (this.supportDynamicHeights) {\n            this._rerender(this.scrollTop, this.renderHeight);\n        }\n        return deleted.map(i => i.element);\n    }\n    eventuallyUpdateScrollDimensions() {\n        this._scrollHeight = this.contentHeight;\n        this.rowsContainer.style.height = `${this._scrollHeight}px`;\n        if (!this.scrollableElementUpdateDisposable) {\n            this.scrollableElementUpdateDisposable = scheduleAtNextAnimationFrame(() => {\n                this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight });\n                this.updateScrollWidth();\n                this.scrollableElementUpdateDisposable = null;\n            });\n        }\n    }\n    eventuallyUpdateScrollWidth() {\n        if (!this.horizontalScrolling) {\n            this.scrollableElementWidthDelayer.cancel();\n            return;\n        }\n        this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());\n    }\n    updateScrollWidth() {\n        if (!this.horizontalScrolling) {\n            return;\n        }\n        let scrollWidth = 0;\n        for (const item of this.items) {\n            if (typeof item.width !== 'undefined') {\n                scrollWidth = Math.max(scrollWidth, item.width);\n            }\n        }\n        this.scrollWidth = scrollWidth;\n        this.scrollableElement.setScrollDimensions({ scrollWidth: scrollWidth === 0 ? 0 : (scrollWidth + 10) });\n    }\n    rerender() {\n        if (!this.supportDynamicHeights) {\n            return;\n        }\n        for (const item of this.items) {\n            item.lastDynamicHeightWidth = undefined;\n        }\n        this._rerender(this.lastRenderTop, this.lastRenderHeight);\n    }\n    get length() {\n        return this.items.length;\n    }\n    get renderHeight() {\n        const scrollDimensions = this.scrollableElement.getScrollDimensions();\n        return scrollDimensions.height;\n    }\n    element(index) {\n        return this.items[index].element;\n    }\n    domElement(index) {\n        const row = this.items[index].row;\n        return row && row.domNode;\n    }\n    elementHeight(index) {\n        return this.items[index].size;\n    }\n    elementTop(index) {\n        return this.rangeMap.positionAt(index);\n    }\n    indexAt(position) {\n        return this.rangeMap.indexAt(position);\n    }\n    indexAfter(position) {\n        return this.rangeMap.indexAfter(position);\n    }\n    layout(height, width) {\n        const scrollDimensions = {\n            height: typeof height === 'number' ? height : getContentHeight(this.domNode)\n        };\n        if (this.scrollableElementUpdateDisposable) {\n            this.scrollableElementUpdateDisposable.dispose();\n            this.scrollableElementUpdateDisposable = null;\n            scrollDimensions.scrollHeight = this.scrollHeight;\n        }\n        this.scrollableElement.setScrollDimensions(scrollDimensions);\n        if (typeof width !== 'undefined') {\n            this.renderWidth = width;\n            if (this.supportDynamicHeights) {\n                this._rerender(this.scrollTop, this.renderHeight);\n            }\n        }\n        if (this.horizontalScrolling) {\n            this.scrollableElement.setScrollDimensions({\n                width: typeof width === 'number' ? width : getContentWidth(this.domNode)\n            });\n        }\n    }\n    // Render\n    render(previousRenderRange, renderTop, renderHeight, renderLeft, scrollWidth, updateItemsInDOM = false) {\n        const renderRange = this.getRenderRange(renderTop, renderHeight);\n        const rangesToInsert = Range.relativeComplement(renderRange, previousRenderRange);\n        const rangesToRemove = Range.relativeComplement(previousRenderRange, renderRange);\n        const beforeElement = this.getNextToLastElement(rangesToInsert);\n        if (updateItemsInDOM) {\n            const rangesToUpdate = Range.intersect(previousRenderRange, renderRange);\n            for (let i = rangesToUpdate.start; i < rangesToUpdate.end; i++) {\n                this.updateItemInDOM(this.items[i], i);\n            }\n        }\n        for (const range of rangesToInsert) {\n            for (let i = range.start; i < range.end; i++) {\n                this.insertItemInDOM(i, beforeElement);\n            }\n        }\n        for (const range of rangesToRemove) {\n            for (let i = range.start; i < range.end; i++) {\n                this.removeItemFromDOM(i);\n            }\n        }\n        if (renderLeft !== undefined) {\n            this.rowsContainer.style.left = `-${renderLeft}px`;\n        }\n        this.rowsContainer.style.top = `-${renderTop}px`;\n        if (this.horizontalScrolling && scrollWidth !== undefined) {\n            this.rowsContainer.style.width = `${Math.max(scrollWidth, this.renderWidth)}px`;\n        }\n        this.lastRenderTop = renderTop;\n        this.lastRenderHeight = renderHeight;\n    }\n    // DOM operations\n    insertItemInDOM(index, beforeElement, row) {\n        const item = this.items[index];\n        if (!item.row) {\n            item.row = row !== null && row !== void 0 ? row : this.cache.alloc(item.templateId);\n        }\n        const role = this.accessibilityProvider.getRole(item.element) || 'listitem';\n        item.row.domNode.setAttribute('role', role);\n        const checked = this.accessibilityProvider.isChecked(item.element);\n        if (typeof checked === 'boolean') {\n            item.row.domNode.setAttribute('aria-checked', String(!!checked));\n        }\n        else if (checked) {\n            const update = (checked) => item.row.domNode.setAttribute('aria-checked', String(!!checked));\n            update(checked.value);\n            item.checkedDisposable = checked.onDidChange(update);\n        }\n        if (!item.row.domNode.parentElement) {\n            if (beforeElement) {\n                this.rowsContainer.insertBefore(item.row.domNode, beforeElement);\n            }\n            else {\n                this.rowsContainer.appendChild(item.row.domNode);\n            }\n        }\n        this.updateItemInDOM(item, index);\n        const renderer = this.renderers.get(item.templateId);\n        if (!renderer) {\n            throw new Error(`No renderer found for template id ${item.templateId}`);\n        }\n        renderer === null || renderer === void 0 ? void 0 : renderer.renderElement(item.element, index, item.row.templateData, item.size);\n        const uri = this.dnd.getDragURI(item.element);\n        item.dragStartDisposable.dispose();\n        item.row.domNode.draggable = !!uri;\n        if (uri) {\n            item.dragStartDisposable = addDisposableListener(item.row.domNode, 'dragstart', event => this.onDragStart(item.element, uri, event));\n        }\n        if (this.horizontalScrolling) {\n            this.measureItemWidth(item);\n            this.eventuallyUpdateScrollWidth();\n        }\n    }\n    measureItemWidth(item) {\n        if (!item.row || !item.row.domNode) {\n            return;\n        }\n        item.row.domNode.style.width = isFirefox ? '-moz-fit-content' : 'fit-content';\n        item.width = getContentWidth(item.row.domNode);\n        const style = window.getComputedStyle(item.row.domNode);\n        if (style.paddingLeft) {\n            item.width += parseFloat(style.paddingLeft);\n        }\n        if (style.paddingRight) {\n            item.width += parseFloat(style.paddingRight);\n        }\n        item.row.domNode.style.width = '';\n    }\n    updateItemInDOM(item, index) {\n        item.row.domNode.style.top = `${this.elementTop(index)}px`;\n        if (this.setRowHeight) {\n            item.row.domNode.style.height = `${item.size}px`;\n        }\n        if (this.setRowLineHeight) {\n            item.row.domNode.style.lineHeight = `${item.size}px`;\n        }\n        item.row.domNode.setAttribute('data-index', `${index}`);\n        item.row.domNode.setAttribute('data-last-element', index === this.length - 1 ? 'true' : 'false');\n        item.row.domNode.setAttribute('data-parity', index % 2 === 0 ? 'even' : 'odd');\n        item.row.domNode.setAttribute('aria-setsize', String(this.accessibilityProvider.getSetSize(item.element, index, this.length)));\n        item.row.domNode.setAttribute('aria-posinset', String(this.accessibilityProvider.getPosInSet(item.element, index)));\n        item.row.domNode.setAttribute('id', this.getElementDomId(index));\n        item.row.domNode.classList.toggle('drop-target', item.dropTarget);\n    }\n    removeItemFromDOM(index) {\n        const item = this.items[index];\n        item.dragStartDisposable.dispose();\n        item.checkedDisposable.dispose();\n        if (item.row) {\n            const renderer = this.renderers.get(item.templateId);\n            if (renderer && renderer.disposeElement) {\n                renderer.disposeElement(item.element, index, item.row.templateData, item.size);\n            }\n            this.cache.release(item.row);\n            item.row = null;\n        }\n        if (this.horizontalScrolling) {\n            this.eventuallyUpdateScrollWidth();\n        }\n    }\n    getScrollTop() {\n        const scrollPosition = this.scrollableElement.getScrollPosition();\n        return scrollPosition.scrollTop;\n    }\n    setScrollTop(scrollTop, reuseAnimation) {\n        if (this.scrollableElementUpdateDisposable) {\n            this.scrollableElementUpdateDisposable.dispose();\n            this.scrollableElementUpdateDisposable = null;\n            this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight });\n        }\n        this.scrollableElement.setScrollPosition({ scrollTop, reuseAnimation });\n    }\n    get scrollTop() {\n        return this.getScrollTop();\n    }\n    set scrollTop(scrollTop) {\n        this.setScrollTop(scrollTop);\n    }\n    get scrollHeight() {\n        return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.additionalScrollHeight;\n    }\n    // Events\n    get onMouseClick() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'click')).event, e => this.toMouseEvent(e), this.disposables); }\n    get onMouseDblClick() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'dblclick')).event, e => this.toMouseEvent(e), this.disposables); }\n    get onMouseMiddleClick() { return Event.filter(Event.map(this.disposables.add(new DomEmitter(this.domNode, 'auxclick')).event, e => this.toMouseEvent(e), this.disposables), e => e.browserEvent.button === 1, this.disposables); }\n    get onMouseDown() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mousedown')).event, e => this.toMouseEvent(e), this.disposables); }\n    get onMouseOver() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mouseover')).event, e => this.toMouseEvent(e), this.disposables); }\n    get onContextMenu() { return Event.any(Event.map(this.disposables.add(new DomEmitter(this.domNode, 'contextmenu')).event, e => this.toMouseEvent(e), this.disposables), Event.map(this.disposables.add(new DomEmitter(this.domNode, TouchEventType.Contextmenu)).event, e => this.toGestureEvent(e), this.disposables)); }\n    get onTouchStart() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'touchstart')).event, e => this.toTouchEvent(e), this.disposables); }\n    get onTap() { return Event.map(this.disposables.add(new DomEmitter(this.rowsContainer, TouchEventType.Tap)).event, e => this.toGestureEvent(e), this.disposables); }\n    toMouseEvent(browserEvent) {\n        const index = this.getItemIndexFromEventTarget(browserEvent.target || null);\n        const item = typeof index === 'undefined' ? undefined : this.items[index];\n        const element = item && item.element;\n        return { browserEvent, index, element };\n    }\n    toTouchEvent(browserEvent) {\n        const index = this.getItemIndexFromEventTarget(browserEvent.target || null);\n        const item = typeof index === 'undefined' ? undefined : this.items[index];\n        const element = item && item.element;\n        return { browserEvent, index, element };\n    }\n    toGestureEvent(browserEvent) {\n        const index = this.getItemIndexFromEventTarget(browserEvent.initialTarget || null);\n        const item = typeof index === 'undefined' ? undefined : this.items[index];\n        const element = item && item.element;\n        return { browserEvent, index, element };\n    }\n    toDragEvent(browserEvent) {\n        const index = this.getItemIndexFromEventTarget(browserEvent.target || null);\n        const item = typeof index === 'undefined' ? undefined : this.items[index];\n        const element = item && item.element;\n        return { browserEvent, index, element };\n    }\n    onScroll(e) {\n        try {\n            const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);\n            this.render(previousRenderRange, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth);\n            if (this.supportDynamicHeights) {\n                this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);\n            }\n        }\n        catch (err) {\n            console.error('Got bad scroll event:', e);\n            throw err;\n        }\n    }\n    onTouchChange(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.scrollTop -= event.translationY;\n    }\n    // DND\n    onDragStart(element, uri, event) {\n        var _a, _b;\n        if (!event.dataTransfer) {\n            return;\n        }\n        const elements = this.dnd.getDragElements(element);\n        event.dataTransfer.effectAllowed = 'copyMove';\n        event.dataTransfer.setData(DataTransfers.TEXT, uri);\n        if (event.dataTransfer.setDragImage) {\n            let label;\n            if (this.dnd.getDragLabel) {\n                label = this.dnd.getDragLabel(elements, event);\n            }\n            if (typeof label === 'undefined') {\n                label = String(elements.length);\n            }\n            const dragImage = $('.monaco-drag-image');\n            dragImage.textContent = label;\n            document.body.appendChild(dragImage);\n            event.dataTransfer.setDragImage(dragImage, -10, -10);\n            setTimeout(() => document.body.removeChild(dragImage), 0);\n        }\n        this.currentDragData = new ElementsDragAndDropData(elements);\n        StaticDND.CurrentDragAndDropData = new ExternalElementsDragAndDropData(elements);\n        (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, this.currentDragData, event);\n    }\n    onDragOver(event) {\n        var _a;\n        event.browserEvent.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)\n        this.onDragLeaveTimeout.dispose();\n        if (StaticDND.CurrentDragAndDropData && StaticDND.CurrentDragAndDropData.getData() === 'vscode-ui') {\n            return false;\n        }\n        this.setupDragAndDropScrollTopAnimation(event.browserEvent);\n        if (!event.browserEvent.dataTransfer) {\n            return false;\n        }\n        // Drag over from outside\n        if (!this.currentDragData) {\n            if (StaticDND.CurrentDragAndDropData) {\n                // Drag over from another list\n                this.currentDragData = StaticDND.CurrentDragAndDropData;\n            }\n            else {\n                // Drag over from the desktop\n                if (!event.browserEvent.dataTransfer.types) {\n                    return false;\n                }\n                this.currentDragData = new NativeDragAndDropData();\n            }\n        }\n        const result = this.dnd.onDragOver(this.currentDragData, event.element, event.index, event.browserEvent);\n        this.canDrop = typeof result === 'boolean' ? result : result.accept;\n        if (!this.canDrop) {\n            this.currentDragFeedback = undefined;\n            this.currentDragFeedbackDisposable.dispose();\n            return false;\n        }\n        event.browserEvent.dataTransfer.dropEffect = (typeof result !== 'boolean' && result.effect === 0 /* ListDragOverEffect.Copy */) ? 'copy' : 'move';\n        let feedback;\n        if (typeof result !== 'boolean' && result.feedback) {\n            feedback = result.feedback;\n        }\n        else {\n            if (typeof event.index === 'undefined') {\n                feedback = [-1];\n            }\n            else {\n                feedback = [event.index];\n            }\n        }\n        // sanitize feedback list\n        feedback = distinct(feedback).filter(i => i >= -1 && i < this.length).sort((a, b) => a - b);\n        feedback = feedback[0] === -1 ? [-1] : feedback;\n        if (equalsDragFeedback(this.currentDragFeedback, feedback)) {\n            return true;\n        }\n        this.currentDragFeedback = feedback;\n        this.currentDragFeedbackDisposable.dispose();\n        if (feedback[0] === -1) { // entire list feedback\n            this.domNode.classList.add('drop-target');\n            this.rowsContainer.classList.add('drop-target');\n            this.currentDragFeedbackDisposable = toDisposable(() => {\n                this.domNode.classList.remove('drop-target');\n                this.rowsContainer.classList.remove('drop-target');\n            });\n        }\n        else {\n            for (const index of feedback) {\n                const item = this.items[index];\n                item.dropTarget = true;\n                (_a = item.row) === null || _a === void 0 ? void 0 : _a.domNode.classList.add('drop-target');\n            }\n            this.currentDragFeedbackDisposable = toDisposable(() => {\n                var _a;\n                for (const index of feedback) {\n                    const item = this.items[index];\n                    item.dropTarget = false;\n                    (_a = item.row) === null || _a === void 0 ? void 0 : _a.domNode.classList.remove('drop-target');\n                }\n            });\n        }\n        return true;\n    }\n    onDragLeave(event) {\n        var _a, _b;\n        this.onDragLeaveTimeout.dispose();\n        this.onDragLeaveTimeout = disposableTimeout(() => this.clearDragOverFeedback(), 100);\n        if (this.currentDragData) {\n            (_b = (_a = this.dnd).onDragLeave) === null || _b === void 0 ? void 0 : _b.call(_a, this.currentDragData, event.element, event.index, event.browserEvent);\n        }\n    }\n    onDrop(event) {\n        if (!this.canDrop) {\n            return;\n        }\n        const dragData = this.currentDragData;\n        this.teardownDragAndDropScrollTopAnimation();\n        this.clearDragOverFeedback();\n        this.currentDragData = undefined;\n        StaticDND.CurrentDragAndDropData = undefined;\n        if (!dragData || !event.browserEvent.dataTransfer) {\n            return;\n        }\n        event.browserEvent.preventDefault();\n        dragData.update(event.browserEvent.dataTransfer);\n        this.dnd.drop(dragData, event.element, event.index, event.browserEvent);\n    }\n    onDragEnd(event) {\n        var _a, _b;\n        this.canDrop = false;\n        this.teardownDragAndDropScrollTopAnimation();\n        this.clearDragOverFeedback();\n        this.currentDragData = undefined;\n        StaticDND.CurrentDragAndDropData = undefined;\n        (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    }\n    clearDragOverFeedback() {\n        this.currentDragFeedback = undefined;\n        this.currentDragFeedbackDisposable.dispose();\n        this.currentDragFeedbackDisposable = Disposable.None;\n    }\n    // DND scroll top animation\n    setupDragAndDropScrollTopAnimation(event) {\n        if (!this.dragOverAnimationDisposable) {\n            const viewTop = getTopLeftOffset(this.domNode).top;\n            this.dragOverAnimationDisposable = animate(this.animateDragAndDropScrollTop.bind(this, viewTop));\n        }\n        this.dragOverAnimationStopDisposable.dispose();\n        this.dragOverAnimationStopDisposable = disposableTimeout(() => {\n            if (this.dragOverAnimationDisposable) {\n                this.dragOverAnimationDisposable.dispose();\n                this.dragOverAnimationDisposable = undefined;\n            }\n        }, 1000);\n        this.dragOverMouseY = event.pageY;\n    }\n    animateDragAndDropScrollTop(viewTop) {\n        if (this.dragOverMouseY === undefined) {\n            return;\n        }\n        const diff = this.dragOverMouseY - viewTop;\n        const upperLimit = this.renderHeight - 35;\n        if (diff < 35) {\n            this.scrollTop += Math.max(-14, Math.floor(0.3 * (diff - 35)));\n        }\n        else if (diff > upperLimit) {\n            this.scrollTop += Math.min(14, Math.floor(0.3 * (diff - upperLimit)));\n        }\n    }\n    teardownDragAndDropScrollTopAnimation() {\n        this.dragOverAnimationStopDisposable.dispose();\n        if (this.dragOverAnimationDisposable) {\n            this.dragOverAnimationDisposable.dispose();\n            this.dragOverAnimationDisposable = undefined;\n        }\n    }\n    // Util\n    getItemIndexFromEventTarget(target) {\n        const scrollableElement = this.scrollableElement.getDomNode();\n        let element = target;\n        while (element instanceof HTMLElement && element !== this.rowsContainer && scrollableElement.contains(element)) {\n            const rawIndex = element.getAttribute('data-index');\n            if (rawIndex) {\n                const index = Number(rawIndex);\n                if (!isNaN(index)) {\n                    return index;\n                }\n            }\n            element = element.parentElement;\n        }\n        return undefined;\n    }\n    getRenderRange(renderTop, renderHeight) {\n        return {\n            start: this.rangeMap.indexAt(renderTop),\n            end: this.rangeMap.indexAfter(renderTop + renderHeight - 1)\n        };\n    }\n    /**\n     * Given a stable rendered state, checks every rendered element whether it needs\n     * to be probed for dynamic height. Adjusts scroll height and top if necessary.\n     */\n    _rerender(renderTop, renderHeight, inSmoothScrolling) {\n        const previousRenderRange = this.getRenderRange(renderTop, renderHeight);\n        // Let's remember the second element's position, this helps in scrolling up\n        // and preserving a linear upwards scroll movement\n        let anchorElementIndex;\n        let anchorElementTopDelta;\n        if (renderTop === this.elementTop(previousRenderRange.start)) {\n            anchorElementIndex = previousRenderRange.start;\n            anchorElementTopDelta = 0;\n        }\n        else if (previousRenderRange.end - previousRenderRange.start > 1) {\n            anchorElementIndex = previousRenderRange.start + 1;\n            anchorElementTopDelta = this.elementTop(anchorElementIndex) - renderTop;\n        }\n        let heightDiff = 0;\n        while (true) {\n            const renderRange = this.getRenderRange(renderTop, renderHeight);\n            let didChange = false;\n            for (let i = renderRange.start; i < renderRange.end; i++) {\n                const diff = this.probeDynamicHeight(i);\n                if (diff !== 0) {\n                    this.rangeMap.splice(i, 1, [this.items[i]]);\n                }\n                heightDiff += diff;\n                didChange = didChange || diff !== 0;\n            }\n            if (!didChange) {\n                if (heightDiff !== 0) {\n                    this.eventuallyUpdateScrollDimensions();\n                }\n                const unrenderRanges = Range.relativeComplement(previousRenderRange, renderRange);\n                for (const range of unrenderRanges) {\n                    for (let i = range.start; i < range.end; i++) {\n                        if (this.items[i].row) {\n                            this.removeItemFromDOM(i);\n                        }\n                    }\n                }\n                const renderRanges = Range.relativeComplement(renderRange, previousRenderRange);\n                for (const range of renderRanges) {\n                    for (let i = range.start; i < range.end; i++) {\n                        const afterIndex = i + 1;\n                        const beforeRow = afterIndex < this.items.length ? this.items[afterIndex].row : null;\n                        const beforeElement = beforeRow ? beforeRow.domNode : null;\n                        this.insertItemInDOM(i, beforeElement);\n                    }\n                }\n                for (let i = renderRange.start; i < renderRange.end; i++) {\n                    if (this.items[i].row) {\n                        this.updateItemInDOM(this.items[i], i);\n                    }\n                }\n                if (typeof anchorElementIndex === 'number') {\n                    // To compute a destination scroll top, we need to take into account the current smooth scrolling\n                    // animation, and then reuse it with a new target (to avoid prolonging the scroll)\n                    // See https://github.com/microsoft/vscode/issues/104144\n                    // See https://github.com/microsoft/vscode/pull/104284\n                    // See https://github.com/microsoft/vscode/issues/107704\n                    const deltaScrollTop = this.scrollable.getFutureScrollPosition().scrollTop - renderTop;\n                    const newScrollTop = this.elementTop(anchorElementIndex) - anchorElementTopDelta + deltaScrollTop;\n                    this.setScrollTop(newScrollTop, inSmoothScrolling);\n                }\n                this._onDidChangeContentHeight.fire(this.contentHeight);\n                return;\n            }\n        }\n    }\n    probeDynamicHeight(index) {\n        var _a, _b, _c;\n        const item = this.items[index];\n        if (!!this.virtualDelegate.getDynamicHeight) {\n            const newSize = this.virtualDelegate.getDynamicHeight(item.element);\n            if (newSize !== null) {\n                const size = item.size;\n                item.size = newSize;\n                item.lastDynamicHeightWidth = this.renderWidth;\n                return newSize - size;\n            }\n        }\n        if (!item.hasDynamicHeight || item.lastDynamicHeightWidth === this.renderWidth) {\n            return 0;\n        }\n        if (!!this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(item.element)) {\n            return 0;\n        }\n        const size = item.size;\n        if (!this.setRowHeight && item.row) {\n            const newSize = item.row.domNode.offsetHeight;\n            item.size = newSize;\n            item.lastDynamicHeightWidth = this.renderWidth;\n            return newSize - size;\n        }\n        const row = this.cache.alloc(item.templateId);\n        row.domNode.style.height = '';\n        this.rowsContainer.appendChild(row.domNode);\n        const renderer = this.renderers.get(item.templateId);\n        if (renderer) {\n            renderer.renderElement(item.element, index, row.templateData, undefined);\n            (_a = renderer.disposeElement) === null || _a === void 0 ? void 0 : _a.call(renderer, item.element, index, row.templateData, undefined);\n        }\n        item.size = row.domNode.offsetHeight;\n        (_c = (_b = this.virtualDelegate).setDynamicHeight) === null || _c === void 0 ? void 0 : _c.call(_b, item.element, item.size);\n        item.lastDynamicHeightWidth = this.renderWidth;\n        this.rowsContainer.removeChild(row.domNode);\n        this.cache.release(row);\n        return item.size - size;\n    }\n    getNextToLastElement(ranges) {\n        const lastRange = ranges[ranges.length - 1];\n        if (!lastRange) {\n            return null;\n        }\n        const nextToLastItem = this.items[lastRange.end];\n        if (!nextToLastItem) {\n            return null;\n        }\n        if (!nextToLastItem.row) {\n            return null;\n        }\n        return nextToLastItem.row.domNode;\n    }\n    getElementDomId(index) {\n        return `${this.domId}_${index}`;\n    }\n    // Dispose\n    dispose() {\n        var _a;\n        if (this.items) {\n            for (const item of this.items) {\n                if (item.row) {\n                    const renderer = this.renderers.get(item.row.templateId);\n                    if (renderer) {\n                        (_a = renderer.disposeElement) === null || _a === void 0 ? void 0 : _a.call(renderer, item.element, -1, item.row.templateData, undefined);\n                        renderer.disposeTemplate(item.row.templateData);\n                    }\n                }\n            }\n            this.items = [];\n        }\n        if (this.domNode && this.domNode.parentNode) {\n            this.domNode.parentNode.removeChild(this.domNode);\n        }\n        dispose(this.disposables);\n    }\n}\nListView.InstanceCount = 0;\n__decorate([\n    memoize\n], ListView.prototype, \"onMouseClick\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onMouseDblClick\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onMouseMiddleClick\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onMouseDown\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onMouseOver\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onContextMenu\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onTouchStart\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onTap\", null);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { createStyleSheet } from '../../dom.js';\nimport { DomEmitter, stopEvent } from '../../event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { Gesture } from '../../touch.js';\nimport { alert } from '../aria/aria.js';\nimport { CombinedSpliceable } from './splice.js';\nimport { binarySearch, firstOrDefault, range } from '../../../common/arrays.js';\nimport { timeout } from '../../../common/async.js';\nimport { Color } from '../../../common/color.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { Emitter, Event, EventBufferer } from '../../../common/event.js';\nimport { matchesPrefix } from '../../../common/filters.js';\nimport { DisposableStore, dispose } from '../../../common/lifecycle.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { mixin } from '../../../common/objects.js';\nimport * as platform from '../../../common/platform.js';\nimport { isNumber } from '../../../common/types.js';\nimport './list.css';\nimport { ListError } from './list.js';\nimport { ListView } from './listView.js';\nclass TraitRenderer {\n    constructor(trait) {\n        this.trait = trait;\n        this.renderedElements = [];\n    }\n    get templateId() {\n        return `template:${this.trait.name}`;\n    }\n    renderTemplate(container) {\n        return container;\n    }\n    renderElement(element, index, templateData) {\n        const renderedElementIndex = this.renderedElements.findIndex(el => el.templateData === templateData);\n        if (renderedElementIndex >= 0) {\n            const rendered = this.renderedElements[renderedElementIndex];\n            this.trait.unrender(templateData);\n            rendered.index = index;\n        }\n        else {\n            const rendered = { index, templateData };\n            this.renderedElements.push(rendered);\n        }\n        this.trait.renderIndex(index, templateData);\n    }\n    splice(start, deleteCount, insertCount) {\n        const rendered = [];\n        for (const renderedElement of this.renderedElements) {\n            if (renderedElement.index < start) {\n                rendered.push(renderedElement);\n            }\n            else if (renderedElement.index >= start + deleteCount) {\n                rendered.push({\n                    index: renderedElement.index + insertCount - deleteCount,\n                    templateData: renderedElement.templateData\n                });\n            }\n        }\n        this.renderedElements = rendered;\n    }\n    renderIndexes(indexes) {\n        for (const { index, templateData } of this.renderedElements) {\n            if (indexes.indexOf(index) > -1) {\n                this.trait.renderIndex(index, templateData);\n            }\n        }\n    }\n    disposeTemplate(templateData) {\n        const index = this.renderedElements.findIndex(el => el.templateData === templateData);\n        if (index < 0) {\n            return;\n        }\n        this.renderedElements.splice(index, 1);\n    }\n}\nclass Trait {\n    constructor(_trait) {\n        this._trait = _trait;\n        this.length = 0;\n        this.indexes = [];\n        this.sortedIndexes = [];\n        this._onChange = new Emitter();\n        this.onChange = this._onChange.event;\n    }\n    get name() { return this._trait; }\n    get renderer() {\n        return new TraitRenderer(this);\n    }\n    splice(start, deleteCount, elements) {\n        var _a;\n        deleteCount = Math.max(0, Math.min(deleteCount, this.length - start));\n        const diff = elements.length - deleteCount;\n        const end = start + deleteCount;\n        const sortedIndexes = [\n            ...this.sortedIndexes.filter(i => i < start),\n            ...elements.map((hasTrait, i) => hasTrait ? i + start : -1).filter(i => i !== -1),\n            ...this.sortedIndexes.filter(i => i >= end).map(i => i + diff)\n        ];\n        const length = this.length + diff;\n        if (this.sortedIndexes.length > 0 && sortedIndexes.length === 0 && length > 0) {\n            const first = (_a = this.sortedIndexes.find(index => index >= start)) !== null && _a !== void 0 ? _a : length - 1;\n            sortedIndexes.push(Math.min(first, length - 1));\n        }\n        this.renderer.splice(start, deleteCount, elements.length);\n        this._set(sortedIndexes, sortedIndexes);\n        this.length = length;\n    }\n    renderIndex(index, container) {\n        container.classList.toggle(this._trait, this.contains(index));\n    }\n    unrender(container) {\n        container.classList.remove(this._trait);\n    }\n    /**\n     * Sets the indexes which should have this trait.\n     *\n     * @param indexes Indexes which should have this trait.\n     * @return The old indexes which had this trait.\n     */\n    set(indexes, browserEvent) {\n        return this._set(indexes, [...indexes].sort(numericSort), browserEvent);\n    }\n    _set(indexes, sortedIndexes, browserEvent) {\n        const result = this.indexes;\n        const sortedResult = this.sortedIndexes;\n        this.indexes = indexes;\n        this.sortedIndexes = sortedIndexes;\n        const toRender = disjunction(sortedResult, indexes);\n        this.renderer.renderIndexes(toRender);\n        this._onChange.fire({ indexes, browserEvent });\n        return result;\n    }\n    get() {\n        return this.indexes;\n    }\n    contains(index) {\n        return binarySearch(this.sortedIndexes, index, numericSort) >= 0;\n    }\n    dispose() {\n        dispose(this._onChange);\n    }\n}\n__decorate([\n    memoize\n], Trait.prototype, \"renderer\", null);\nclass SelectionTrait extends Trait {\n    constructor(setAriaSelected) {\n        super('selected');\n        this.setAriaSelected = setAriaSelected;\n    }\n    renderIndex(index, container) {\n        super.renderIndex(index, container);\n        if (this.setAriaSelected) {\n            if (this.contains(index)) {\n                container.setAttribute('aria-selected', 'true');\n            }\n            else {\n                container.setAttribute('aria-selected', 'false');\n            }\n        }\n    }\n}\n/**\n * The TraitSpliceable is used as a util class to be able\n * to preserve traits across splice calls, given an identity\n * provider.\n */\nclass TraitSpliceable {\n    constructor(trait, view, identityProvider) {\n        this.trait = trait;\n        this.view = view;\n        this.identityProvider = identityProvider;\n    }\n    splice(start, deleteCount, elements) {\n        if (!this.identityProvider) {\n            return this.trait.splice(start, deleteCount, elements.map(() => false));\n        }\n        const pastElementsWithTrait = this.trait.get().map(i => this.identityProvider.getId(this.view.element(i)).toString());\n        const elementsWithTrait = elements.map(e => pastElementsWithTrait.indexOf(this.identityProvider.getId(e).toString()) > -1);\n        this.trait.splice(start, deleteCount, elementsWithTrait);\n    }\n}\nexport function isInputElement(e) {\n    return e.tagName === 'INPUT' || e.tagName === 'TEXTAREA';\n}\nexport function isMonacoEditor(e) {\n    if (e.classList.contains('monaco-editor')) {\n        return true;\n    }\n    if (e.classList.contains('monaco-list')) {\n        return false;\n    }\n    if (!e.parentElement) {\n        return false;\n    }\n    return isMonacoEditor(e.parentElement);\n}\nexport function isButton(e) {\n    if ((e.tagName === 'A' && e.classList.contains('monaco-button')) ||\n        (e.tagName === 'DIV' && e.classList.contains('monaco-button-dropdown'))) {\n        return true;\n    }\n    if (e.classList.contains('monaco-list')) {\n        return false;\n    }\n    if (!e.parentElement) {\n        return false;\n    }\n    return isButton(e.parentElement);\n}\nclass KeyboardController {\n    constructor(list, view, options) {\n        this.list = list;\n        this.view = view;\n        this.disposables = new DisposableStore();\n        this.multipleSelectionDisposables = new DisposableStore();\n        this.onKeyDown.filter(e => e.keyCode === 3 /* KeyCode.Enter */).on(this.onEnter, this, this.disposables);\n        this.onKeyDown.filter(e => e.keyCode === 16 /* KeyCode.UpArrow */).on(this.onUpArrow, this, this.disposables);\n        this.onKeyDown.filter(e => e.keyCode === 18 /* KeyCode.DownArrow */).on(this.onDownArrow, this, this.disposables);\n        this.onKeyDown.filter(e => e.keyCode === 11 /* KeyCode.PageUp */).on(this.onPageUpArrow, this, this.disposables);\n        this.onKeyDown.filter(e => e.keyCode === 12 /* KeyCode.PageDown */).on(this.onPageDownArrow, this, this.disposables);\n        this.onKeyDown.filter(e => e.keyCode === 9 /* KeyCode.Escape */).on(this.onEscape, this, this.disposables);\n        if (options.multipleSelectionSupport !== false) {\n            this.onKeyDown.filter(e => (platform.isMacintosh ? e.metaKey : e.ctrlKey) && e.keyCode === 31 /* KeyCode.KeyA */).on(this.onCtrlA, this, this.multipleSelectionDisposables);\n        }\n    }\n    get onKeyDown() {\n        return this.disposables.add(Event.chain(this.disposables.add(new DomEmitter(this.view.domNode, 'keydown')).event)\n            .filter(e => !isInputElement(e.target))\n            .map(e => new StandardKeyboardEvent(e)));\n    }\n    updateOptions(optionsUpdate) {\n        if (optionsUpdate.multipleSelectionSupport !== undefined) {\n            this.multipleSelectionDisposables.clear();\n            if (optionsUpdate.multipleSelectionSupport) {\n                this.onKeyDown.filter(e => (platform.isMacintosh ? e.metaKey : e.ctrlKey) && e.keyCode === 31 /* KeyCode.KeyA */).on(this.onCtrlA, this, this.multipleSelectionDisposables);\n            }\n        }\n    }\n    onEnter(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.setSelection(this.list.getFocus(), e.browserEvent);\n    }\n    onUpArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusPrevious(1, false, e.browserEvent);\n        const el = this.list.getFocus()[0];\n        this.list.setAnchor(el);\n        this.list.reveal(el);\n        this.view.domNode.focus();\n    }\n    onDownArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusNext(1, false, e.browserEvent);\n        const el = this.list.getFocus()[0];\n        this.list.setAnchor(el);\n        this.list.reveal(el);\n        this.view.domNode.focus();\n    }\n    onPageUpArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusPreviousPage(e.browserEvent);\n        const el = this.list.getFocus()[0];\n        this.list.setAnchor(el);\n        this.list.reveal(el);\n        this.view.domNode.focus();\n    }\n    onPageDownArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusNextPage(e.browserEvent);\n        const el = this.list.getFocus()[0];\n        this.list.setAnchor(el);\n        this.list.reveal(el);\n        this.view.domNode.focus();\n    }\n    onCtrlA(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.setSelection(range(this.list.length), e.browserEvent);\n        this.list.setAnchor(undefined);\n        this.view.domNode.focus();\n    }\n    onEscape(e) {\n        if (this.list.getSelection().length) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.list.setSelection([], e.browserEvent);\n            this.list.setAnchor(undefined);\n            this.view.domNode.focus();\n        }\n    }\n    dispose() {\n        this.disposables.dispose();\n        this.multipleSelectionDisposables.dispose();\n    }\n}\n__decorate([\n    memoize\n], KeyboardController.prototype, \"onKeyDown\", null);\nexport var TypeNavigationMode;\n(function (TypeNavigationMode) {\n    TypeNavigationMode[TypeNavigationMode[\"Automatic\"] = 0] = \"Automatic\";\n    TypeNavigationMode[TypeNavigationMode[\"Trigger\"] = 1] = \"Trigger\";\n})(TypeNavigationMode || (TypeNavigationMode = {}));\nvar TypeNavigationControllerState;\n(function (TypeNavigationControllerState) {\n    TypeNavigationControllerState[TypeNavigationControllerState[\"Idle\"] = 0] = \"Idle\";\n    TypeNavigationControllerState[TypeNavigationControllerState[\"Typing\"] = 1] = \"Typing\";\n})(TypeNavigationControllerState || (TypeNavigationControllerState = {}));\nexport const DefaultKeyboardNavigationDelegate = new class {\n    mightProducePrintableCharacter(event) {\n        if (event.ctrlKey || event.metaKey || event.altKey) {\n            return false;\n        }\n        return (event.keyCode >= 31 /* KeyCode.KeyA */ && event.keyCode <= 56 /* KeyCode.KeyZ */)\n            || (event.keyCode >= 21 /* KeyCode.Digit0 */ && event.keyCode <= 30 /* KeyCode.Digit9 */)\n            || (event.keyCode >= 93 /* KeyCode.Numpad0 */ && event.keyCode <= 102 /* KeyCode.Numpad9 */)\n            || (event.keyCode >= 80 /* KeyCode.Semicolon */ && event.keyCode <= 90 /* KeyCode.Quote */);\n    }\n};\nclass TypeNavigationController {\n    constructor(list, view, keyboardNavigationLabelProvider, keyboardNavigationEventFilter, delegate) {\n        this.list = list;\n        this.view = view;\n        this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n        this.keyboardNavigationEventFilter = keyboardNavigationEventFilter;\n        this.delegate = delegate;\n        this.enabled = false;\n        this.state = TypeNavigationControllerState.Idle;\n        this.mode = TypeNavigationMode.Automatic;\n        this.triggered = false;\n        this.previouslyFocused = -1;\n        this.enabledDisposables = new DisposableStore();\n        this.disposables = new DisposableStore();\n        this.updateOptions(list.options);\n    }\n    updateOptions(options) {\n        var _a, _b;\n        if ((_a = options.typeNavigationEnabled) !== null && _a !== void 0 ? _a : true) {\n            this.enable();\n        }\n        else {\n            this.disable();\n        }\n        this.mode = (_b = options.typeNavigationMode) !== null && _b !== void 0 ? _b : TypeNavigationMode.Automatic;\n    }\n    enable() {\n        if (this.enabled) {\n            return;\n        }\n        let typing = false;\n        const onChar = this.enabledDisposables.add(Event.chain(this.enabledDisposables.add(new DomEmitter(this.view.domNode, 'keydown')).event))\n            .filter(e => !isInputElement(e.target))\n            .filter(() => this.mode === TypeNavigationMode.Automatic || this.triggered)\n            .map(event => new StandardKeyboardEvent(event))\n            .filter(e => typing || this.keyboardNavigationEventFilter(e))\n            .filter(e => this.delegate.mightProducePrintableCharacter(e))\n            .forEach(stopEvent)\n            .map(event => event.browserEvent.key)\n            .event;\n        const onClear = Event.debounce(onChar, () => null, 800, undefined, undefined, this.enabledDisposables);\n        const onInput = Event.reduce(Event.any(onChar, onClear), (r, i) => i === null ? null : ((r || '') + i), undefined, this.enabledDisposables);\n        onInput(this.onInput, this, this.enabledDisposables);\n        onClear(this.onClear, this, this.enabledDisposables);\n        onChar(() => typing = true, undefined, this.enabledDisposables);\n        onClear(() => typing = false, undefined, this.enabledDisposables);\n        this.enabled = true;\n        this.triggered = false;\n    }\n    disable() {\n        if (!this.enabled) {\n            return;\n        }\n        this.enabledDisposables.clear();\n        this.enabled = false;\n        this.triggered = false;\n    }\n    onClear() {\n        var _a;\n        const focus = this.list.getFocus();\n        if (focus.length > 0 && focus[0] === this.previouslyFocused) {\n            // List: re-announce element on typing end since typed keys will interrupt aria label of focused element\n            // Do not announce if there was a focus change at the end to prevent duplication https://github.com/microsoft/vscode/issues/95961\n            const ariaLabel = (_a = this.list.options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getAriaLabel(this.list.element(focus[0]));\n            if (ariaLabel) {\n                alert(ariaLabel);\n            }\n        }\n        this.previouslyFocused = -1;\n    }\n    onInput(word) {\n        if (!word) {\n            this.state = TypeNavigationControllerState.Idle;\n            this.triggered = false;\n            return;\n        }\n        const focus = this.list.getFocus();\n        const start = focus.length > 0 ? focus[0] : 0;\n        const delta = this.state === TypeNavigationControllerState.Idle ? 1 : 0;\n        this.state = TypeNavigationControllerState.Typing;\n        for (let i = 0; i < this.list.length; i++) {\n            const index = (start + i + delta) % this.list.length;\n            const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(index));\n            const labelStr = label && label.toString();\n            if (typeof labelStr === 'undefined' || matchesPrefix(word, labelStr)) {\n                this.previouslyFocused = start;\n                this.list.setFocus([index]);\n                this.list.reveal(index);\n                return;\n            }\n        }\n    }\n    dispose() {\n        this.disable();\n        this.enabledDisposables.dispose();\n        this.disposables.dispose();\n    }\n}\nclass DOMFocusController {\n    constructor(list, view) {\n        this.list = list;\n        this.view = view;\n        this.disposables = new DisposableStore();\n        const onKeyDown = this.disposables.add(Event.chain(this.disposables.add(new DomEmitter(view.domNode, 'keydown')).event))\n            .filter(e => !isInputElement(e.target))\n            .map(e => new StandardKeyboardEvent(e));\n        onKeyDown.filter(e => e.keyCode === 2 /* KeyCode.Tab */ && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey)\n            .on(this.onTab, this, this.disposables);\n    }\n    onTab(e) {\n        if (e.target !== this.view.domNode) {\n            return;\n        }\n        const focus = this.list.getFocus();\n        if (focus.length === 0) {\n            return;\n        }\n        const focusedDomElement = this.view.domElement(focus[0]);\n        if (!focusedDomElement) {\n            return;\n        }\n        const tabIndexElement = focusedDomElement.querySelector('[tabIndex]');\n        if (!tabIndexElement || !(tabIndexElement instanceof HTMLElement) || tabIndexElement.tabIndex === -1) {\n            return;\n        }\n        const style = window.getComputedStyle(tabIndexElement);\n        if (style.visibility === 'hidden' || style.display === 'none') {\n            return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        tabIndexElement.focus();\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nexport function isSelectionSingleChangeEvent(event) {\n    return platform.isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;\n}\nexport function isSelectionRangeChangeEvent(event) {\n    return event.browserEvent.shiftKey;\n}\nfunction isMouseRightClick(event) {\n    return event instanceof MouseEvent && event.button === 2;\n}\nconst DefaultMultipleSelectionController = {\n    isSelectionSingleChangeEvent,\n    isSelectionRangeChangeEvent\n};\nexport class MouseController {\n    constructor(list) {\n        this.list = list;\n        this.disposables = new DisposableStore();\n        this._onPointer = new Emitter();\n        this.onPointer = this._onPointer.event;\n        if (list.options.multipleSelectionSupport !== false) {\n            this.multipleSelectionController = this.list.options.multipleSelectionController || DefaultMultipleSelectionController;\n        }\n        this.mouseSupport = typeof list.options.mouseSupport === 'undefined' || !!list.options.mouseSupport;\n        if (this.mouseSupport) {\n            list.onMouseDown(this.onMouseDown, this, this.disposables);\n            list.onContextMenu(this.onContextMenu, this, this.disposables);\n            list.onMouseDblClick(this.onDoubleClick, this, this.disposables);\n            list.onTouchStart(this.onMouseDown, this, this.disposables);\n            this.disposables.add(Gesture.addTarget(list.getHTMLElement()));\n        }\n        Event.any(list.onMouseClick, list.onMouseMiddleClick, list.onTap)(this.onViewPointer, this, this.disposables);\n    }\n    updateOptions(optionsUpdate) {\n        if (optionsUpdate.multipleSelectionSupport !== undefined) {\n            this.multipleSelectionController = undefined;\n            if (optionsUpdate.multipleSelectionSupport) {\n                this.multipleSelectionController = this.list.options.multipleSelectionController || DefaultMultipleSelectionController;\n            }\n        }\n    }\n    isSelectionSingleChangeEvent(event) {\n        if (!this.multipleSelectionController) {\n            return false;\n        }\n        return this.multipleSelectionController.isSelectionSingleChangeEvent(event);\n    }\n    isSelectionRangeChangeEvent(event) {\n        if (!this.multipleSelectionController) {\n            return false;\n        }\n        return this.multipleSelectionController.isSelectionRangeChangeEvent(event);\n    }\n    isSelectionChangeEvent(event) {\n        return this.isSelectionSingleChangeEvent(event) || this.isSelectionRangeChangeEvent(event);\n    }\n    onMouseDown(e) {\n        if (isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        if (document.activeElement !== e.browserEvent.target) {\n            this.list.domFocus();\n        }\n    }\n    onContextMenu(e) {\n        if (isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        const focus = typeof e.index === 'undefined' ? [] : [e.index];\n        this.list.setFocus(focus, e.browserEvent);\n    }\n    onViewPointer(e) {\n        if (!this.mouseSupport) {\n            return;\n        }\n        if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        const focus = e.index;\n        if (typeof focus === 'undefined') {\n            this.list.setFocus([], e.browserEvent);\n            this.list.setSelection([], e.browserEvent);\n            this.list.setAnchor(undefined);\n            return;\n        }\n        if (this.isSelectionRangeChangeEvent(e)) {\n            return this.changeSelection(e);\n        }\n        if (this.isSelectionChangeEvent(e)) {\n            return this.changeSelection(e);\n        }\n        this.list.setFocus([focus], e.browserEvent);\n        this.list.setAnchor(focus);\n        if (!isMouseRightClick(e.browserEvent)) {\n            this.list.setSelection([focus], e.browserEvent);\n        }\n        this._onPointer.fire(e);\n    }\n    onDoubleClick(e) {\n        if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        if (this.isSelectionChangeEvent(e)) {\n            return;\n        }\n        const focus = this.list.getFocus();\n        this.list.setSelection(focus, e.browserEvent);\n    }\n    changeSelection(e) {\n        const focus = e.index;\n        let anchor = this.list.getAnchor();\n        if (this.isSelectionRangeChangeEvent(e)) {\n            if (typeof anchor === 'undefined') {\n                const currentFocus = this.list.getFocus()[0];\n                anchor = currentFocus !== null && currentFocus !== void 0 ? currentFocus : focus;\n                this.list.setAnchor(anchor);\n            }\n            const min = Math.min(anchor, focus);\n            const max = Math.max(anchor, focus);\n            const rangeSelection = range(min, max + 1);\n            const selection = this.list.getSelection();\n            const contiguousRange = getContiguousRangeContaining(disjunction(selection, [anchor]), anchor);\n            if (contiguousRange.length === 0) {\n                return;\n            }\n            const newSelection = disjunction(rangeSelection, relativeComplement(selection, contiguousRange));\n            this.list.setSelection(newSelection, e.browserEvent);\n            this.list.setFocus([focus], e.browserEvent);\n        }\n        else if (this.isSelectionSingleChangeEvent(e)) {\n            const selection = this.list.getSelection();\n            const newSelection = selection.filter(i => i !== focus);\n            this.list.setFocus([focus]);\n            this.list.setAnchor(focus);\n            if (selection.length === newSelection.length) {\n                this.list.setSelection([...newSelection, focus], e.browserEvent);\n            }\n            else {\n                this.list.setSelection(newSelection, e.browserEvent);\n            }\n        }\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nexport class DefaultStyleController {\n    constructor(styleElement, selectorSuffix) {\n        this.styleElement = styleElement;\n        this.selectorSuffix = selectorSuffix;\n    }\n    style(styles) {\n        const suffix = this.selectorSuffix && `.${this.selectorSuffix}`;\n        const content = [];\n        if (styles.listBackground) {\n            if (styles.listBackground.isOpaque()) {\n                content.push(`.monaco-list${suffix} .monaco-list-rows { background: ${styles.listBackground}; }`);\n            }\n            else if (!platform.isMacintosh) { // subpixel AA doesn't exist in macOS\n                console.warn(`List with id '${this.selectorSuffix}' was styled with a non-opaque background color. This will break sub-pixel antialiasing.`);\n            }\n        }\n        if (styles.listFocusBackground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { background-color: ${styles.listFocusBackground}; }`);\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused:hover { background-color: ${styles.listFocusBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listFocusForeground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { color: ${styles.listFocusForeground}; }`);\n        }\n        if (styles.listActiveSelectionBackground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { background-color: ${styles.listActiveSelectionBackground}; }`);\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected:hover { background-color: ${styles.listActiveSelectionBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listActiveSelectionForeground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { color: ${styles.listActiveSelectionForeground}; }`);\n        }\n        if (styles.listActiveSelectionIconForeground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected .codicon { color: ${styles.listActiveSelectionIconForeground}; }`);\n        }\n        if (styles.listFocusAndSelectionOutline) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { outline-color: ${styles.listFocusAndSelectionOutline} !important; }`);\n        }\n        if (styles.listFocusAndSelectionBackground) {\n            content.push(`\n\t\t\t\t.monaco-drag-image,\n\t\t\t\t.monaco-list${suffix}:focus .monaco-list-row.selected.focused { background-color: ${styles.listFocusAndSelectionBackground}; }\n\t\t\t`);\n        }\n        if (styles.listFocusAndSelectionForeground) {\n            content.push(`\n\t\t\t\t.monaco-drag-image,\n\t\t\t\t.monaco-list${suffix}:focus .monaco-list-row.selected.focused { color: ${styles.listFocusAndSelectionForeground}; }\n\t\t\t`);\n        }\n        if (styles.listInactiveFocusForeground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused { color:  ${styles.listInactiveFocusForeground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { color:  ${styles.listInactiveFocusForeground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listInactiveSelectionIconForeground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused .codicon { color:  ${styles.listInactiveSelectionIconForeground}; }`);\n        }\n        if (styles.listInactiveFocusBackground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused { background-color:  ${styles.listInactiveFocusBackground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { background-color:  ${styles.listInactiveFocusBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listInactiveSelectionBackground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected { background-color:  ${styles.listInactiveSelectionBackground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected:hover { background-color:  ${styles.listInactiveSelectionBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listInactiveSelectionForeground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected { color: ${styles.listInactiveSelectionForeground}; }`);\n        }\n        if (styles.listHoverBackground) {\n            content.push(`.monaco-list${suffix}:not(.drop-target) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${styles.listHoverBackground}; }`);\n        }\n        if (styles.listHoverForeground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${styles.listHoverForeground}; }`);\n        }\n        if (styles.listSelectionOutline) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected { outline: 1px dotted ${styles.listSelectionOutline}; outline-offset: -1px; }`);\n        }\n        if (styles.listFocusOutline) {\n            content.push(`\n\t\t\t\t.monaco-drag-image,\n\t\t\t\t.monaco-list${suffix}:focus .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }\n\t\t\t\t.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }\n\t\t\t`);\n        }\n        if (styles.listInactiveFocusOutline) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused { outline: 1px dotted ${styles.listInactiveFocusOutline}; outline-offset: -1px; }`);\n        }\n        if (styles.listHoverOutline) {\n            content.push(`.monaco-list${suffix} .monaco-list-row:hover { outline: 1px dashed ${styles.listHoverOutline}; outline-offset: -1px; }`);\n        }\n        if (styles.listDropBackground) {\n            content.push(`\n\t\t\t\t.monaco-list${suffix}.drop-target,\n\t\t\t\t.monaco-list${suffix} .monaco-list-rows.drop-target,\n\t\t\t\t.monaco-list${suffix} .monaco-list-row.drop-target { background-color: ${styles.listDropBackground} !important; color: inherit !important; }\n\t\t\t`);\n        }\n        if (styles.tableColumnsBorder) {\n            content.push(`\n\t\t\t\t.monaco-table:hover > .monaco-split-view2,\n\t\t\t\t.monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {\n\t\t\t\t\tborder-color: ${styles.tableColumnsBorder};\n\t\t\t}`);\n        }\n        if (styles.tableOddRowsBackgroundColor) {\n            content.push(`\n\t\t\t\t.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,\n\t\t\t\t.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,\n\t\t\t\t.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {\n\t\t\t\t\tbackground-color: ${styles.tableOddRowsBackgroundColor};\n\t\t\t\t}\n\t\t\t`);\n        }\n        this.styleElement.textContent = content.join('\\n');\n    }\n}\nconst defaultStyles = {\n    listFocusBackground: Color.fromHex('#7FB0D0'),\n    listActiveSelectionBackground: Color.fromHex('#0E639C'),\n    listActiveSelectionForeground: Color.fromHex('#FFFFFF'),\n    listActiveSelectionIconForeground: Color.fromHex('#FFFFFF'),\n    listFocusAndSelectionOutline: Color.fromHex('#90C2F9'),\n    listFocusAndSelectionBackground: Color.fromHex('#094771'),\n    listFocusAndSelectionForeground: Color.fromHex('#FFFFFF'),\n    listInactiveSelectionBackground: Color.fromHex('#3F3F46'),\n    listInactiveSelectionIconForeground: Color.fromHex('#FFFFFF'),\n    listHoverBackground: Color.fromHex('#2A2D2E'),\n    listDropBackground: Color.fromHex('#383B3D'),\n    treeIndentGuidesStroke: Color.fromHex('#a9a9a9'),\n    tableColumnsBorder: Color.fromHex('#cccccc').transparent(0.2),\n    tableOddRowsBackgroundColor: Color.fromHex('#cccccc').transparent(0.04)\n};\nconst DefaultOptions = {\n    keyboardSupport: true,\n    mouseSupport: true,\n    multipleSelectionSupport: true,\n    dnd: {\n        getDragURI() { return null; },\n        onDragStart() { },\n        onDragOver() { return false; },\n        drop() { }\n    }\n};\n// TODO@Joao: move these utils into a SortedArray class\nfunction getContiguousRangeContaining(range, value) {\n    const index = range.indexOf(value);\n    if (index === -1) {\n        return [];\n    }\n    const result = [];\n    let i = index - 1;\n    while (i >= 0 && range[i] === value - (index - i)) {\n        result.push(range[i--]);\n    }\n    result.reverse();\n    i = index;\n    while (i < range.length && range[i] === value + (i - index)) {\n        result.push(range[i++]);\n    }\n    return result;\n}\n/**\n * Given two sorted collections of numbers, returns the intersection\n * between them (OR).\n */\nfunction disjunction(one, other) {\n    const result = [];\n    let i = 0, j = 0;\n    while (i < one.length || j < other.length) {\n        if (i >= one.length) {\n            result.push(other[j++]);\n        }\n        else if (j >= other.length) {\n            result.push(one[i++]);\n        }\n        else if (one[i] === other[j]) {\n            result.push(one[i]);\n            i++;\n            j++;\n            continue;\n        }\n        else if (one[i] < other[j]) {\n            result.push(one[i++]);\n        }\n        else {\n            result.push(other[j++]);\n        }\n    }\n    return result;\n}\n/**\n * Given two sorted collections of numbers, returns the relative\n * complement between them (XOR).\n */\nfunction relativeComplement(one, other) {\n    const result = [];\n    let i = 0, j = 0;\n    while (i < one.length || j < other.length) {\n        if (i >= one.length) {\n            result.push(other[j++]);\n        }\n        else if (j >= other.length) {\n            result.push(one[i++]);\n        }\n        else if (one[i] === other[j]) {\n            i++;\n            j++;\n            continue;\n        }\n        else if (one[i] < other[j]) {\n            result.push(one[i++]);\n        }\n        else {\n            j++;\n        }\n    }\n    return result;\n}\nconst numericSort = (a, b) => a - b;\nclass PipelineRenderer {\n    constructor(_templateId, renderers) {\n        this._templateId = _templateId;\n        this.renderers = renderers;\n    }\n    get templateId() {\n        return this._templateId;\n    }\n    renderTemplate(container) {\n        return this.renderers.map(r => r.renderTemplate(container));\n    }\n    renderElement(element, index, templateData, height) {\n        let i = 0;\n        for (const renderer of this.renderers) {\n            renderer.renderElement(element, index, templateData[i++], height);\n        }\n    }\n    disposeElement(element, index, templateData, height) {\n        var _a;\n        let i = 0;\n        for (const renderer of this.renderers) {\n            (_a = renderer.disposeElement) === null || _a === void 0 ? void 0 : _a.call(renderer, element, index, templateData[i], height);\n            i += 1;\n        }\n    }\n    disposeTemplate(templateData) {\n        let i = 0;\n        for (const renderer of this.renderers) {\n            renderer.disposeTemplate(templateData[i++]);\n        }\n    }\n}\nclass AccessibiltyRenderer {\n    constructor(accessibilityProvider) {\n        this.accessibilityProvider = accessibilityProvider;\n        this.templateId = 'a18n';\n    }\n    renderTemplate(container) {\n        return container;\n    }\n    renderElement(element, index, container) {\n        const ariaLabel = this.accessibilityProvider.getAriaLabel(element);\n        if (ariaLabel) {\n            container.setAttribute('aria-label', ariaLabel);\n        }\n        else {\n            container.removeAttribute('aria-label');\n        }\n        const ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);\n        if (typeof ariaLevel === 'number') {\n            container.setAttribute('aria-level', `${ariaLevel}`);\n        }\n        else {\n            container.removeAttribute('aria-level');\n        }\n    }\n    disposeTemplate(templateData) {\n        // noop\n    }\n}\nclass ListViewDragAndDrop {\n    constructor(list, dnd) {\n        this.list = list;\n        this.dnd = dnd;\n    }\n    getDragElements(element) {\n        const selection = this.list.getSelectedElements();\n        const elements = selection.indexOf(element) > -1 ? selection : [element];\n        return elements;\n    }\n    getDragURI(element) {\n        return this.dnd.getDragURI(element);\n    }\n    getDragLabel(elements, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(elements, originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        var _a, _b;\n        (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, data, originalEvent);\n    }\n    onDragOver(data, targetElement, targetIndex, originalEvent) {\n        return this.dnd.onDragOver(data, targetElement, targetIndex, originalEvent);\n    }\n    onDragLeave(data, targetElement, targetIndex, originalEvent) {\n        var _a, _b;\n        (_b = (_a = this.dnd).onDragLeave) === null || _b === void 0 ? void 0 : _b.call(_a, data, targetElement, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        var _a, _b;\n        (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, originalEvent);\n    }\n    drop(data, targetElement, targetIndex, originalEvent) {\n        this.dnd.drop(data, targetElement, targetIndex, originalEvent);\n    }\n}\n/**\n * The {@link List} is a virtual scrolling widget, built on top of the {@link ListView}\n * widget.\n *\n * Features:\n * - Customizable keyboard and mouse support\n * - Element traits: focus, selection, achor\n * - Accessibility support\n * - Touch support\n * - Performant template-based rendering\n * - Horizontal scrolling\n * - Variable element height support\n * - Dynamic element height support\n * - Drag-and-drop support\n */\nexport class List {\n    constructor(user, container, virtualDelegate, renderers, _options = DefaultOptions) {\n        var _a, _b, _c, _d;\n        this.user = user;\n        this._options = _options;\n        this.focus = new Trait('focused');\n        this.anchor = new Trait('anchor');\n        this.eventBufferer = new EventBufferer();\n        this._ariaLabel = '';\n        this.disposables = new DisposableStore();\n        this._onDidDispose = new Emitter();\n        this.onDidDispose = this._onDidDispose.event;\n        const role = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (_a = this._options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getWidgetRole() : 'list';\n        this.selection = new SelectionTrait(role !== 'listbox');\n        mixin(_options, defaultStyles, false);\n        const baseRenderers = [this.focus.renderer, this.selection.renderer];\n        this.accessibilityProvider = _options.accessibilityProvider;\n        if (this.accessibilityProvider) {\n            baseRenderers.push(new AccessibiltyRenderer(this.accessibilityProvider));\n            (_c = (_b = this.accessibilityProvider).onDidChangeActiveDescendant) === null || _c === void 0 ? void 0 : _c.call(_b, this.onDidChangeActiveDescendant, this, this.disposables);\n        }\n        renderers = renderers.map(r => new PipelineRenderer(r.templateId, [...baseRenderers, r]));\n        const viewOptions = Object.assign(Object.assign({}, _options), { dnd: _options.dnd && new ListViewDragAndDrop(this, _options.dnd) });\n        this.view = new ListView(container, virtualDelegate, renderers, viewOptions);\n        this.view.domNode.setAttribute('role', role);\n        if (_options.styleController) {\n            this.styleController = _options.styleController(this.view.domId);\n        }\n        else {\n            const styleElement = createStyleSheet(this.view.domNode);\n            this.styleController = new DefaultStyleController(styleElement, this.view.domId);\n        }\n        this.spliceable = new CombinedSpliceable([\n            new TraitSpliceable(this.focus, this.view, _options.identityProvider),\n            new TraitSpliceable(this.selection, this.view, _options.identityProvider),\n            new TraitSpliceable(this.anchor, this.view, _options.identityProvider),\n            this.view\n        ]);\n        this.disposables.add(this.focus);\n        this.disposables.add(this.selection);\n        this.disposables.add(this.anchor);\n        this.disposables.add(this.view);\n        this.disposables.add(this._onDidDispose);\n        this.disposables.add(new DOMFocusController(this, this.view));\n        if (typeof _options.keyboardSupport !== 'boolean' || _options.keyboardSupport) {\n            this.keyboardController = new KeyboardController(this, this.view, _options);\n            this.disposables.add(this.keyboardController);\n        }\n        if (_options.keyboardNavigationLabelProvider) {\n            const delegate = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;\n            this.typeNavigationController = new TypeNavigationController(this, this.view, _options.keyboardNavigationLabelProvider, (_d = _options.keyboardNavigationEventFilter) !== null && _d !== void 0 ? _d : (() => true), delegate);\n            this.disposables.add(this.typeNavigationController);\n        }\n        this.mouseController = this.createMouseController(_options);\n        this.disposables.add(this.mouseController);\n        this.onDidChangeFocus(this._onFocusChange, this, this.disposables);\n        this.onDidChangeSelection(this._onSelectionChange, this, this.disposables);\n        if (this.accessibilityProvider) {\n            this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel();\n        }\n        if (this._options.multipleSelectionSupport !== false) {\n            this.view.domNode.setAttribute('aria-multiselectable', 'true');\n        }\n    }\n    get onDidChangeFocus() {\n        return Event.map(this.eventBufferer.wrapEvent(this.focus.onChange), e => this.toListEvent(e), this.disposables);\n    }\n    get onDidChangeSelection() {\n        return Event.map(this.eventBufferer.wrapEvent(this.selection.onChange), e => this.toListEvent(e), this.disposables);\n    }\n    get domId() { return this.view.domId; }\n    get onMouseClick() { return this.view.onMouseClick; }\n    get onMouseDblClick() { return this.view.onMouseDblClick; }\n    get onMouseMiddleClick() { return this.view.onMouseMiddleClick; }\n    get onPointer() { return this.mouseController.onPointer; }\n    get onMouseDown() { return this.view.onMouseDown; }\n    get onMouseOver() { return this.view.onMouseOver; }\n    get onTouchStart() { return this.view.onTouchStart; }\n    get onTap() { return this.view.onTap; }\n    /**\n     * Possible context menu trigger events:\n     * - ContextMenu key\n     * - Shift F10\n     * - Ctrl Option Shift M (macOS with VoiceOver)\n     * - Mouse right click\n     */\n    get onContextMenu() {\n        let didJustPressContextMenuKey = false;\n        const fromKeyDown = this.disposables.add(Event.chain(this.disposables.add(new DomEmitter(this.view.domNode, 'keydown')).event))\n            .map(e => new StandardKeyboardEvent(e))\n            .filter(e => didJustPressContextMenuKey = e.keyCode === 58 /* KeyCode.ContextMenu */ || (e.shiftKey && e.keyCode === 68 /* KeyCode.F10 */))\n            .map(stopEvent)\n            .filter(() => false)\n            .event;\n        const fromKeyUp = this.disposables.add(Event.chain(this.disposables.add(new DomEmitter(this.view.domNode, 'keyup')).event))\n            .forEach(() => didJustPressContextMenuKey = false)\n            .map(e => new StandardKeyboardEvent(e))\n            .filter(e => e.keyCode === 58 /* KeyCode.ContextMenu */ || (e.shiftKey && e.keyCode === 68 /* KeyCode.F10 */))\n            .map(stopEvent)\n            .map(({ browserEvent }) => {\n            const focus = this.getFocus();\n            const index = focus.length ? focus[0] : undefined;\n            const element = typeof index !== 'undefined' ? this.view.element(index) : undefined;\n            const anchor = typeof index !== 'undefined' ? this.view.domElement(index) : this.view.domNode;\n            return { index, element, anchor, browserEvent };\n        })\n            .event;\n        const fromMouse = this.disposables.add(Event.chain(this.view.onContextMenu))\n            .filter(_ => !didJustPressContextMenuKey)\n            .map(({ element, index, browserEvent }) => ({ element, index, anchor: { x: browserEvent.pageX + 1, y: browserEvent.pageY }, browserEvent }))\n            .event;\n        return Event.any(fromKeyDown, fromKeyUp, fromMouse);\n    }\n    get onKeyDown() { return this.disposables.add(new DomEmitter(this.view.domNode, 'keydown')).event; }\n    get onDidFocus() { return Event.signal(this.disposables.add(new DomEmitter(this.view.domNode, 'focus', true)).event); }\n    createMouseController(options) {\n        return new MouseController(this);\n    }\n    updateOptions(optionsUpdate = {}) {\n        var _a, _b;\n        this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);\n        (_a = this.typeNavigationController) === null || _a === void 0 ? void 0 : _a.updateOptions(this._options);\n        if (this._options.multipleSelectionController !== undefined) {\n            if (this._options.multipleSelectionSupport) {\n                this.view.domNode.setAttribute('aria-multiselectable', 'true');\n            }\n            else {\n                this.view.domNode.removeAttribute('aria-multiselectable');\n            }\n        }\n        this.mouseController.updateOptions(optionsUpdate);\n        (_b = this.keyboardController) === null || _b === void 0 ? void 0 : _b.updateOptions(optionsUpdate);\n        this.view.updateOptions(optionsUpdate);\n    }\n    get options() {\n        return this._options;\n    }\n    splice(start, deleteCount, elements = []) {\n        if (start < 0 || start > this.view.length) {\n            throw new ListError(this.user, `Invalid start index: ${start}`);\n        }\n        if (deleteCount < 0) {\n            throw new ListError(this.user, `Invalid delete count: ${deleteCount}`);\n        }\n        if (deleteCount === 0 && elements.length === 0) {\n            return;\n        }\n        this.eventBufferer.bufferEvents(() => this.spliceable.splice(start, deleteCount, elements));\n    }\n    rerender() {\n        this.view.rerender();\n    }\n    element(index) {\n        return this.view.element(index);\n    }\n    get length() {\n        return this.view.length;\n    }\n    get contentHeight() {\n        return this.view.contentHeight;\n    }\n    get scrollTop() {\n        return this.view.getScrollTop();\n    }\n    set scrollTop(scrollTop) {\n        this.view.setScrollTop(scrollTop);\n    }\n    get ariaLabel() {\n        return this._ariaLabel;\n    }\n    set ariaLabel(value) {\n        this._ariaLabel = value;\n        this.view.domNode.setAttribute('aria-label', value);\n    }\n    domFocus() {\n        this.view.domNode.focus({ preventScroll: true });\n    }\n    layout(height, width) {\n        this.view.layout(height, width);\n    }\n    setSelection(indexes, browserEvent) {\n        for (const index of indexes) {\n            if (index < 0 || index >= this.length) {\n                throw new ListError(this.user, `Invalid index ${index}`);\n            }\n        }\n        this.selection.set(indexes, browserEvent);\n    }\n    getSelection() {\n        return this.selection.get();\n    }\n    getSelectedElements() {\n        return this.getSelection().map(i => this.view.element(i));\n    }\n    setAnchor(index) {\n        if (typeof index === 'undefined') {\n            this.anchor.set([]);\n            return;\n        }\n        if (index < 0 || index >= this.length) {\n            throw new ListError(this.user, `Invalid index ${index}`);\n        }\n        this.anchor.set([index]);\n    }\n    getAnchor() {\n        return firstOrDefault(this.anchor.get(), undefined);\n    }\n    getAnchorElement() {\n        const anchor = this.getAnchor();\n        return typeof anchor === 'undefined' ? undefined : this.element(anchor);\n    }\n    setFocus(indexes, browserEvent) {\n        for (const index of indexes) {\n            if (index < 0 || index >= this.length) {\n                throw new ListError(this.user, `Invalid index ${index}`);\n            }\n        }\n        this.focus.set(indexes, browserEvent);\n    }\n    focusNext(n = 1, loop = false, browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const focus = this.focus.get();\n        const index = this.findNextIndex(focus.length > 0 ? focus[0] + n : 0, loop, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    focusPrevious(n = 1, loop = false, browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const focus = this.focus.get();\n        const index = this.findPreviousIndex(focus.length > 0 ? focus[0] - n : 0, loop, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    focusNextPage(browserEvent, filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);\n            lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;\n            const currentlyFocusedElementIndex = this.getFocus()[0];\n            if (currentlyFocusedElementIndex !== lastPageIndex && (currentlyFocusedElementIndex === undefined || lastPageIndex > currentlyFocusedElementIndex)) {\n                const lastGoodPageIndex = this.findPreviousIndex(lastPageIndex, false, filter);\n                if (lastGoodPageIndex > -1 && currentlyFocusedElementIndex !== lastGoodPageIndex) {\n                    this.setFocus([lastGoodPageIndex], browserEvent);\n                }\n                else {\n                    this.setFocus([lastPageIndex], browserEvent);\n                }\n            }\n            else {\n                const previousScrollTop = this.view.getScrollTop();\n                let nextpageScrollTop = previousScrollTop + this.view.renderHeight;\n                if (lastPageIndex > currentlyFocusedElementIndex) {\n                    // scroll last page element to the top only if the last page element is below the focused element\n                    nextpageScrollTop -= this.view.elementHeight(lastPageIndex);\n                }\n                this.view.setScrollTop(nextpageScrollTop);\n                if (this.view.getScrollTop() !== previousScrollTop) {\n                    this.setFocus([]);\n                    // Let the scroll event listener run\n                    yield timeout(0);\n                    yield this.focusNextPage(browserEvent, filter);\n                }\n            }\n        });\n    }\n    focusPreviousPage(browserEvent, filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let firstPageIndex;\n            const scrollTop = this.view.getScrollTop();\n            if (scrollTop === 0) {\n                firstPageIndex = this.view.indexAt(scrollTop);\n            }\n            else {\n                firstPageIndex = this.view.indexAfter(scrollTop - 1);\n            }\n            const currentlyFocusedElementIndex = this.getFocus()[0];\n            if (currentlyFocusedElementIndex !== firstPageIndex && (currentlyFocusedElementIndex === undefined || currentlyFocusedElementIndex >= firstPageIndex)) {\n                const firstGoodPageIndex = this.findNextIndex(firstPageIndex, false, filter);\n                if (firstGoodPageIndex > -1 && currentlyFocusedElementIndex !== firstGoodPageIndex) {\n                    this.setFocus([firstGoodPageIndex], browserEvent);\n                }\n                else {\n                    this.setFocus([firstPageIndex], browserEvent);\n                }\n            }\n            else {\n                const previousScrollTop = scrollTop;\n                this.view.setScrollTop(scrollTop - this.view.renderHeight);\n                if (this.view.getScrollTop() !== previousScrollTop) {\n                    this.setFocus([]);\n                    // Let the scroll event listener run\n                    yield timeout(0);\n                    yield this.focusPreviousPage(browserEvent, filter);\n                }\n            }\n        });\n    }\n    focusLast(browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const index = this.findPreviousIndex(this.length - 1, false, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    focusFirst(browserEvent, filter) {\n        this.focusNth(0, browserEvent, filter);\n    }\n    focusNth(n, browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const index = this.findNextIndex(n, false, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    findNextIndex(index, loop = false, filter) {\n        for (let i = 0; i < this.length; i++) {\n            if (index >= this.length && !loop) {\n                return -1;\n            }\n            index = index % this.length;\n            if (!filter || filter(this.element(index))) {\n                return index;\n            }\n            index++;\n        }\n        return -1;\n    }\n    findPreviousIndex(index, loop = false, filter) {\n        for (let i = 0; i < this.length; i++) {\n            if (index < 0 && !loop) {\n                return -1;\n            }\n            index = (this.length + (index % this.length)) % this.length;\n            if (!filter || filter(this.element(index))) {\n                return index;\n            }\n            index--;\n        }\n        return -1;\n    }\n    getFocus() {\n        return this.focus.get();\n    }\n    getFocusedElements() {\n        return this.getFocus().map(i => this.view.element(i));\n    }\n    reveal(index, relativeTop) {\n        if (index < 0 || index >= this.length) {\n            throw new ListError(this.user, `Invalid index ${index}`);\n        }\n        const scrollTop = this.view.getScrollTop();\n        const elementTop = this.view.elementTop(index);\n        const elementHeight = this.view.elementHeight(index);\n        if (isNumber(relativeTop)) {\n            // y = mx + b\n            const m = elementHeight - this.view.renderHeight;\n            this.view.setScrollTop(m * clamp(relativeTop, 0, 1) + elementTop);\n        }\n        else {\n            const viewItemBottom = elementTop + elementHeight;\n            const scrollBottom = scrollTop + this.view.renderHeight;\n            if (elementTop < scrollTop && viewItemBottom >= scrollBottom) {\n                // The element is already overflowing the viewport, no-op\n            }\n            else if (elementTop < scrollTop || (viewItemBottom >= scrollBottom && elementHeight >= this.view.renderHeight)) {\n                this.view.setScrollTop(elementTop);\n            }\n            else if (viewItemBottom >= scrollBottom) {\n                this.view.setScrollTop(viewItemBottom - this.view.renderHeight);\n            }\n        }\n    }\n    getHTMLElement() {\n        return this.view.domNode;\n    }\n    getElementID(index) {\n        return this.view.getElementDomId(index);\n    }\n    style(styles) {\n        this.styleController.style(styles);\n    }\n    toListEvent({ indexes, browserEvent }) {\n        return { indexes, elements: indexes.map(i => this.view.element(i)), browserEvent };\n    }\n    _onFocusChange() {\n        const focus = this.focus.get();\n        this.view.domNode.classList.toggle('element-focused', focus.length > 0);\n        this.onDidChangeActiveDescendant();\n    }\n    onDidChangeActiveDescendant() {\n        var _a;\n        const focus = this.focus.get();\n        if (focus.length > 0) {\n            let id;\n            if ((_a = this.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getActiveDescendantId) {\n                id = this.accessibilityProvider.getActiveDescendantId(this.view.element(focus[0]));\n            }\n            this.view.domNode.setAttribute('aria-activedescendant', id || this.view.getElementDomId(focus[0]));\n        }\n        else {\n            this.view.domNode.removeAttribute('aria-activedescendant');\n        }\n    }\n    _onSelectionChange() {\n        const selection = this.selection.get();\n        this.view.domNode.classList.toggle('selection-none', selection.length === 0);\n        this.view.domNode.classList.toggle('selection-single', selection.length === 1);\n        this.view.domNode.classList.toggle('selection-multiple', selection.length > 1);\n    }\n    dispose() {\n        this._onDidDispose.fire();\n        this.disposables.dispose();\n        this._onDidDispose.dispose();\n    }\n}\n__decorate([\n    memoize\n], List.prototype, \"onDidChangeFocus\", null);\n__decorate([\n    memoize\n], List.prototype, \"onDidChangeSelection\", null);\n__decorate([\n    memoize\n], List.prototype, \"onContextMenu\", null);\n__decorate([\n    memoize\n], List.prototype, \"onKeyDown\", null);\n__decorate([\n    memoize\n], List.prototype, \"onDidFocus\", null);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $, append, clearNode, createStyleSheet } from '../../dom.js';\nimport { List } from '../list/listWidget.js';\nimport { SplitView } from '../splitview/splitview.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { DisposableStore } from '../../../common/lifecycle.js';\nimport './table.css';\nclass TableListRenderer {\n    constructor(columns, renderers, getColumnSize) {\n        this.columns = columns;\n        this.getColumnSize = getColumnSize;\n        this.templateId = TableListRenderer.TemplateId;\n        this.renderedTemplates = new Set();\n        const rendererMap = new Map(renderers.map(r => [r.templateId, r]));\n        this.renderers = [];\n        for (const column of columns) {\n            const renderer = rendererMap.get(column.templateId);\n            if (!renderer) {\n                throw new Error(`Table cell renderer for template id ${column.templateId} not found.`);\n            }\n            this.renderers.push(renderer);\n        }\n    }\n    renderTemplate(container) {\n        const rowContainer = append(container, $('.monaco-table-tr'));\n        const cellContainers = [];\n        const cellTemplateData = [];\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            const cellContainer = append(rowContainer, $('.monaco-table-td', { 'data-col-index': i }));\n            cellContainer.style.width = `${this.getColumnSize(i)}px`;\n            cellContainers.push(cellContainer);\n            cellTemplateData.push(renderer.renderTemplate(cellContainer));\n        }\n        const result = { container, cellContainers, cellTemplateData };\n        this.renderedTemplates.add(result);\n        return result;\n    }\n    renderElement(element, index, templateData, height) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const column = this.columns[i];\n            const cell = column.project(element);\n            const renderer = this.renderers[i];\n            renderer.renderElement(cell, index, templateData.cellTemplateData[i], height);\n        }\n    }\n    disposeElement(element, index, templateData, height) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            if (renderer.disposeElement) {\n                const column = this.columns[i];\n                const cell = column.project(element);\n                renderer.disposeElement(cell, index, templateData.cellTemplateData[i], height);\n            }\n        }\n    }\n    disposeTemplate(templateData) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            renderer.disposeTemplate(templateData.cellTemplateData[i]);\n        }\n        clearNode(templateData.container);\n        this.renderedTemplates.delete(templateData);\n    }\n    layoutColumn(index, size) {\n        for (const { cellContainers } of this.renderedTemplates) {\n            cellContainers[index].style.width = `${size}px`;\n        }\n    }\n}\nTableListRenderer.TemplateId = 'row';\nfunction asListVirtualDelegate(delegate) {\n    return {\n        getHeight(row) { return delegate.getHeight(row); },\n        getTemplateId() { return TableListRenderer.TemplateId; },\n    };\n}\nclass ColumnHeader {\n    constructor(column, index) {\n        this.column = column;\n        this.index = index;\n        this._onDidLayout = new Emitter();\n        this.onDidLayout = this._onDidLayout.event;\n        this.element = $('.monaco-table-th', { 'data-col-index': index, title: column.tooltip }, column.label);\n    }\n    get minimumSize() { var _a; return (_a = this.column.minimumWidth) !== null && _a !== void 0 ? _a : 120; }\n    get maximumSize() { var _a; return (_a = this.column.maximumWidth) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY; }\n    get onDidChange() { var _a; return (_a = this.column.onDidChangeWidthConstraints) !== null && _a !== void 0 ? _a : Event.None; }\n    layout(size) {\n        this._onDidLayout.fire([this.index, size]);\n    }\n}\nexport class Table {\n    constructor(user, container, virtualDelegate, columns, renderers, _options) {\n        this.virtualDelegate = virtualDelegate;\n        this.domId = `table_id_${++Table.InstanceCount}`;\n        this.disposables = new DisposableStore();\n        this.cachedWidth = 0;\n        this.cachedHeight = 0;\n        this.domNode = append(container, $(`.monaco-table.${this.domId}`));\n        const headers = columns.map((c, i) => new ColumnHeader(c, i));\n        const descriptor = {\n            size: headers.reduce((a, b) => a + b.column.weight, 0),\n            views: headers.map(view => ({ size: view.column.weight, view }))\n        };\n        this.splitview = this.disposables.add(new SplitView(this.domNode, {\n            orientation: 1 /* Orientation.HORIZONTAL */,\n            scrollbarVisibility: 2 /* ScrollbarVisibility.Hidden */,\n            getSashOrthogonalSize: () => this.cachedHeight,\n            descriptor\n        }));\n        this.splitview.el.style.height = `${virtualDelegate.headerRowHeight}px`;\n        this.splitview.el.style.lineHeight = `${virtualDelegate.headerRowHeight}px`;\n        const renderer = new TableListRenderer(columns, renderers, i => this.splitview.getViewSize(i));\n        this.list = this.disposables.add(new List(user, this.domNode, asListVirtualDelegate(virtualDelegate), [renderer], _options));\n        Event.any(...headers.map(h => h.onDidLayout))(([index, size]) => renderer.layoutColumn(index, size), null, this.disposables);\n        this.splitview.onDidSashReset(index => {\n            const totalWeight = columns.reduce((r, c) => r + c.weight, 0);\n            const size = columns[index].weight / totalWeight * this.cachedWidth;\n            this.splitview.resizeView(index, size);\n        }, null, this.disposables);\n        this.styleElement = createStyleSheet(this.domNode);\n        this.style({});\n    }\n    get onDidChangeFocus() { return this.list.onDidChangeFocus; }\n    get onDidChangeSelection() { return this.list.onDidChangeSelection; }\n    get onMouseDblClick() { return this.list.onMouseDblClick; }\n    get onPointer() { return this.list.onPointer; }\n    get onDidFocus() { return this.list.onDidFocus; }\n    get onDidDispose() { return this.list.onDidDispose; }\n    updateOptions(options) {\n        this.list.updateOptions(options);\n    }\n    splice(start, deleteCount, elements = []) {\n        this.list.splice(start, deleteCount, elements);\n    }\n    getHTMLElement() {\n        return this.domNode;\n    }\n    style(styles) {\n        const content = [];\n        content.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {\n\t\t\ttop: ${this.virtualDelegate.headerRowHeight + 1}px;\n\t\t\theight: calc(100% - ${this.virtualDelegate.headerRowHeight}px);\n\t\t}`);\n        this.styleElement.textContent = content.join('\\n');\n        this.list.style(styles);\n    }\n    getSelectedElements() {\n        return this.list.getSelectedElements();\n    }\n    getSelection() {\n        return this.list.getSelection();\n    }\n    getFocus() {\n        return this.list.getFocus();\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nTable.InstanceCount = 0;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Widget } from '../widget.js';\nimport { CSSIcon } from '../../../common/codicons.js';\nimport { Color } from '../../../common/color.js';\nimport { Emitter } from '../../../common/event.js';\nimport './toggle.css';\nconst defaultOpts = {\n    inputActiveOptionBorder: Color.fromHex('#007ACC00'),\n    inputActiveOptionForeground: Color.fromHex('#FFFFFF'),\n    inputActiveOptionBackground: Color.fromHex('#0E639C50')\n};\nexport class Toggle extends Widget {\n    constructor(opts) {\n        super();\n        this._onChange = this._register(new Emitter());\n        this.onChange = this._onChange.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._opts = Object.assign(Object.assign({}, defaultOpts), opts);\n        this._checked = this._opts.isChecked;\n        const classes = ['monaco-custom-toggle'];\n        if (this._opts.icon) {\n            this._icon = this._opts.icon;\n            classes.push(...CSSIcon.asClassNameArray(this._icon));\n        }\n        if (this._opts.actionClassName) {\n            classes.push(...this._opts.actionClassName.split(' '));\n        }\n        if (this._checked) {\n            classes.push('checked');\n        }\n        this.domNode = document.createElement('div');\n        this.domNode.title = this._opts.title;\n        this.domNode.classList.add(...classes);\n        if (!this._opts.notFocusable) {\n            this.domNode.tabIndex = 0;\n        }\n        this.domNode.setAttribute('role', 'checkbox');\n        this.domNode.setAttribute('aria-checked', String(this._checked));\n        this.domNode.setAttribute('aria-label', this._opts.title);\n        this.applyStyles();\n        this.onclick(this.domNode, (ev) => {\n            if (this.enabled) {\n                this.checked = !this._checked;\n                this._onChange.fire(false);\n                ev.preventDefault();\n            }\n        });\n        this.ignoreGesture(this.domNode);\n        this.onkeydown(this.domNode, (keyboardEvent) => {\n            if (keyboardEvent.keyCode === 10 /* KeyCode.Space */ || keyboardEvent.keyCode === 3 /* KeyCode.Enter */) {\n                this.checked = !this._checked;\n                this._onChange.fire(true);\n                keyboardEvent.preventDefault();\n                keyboardEvent.stopPropagation();\n                return;\n            }\n            this._onKeyDown.fire(keyboardEvent);\n        });\n    }\n    get enabled() {\n        return this.domNode.getAttribute('aria-disabled') !== 'true';\n    }\n    focus() {\n        this.domNode.focus();\n    }\n    get checked() {\n        return this._checked;\n    }\n    set checked(newIsChecked) {\n        this._checked = newIsChecked;\n        this.domNode.setAttribute('aria-checked', String(this._checked));\n        this.domNode.classList.toggle('checked', this._checked);\n        this.applyStyles();\n    }\n    width() {\n        return 2 /*margin left*/ + 2 /*border*/ + 2 /*padding*/ + 16 /* icon width */;\n    }\n    style(styles) {\n        if (styles.inputActiveOptionBorder) {\n            this._opts.inputActiveOptionBorder = styles.inputActiveOptionBorder;\n        }\n        if (styles.inputActiveOptionForeground) {\n            this._opts.inputActiveOptionForeground = styles.inputActiveOptionForeground;\n        }\n        if (styles.inputActiveOptionBackground) {\n            this._opts.inputActiveOptionBackground = styles.inputActiveOptionBackground;\n        }\n        this.applyStyles();\n    }\n    applyStyles() {\n        if (this.domNode) {\n            this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder ? this._opts.inputActiveOptionBorder.toString() : '';\n            this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground ? this._opts.inputActiveOptionForeground.toString() : 'inherit';\n            this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground ? this._opts.inputActiveOptionBackground.toString() : '';\n        }\n    }\n    enable() {\n        this.domNode.setAttribute('aria-disabled', String(false));\n    }\n    disable() {\n        this.domNode.setAttribute('aria-disabled', String(true));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Toggle } from '../toggle/toggle.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport * as nls from '../../../../nls.js';\nconst NLS_CASE_SENSITIVE_TOGGLE_LABEL = nls.localize('caseDescription', \"Match Case\");\nconst NLS_WHOLE_WORD_TOGGLE_LABEL = nls.localize('wordsDescription', \"Match Whole Word\");\nconst NLS_REGEX_TOGGLE_LABEL = nls.localize('regexDescription', \"Use Regular Expression\");\nexport class CaseSensitiveToggle extends Toggle {\n    constructor(opts) {\n        super({\n            icon: Codicon.caseSensitive,\n            title: NLS_CASE_SENSITIVE_TOGGLE_LABEL + opts.appendTitle,\n            isChecked: opts.isChecked,\n            inputActiveOptionBorder: opts.inputActiveOptionBorder,\n            inputActiveOptionForeground: opts.inputActiveOptionForeground,\n            inputActiveOptionBackground: opts.inputActiveOptionBackground\n        });\n    }\n}\nexport class WholeWordsToggle extends Toggle {\n    constructor(opts) {\n        super({\n            icon: Codicon.wholeWord,\n            title: NLS_WHOLE_WORD_TOGGLE_LABEL + opts.appendTitle,\n            isChecked: opts.isChecked,\n            inputActiveOptionBorder: opts.inputActiveOptionBorder,\n            inputActiveOptionForeground: opts.inputActiveOptionForeground,\n            inputActiveOptionBackground: opts.inputActiveOptionBackground\n        });\n    }\n}\nexport class RegexToggle extends Toggle {\n    constructor(opts) {\n        super({\n            icon: Codicon.regex,\n            title: NLS_REGEX_TOGGLE_LABEL + opts.appendTitle,\n            isChecked: opts.isChecked,\n            inputActiveOptionBorder: opts.inputActiveOptionBorder,\n            inputActiveOptionForeground: opts.inputActiveOptionForeground,\n            inputActiveOptionBackground: opts.inputActiveOptionBackground\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../dom.js';\nimport { CaseSensitiveToggle, RegexToggle, WholeWordsToggle } from './findInputToggles.js';\nimport { HistoryInputBox } from '../inputbox/inputBox.js';\nimport { Widget } from '../widget.js';\nimport { Emitter } from '../../../common/event.js';\nimport './findInput.css';\nimport * as nls from '../../../../nls.js';\nconst NLS_DEFAULT_LABEL = nls.localize('defaultLabel', \"input\");\nexport class FindInput extends Widget {\n    constructor(parent, contextViewProvider, _showOptionButtons, options) {\n        var _a;\n        super();\n        this._showOptionButtons = _showOptionButtons;\n        this.fixFocusOnOptionClickEnabled = true;\n        this.imeSessionInProgress = false;\n        this.additionalToggles = [];\n        this._onDidOptionChange = this._register(new Emitter());\n        this.onDidOptionChange = this._onDidOptionChange.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onMouseDown = this._register(new Emitter());\n        this.onMouseDown = this._onMouseDown.event;\n        this._onInput = this._register(new Emitter());\n        this._onKeyUp = this._register(new Emitter());\n        this._onCaseSensitiveKeyDown = this._register(new Emitter());\n        this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event;\n        this._onRegexKeyDown = this._register(new Emitter());\n        this.onRegexKeyDown = this._onRegexKeyDown.event;\n        this._lastHighlightFindOptions = 0;\n        this.contextViewProvider = contextViewProvider;\n        this.placeholder = options.placeholder || '';\n        this.validation = options.validation;\n        this.label = options.label || NLS_DEFAULT_LABEL;\n        this.inputActiveOptionBorder = options.inputActiveOptionBorder;\n        this.inputActiveOptionForeground = options.inputActiveOptionForeground;\n        this.inputActiveOptionBackground = options.inputActiveOptionBackground;\n        this.inputBackground = options.inputBackground;\n        this.inputForeground = options.inputForeground;\n        this.inputBorder = options.inputBorder;\n        this.inputValidationInfoBorder = options.inputValidationInfoBorder;\n        this.inputValidationInfoBackground = options.inputValidationInfoBackground;\n        this.inputValidationInfoForeground = options.inputValidationInfoForeground;\n        this.inputValidationWarningBorder = options.inputValidationWarningBorder;\n        this.inputValidationWarningBackground = options.inputValidationWarningBackground;\n        this.inputValidationWarningForeground = options.inputValidationWarningForeground;\n        this.inputValidationErrorBorder = options.inputValidationErrorBorder;\n        this.inputValidationErrorBackground = options.inputValidationErrorBackground;\n        this.inputValidationErrorForeground = options.inputValidationErrorForeground;\n        const appendCaseSensitiveLabel = options.appendCaseSensitiveLabel || '';\n        const appendWholeWordsLabel = options.appendWholeWordsLabel || '';\n        const appendRegexLabel = options.appendRegexLabel || '';\n        const history = options.history || [];\n        const flexibleHeight = !!options.flexibleHeight;\n        const flexibleWidth = !!options.flexibleWidth;\n        const flexibleMaxHeight = options.flexibleMaxHeight;\n        this.domNode = document.createElement('div');\n        this.domNode.classList.add('monaco-findInput');\n        this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {\n            placeholder: this.placeholder || '',\n            ariaLabel: this.label || '',\n            validationOptions: {\n                validation: this.validation\n            },\n            inputBackground: this.inputBackground,\n            inputForeground: this.inputForeground,\n            inputBorder: this.inputBorder,\n            inputValidationInfoBackground: this.inputValidationInfoBackground,\n            inputValidationInfoForeground: this.inputValidationInfoForeground,\n            inputValidationInfoBorder: this.inputValidationInfoBorder,\n            inputValidationWarningBackground: this.inputValidationWarningBackground,\n            inputValidationWarningForeground: this.inputValidationWarningForeground,\n            inputValidationWarningBorder: this.inputValidationWarningBorder,\n            inputValidationErrorBackground: this.inputValidationErrorBackground,\n            inputValidationErrorForeground: this.inputValidationErrorForeground,\n            inputValidationErrorBorder: this.inputValidationErrorBorder,\n            history,\n            showHistoryHint: options.showHistoryHint,\n            flexibleHeight,\n            flexibleWidth,\n            flexibleMaxHeight\n        }));\n        this.regex = this._register(new RegexToggle({\n            appendTitle: appendRegexLabel,\n            isChecked: false,\n            inputActiveOptionBorder: this.inputActiveOptionBorder,\n            inputActiveOptionForeground: this.inputActiveOptionForeground,\n            inputActiveOptionBackground: this.inputActiveOptionBackground\n        }));\n        this._register(this.regex.onChange(viaKeyboard => {\n            this._onDidOptionChange.fire(viaKeyboard);\n            if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {\n                this.inputBox.focus();\n            }\n            this.validate();\n        }));\n        this._register(this.regex.onKeyDown(e => {\n            this._onRegexKeyDown.fire(e);\n        }));\n        this.wholeWords = this._register(new WholeWordsToggle({\n            appendTitle: appendWholeWordsLabel,\n            isChecked: false,\n            inputActiveOptionBorder: this.inputActiveOptionBorder,\n            inputActiveOptionForeground: this.inputActiveOptionForeground,\n            inputActiveOptionBackground: this.inputActiveOptionBackground\n        }));\n        this._register(this.wholeWords.onChange(viaKeyboard => {\n            this._onDidOptionChange.fire(viaKeyboard);\n            if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {\n                this.inputBox.focus();\n            }\n            this.validate();\n        }));\n        this.caseSensitive = this._register(new CaseSensitiveToggle({\n            appendTitle: appendCaseSensitiveLabel,\n            isChecked: false,\n            inputActiveOptionBorder: this.inputActiveOptionBorder,\n            inputActiveOptionForeground: this.inputActiveOptionForeground,\n            inputActiveOptionBackground: this.inputActiveOptionBackground\n        }));\n        this._register(this.caseSensitive.onChange(viaKeyboard => {\n            this._onDidOptionChange.fire(viaKeyboard);\n            if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {\n                this.inputBox.focus();\n            }\n            this.validate();\n        }));\n        this._register(this.caseSensitive.onKeyDown(e => {\n            this._onCaseSensitiveKeyDown.fire(e);\n        }));\n        // Arrow-Key support to navigate between options\n        const indexes = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];\n        this.onkeydown(this.domNode, (event) => {\n            if (event.equals(15 /* KeyCode.LeftArrow */) || event.equals(17 /* KeyCode.RightArrow */) || event.equals(9 /* KeyCode.Escape */)) {\n                const index = indexes.indexOf(document.activeElement);\n                if (index >= 0) {\n                    let newIndex = -1;\n                    if (event.equals(17 /* KeyCode.RightArrow */)) {\n                        newIndex = (index + 1) % indexes.length;\n                    }\n                    else if (event.equals(15 /* KeyCode.LeftArrow */)) {\n                        if (index === 0) {\n                            newIndex = indexes.length - 1;\n                        }\n                        else {\n                            newIndex = index - 1;\n                        }\n                    }\n                    if (event.equals(9 /* KeyCode.Escape */)) {\n                        indexes[index].blur();\n                        this.inputBox.focus();\n                    }\n                    else if (newIndex >= 0) {\n                        indexes[newIndex].focus();\n                    }\n                    dom.EventHelper.stop(event, true);\n                }\n            }\n        });\n        this.controls = document.createElement('div');\n        this.controls.className = 'controls';\n        this.controls.style.display = this._showOptionButtons ? 'block' : 'none';\n        this.controls.appendChild(this.caseSensitive.domNode);\n        this.controls.appendChild(this.wholeWords.domNode);\n        this.controls.appendChild(this.regex.domNode);\n        if (!this._showOptionButtons) {\n            this.caseSensitive.domNode.style.display = 'none';\n            this.wholeWords.domNode.style.display = 'none';\n            this.regex.domNode.style.display = 'none';\n        }\n        for (const toggle of (_a = options === null || options === void 0 ? void 0 : options.additionalToggles) !== null && _a !== void 0 ? _a : []) {\n            this._register(toggle);\n            this.controls.appendChild(toggle.domNode);\n            this._register(toggle.onChange(viaKeyboard => {\n                this._onDidOptionChange.fire(viaKeyboard);\n                if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {\n                    this.inputBox.focus();\n                }\n            }));\n            this.additionalToggles.push(toggle);\n        }\n        if (this.additionalToggles.length > 0) {\n            this.controls.style.display = 'block';\n        }\n        this.inputBox.paddingRight =\n            (this._showOptionButtons ? this.caseSensitive.width() + this.wholeWords.width() + this.regex.width() : 0)\n                + this.additionalToggles.reduce((r, t) => r + t.width(), 0);\n        this.domNode.appendChild(this.controls);\n        parent === null || parent === void 0 ? void 0 : parent.appendChild(this.domNode);\n        this._register(dom.addDisposableListener(this.inputBox.inputElement, 'compositionstart', (e) => {\n            this.imeSessionInProgress = true;\n        }));\n        this._register(dom.addDisposableListener(this.inputBox.inputElement, 'compositionend', (e) => {\n            this.imeSessionInProgress = false;\n            this._onInput.fire();\n        }));\n        this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));\n        this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));\n        this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());\n        this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));\n    }\n    get onDidChange() {\n        return this.inputBox.onDidChange;\n    }\n    enable() {\n        this.domNode.classList.remove('disabled');\n        this.inputBox.enable();\n        this.regex.enable();\n        this.wholeWords.enable();\n        this.caseSensitive.enable();\n        for (const toggle of this.additionalToggles) {\n            toggle.enable();\n        }\n    }\n    disable() {\n        this.domNode.classList.add('disabled');\n        this.inputBox.disable();\n        this.regex.disable();\n        this.wholeWords.disable();\n        this.caseSensitive.disable();\n        for (const toggle of this.additionalToggles) {\n            toggle.disable();\n        }\n    }\n    setFocusInputOnOptionClick(value) {\n        this.fixFocusOnOptionClickEnabled = value;\n    }\n    setEnabled(enabled) {\n        if (enabled) {\n            this.enable();\n        }\n        else {\n            this.disable();\n        }\n    }\n    getValue() {\n        return this.inputBox.value;\n    }\n    setValue(value) {\n        if (this.inputBox.value !== value) {\n            this.inputBox.value = value;\n        }\n    }\n    style(styles) {\n        this.inputActiveOptionBorder = styles.inputActiveOptionBorder;\n        this.inputActiveOptionForeground = styles.inputActiveOptionForeground;\n        this.inputActiveOptionBackground = styles.inputActiveOptionBackground;\n        this.inputBackground = styles.inputBackground;\n        this.inputForeground = styles.inputForeground;\n        this.inputBorder = styles.inputBorder;\n        this.inputValidationInfoBackground = styles.inputValidationInfoBackground;\n        this.inputValidationInfoForeground = styles.inputValidationInfoForeground;\n        this.inputValidationInfoBorder = styles.inputValidationInfoBorder;\n        this.inputValidationWarningBackground = styles.inputValidationWarningBackground;\n        this.inputValidationWarningForeground = styles.inputValidationWarningForeground;\n        this.inputValidationWarningBorder = styles.inputValidationWarningBorder;\n        this.inputValidationErrorBackground = styles.inputValidationErrorBackground;\n        this.inputValidationErrorForeground = styles.inputValidationErrorForeground;\n        this.inputValidationErrorBorder = styles.inputValidationErrorBorder;\n        this.applyStyles();\n    }\n    applyStyles() {\n        if (this.domNode) {\n            const toggleStyles = {\n                inputActiveOptionBorder: this.inputActiveOptionBorder,\n                inputActiveOptionForeground: this.inputActiveOptionForeground,\n                inputActiveOptionBackground: this.inputActiveOptionBackground,\n            };\n            this.regex.style(toggleStyles);\n            this.wholeWords.style(toggleStyles);\n            this.caseSensitive.style(toggleStyles);\n            for (const toggle of this.additionalToggles) {\n                toggle.style(toggleStyles);\n            }\n            const inputBoxStyles = {\n                inputBackground: this.inputBackground,\n                inputForeground: this.inputForeground,\n                inputBorder: this.inputBorder,\n                inputValidationInfoBackground: this.inputValidationInfoBackground,\n                inputValidationInfoForeground: this.inputValidationInfoForeground,\n                inputValidationInfoBorder: this.inputValidationInfoBorder,\n                inputValidationWarningBackground: this.inputValidationWarningBackground,\n                inputValidationWarningForeground: this.inputValidationWarningForeground,\n                inputValidationWarningBorder: this.inputValidationWarningBorder,\n                inputValidationErrorBackground: this.inputValidationErrorBackground,\n                inputValidationErrorForeground: this.inputValidationErrorForeground,\n                inputValidationErrorBorder: this.inputValidationErrorBorder\n            };\n            this.inputBox.style(inputBoxStyles);\n        }\n    }\n    select() {\n        this.inputBox.select();\n    }\n    focus() {\n        this.inputBox.focus();\n    }\n    getCaseSensitive() {\n        return this.caseSensitive.checked;\n    }\n    setCaseSensitive(value) {\n        this.caseSensitive.checked = value;\n    }\n    getWholeWords() {\n        return this.wholeWords.checked;\n    }\n    setWholeWords(value) {\n        this.wholeWords.checked = value;\n    }\n    getRegex() {\n        return this.regex.checked;\n    }\n    setRegex(value) {\n        this.regex.checked = value;\n        this.validate();\n    }\n    focusOnCaseSensitive() {\n        this.caseSensitive.focus();\n    }\n    highlightFindOptions() {\n        this.domNode.classList.remove('highlight-' + (this._lastHighlightFindOptions));\n        this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;\n        this.domNode.classList.add('highlight-' + (this._lastHighlightFindOptions));\n    }\n    validate() {\n        this.inputBox.validate();\n    }\n    showMessage(message) {\n        this.inputBox.showMessage(message);\n    }\n    clearMessage() {\n        this.inputBox.hideMessage();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var TreeMouseEventTarget;\n(function (TreeMouseEventTarget) {\n    TreeMouseEventTarget[TreeMouseEventTarget[\"Unknown\"] = 0] = \"Unknown\";\n    TreeMouseEventTarget[TreeMouseEventTarget[\"Twistie\"] = 1] = \"Twistie\";\n    TreeMouseEventTarget[TreeMouseEventTarget[\"Element\"] = 2] = \"Element\";\n    TreeMouseEventTarget[TreeMouseEventTarget[\"Filter\"] = 3] = \"Filter\";\n})(TreeMouseEventTarget || (TreeMouseEventTarget = {}));\nexport class TreeError extends Error {\n    constructor(user, message) {\n        super(`TreeError [${user}] ${message}`);\n    }\n}\nexport class WeakMapper {\n    constructor(fn) {\n        this.fn = fn;\n        this._map = new WeakMap();\n    }\n    map(key) {\n        let result = this._map.get(key);\n        if (!result) {\n            result = this.fn(key);\n            this._map.set(key, result);\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeError } from './tree.js';\nimport { splice, tail2 } from '../../../common/arrays.js';\nimport { Delayer, MicrotaskDelay } from '../../../common/async.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n    return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n    switch (visibility) {\n        case true: return 1 /* TreeVisibility.Visible */;\n        case false: return 0 /* TreeVisibility.Hidden */;\n        default: return visibility;\n    }\n}\nfunction isCollapsibleStateUpdate(update) {\n    return typeof update.collapsible === 'boolean';\n}\nexport class IndexTreeModel {\n    constructor(user, list, rootElement, options = {}) {\n        this.user = user;\n        this.list = list;\n        this.rootRef = [];\n        this.eventBufferer = new EventBufferer();\n        this._onDidChangeCollapseState = new Emitter();\n        this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n        this._onDidChangeRenderNodeCount = new Emitter();\n        this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n        this._onDidSplice = new Emitter();\n        this.onDidSplice = this._onDidSplice.event;\n        this.refilterDelayer = new Delayer(MicrotaskDelay);\n        this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n        this.filter = options.filter;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.root = {\n            parent: undefined,\n            element: rootElement,\n            children: [],\n            depth: 0,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: false,\n            collapsed: false,\n            renderNodeCount: 0,\n            visibility: 1 /* TreeVisibility.Visible */,\n            visible: true,\n            filterData: undefined\n        };\n    }\n    splice(location, deleteCount, toInsert = Iterable.empty(), options = {}) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        if (options.diffIdentityProvider) {\n            this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n        }\n        else {\n            this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n    }\n    spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\n        var _a;\n        if (toInsertIterable === void 0) { toInsertIterable = Iterable.empty(); }\n        if (recurseLevels === void 0) { recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0; }\n        const { parentNode } = this.getParentNodeWithListIndex(location);\n        if (!parentNode.lastDiffIds) {\n            return this.spliceSimple(location, deleteCount, toInsertIterable, options);\n        }\n        const toInsert = [...toInsertIterable];\n        const index = location[location.length - 1];\n        const diff = new LcsDiff({ getElements: () => parentNode.lastDiffIds }, {\n            getElements: () => [\n                ...parentNode.children.slice(0, index),\n                ...toInsert,\n                ...parentNode.children.slice(index + deleteCount),\n            ].map(e => identity.getId(e.element).toString())\n        }).ComputeDiff(false);\n        // if we were given a 'best effort' diff, use default behavior\n        if (diff.quitEarly) {\n            parentNode.lastDiffIds = undefined;\n            return this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n        const locationPrefix = location.slice(0, -1);\n        const recurseSplice = (fromOriginal, fromModified, count) => {\n            if (recurseLevels > 0) {\n                for (let i = 0; i < count; i++) {\n                    fromOriginal--;\n                    fromModified--;\n                    this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\n                }\n            }\n        };\n        let lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n        let lastStartM = toInsert.length;\n        for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\n            recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n            lastStartO = change.originalStart;\n            lastStartM = change.modifiedStart - index;\n            this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\n        }\n        // at this point, startO === startM === count since any remaining prefix should match\n        recurseSplice(lastStartO, lastStartM, lastStartO);\n    }\n    spliceSimple(location, deleteCount, toInsert = Iterable.empty(), { onDidCreateNode, onDidDeleteNode, diffIdentityProvider }) {\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const treeListElementsToInsert = [];\n        const nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */, revealed, treeListElementsToInsert, onDidCreateNode));\n        const lastIndex = location[location.length - 1];\n        const lastHadChildren = parentNode.children.length > 0;\n        // figure out what's the visible child start index right before the\n        // splice point\n        let visibleChildStartIndex = 0;\n        for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n            const child = parentNode.children[i];\n            if (child.visible) {\n                visibleChildStartIndex = child.visibleChildIndex;\n                break;\n            }\n        }\n        const nodesToInsert = [];\n        let insertedVisibleChildrenCount = 0;\n        let renderNodeCount = 0;\n        for (const child of nodesToInsertIterator) {\n            nodesToInsert.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n            }\n        }\n        const deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);\n        if (!diffIdentityProvider) {\n            parentNode.lastDiffIds = undefined;\n        }\n        else if (parentNode.lastDiffIds) {\n            splice(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map(n => diffIdentityProvider.getId(n.element).toString()));\n        }\n        else {\n            parentNode.lastDiffIds = parentNode.children.map(n => diffIdentityProvider.getId(n.element).toString());\n        }\n        // figure out what is the count of deleted visible children\n        let deletedVisibleChildrenCount = 0;\n        for (const child of deletedNodes) {\n            if (child.visible) {\n                deletedVisibleChildrenCount++;\n            }\n        }\n        // and adjust for all visible children after the splice point\n        if (deletedVisibleChildrenCount !== 0) {\n            for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n                const child = parentNode.children[i];\n                if (child.visible) {\n                    child.visibleChildIndex -= deletedVisibleChildrenCount;\n                }\n            }\n        }\n        // update parent's visible children count\n        parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n        if (revealed && visible) {\n            const visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\n            this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n            this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n        }\n        if (deletedNodes.length > 0 && onDidDeleteNode) {\n            const visit = (node) => {\n                onDidDeleteNode(node);\n                node.children.forEach(visit);\n            };\n            deletedNodes.forEach(visit);\n        }\n        this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });\n        const currentlyHasChildren = parentNode.children.length > 0;\n        if (lastHadChildren !== currentlyHasChildren) {\n            this.setCollapsible(location.slice(0, -1), currentlyHasChildren);\n        }\n        let node = parentNode;\n        while (node) {\n            if (node.visibility === 2 /* TreeVisibility.Recurse */) {\n                // delayed to avoid excessive refiltering, see #135941\n                this.refilterDelayer.trigger(() => this.refilter());\n                break;\n            }\n            node = node.parent;\n        }\n    }\n    rerender(location) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        if (node.visible && revealed) {\n            this.list.splice(listIndex, 1, [node]);\n        }\n    }\n    has(location) {\n        return this.hasTreeNode(location);\n    }\n    getListIndex(location) {\n        const { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);\n        return visible && revealed ? listIndex : -1;\n    }\n    getListRenderCount(location) {\n        return this.getTreeNode(location).renderNodeCount;\n    }\n    isCollapsible(location) {\n        return this.getTreeNode(location).collapsible;\n    }\n    setCollapsible(location, collapsible) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsible === 'undefined') {\n            collapsible = !node.collapsible;\n        }\n        const update = { collapsible };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    isCollapsed(location) {\n        return this.getTreeNode(location).collapsed;\n    }\n    setCollapsed(location, collapsed, recursive) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsed === 'undefined') {\n            collapsed = !node.collapsed;\n        }\n        const update = { collapsed, recursive: recursive || false };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    _setCollapseState(location, update) {\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        const result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n        if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n            let onlyVisibleChildIndex = -1;\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                if (child.visible) {\n                    if (onlyVisibleChildIndex > -1) {\n                        onlyVisibleChildIndex = -1;\n                        break;\n                    }\n                    else {\n                        onlyVisibleChildIndex = i;\n                    }\n                }\n            }\n            if (onlyVisibleChildIndex > -1) {\n                this._setCollapseState([...location, onlyVisibleChildIndex], update);\n            }\n        }\n        return result;\n    }\n    _setListNodeCollapseState(node, listIndex, revealed, update) {\n        const result = this._setNodeCollapseState(node, update, false);\n        if (!revealed || !node.visible || !result) {\n            return result;\n        }\n        const previousRenderNodeCount = node.renderNodeCount;\n        const toInsert = this.updateNodeAfterCollapseChange(node);\n        const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n        this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n        return result;\n    }\n    _setNodeCollapseState(node, update, deep) {\n        let result;\n        if (node === this.root) {\n            result = false;\n        }\n        else {\n            if (isCollapsibleStateUpdate(update)) {\n                result = node.collapsible !== update.collapsible;\n                node.collapsible = update.collapsible;\n            }\n            else if (!node.collapsible) {\n                result = false;\n            }\n            else {\n                result = node.collapsed !== update.collapsed;\n                node.collapsed = update.collapsed;\n            }\n            if (result) {\n                this._onDidChangeCollapseState.fire({ node, deep });\n            }\n        }\n        if (!isCollapsibleStateUpdate(update) && update.recursive) {\n            for (const child of node.children) {\n                result = this._setNodeCollapseState(child, update, true) || result;\n            }\n        }\n        return result;\n    }\n    expandTo(location) {\n        this.eventBufferer.bufferEvents(() => {\n            let node = this.getTreeNode(location);\n            while (node.parent) {\n                node = node.parent;\n                location = location.slice(0, location.length - 1);\n                if (node.collapsed) {\n                    this._setCollapseState(location, { collapsed: false, recursive: false });\n                }\n            }\n        });\n    }\n    refilter() {\n        const previousRenderNodeCount = this.root.renderNodeCount;\n        const toInsert = this.updateNodeAfterFilterChange(this.root);\n        this.list.splice(0, previousRenderNodeCount, toInsert);\n        this.refilterDelayer.cancel();\n    }\n    createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n        const node = {\n            parent,\n            element: treeElement.element,\n            children: [],\n            depth: parent.depth + 1,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\n            collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n            renderNodeCount: 1,\n            visibility: 1 /* TreeVisibility.Visible */,\n            visible: true,\n            filterData: undefined\n        };\n        const visibility = this._filterNode(node, parentVisibility);\n        node.visibility = visibility;\n        if (revealed) {\n            treeListElements.push(node);\n        }\n        const childElements = treeElement.children || Iterable.empty();\n        const childRevealed = revealed && visibility !== 0 /* TreeVisibility.Hidden */ && !node.collapsed;\n        const childNodes = Iterable.map(childElements, el => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));\n        let visibleChildrenCount = 0;\n        let renderNodeCount = 1;\n        for (const child of childNodes) {\n            node.children.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildrenCount++;\n            }\n        }\n        node.collapsible = node.collapsible || node.children.length > 0;\n        node.visibleChildrenCount = visibleChildrenCount;\n        node.visible = visibility === 2 /* TreeVisibility.Recurse */ ? visibleChildrenCount > 0 : (visibility === 1 /* TreeVisibility.Visible */);\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                treeListElements.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount = renderNodeCount;\n        }\n        onDidCreateNode === null || onDidCreateNode === void 0 ? void 0 : onDidCreateNode(node);\n        return node;\n    }\n    updateNodeAfterCollapseChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterCollapseChange(node, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterCollapseChange(node, result) {\n        if (node.visible === false) {\n            return 0;\n        }\n        result.push(node);\n        node.renderNodeCount = 1;\n        if (!node.collapsed) {\n            for (const child of node.children) {\n                node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n            }\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.renderNodeCount;\n    }\n    updateNodeAfterFilterChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterFilterChange(node, node.visible ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {\n        let visibility;\n        if (node !== this.root) {\n            visibility = this._filterNode(node, parentVisibility);\n            if (visibility === 0 /* TreeVisibility.Hidden */) {\n                node.visible = false;\n                node.renderNodeCount = 0;\n                return false;\n            }\n            if (revealed) {\n                result.push(node);\n            }\n        }\n        const resultStartLength = result.length;\n        node.renderNodeCount = node === this.root ? 0 : 1;\n        let hasVisibleDescendants = false;\n        if (!node.collapsed || visibility !== 0 /* TreeVisibility.Hidden */) {\n            let visibleChildIndex = 0;\n            for (const child of node.children) {\n                hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n                if (child.visible) {\n                    child.visibleChildIndex = visibleChildIndex++;\n                }\n            }\n            node.visibleChildrenCount = visibleChildIndex;\n        }\n        else {\n            node.visibleChildrenCount = 0;\n        }\n        if (node !== this.root) {\n            node.visible = visibility === 2 /* TreeVisibility.Recurse */ ? hasVisibleDescendants : (visibility === 1 /* TreeVisibility.Visible */);\n            node.visibility = visibility;\n        }\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                result.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount += result.length - resultStartLength;\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.visible;\n    }\n    _updateAncestorsRenderNodeCount(node, diff) {\n        if (diff === 0) {\n            return;\n        }\n        while (node) {\n            node.renderNodeCount += diff;\n            this._onDidChangeRenderNodeCount.fire(node);\n            node = node.parent;\n        }\n    }\n    _filterNode(node, parentVisibility) {\n        const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* TreeVisibility.Visible */;\n        if (typeof result === 'boolean') {\n            node.filterData = undefined;\n            return result ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n        }\n        else if (isFilterResult(result)) {\n            node.filterData = result.data;\n            return getVisibleState(result.visibility);\n        }\n        else {\n            node.filterData = undefined;\n            return getVisibleState(result);\n        }\n    }\n    // cheap\n    hasTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return true;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            return false;\n        }\n        return this.hasTreeNode(rest, node.children[index]);\n    }\n    // cheap\n    getTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return node;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        return this.getTreeNode(rest, node.children[index]);\n    }\n    // expensive\n    getTreeNodeWithListIndex(location) {\n        if (location.length === 0) {\n            return { node: this.root, listIndex: -1, revealed: true, visible: false };\n        }\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const index = location[location.length - 1];\n        if (index < 0 || index > parentNode.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const node = parentNode.children[index];\n        return { node, listIndex, revealed, visible: visible && node.visible };\n    }\n    getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        // TODO@joao perf!\n        for (let i = 0; i < index; i++) {\n            listIndex += node.children[i].renderNodeCount;\n        }\n        revealed = revealed && !node.collapsed;\n        visible = visible && node.visible;\n        if (rest.length === 0) {\n            return { parentNode: node, listIndex, revealed, visible };\n        }\n        return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n    }\n    getNode(location = []) {\n        return this.getTreeNode(location);\n    }\n    // TODO@joao perf!\n    getNodeLocation(node) {\n        const location = [];\n        let indexTreeNode = node; // typing woes\n        while (indexTreeNode.parent) {\n            location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n            indexTreeNode = indexTreeNode.parent;\n        }\n        return location.reverse();\n    }\n    getParentNodeLocation(location) {\n        if (location.length === 0) {\n            return undefined;\n        }\n        else if (location.length === 1) {\n            return [];\n        }\n        else {\n            return tail2(location)[0];\n        }\n    }\n    getFirstElementChild(location) {\n        const node = this.getTreeNode(location);\n        if (node.children.length === 0) {\n            return undefined;\n        }\n        return node.children[0].element;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SetMap {\n    constructor() {\n        this.map = new Map();\n    }\n    add(key, value) {\n        let values = this.map.get(key);\n        if (!values) {\n            values = new Set();\n            this.map.set(key, values);\n        }\n        values.add(value);\n    }\n    delete(key, value) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.delete(value);\n        if (values.size === 0) {\n            this.map.delete(key);\n        }\n    }\n    forEach(key, fn) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.forEach(fn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { $, append, clearNode, createStyleSheet, h, hasParentWithClass } from '../../dom.js';\nimport { DomEmitter } from '../../event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { ActionBar } from '../actionbar/actionbar.js';\nimport { FindInput } from '../findinput/findInput.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { isButton, isInputElement, isMonacoEditor, List, MouseController } from '../list/listWidget.js';\nimport { Toggle } from '../toggle/toggle.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { TreeMouseEventTarget } from './tree.js';\nimport { Action } from '../../../common/actions.js';\nimport { distinct, equals, range } from '../../../common/arrays.js';\nimport { disposableTimeout, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { SetMap } from '../../../common/collections.js';\nimport { Emitter, Event, EventBufferer, Relay } from '../../../common/event.js';\nimport { fuzzyScore, FuzzyScore } from '../../../common/filters.js';\nimport { Disposable, DisposableStore, dispose, toDisposable } from '../../../common/lifecycle.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { isNumber } from '../../../common/types.js';\nimport './media/tree.css';\nimport { localize } from '../../../../nls.js';\nclass TreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new TreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass TreeNodeListDragAndDrop {\n    constructor(modelProvider, dnd) {\n        this.modelProvider = modelProvider;\n        this.dnd = dnd;\n        this.autoExpandDisposable = Disposable.None;\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        var _a, _b;\n        (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, asTreeDragAndDropData(data), originalEvent);\n    }\n    onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {\n        const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n        const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;\n        if (didChangeAutoExpandNode) {\n            this.autoExpandDisposable.dispose();\n            this.autoExpandNode = targetNode;\n        }\n        if (typeof targetNode === 'undefined') {\n            return result;\n        }\n        if (didChangeAutoExpandNode && typeof result !== 'boolean' && result.autoExpand) {\n            this.autoExpandDisposable = disposableTimeout(() => {\n                const model = this.modelProvider();\n                const ref = model.getNodeLocation(targetNode);\n                if (model.isCollapsed(ref)) {\n                    model.setCollapsed(ref, false);\n                }\n                this.autoExpandNode = undefined;\n            }, 500);\n        }\n        if (typeof result === 'boolean' || !result.accept || typeof result.bubble === 'undefined' || result.feedback) {\n            if (!raw) {\n                const accept = typeof result === 'boolean' ? result : result.accept;\n                const effect = typeof result === 'boolean' ? undefined : result.effect;\n                return { accept, effect, feedback: [targetIndex] };\n            }\n            return result;\n        }\n        if (result.bubble === 1 /* TreeDragOverBubble.Up */) {\n            const model = this.modelProvider();\n            const ref = model.getNodeLocation(targetNode);\n            const parentRef = model.getParentNodeLocation(ref);\n            const parentNode = model.getNode(parentRef);\n            const parentIndex = parentRef && model.getListIndex(parentRef);\n            return this.onDragOver(data, parentNode, parentIndex, originalEvent, false);\n        }\n        const model = this.modelProvider();\n        const ref = model.getNodeLocation(targetNode);\n        const start = model.getListIndex(ref);\n        const length = model.getListRenderCount(ref);\n        return Object.assign(Object.assign({}, result), { feedback: range(start, start + length) });\n    }\n    drop(data, targetNode, targetIndex, originalEvent) {\n        this.autoExpandDisposable.dispose();\n        this.autoExpandNode = undefined;\n        this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        var _a, _b;\n        (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 ? void 0 : _b.call(_a, originalEvent);\n    }\n}\nfunction asListOptions(modelProvider, options) {\n    return options && Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        }, dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd), multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            }\n        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getSetSize(node) {\n                const model = modelProvider();\n                const ref = model.getNodeLocation(node);\n                const parentRef = model.getParentNodeLocation(ref);\n                const parentNode = model.getNode(parentRef);\n                return parentNode.visibleChildrenCount;\n            },\n            getPosInSet(node) {\n                return node.visibleChildIndex + 1;\n            }, isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? (node) => {\n                return options.accessibilityProvider.isChecked(node.element);\n            } : undefined, getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? (node) => {\n                return options.accessibilityProvider.getRole(node.element);\n            } : () => 'treeitem', getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            }, getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? (node) => options.accessibilityProvider.getAriaLevel(node.element) : (node) => {\n                return node.depth;\n            }, getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            }) }), keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(node) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);\n            } }) });\n}\nexport class ComposedTreeDelegate {\n    constructor(delegate) {\n        this.delegate = delegate;\n    }\n    getHeight(element) {\n        return this.delegate.getHeight(element.element);\n    }\n    getTemplateId(element) {\n        return this.delegate.getTemplateId(element.element);\n    }\n    hasDynamicHeight(element) {\n        return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);\n    }\n    setDynamicHeight(element, height) {\n        var _a, _b;\n        (_b = (_a = this.delegate).setDynamicHeight) === null || _b === void 0 ? void 0 : _b.call(_a, element.element, height);\n    }\n}\nexport var RenderIndentGuides;\n(function (RenderIndentGuides) {\n    RenderIndentGuides[\"None\"] = \"none\";\n    RenderIndentGuides[\"OnHover\"] = \"onHover\";\n    RenderIndentGuides[\"Always\"] = \"always\";\n})(RenderIndentGuides || (RenderIndentGuides = {}));\nclass EventCollection {\n    constructor(onDidChange, _elements = []) {\n        this._elements = _elements;\n        this.disposables = new DisposableStore();\n        this.onDidChange = Event.forEach(onDidChange, elements => this._elements = elements, this.disposables);\n    }\n    get elements() {\n        return this._elements;\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nclass TreeRenderer {\n    constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, options = {}) {\n        var _a;\n        this.renderer = renderer;\n        this.modelProvider = modelProvider;\n        this.activeNodes = activeNodes;\n        this.renderedElements = new Map();\n        this.renderedNodes = new Map();\n        this.indent = TreeRenderer.DefaultIndent;\n        this.hideTwistiesOfChildlessElements = false;\n        this.shouldRenderIndentGuides = false;\n        this.renderedIndentGuides = new SetMap();\n        this.activeIndentNodes = new Set();\n        this.indentGuidesDisposable = Disposable.None;\n        this.disposables = new DisposableStore();\n        this.templateId = renderer.templateId;\n        this.updateOptions(options);\n        Event.map(onDidChangeCollapseState, e => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);\n        (_a = renderer.onDidChangeTwistieState) === null || _a === void 0 ? void 0 : _a.call(renderer, this.onDidChangeTwistieState, this, this.disposables);\n    }\n    updateOptions(options = {}) {\n        if (typeof options.indent !== 'undefined') {\n            this.indent = clamp(options.indent, 0, 40);\n        }\n        if (typeof options.renderIndentGuides !== 'undefined') {\n            const shouldRenderIndentGuides = options.renderIndentGuides !== RenderIndentGuides.None;\n            if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {\n                this.shouldRenderIndentGuides = shouldRenderIndentGuides;\n                this.indentGuidesDisposable.dispose();\n                if (shouldRenderIndentGuides) {\n                    const disposables = new DisposableStore();\n                    this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);\n                    this.indentGuidesDisposable = disposables;\n                    this._onDidChangeActiveNodes(this.activeNodes.elements);\n                }\n            }\n        }\n        if (typeof options.hideTwistiesOfChildlessElements !== 'undefined') {\n            this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements;\n        }\n    }\n    renderTemplate(container) {\n        const el = append(container, $('.monaco-tl-row'));\n        const indent = append(el, $('.monaco-tl-indent'));\n        const twistie = append(el, $('.monaco-tl-twistie'));\n        const contents = append(el, $('.monaco-tl-contents'));\n        const templateData = this.renderer.renderTemplate(contents);\n        return { container, indent, twistie, indentGuidesDisposable: Disposable.None, templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        if (typeof height === 'number') {\n            this.renderedNodes.set(node, { templateData, height });\n            this.renderedElements.set(node.element, node);\n        }\n        const indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;\n        templateData.twistie.style.paddingLeft = `${indent}px`;\n        templateData.indent.style.width = `${indent + this.indent - 16}px`;\n        this.renderTwistie(node, templateData);\n        if (typeof height === 'number') {\n            this.renderIndentGuides(node, templateData);\n        }\n        this.renderer.renderElement(node, index, templateData.templateData, height);\n    }\n    disposeElement(node, index, templateData, height) {\n        var _a, _b;\n        templateData.indentGuidesDisposable.dispose();\n        (_b = (_a = this.renderer).disposeElement) === null || _b === void 0 ? void 0 : _b.call(_a, node, index, templateData.templateData, height);\n        if (typeof height === 'number') {\n            this.renderedNodes.delete(node);\n            this.renderedElements.delete(node.element);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    onDidChangeTwistieState(element) {\n        const node = this.renderedElements.get(element);\n        if (!node) {\n            return;\n        }\n        this.onDidChangeNodeTwistieState(node);\n    }\n    onDidChangeNodeTwistieState(node) {\n        const data = this.renderedNodes.get(node);\n        if (!data) {\n            return;\n        }\n        this.renderTwistie(node, data.templateData);\n        this._onDidChangeActiveNodes(this.activeNodes.elements);\n        this.renderIndentGuides(node, data.templateData);\n    }\n    renderTwistie(node, templateData) {\n        templateData.twistie.classList.remove(...Codicon.treeItemExpanded.classNamesArray);\n        let twistieRendered = false;\n        if (this.renderer.renderTwistie) {\n            twistieRendered = this.renderer.renderTwistie(node.element, templateData.twistie);\n        }\n        if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {\n            if (!twistieRendered) {\n                templateData.twistie.classList.add(...Codicon.treeItemExpanded.classNamesArray);\n            }\n            templateData.twistie.classList.add('collapsible');\n            templateData.twistie.classList.toggle('collapsed', node.collapsed);\n        }\n        else {\n            templateData.twistie.classList.remove('collapsible', 'collapsed');\n        }\n        if (node.collapsible) {\n            templateData.container.setAttribute('aria-expanded', String(!node.collapsed));\n        }\n        else {\n            templateData.container.removeAttribute('aria-expanded');\n        }\n    }\n    renderIndentGuides(target, templateData) {\n        clearNode(templateData.indent);\n        templateData.indentGuidesDisposable.dispose();\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const disposableStore = new DisposableStore();\n        const model = this.modelProvider();\n        let node = target;\n        while (true) {\n            const ref = model.getNodeLocation(node);\n            const parentRef = model.getParentNodeLocation(ref);\n            if (!parentRef) {\n                break;\n            }\n            const parent = model.getNode(parentRef);\n            const guide = $('.indent-guide', { style: `width: ${this.indent}px` });\n            if (this.activeIndentNodes.has(parent)) {\n                guide.classList.add('active');\n            }\n            if (templateData.indent.childElementCount === 0) {\n                templateData.indent.appendChild(guide);\n            }\n            else {\n                templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);\n            }\n            this.renderedIndentGuides.add(parent, guide);\n            disposableStore.add(toDisposable(() => this.renderedIndentGuides.delete(parent, guide)));\n            node = parent;\n        }\n        templateData.indentGuidesDisposable = disposableStore;\n    }\n    _onDidChangeActiveNodes(nodes) {\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const set = new Set();\n        const model = this.modelProvider();\n        nodes.forEach(node => {\n            const ref = model.getNodeLocation(node);\n            try {\n                const parentRef = model.getParentNodeLocation(ref);\n                if (node.collapsible && node.children.length > 0 && !node.collapsed) {\n                    set.add(node);\n                }\n                else if (parentRef) {\n                    set.add(model.getNode(parentRef));\n                }\n            }\n            catch (_a) {\n                // noop\n            }\n        });\n        this.activeIndentNodes.forEach(node => {\n            if (!set.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.remove('active'));\n            }\n        });\n        set.forEach(node => {\n            if (!this.activeIndentNodes.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.add('active'));\n            }\n        });\n        this.activeIndentNodes = set;\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.renderedElements.clear();\n        this.indentGuidesDisposable.dispose();\n        dispose(this.disposables);\n    }\n}\nTreeRenderer.DefaultIndent = 8;\nclass FindFilter {\n    constructor(tree, keyboardNavigationLabelProvider, _filter) {\n        this.tree = tree;\n        this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n        this._filter = _filter;\n        this._totalCount = 0;\n        this._matchCount = 0;\n        this._pattern = '';\n        this._lowercasePattern = '';\n        this.disposables = new DisposableStore();\n        tree.onWillRefilter(this.reset, this, this.disposables);\n    }\n    get totalCount() { return this._totalCount; }\n    get matchCount() { return this._matchCount; }\n    filter(element, parentVisibility) {\n        let visibility = 1 /* TreeVisibility.Visible */;\n        if (this._filter) {\n            const result = this._filter.filter(element, parentVisibility);\n            if (typeof result === 'boolean') {\n                visibility = result ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n            }\n            else if (isFilterResult(result)) {\n                visibility = getVisibleState(result.visibility);\n            }\n            else {\n                visibility = result;\n            }\n            if (visibility === 0 /* TreeVisibility.Hidden */) {\n                return false;\n            }\n        }\n        this._totalCount++;\n        if (!this._pattern) {\n            this._matchCount++;\n            return { data: FuzzyScore.Default, visibility };\n        }\n        const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);\n        const labels = Array.isArray(label) ? label : [label];\n        for (const l of labels) {\n            const labelStr = l && l.toString();\n            if (typeof labelStr === 'undefined') {\n                return { data: FuzzyScore.Default, visibility };\n            }\n            const score = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n            if (score) {\n                this._matchCount++;\n                return labels.length === 1 ?\n                    { data: score, visibility } :\n                    { data: { label: labelStr, score: score }, visibility };\n            }\n        }\n        if (this.tree.findMode === TreeFindMode.Filter) {\n            return 2 /* TreeVisibility.Recurse */;\n        }\n        else {\n            return { data: FuzzyScore.Default, visibility };\n        }\n    }\n    reset() {\n        this._totalCount = 0;\n        this._matchCount = 0;\n    }\n    dispose() {\n        dispose(this.disposables);\n    }\n}\nexport class ModeToggle extends Toggle {\n    constructor(opts) {\n        var _a;\n        super({\n            icon: Codicon.filter,\n            title: localize('filter', \"Filter\"),\n            isChecked: (_a = opts === null || opts === void 0 ? void 0 : opts.isChecked) !== null && _a !== void 0 ? _a : false,\n            inputActiveOptionBorder: opts === null || opts === void 0 ? void 0 : opts.inputActiveOptionBorder,\n            inputActiveOptionForeground: opts === null || opts === void 0 ? void 0 : opts.inputActiveOptionForeground,\n            inputActiveOptionBackground: opts === null || opts === void 0 ? void 0 : opts.inputActiveOptionBackground\n        });\n    }\n}\nexport var TreeFindMode;\n(function (TreeFindMode) {\n    TreeFindMode[TreeFindMode[\"Highlight\"] = 0] = \"Highlight\";\n    TreeFindMode[TreeFindMode[\"Filter\"] = 1] = \"Filter\";\n})(TreeFindMode || (TreeFindMode = {}));\nclass FindWidget extends Disposable {\n    constructor(container, tree, contextViewProvider, mode, options) {\n        super();\n        this.tree = tree;\n        this.elements = h('.monaco-tree-type-filter', [\n            h('.monaco-tree-type-filter-grab.codicon.codicon-debug-gripper@grab', { tabIndex: 0 }),\n            h('.monaco-tree-type-filter-input@findInput'),\n            h('.monaco-tree-type-filter-actionbar@actionbar'),\n        ]);\n        this.width = 0;\n        this.right = 0;\n        this._onDidDisable = new Emitter();\n        container.appendChild(this.elements.root);\n        this._register(toDisposable(() => container.removeChild(this.elements.root)));\n        this.modeToggle = this._register(new ModeToggle(Object.assign(Object.assign({}, options), { isChecked: mode === TreeFindMode.Filter })));\n        this.onDidChangeMode = Event.map(this.modeToggle.onChange, () => this.modeToggle.checked ? TreeFindMode.Filter : TreeFindMode.Highlight, this._store);\n        this.findInput = this._register(new FindInput(this.elements.findInput, contextViewProvider, false, {\n            label: localize('type to search', \"Type to search\"),\n            additionalToggles: [this.modeToggle]\n        }));\n        this.actionbar = this._register(new ActionBar(this.elements.actionbar));\n        this.mode = mode;\n        const emitter = this._register(new DomEmitter(this.findInput.inputBox.inputElement, 'keydown'));\n        const onKeyDown = this._register(Event.chain(emitter.event))\n            .map(e => new StandardKeyboardEvent(e))\n            .event;\n        this._register(onKeyDown((e) => {\n            switch (e.keyCode) {\n                case 18 /* KeyCode.DownArrow */:\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.tree.domFocus();\n                    return;\n            }\n        }));\n        const closeAction = this._register(new Action('close', localize('close', \"Close\"), 'codicon codicon-close', true, () => this.dispose()));\n        this.actionbar.push(closeAction, { icon: true, label: false });\n        const onGrabMouseDown = this._register(new DomEmitter(this.elements.grab, 'mousedown'));\n        this._register(onGrabMouseDown.event(e => {\n            const disposables = new DisposableStore();\n            const onWindowMouseMove = disposables.add(new DomEmitter(window, 'mousemove'));\n            const onWindowMouseUp = disposables.add(new DomEmitter(window, 'mouseup'));\n            const startRight = this.right;\n            const startX = e.pageX;\n            this.elements.grab.classList.add('grabbing');\n            const update = (e) => {\n                const deltaX = e.pageX - startX;\n                this.right = startRight - deltaX;\n                this.layout();\n            };\n            disposables.add(onWindowMouseMove.event(update));\n            disposables.add(onWindowMouseUp.event(e => {\n                update(e);\n                this.elements.grab.classList.remove('grabbing');\n                disposables.dispose();\n            }));\n        }));\n        const onGrabKeyDown = this._register(Event.chain(this._register(new DomEmitter(this.elements.grab, 'keydown')).event))\n            .map(e => new StandardKeyboardEvent(e))\n            .event;\n        this._register(onGrabKeyDown((e) => {\n            let right;\n            if (e.keyCode === 15 /* KeyCode.LeftArrow */) {\n                right = Number.POSITIVE_INFINITY;\n            }\n            else if (e.keyCode === 17 /* KeyCode.RightArrow */) {\n                right = 0;\n            }\n            else if (e.keyCode === 10 /* KeyCode.Space */) {\n                right = this.right === 0 ? Number.POSITIVE_INFINITY : 0;\n            }\n            if (right !== undefined) {\n                e.preventDefault();\n                e.stopPropagation();\n                this.right = right;\n                this.layout();\n            }\n        }));\n        this.onDidChangeValue = this.findInput.onDidChange;\n        this.style(options !== null && options !== void 0 ? options : {});\n    }\n    set mode(mode) {\n        this.modeToggle.checked = mode === TreeFindMode.Filter;\n        this.findInput.inputBox.setPlaceHolder(mode === TreeFindMode.Filter ? localize('type to filter', \"Type to filter\") : localize('type to search', \"Type to search\"));\n    }\n    style(styles) {\n        this.findInput.style(styles);\n        if (styles.listFilterWidgetBackground) {\n            this.elements.root.style.backgroundColor = styles.listFilterWidgetBackground.toString();\n        }\n        if (styles.listFilterWidgetShadow) {\n            this.elements.root.style.boxShadow = `0 0 8px 2px ${styles.listFilterWidgetShadow}`;\n        }\n    }\n    layout(width = this.width) {\n        this.width = width;\n        this.right = clamp(this.right, 0, Math.max(0, width - 212));\n        this.elements.root.style.right = `${this.right}px`;\n    }\n    showMessage(message) {\n        this.findInput.showMessage(message);\n    }\n    clearMessage() {\n        this.findInput.clearMessage();\n    }\n    dispose() {\n        const _super = Object.create(null, {\n            dispose: { get: () => super.dispose }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            this._onDidDisable.fire();\n            this.elements.root.classList.add('disabled');\n            yield timeout(300);\n            _super.dispose.call(this);\n        });\n    }\n}\nclass FindController {\n    constructor(tree, model, view, filter, contextViewProvider) {\n        var _a;\n        this.tree = tree;\n        this.view = view;\n        this.filter = filter;\n        this.contextViewProvider = contextViewProvider;\n        this._pattern = '';\n        this.width = 0;\n        this._onDidChangeMode = new Emitter();\n        this.onDidChangeMode = this._onDidChangeMode.event;\n        this._onDidChangePattern = new Emitter();\n        this._onDidChangeOpenState = new Emitter();\n        this.onDidChangeOpenState = this._onDidChangeOpenState.event;\n        this.enabledDisposables = new DisposableStore();\n        this.disposables = new DisposableStore();\n        this._mode = (_a = tree.options.defaultFindMode) !== null && _a !== void 0 ? _a : TreeFindMode.Highlight;\n        model.onDidSplice(this.onDidSpliceModel, this, this.disposables);\n    }\n    get pattern() { return this._pattern; }\n    get mode() { return this._mode; }\n    set mode(mode) {\n        if (mode === this._mode) {\n            return;\n        }\n        this._mode = mode;\n        if (this.widget) {\n            this.widget.mode = this._mode;\n        }\n        this.tree.refilter();\n        this.render();\n        this._onDidChangeMode.fire(mode);\n    }\n    onDidSpliceModel() {\n        if (!this.widget || this.pattern.length === 0) {\n            return;\n        }\n        this.tree.refilter();\n        this.render();\n    }\n    render() {\n        var _a, _b;\n        const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;\n        if (this.pattern && noMatches) {\n            (_a = this.widget) === null || _a === void 0 ? void 0 : _a.showMessage({ type: 2 /* MessageType.WARNING */, content: localize('not found', \"No elements found.\") });\n        }\n        else {\n            (_b = this.widget) === null || _b === void 0 ? void 0 : _b.clearMessage();\n        }\n    }\n    shouldAllowFocus(node) {\n        if (!this.widget || !this.pattern || this._mode === TreeFindMode.Filter) {\n            return true;\n        }\n        if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {\n            return true;\n        }\n        return !FuzzyScore.isDefault(node.filterData);\n    }\n    style(styles) {\n        var _a;\n        this.styles = styles;\n        (_a = this.widget) === null || _a === void 0 ? void 0 : _a.style(styles);\n    }\n    layout(width) {\n        var _a;\n        this.width = width;\n        (_a = this.widget) === null || _a === void 0 ? void 0 : _a.layout(width);\n    }\n    dispose() {\n        this._onDidChangePattern.dispose();\n        this.enabledDisposables.dispose();\n        this.disposables.dispose();\n    }\n}\nfunction asTreeMouseEvent(event) {\n    let target = TreeMouseEventTarget.Unknown;\n    if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-twistie', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Twistie;\n    }\n    else if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-contents', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Element;\n    }\n    else if (hasParentWithClass(event.browserEvent.target, 'monaco-tree-type-filter', 'monaco-list')) {\n        target = TreeMouseEventTarget.Filter;\n    }\n    return {\n        browserEvent: event.browserEvent,\n        element: event.element ? event.element.element : null,\n        target\n    };\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\n/**\n * The trait concept needs to exist at the tree level, because collapsed\n * tree nodes will not be known by the list.\n */\nclass Trait {\n    constructor(getFirstViewElementWithTrait, identityProvider) {\n        this.getFirstViewElementWithTrait = getFirstViewElementWithTrait;\n        this.identityProvider = identityProvider;\n        this.nodes = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    get nodeSet() {\n        if (!this._nodeSet) {\n            this._nodeSet = this.createNodeSet();\n        }\n        return this._nodeSet;\n    }\n    set(nodes, browserEvent) {\n        if (!(browserEvent === null || browserEvent === void 0 ? void 0 : browserEvent.__forceEvent) && equals(this.nodes, nodes)) {\n            return;\n        }\n        this._set(nodes, false, browserEvent);\n    }\n    _set(nodes, silent, browserEvent) {\n        this.nodes = [...nodes];\n        this.elements = undefined;\n        this._nodeSet = undefined;\n        if (!silent) {\n            const that = this;\n            this._onDidChange.fire({ get elements() { return that.get(); }, browserEvent });\n        }\n    }\n    get() {\n        if (!this.elements) {\n            this.elements = this.nodes.map(node => node.element);\n        }\n        return [...this.elements];\n    }\n    getNodes() {\n        return this.nodes;\n    }\n    has(node) {\n        return this.nodeSet.has(node);\n    }\n    onDidModelSplice({ insertedNodes, deletedNodes }) {\n        if (!this.identityProvider) {\n            const set = this.createNodeSet();\n            const visit = (node) => set.delete(node);\n            deletedNodes.forEach(node => dfs(node, visit));\n            this.set([...set.values()]);\n            return;\n        }\n        const deletedNodesIdSet = new Set();\n        const deletedNodesVisitor = (node) => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());\n        deletedNodes.forEach(node => dfs(node, deletedNodesVisitor));\n        const insertedNodesMap = new Map();\n        const insertedNodesVisitor = (node) => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);\n        insertedNodes.forEach(node => dfs(node, insertedNodesVisitor));\n        const nodes = [];\n        for (const node of this.nodes) {\n            const id = this.identityProvider.getId(node.element).toString();\n            const wasDeleted = deletedNodesIdSet.has(id);\n            if (!wasDeleted) {\n                nodes.push(node);\n            }\n            else {\n                const insertedNode = insertedNodesMap.get(id);\n                if (insertedNode) {\n                    nodes.push(insertedNode);\n                }\n            }\n        }\n        if (this.nodes.length > 0 && nodes.length === 0) {\n            const node = this.getFirstViewElementWithTrait();\n            if (node) {\n                nodes.push(node);\n            }\n        }\n        this._set(nodes, true);\n    }\n    createNodeSet() {\n        const set = new Set();\n        for (const node of this.nodes) {\n            set.add(node);\n        }\n        return set;\n    }\n}\nclass TreeNodeListMouseController extends MouseController {\n    constructor(list, tree) {\n        super(list);\n        this.tree = tree;\n    }\n    onViewPointer(e) {\n        if (isButton(e.browserEvent.target) ||\n            isInputElement(e.browserEvent.target) ||\n            isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        const node = e.element;\n        if (!node) {\n            return super.onViewPointer(e);\n        }\n        if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {\n            return super.onViewPointer(e);\n        }\n        const target = e.browserEvent.target;\n        const onTwistie = target.classList.contains('monaco-tl-twistie')\n            || (target.classList.contains('monaco-icon-label') && target.classList.contains('folder-icon') && e.browserEvent.offsetX < 16);\n        let expandOnlyOnTwistieClick = false;\n        if (typeof this.tree.expandOnlyOnTwistieClick === 'function') {\n            expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);\n        }\n        else {\n            expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;\n        }\n        if (expandOnlyOnTwistieClick && !onTwistie && e.browserEvent.detail !== 2) {\n            return super.onViewPointer(e);\n        }\n        if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {\n            return super.onViewPointer(e);\n        }\n        if (node.collapsible) {\n            const model = this.tree.model; // internal\n            const location = model.getNodeLocation(node);\n            const recursive = e.browserEvent.altKey;\n            this.tree.setFocus([location]);\n            model.setCollapsed(location, undefined, recursive);\n            if (expandOnlyOnTwistieClick && onTwistie) {\n                return;\n            }\n        }\n        super.onViewPointer(e);\n    }\n    onDoubleClick(e) {\n        const onTwistie = e.browserEvent.target.classList.contains('monaco-tl-twistie');\n        if (onTwistie || !this.tree.expandOnDoubleClick) {\n            return;\n        }\n        super.onDoubleClick(e);\n    }\n}\n/**\n * We use this List subclass to restore selection and focus as nodes\n * get rendered in the list, possibly due to a node expand() call.\n */\nclass TreeNodeList extends List {\n    constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options) {\n        super(user, container, virtualDelegate, renderers, options);\n        this.focusTrait = focusTrait;\n        this.selectionTrait = selectionTrait;\n        this.anchorTrait = anchorTrait;\n    }\n    createMouseController(options) {\n        return new TreeNodeListMouseController(this, options.tree);\n    }\n    splice(start, deleteCount, elements = []) {\n        super.splice(start, deleteCount, elements);\n        if (elements.length === 0) {\n            return;\n        }\n        const additionalFocus = [];\n        const additionalSelection = [];\n        let anchor;\n        elements.forEach((node, index) => {\n            if (this.focusTrait.has(node)) {\n                additionalFocus.push(start + index);\n            }\n            if (this.selectionTrait.has(node)) {\n                additionalSelection.push(start + index);\n            }\n            if (this.anchorTrait.has(node)) {\n                anchor = start + index;\n            }\n        });\n        if (additionalFocus.length > 0) {\n            super.setFocus(distinct([...super.getFocus(), ...additionalFocus]));\n        }\n        if (additionalSelection.length > 0) {\n            super.setSelection(distinct([...super.getSelection(), ...additionalSelection]));\n        }\n        if (typeof anchor === 'number') {\n            super.setAnchor(anchor);\n        }\n    }\n    setFocus(indexes, browserEvent, fromAPI = false) {\n        super.setFocus(indexes, browserEvent);\n        if (!fromAPI) {\n            this.focusTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setSelection(indexes, browserEvent, fromAPI = false) {\n        super.setSelection(indexes, browserEvent);\n        if (!fromAPI) {\n            this.selectionTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setAnchor(index, fromAPI = false) {\n        super.setAnchor(index);\n        if (!fromAPI) {\n            if (typeof index === 'undefined') {\n                this.anchorTrait.set([]);\n            }\n            else {\n                this.anchorTrait.set([this.element(index)]);\n            }\n        }\n    }\n}\nexport class AbstractTree {\n    constructor(_user, container, delegate, renderers, _options = {}) {\n        var _a;\n        this._user = _user;\n        this._options = _options;\n        this.eventBufferer = new EventBufferer();\n        this.onDidChangeFindOpenState = Event.None;\n        this.disposables = new DisposableStore();\n        this._onWillRefilter = new Emitter();\n        this.onWillRefilter = this._onWillRefilter.event;\n        this._onDidUpdateOptions = new Emitter();\n        const treeDelegate = new ComposedTreeDelegate(delegate);\n        const onDidChangeCollapseStateRelay = new Relay();\n        const onDidChangeActiveNodes = new Relay();\n        const activeNodes = this.disposables.add(new EventCollection(onDidChangeActiveNodes.event));\n        this.renderers = renderers.map(r => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, _options));\n        for (const r of this.renderers) {\n            this.disposables.add(r);\n        }\n        let filter;\n        if (_options.keyboardNavigationLabelProvider) {\n            filter = new FindFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);\n            _options = Object.assign(Object.assign({}, _options), { filter: filter }); // TODO need typescript help here\n            this.disposables.add(filter);\n        }\n        this.focus = new Trait(() => this.view.getFocusedElements()[0], _options.identityProvider);\n        this.selection = new Trait(() => this.view.getSelectedElements()[0], _options.identityProvider);\n        this.anchor = new Trait(() => this.view.getAnchorElement(), _options.identityProvider);\n        this.view = new TreeNodeList(_user, container, treeDelegate, this.renderers, this.focus, this.selection, this.anchor, Object.assign(Object.assign({}, asListOptions(() => this.model, _options)), { tree: this }));\n        this.model = this.createModel(_user, this.view, _options);\n        onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;\n        const onDidModelSplice = Event.forEach(this.model.onDidSplice, e => {\n            this.eventBufferer.bufferEvents(() => {\n                this.focus.onDidModelSplice(e);\n                this.selection.onDidModelSplice(e);\n            });\n        }, this.disposables);\n        // Make sure the `forEach` always runs\n        onDidModelSplice(() => null, null, this.disposables);\n        // Active nodes can change when the model changes or when focus or selection change.\n        // We debounce it with 0 delay since these events may fire in the same stack and we only\n        // want to run this once. It also doesn't matter if it runs on the next tick since it's only\n        // a nice to have UI feature.\n        onDidChangeActiveNodes.input = Event.chain(Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange))\n            .debounce(() => null, 0)\n            .map(() => {\n            const set = new Set();\n            for (const node of this.focus.getNodes()) {\n                set.add(node);\n            }\n            for (const node of this.selection.getNodes()) {\n                set.add(node);\n            }\n            return [...set.values()];\n        }).event;\n        if (_options.keyboardSupport !== false) {\n            const onKeyDown = Event.chain(this.view.onKeyDown)\n                .filter(e => !isInputElement(e.target))\n                .map(e => new StandardKeyboardEvent(e));\n            onKeyDown.filter(e => e.keyCode === 15 /* KeyCode.LeftArrow */).on(this.onLeftArrow, this, this.disposables);\n            onKeyDown.filter(e => e.keyCode === 17 /* KeyCode.RightArrow */).on(this.onRightArrow, this, this.disposables);\n            onKeyDown.filter(e => e.keyCode === 10 /* KeyCode.Space */).on(this.onSpace, this, this.disposables);\n        }\n        if (((_a = _options.findWidgetEnabled) !== null && _a !== void 0 ? _a : true) && _options.keyboardNavigationLabelProvider && _options.contextViewProvider) {\n            this.findController = new FindController(this, this.model, this.view, filter, _options.contextViewProvider);\n            this.focusNavigationFilter = node => this.findController.shouldAllowFocus(node);\n            this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState;\n            this.disposables.add(this.findController);\n            this.onDidChangeFindMode = this.findController.onDidChangeMode;\n        }\n        else {\n            this.onDidChangeFindMode = Event.None;\n        }\n        this.styleElement = createStyleSheet(this.view.getHTMLElement());\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    get onDidChangeFocus() { return this.eventBufferer.wrapEvent(this.focus.onDidChange); }\n    get onDidChangeSelection() { return this.eventBufferer.wrapEvent(this.selection.onDidChange); }\n    get onMouseDblClick() { return Event.filter(Event.map(this.view.onMouseDblClick, asTreeMouseEvent), e => e.target !== TreeMouseEventTarget.Filter); }\n    get onPointer() { return Event.map(this.view.onPointer, asTreeMouseEvent); }\n    get onDidFocus() { return this.view.onDidFocus; }\n    get onDidChangeModel() { return Event.signal(this.model.onDidSplice); }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    get findMode() { var _a, _b; return (_b = (_a = this.findController) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : TreeFindMode.Highlight; }\n    set findMode(findMode) { if (this.findController) {\n        this.findController.mode = findMode;\n    } }\n    get expandOnDoubleClick() { return typeof this._options.expandOnDoubleClick === 'undefined' ? true : this._options.expandOnDoubleClick; }\n    get expandOnlyOnTwistieClick() { return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? true : this._options.expandOnlyOnTwistieClick; }\n    get onDidDispose() { return this.view.onDidDispose; }\n    updateOptions(optionsUpdate = {}) {\n        this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);\n        for (const renderer of this.renderers) {\n            renderer.updateOptions(optionsUpdate);\n        }\n        this.view.updateOptions(this._options);\n        this._onDidUpdateOptions.fire(this._options);\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    get options() {\n        return this._options;\n    }\n    // Widget\n    getHTMLElement() {\n        return this.view.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.view.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.view.scrollTop = scrollTop;\n    }\n    domFocus() {\n        this.view.domFocus();\n    }\n    layout(height, width) {\n        var _a;\n        this.view.layout(height, width);\n        if (isNumber(width)) {\n            (_a = this.findController) === null || _a === void 0 ? void 0 : _a.layout(width);\n        }\n    }\n    style(styles) {\n        var _a;\n        const suffix = `.${this.view.domId}`;\n        const content = [];\n        if (styles.treeIndentGuidesStroke) {\n            content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeIndentGuidesStroke.transparent(0.4)}; }`);\n            content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`);\n        }\n        this.styleElement.textContent = content.join('\\n');\n        (_a = this.findController) === null || _a === void 0 ? void 0 : _a.style(styles);\n        this.view.style(styles);\n    }\n    // Tree navigation\n    getParentElement(location) {\n        const parentRef = this.model.getParentNodeLocation(location);\n        const parentNode = this.model.getNode(parentRef);\n        return parentNode.element;\n    }\n    getFirstElementChild(location) {\n        return this.model.getFirstElementChild(location);\n    }\n    // Tree\n    getNode(location) {\n        return this.model.getNode(location);\n    }\n    collapse(location, recursive = false) {\n        return this.model.setCollapsed(location, true, recursive);\n    }\n    expand(location, recursive = false) {\n        return this.model.setCollapsed(location, false, recursive);\n    }\n    isCollapsible(location) {\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(location, collapsible) {\n        return this.model.setCollapsible(location, collapsible);\n    }\n    isCollapsed(location) {\n        return this.model.isCollapsed(location);\n    }\n    refilter() {\n        this._onWillRefilter.fire(undefined);\n        this.model.refilter();\n    }\n    setSelection(elements, browserEvent) {\n        const nodes = elements.map(e => this.model.getNode(e));\n        this.selection.set(nodes, browserEvent);\n        const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n        this.view.setSelection(indexes, browserEvent, true);\n    }\n    getSelection() {\n        return this.selection.get();\n    }\n    setFocus(elements, browserEvent) {\n        const nodes = elements.map(e => this.model.getNode(e));\n        this.focus.set(nodes, browserEvent);\n        const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n        this.view.setFocus(indexes, browserEvent, true);\n    }\n    getFocus() {\n        return this.focus.get();\n    }\n    reveal(location, relativeTop) {\n        this.model.expandTo(location);\n        const index = this.model.getListIndex(location);\n        if (index === -1) {\n            return;\n        }\n        this.view.reveal(index, relativeTop);\n    }\n    // List\n    onLeftArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, true);\n        if (!didChange) {\n            const parentLocation = this.model.getParentNodeLocation(location);\n            if (!parentLocation) {\n                return;\n            }\n            const parentListIndex = this.model.getListIndex(parentLocation);\n            this.view.reveal(parentListIndex);\n            this.view.setFocus([parentListIndex]);\n        }\n    }\n    onRightArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, false);\n        if (!didChange) {\n            if (!node.children.some(child => child.visible)) {\n                return;\n            }\n            const [focusedIndex] = this.view.getFocus();\n            const firstChildIndex = focusedIndex + 1;\n            this.view.reveal(firstChildIndex);\n            this.view.setFocus([firstChildIndex]);\n        }\n    }\n    onSpace(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const recursive = e.browserEvent.altKey;\n        this.model.setCollapsed(location, undefined, recursive);\n    }\n    dispose() {\n        dispose(this.disposables);\n        this.view.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* FontStyle.None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* FontStyle.None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (const color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* StandardTokenType.Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* StandardTokenType.Comment */;\n        case 'string':\n            return 2 /* StandardTokenType.String */;\n        case 'regex':\n            return 3 /* StandardTokenType.RegEx */;\n        case 'regexp':\n            return 3 /* StandardTokenType.RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* ColorId.None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* ColorId.None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { editorActiveIndentGuides, editorIndentGuides } from '../../common/core/editorColorRegistry.js';\nimport { editorBackground, editorForeground, editorInactiveSelection, editorSelectionHighlight } from '../../../platform/theme/common/colorRegistry.js';\n/* -------------------------------- Begin vs theme -------------------------------- */\nexport const vs = {\n    base: 'vs',\n    inherit: false,\n    rules: [\n        { token: '', foreground: '000000', background: 'fffffe' },\n        { token: 'invalid', foreground: 'cd3131' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '001188' },\n        { token: 'variable.predefined', foreground: '4864AA' },\n        { token: 'constant', foreground: 'dd0000' },\n        { token: 'comment', foreground: '008000' },\n        { token: 'number', foreground: '098658' },\n        { token: 'number.hex', foreground: '3030c0' },\n        { token: 'regexp', foreground: '800000' },\n        { token: 'annotation', foreground: '808080' },\n        { token: 'type', foreground: '008080' },\n        { token: 'delimiter', foreground: '000000' },\n        { token: 'delimiter.html', foreground: '383838' },\n        { token: 'delimiter.xml', foreground: '0000FF' },\n        { token: 'tag', foreground: '800000' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta.scss', foreground: '800000' },\n        { token: 'metatag', foreground: 'e00000' },\n        { token: 'metatag.content.html', foreground: 'FF0000' },\n        { token: 'metatag.html', foreground: '808080' },\n        { token: 'metatag.xml', foreground: '808080' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '863B00' },\n        { token: 'string.key.json', foreground: 'A31515' },\n        { token: 'string.value.json', foreground: '0451A5' },\n        { token: 'attribute.name', foreground: 'FF0000' },\n        { token: 'attribute.value', foreground: '0451A5' },\n        { token: 'attribute.value.number', foreground: '098658' },\n        { token: 'attribute.value.unit', foreground: '098658' },\n        { token: 'attribute.value.html', foreground: '0000FF' },\n        { token: 'attribute.value.xml', foreground: '0000FF' },\n        { token: 'string', foreground: 'A31515' },\n        { token: 'string.html', foreground: '0000FF' },\n        { token: 'string.sql', foreground: 'FF0000' },\n        { token: 'string.yaml', foreground: '0451A5' },\n        { token: 'keyword', foreground: '0000FF' },\n        { token: 'keyword.json', foreground: '0451A5' },\n        { token: 'keyword.flow', foreground: 'AF00DB' },\n        { token: 'keyword.flow.scss', foreground: '0000FF' },\n        { token: 'operator.scss', foreground: '666666' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '666666' },\n        { token: 'predefined.sql', foreground: 'C700C7' },\n    ],\n    colors: {\n        [editorBackground]: '#FFFFFE',\n        [editorForeground]: '#000000',\n        [editorInactiveSelection]: '#E5EBF1',\n        [editorIndentGuides]: '#D3D3D3',\n        [editorActiveIndentGuides]: '#939393',\n        [editorSelectionHighlight]: '#ADD6FF4D'\n    }\n};\n/* -------------------------------- End vs theme -------------------------------- */\n/* -------------------------------- Begin vs-dark theme -------------------------------- */\nexport const vs_dark = {\n    base: 'vs-dark',\n    inherit: false,\n    rules: [\n        { token: '', foreground: 'D4D4D4', background: '1E1E1E' },\n        { token: 'invalid', foreground: 'f44747' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '74B0DF' },\n        { token: 'variable.predefined', foreground: '4864AA' },\n        { token: 'variable.parameter', foreground: '9CDCFE' },\n        { token: 'constant', foreground: '569CD6' },\n        { token: 'comment', foreground: '608B4E' },\n        { token: 'number', foreground: 'B5CEA8' },\n        { token: 'number.hex', foreground: '5BB498' },\n        { token: 'regexp', foreground: 'B46695' },\n        { token: 'annotation', foreground: 'cc6666' },\n        { token: 'type', foreground: '3DC9B0' },\n        { token: 'delimiter', foreground: 'DCDCDC' },\n        { token: 'delimiter.html', foreground: '808080' },\n        { token: 'delimiter.xml', foreground: '808080' },\n        { token: 'tag', foreground: '569CD6' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta.scss', foreground: 'A79873' },\n        { token: 'meta.tag', foreground: 'CE9178' },\n        { token: 'metatag', foreground: 'DD6A6F' },\n        { token: 'metatag.content.html', foreground: '9CDCFE' },\n        { token: 'metatag.html', foreground: '569CD6' },\n        { token: 'metatag.xml', foreground: '569CD6' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '9CDCFE' },\n        { token: 'string.key.json', foreground: '9CDCFE' },\n        { token: 'string.value.json', foreground: 'CE9178' },\n        { token: 'attribute.name', foreground: '9CDCFE' },\n        { token: 'attribute.value', foreground: 'CE9178' },\n        { token: 'attribute.value.number.css', foreground: 'B5CEA8' },\n        { token: 'attribute.value.unit.css', foreground: 'B5CEA8' },\n        { token: 'attribute.value.hex.css', foreground: 'D4D4D4' },\n        { token: 'string', foreground: 'CE9178' },\n        { token: 'string.sql', foreground: 'FF0000' },\n        { token: 'keyword', foreground: '569CD6' },\n        { token: 'keyword.flow', foreground: 'C586C0' },\n        { token: 'keyword.json', foreground: 'CE9178' },\n        { token: 'keyword.flow.scss', foreground: '569CD6' },\n        { token: 'operator.scss', foreground: '909090' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '909090' },\n        { token: 'predefined.sql', foreground: 'FF00FF' },\n    ],\n    colors: {\n        [editorBackground]: '#1E1E1E',\n        [editorForeground]: '#D4D4D4',\n        [editorInactiveSelection]: '#3A3D41',\n        [editorIndentGuides]: '#404040',\n        [editorActiveIndentGuides]: '#707070',\n        [editorSelectionHighlight]: '#ADD6FF26'\n    }\n};\n/* -------------------------------- End vs-dark theme -------------------------------- */\n/* -------------------------------- Begin hc-black theme -------------------------------- */\nexport const hc_black = {\n    base: 'hc-black',\n    inherit: false,\n    rules: [\n        { token: '', foreground: 'FFFFFF', background: '000000' },\n        { token: 'invalid', foreground: 'f44747' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '1AEBFF' },\n        { token: 'variable.parameter', foreground: '9CDCFE' },\n        { token: 'constant', foreground: '569CD6' },\n        { token: 'comment', foreground: '608B4E' },\n        { token: 'number', foreground: 'FFFFFF' },\n        { token: 'regexp', foreground: 'C0C0C0' },\n        { token: 'annotation', foreground: '569CD6' },\n        { token: 'type', foreground: '3DC9B0' },\n        { token: 'delimiter', foreground: 'FFFF00' },\n        { token: 'delimiter.html', foreground: 'FFFF00' },\n        { token: 'tag', foreground: '569CD6' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta', foreground: 'D4D4D4' },\n        { token: 'meta.tag', foreground: 'CE9178' },\n        { token: 'metatag', foreground: '569CD6' },\n        { token: 'metatag.content.html', foreground: '1AEBFF' },\n        { token: 'metatag.html', foreground: '569CD6' },\n        { token: 'metatag.xml', foreground: '569CD6' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '9CDCFE' },\n        { token: 'string.key', foreground: '9CDCFE' },\n        { token: 'string.value', foreground: 'CE9178' },\n        { token: 'attribute.name', foreground: '569CD6' },\n        { token: 'attribute.value', foreground: '3FF23F' },\n        { token: 'string', foreground: 'CE9178' },\n        { token: 'string.sql', foreground: 'FF0000' },\n        { token: 'keyword', foreground: '569CD6' },\n        { token: 'keyword.flow', foreground: 'C586C0' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '909090' },\n        { token: 'predefined.sql', foreground: 'FF00FF' },\n    ],\n    colors: {\n        [editorBackground]: '#000000',\n        [editorForeground]: '#FFFFFF',\n        [editorIndentGuides]: '#FFFFFF',\n        [editorActiveIndentGuides]: '#FFFFFF',\n    }\n};\n/* -------------------------------- End hc-black theme -------------------------------- */\n/* -------------------------------- Begin hc-light theme -------------------------------- */\nexport const hc_light = {\n    base: 'hc-light',\n    inherit: false,\n    rules: [\n        { token: '', foreground: '292929', background: 'FFFFFF' },\n        { token: 'invalid', foreground: 'B5200D' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '264F70' },\n        { token: 'variable.predefined', foreground: '4864AA' },\n        { token: 'constant', foreground: 'dd0000' },\n        { token: 'comment', foreground: '008000' },\n        { token: 'number', foreground: '098658' },\n        { token: 'number.hex', foreground: '3030c0' },\n        { token: 'regexp', foreground: '800000' },\n        { token: 'annotation', foreground: '808080' },\n        { token: 'type', foreground: '008080' },\n        { token: 'delimiter', foreground: '000000' },\n        { token: 'delimiter.html', foreground: '383838' },\n        { token: 'tag', foreground: '800000' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta.scss', foreground: '800000' },\n        { token: 'metatag', foreground: 'e00000' },\n        { token: 'metatag.content.html', foreground: 'B5200D' },\n        { token: 'metatag.html', foreground: '808080' },\n        { token: 'metatag.xml', foreground: '808080' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '863B00' },\n        { token: 'string.key.json', foreground: 'A31515' },\n        { token: 'string.value.json', foreground: '0451A5' },\n        { token: 'attribute.name', foreground: '264F78' },\n        { token: 'attribute.value', foreground: '0451A5' },\n        { token: 'string', foreground: 'A31515' },\n        { token: 'string.sql', foreground: 'B5200D' },\n        { token: 'keyword', foreground: '0000FF' },\n        { token: 'keyword.flow', foreground: 'AF00DB' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '666666' },\n        { token: 'predefined.sql', foreground: 'C700C7' },\n    ],\n    colors: {\n        [editorBackground]: '#FFFFFF',\n        [editorForeground]: '#292929',\n        [editorIndentGuides]: '#292929',\n        [editorActiveIndentGuides]: '#292929',\n    }\n};\n/* -------------------------------- End hc-light theme -------------------------------- */\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { asCSSPropertyValue, asCSSUrl } from '../../../base/browser/dom.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { getIconRegistry } from '../common/iconRegistry.js';\nimport { ThemeIcon } from '../common/themeService.js';\nexport function getIconsStyleSheet(themeService) {\n    const onDidChangeEmmiter = new Emitter();\n    const iconRegistry = getIconRegistry();\n    iconRegistry.onDidChange(() => onDidChangeEmmiter.fire());\n    themeService === null || themeService === void 0 ? void 0 : themeService.onDidProductIconThemeChange(() => onDidChangeEmmiter.fire());\n    return {\n        onDidChange: onDidChangeEmmiter.event,\n        getCSS() {\n            const productIconTheme = themeService ? themeService.getProductIconTheme() : new UnthemedProductIconTheme();\n            const usedFontIds = {};\n            const formatIconRule = (contribution) => {\n                const definition = productIconTheme.getIcon(contribution);\n                if (!definition) {\n                    return undefined;\n                }\n                const fontContribution = definition.font;\n                if (fontContribution) {\n                    usedFontIds[fontContribution.id] = fontContribution.definition;\n                    return `.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; font-family: ${asCSSPropertyValue(fontContribution.id)}; }`;\n                }\n                // default font (codicon)\n                return `.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; }`;\n            };\n            const rules = [];\n            for (const contribution of iconRegistry.getIcons()) {\n                const rule = formatIconRule(contribution);\n                if (rule) {\n                    rules.push(rule);\n                }\n            }\n            for (const id in usedFontIds) {\n                const definition = usedFontIds[id];\n                const fontWeight = definition.weight ? `font-weight: ${definition.weight};` : '';\n                const fontStyle = definition.style ? `font-style: ${definition.style};` : '';\n                const src = definition.src.map(l => `${asCSSUrl(l.location)} format('${l.format}')`).join(', ');\n                rules.push(`@font-face { src: ${src}; font-family: ${asCSSPropertyValue(id)};${fontWeight}${fontStyle} font-display: block; }`);\n            }\n            return rules.join('\\n');\n        }\n    };\n}\nexport class UnthemedProductIconTheme {\n    getIcon(contribution) {\n        const iconRegistry = getIconRegistry();\n        let definition = contribution.defaults;\n        while (ThemeIcon.isThemeIcon(definition)) {\n            const c = iconRegistry.getIcon(definition.id);\n            if (!c) {\n                return undefined;\n            }\n            definition = c.defaults;\n        }\n        return definition;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../base/browser/dom.js';\nimport { addMatchMediaChangeListener } from '../../../base/browser/browser.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { TokenizationRegistry } from '../../common/languages.js';\nimport { TokenMetadata } from '../../common/encodedTokenAttributes.js';\nimport { TokenTheme, generateTokensCSSForColorMap } from '../../common/languages/supports/tokenization.js';\nimport { hc_black, hc_light, vs, vs_dark } from '../common/themes.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { asCssVariableName, Extensions } from '../../../platform/theme/common/colorRegistry.js';\nimport { Extensions as ThemingExtensions } from '../../../platform/theme/common/themeService.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ColorScheme, isDark, isHighContrast } from '../../../platform/theme/common/theme.js';\nimport { getIconsStyleSheet, UnthemedProductIconTheme } from '../../../platform/theme/browser/iconsStyleSheet.js';\nexport const VS_LIGHT_THEME_NAME = 'vs';\nexport const VS_DARK_THEME_NAME = 'vs-dark';\nexport const HC_BLACK_THEME_NAME = 'hc-black';\nexport const HC_LIGHT_THEME_NAME = 'hc-light';\nconst colorRegistry = Registry.as(Extensions.ColorContribution);\nconst themingRegistry = Registry.as(ThemingExtensions.ThemingContribution);\nclass StandaloneTheme {\n    constructor(name, standaloneThemeData) {\n        this.semanticHighlighting = false;\n        this.themeData = standaloneThemeData;\n        const base = standaloneThemeData.base;\n        if (name.length > 0) {\n            if (isBuiltinTheme(name)) {\n                this.id = name;\n            }\n            else {\n                this.id = base + ' ' + name;\n            }\n            this.themeName = name;\n        }\n        else {\n            this.id = base;\n            this.themeName = base;\n        }\n        this.colors = null;\n        this.defaultColors = Object.create(null);\n        this._tokenTheme = null;\n    }\n    get base() {\n        return this.themeData.base;\n    }\n    notifyBaseUpdated() {\n        if (this.themeData.inherit) {\n            this.colors = null;\n            this._tokenTheme = null;\n        }\n    }\n    getColors() {\n        if (!this.colors) {\n            const colors = new Map();\n            for (const id in this.themeData.colors) {\n                colors.set(id, Color.fromHex(this.themeData.colors[id]));\n            }\n            if (this.themeData.inherit) {\n                const baseData = getBuiltinRules(this.themeData.base);\n                for (const id in baseData.colors) {\n                    if (!colors.has(id)) {\n                        colors.set(id, Color.fromHex(baseData.colors[id]));\n                    }\n                }\n            }\n            this.colors = colors;\n        }\n        return this.colors;\n    }\n    getColor(colorId, useDefault) {\n        const color = this.getColors().get(colorId);\n        if (color) {\n            return color;\n        }\n        if (useDefault !== false) {\n            return this.getDefault(colorId);\n        }\n        return undefined;\n    }\n    getDefault(colorId) {\n        let color = this.defaultColors[colorId];\n        if (color) {\n            return color;\n        }\n        color = colorRegistry.resolveDefaultColor(colorId, this);\n        this.defaultColors[colorId] = color;\n        return color;\n    }\n    defines(colorId) {\n        return Object.prototype.hasOwnProperty.call(this.getColors(), colorId);\n    }\n    get type() {\n        switch (this.base) {\n            case VS_LIGHT_THEME_NAME: return ColorScheme.LIGHT;\n            case HC_BLACK_THEME_NAME: return ColorScheme.HIGH_CONTRAST_DARK;\n            case HC_LIGHT_THEME_NAME: return ColorScheme.HIGH_CONTRAST_LIGHT;\n            default: return ColorScheme.DARK;\n        }\n    }\n    get tokenTheme() {\n        if (!this._tokenTheme) {\n            let rules = [];\n            let encodedTokensColors = [];\n            if (this.themeData.inherit) {\n                const baseData = getBuiltinRules(this.themeData.base);\n                rules = baseData.rules;\n                if (baseData.encodedTokensColors) {\n                    encodedTokensColors = baseData.encodedTokensColors;\n                }\n            }\n            // Pick up default colors from `editor.foreground` and `editor.background` if available\n            const editorForeground = this.themeData.colors['editor.foreground'];\n            const editorBackground = this.themeData.colors['editor.background'];\n            if (editorForeground || editorBackground) {\n                const rule = { token: '' };\n                if (editorForeground) {\n                    rule.foreground = editorForeground;\n                }\n                if (editorBackground) {\n                    rule.background = editorBackground;\n                }\n                rules.push(rule);\n            }\n            rules = rules.concat(this.themeData.rules);\n            if (this.themeData.encodedTokensColors) {\n                encodedTokensColors = this.themeData.encodedTokensColors;\n            }\n            this._tokenTheme = TokenTheme.createFromRawTokenTheme(rules, encodedTokensColors);\n        }\n        return this._tokenTheme;\n    }\n    getTokenStyleMetadata(type, modifiers, modelLanguage) {\n        // use theme rules match\n        const style = this.tokenTheme._match([type].concat(modifiers).join('.'));\n        const metadata = style.metadata;\n        const foreground = TokenMetadata.getForeground(metadata);\n        const fontStyle = TokenMetadata.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */)\n        };\n    }\n}\nfunction isBuiltinTheme(themeName) {\n    return (themeName === VS_LIGHT_THEME_NAME\n        || themeName === VS_DARK_THEME_NAME\n        || themeName === HC_BLACK_THEME_NAME\n        || themeName === HC_LIGHT_THEME_NAME);\n}\nfunction getBuiltinRules(builtinTheme) {\n    switch (builtinTheme) {\n        case VS_LIGHT_THEME_NAME:\n            return vs;\n        case VS_DARK_THEME_NAME:\n            return vs_dark;\n        case HC_BLACK_THEME_NAME:\n            return hc_black;\n        case HC_LIGHT_THEME_NAME:\n            return hc_light;\n    }\n}\nfunction newBuiltInTheme(builtinTheme) {\n    const themeData = getBuiltinRules(builtinTheme);\n    return new StandaloneTheme(builtinTheme, themeData);\n}\nexport class StandaloneThemeService extends Disposable {\n    constructor() {\n        super();\n        this._onColorThemeChange = this._register(new Emitter());\n        this.onDidColorThemeChange = this._onColorThemeChange.event;\n        this._onProductIconThemeChange = this._register(new Emitter());\n        this.onDidProductIconThemeChange = this._onProductIconThemeChange.event;\n        this._environment = Object.create(null);\n        this._builtInProductIconTheme = new UnthemedProductIconTheme();\n        this._autoDetectHighContrast = true;\n        this._knownThemes = new Map();\n        this._knownThemes.set(VS_LIGHT_THEME_NAME, newBuiltInTheme(VS_LIGHT_THEME_NAME));\n        this._knownThemes.set(VS_DARK_THEME_NAME, newBuiltInTheme(VS_DARK_THEME_NAME));\n        this._knownThemes.set(HC_BLACK_THEME_NAME, newBuiltInTheme(HC_BLACK_THEME_NAME));\n        this._knownThemes.set(HC_LIGHT_THEME_NAME, newBuiltInTheme(HC_LIGHT_THEME_NAME));\n        const iconsStyleSheet = getIconsStyleSheet(this);\n        this._codiconCSS = iconsStyleSheet.getCSS();\n        this._themeCSS = '';\n        this._allCSS = `${this._codiconCSS}\\n${this._themeCSS}`;\n        this._globalStyleElement = null;\n        this._styleElements = [];\n        this._colorMapOverride = null;\n        this.setTheme(VS_LIGHT_THEME_NAME);\n        this._onOSSchemeChanged();\n        iconsStyleSheet.onDidChange(() => {\n            this._codiconCSS = iconsStyleSheet.getCSS();\n            this._updateCSS();\n        });\n        addMatchMediaChangeListener('(forced-colors: active)', () => {\n            this._onOSSchemeChanged();\n        });\n    }\n    registerEditorContainer(domNode) {\n        if (dom.isInShadowDOM(domNode)) {\n            return this._registerShadowDomContainer(domNode);\n        }\n        return this._registerRegularEditorContainer();\n    }\n    _registerRegularEditorContainer() {\n        if (!this._globalStyleElement) {\n            this._globalStyleElement = dom.createStyleSheet();\n            this._globalStyleElement.className = 'monaco-colors';\n            this._globalStyleElement.textContent = this._allCSS;\n            this._styleElements.push(this._globalStyleElement);\n        }\n        return Disposable.None;\n    }\n    _registerShadowDomContainer(domNode) {\n        const styleElement = dom.createStyleSheet(domNode);\n        styleElement.className = 'monaco-colors';\n        styleElement.textContent = this._allCSS;\n        this._styleElements.push(styleElement);\n        return {\n            dispose: () => {\n                for (let i = 0; i < this._styleElements.length; i++) {\n                    if (this._styleElements[i] === styleElement) {\n                        this._styleElements.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    defineTheme(themeName, themeData) {\n        if (!/^[a-z0-9\\-]+$/i.test(themeName)) {\n            throw new Error('Illegal theme name!');\n        }\n        if (!isBuiltinTheme(themeData.base) && !isBuiltinTheme(themeName)) {\n            throw new Error('Illegal theme base!');\n        }\n        // set or replace theme\n        this._knownThemes.set(themeName, new StandaloneTheme(themeName, themeData));\n        if (isBuiltinTheme(themeName)) {\n            this._knownThemes.forEach(theme => {\n                if (theme.base === themeName) {\n                    theme.notifyBaseUpdated();\n                }\n            });\n        }\n        if (this._theme.themeName === themeName) {\n            this.setTheme(themeName); // refresh theme\n        }\n    }\n    getColorTheme() {\n        return this._theme;\n    }\n    setColorMapOverride(colorMapOverride) {\n        this._colorMapOverride = colorMapOverride;\n        this._updateThemeOrColorMap();\n    }\n    setTheme(themeName) {\n        let theme;\n        if (this._knownThemes.has(themeName)) {\n            theme = this._knownThemes.get(themeName);\n        }\n        else {\n            theme = this._knownThemes.get(VS_LIGHT_THEME_NAME);\n        }\n        this._updateActualTheme(theme);\n    }\n    _updateActualTheme(desiredTheme) {\n        if (!desiredTheme || this._theme === desiredTheme) {\n            // Nothing to do\n            return;\n        }\n        this._theme = desiredTheme;\n        this._updateThemeOrColorMap();\n    }\n    _onOSSchemeChanged() {\n        if (this._autoDetectHighContrast) {\n            const wantsHighContrast = window.matchMedia(`(forced-colors: active)`).matches;\n            if (wantsHighContrast !== isHighContrast(this._theme.type)) {\n                // switch to high contrast or non-high contrast but stick to dark or light\n                let newThemeName;\n                if (isDark(this._theme.type)) {\n                    newThemeName = wantsHighContrast ? HC_BLACK_THEME_NAME : VS_DARK_THEME_NAME;\n                }\n                else {\n                    newThemeName = wantsHighContrast ? HC_LIGHT_THEME_NAME : VS_LIGHT_THEME_NAME;\n                }\n                this._updateActualTheme(this._knownThemes.get(newThemeName));\n            }\n        }\n    }\n    setAutoDetectHighContrast(autoDetectHighContrast) {\n        this._autoDetectHighContrast = autoDetectHighContrast;\n        this._onOSSchemeChanged();\n    }\n    _updateThemeOrColorMap() {\n        const cssRules = [];\n        const hasRule = {};\n        const ruleCollector = {\n            addRule: (rule) => {\n                if (!hasRule[rule]) {\n                    cssRules.push(rule);\n                    hasRule[rule] = true;\n                }\n            }\n        };\n        themingRegistry.getThemingParticipants().forEach(p => p(this._theme, ruleCollector, this._environment));\n        const colorVariables = [];\n        for (const item of colorRegistry.getColors()) {\n            const color = this._theme.getColor(item.id, true);\n            if (color) {\n                colorVariables.push(`${asCssVariableName(item.id)}: ${color.toString()};`);\n            }\n        }\n        ruleCollector.addRule(`.monaco-editor { ${colorVariables.join('\\n')} }`);\n        const colorMap = this._colorMapOverride || this._theme.tokenTheme.getColorMap();\n        ruleCollector.addRule(generateTokensCSSForColorMap(colorMap));\n        this._themeCSS = cssRules.join('\\n');\n        this._updateCSS();\n        TokenizationRegistry.setColorMap(colorMap);\n        this._onColorThemeChange.fire(this._theme);\n    }\n    _updateCSS() {\n        this._allCSS = `${this._codiconCSS}\\n${this._themeCSS}`;\n        this._styleElements.forEach(styleElement => styleElement.textContent = this._allCSS);\n    }\n    getFileIconTheme() {\n        return {\n            hasFileIcons: false,\n            hasFolderIcons: false,\n            hidesExplorerArrows: false\n        };\n    }\n    getProductIconTheme() {\n        return this._builtInProductIconTheme;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IStandaloneThemeService = createDecorator('themeService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { addDisposableListener } from '../../../base/browser/dom.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { CONTEXT_ACCESSIBILITY_MODE_ENABLED } from '../common/accessibility.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nlet AccessibilityService = class AccessibilityService extends Disposable {\n    constructor(_contextKeyService, _layoutService, _configurationService) {\n        super();\n        this._contextKeyService = _contextKeyService;\n        this._layoutService = _layoutService;\n        this._configurationService = _configurationService;\n        this._accessibilitySupport = 0 /* AccessibilitySupport.Unknown */;\n        this._onDidChangeScreenReaderOptimized = new Emitter();\n        this._onDidChangeReducedMotion = new Emitter();\n        this._accessibilityModeEnabledContext = CONTEXT_ACCESSIBILITY_MODE_ENABLED.bindTo(this._contextKeyService);\n        const updateContextKey = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());\n        this._register(this._configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('editor.accessibilitySupport')) {\n                updateContextKey();\n                this._onDidChangeScreenReaderOptimized.fire();\n            }\n            if (e.affectsConfiguration('workbench.reduceMotion')) {\n                this._configMotionReduced = this._configurationService.getValue('workbench.reduceMotion');\n                this._onDidChangeReducedMotion.fire();\n            }\n        }));\n        updateContextKey();\n        this._register(this.onDidChangeScreenReaderOptimized(() => updateContextKey()));\n        const reduceMotionMatcher = window.matchMedia(`(prefers-reduced-motion: reduce)`);\n        this._systemMotionReduced = reduceMotionMatcher.matches;\n        this._configMotionReduced = this._configurationService.getValue('workbench.reduceMotion');\n        this.initReducedMotionListeners(reduceMotionMatcher);\n    }\n    initReducedMotionListeners(reduceMotionMatcher) {\n        if (!this._layoutService.hasContainer) {\n            // we can't use `ILayoutService.container` because the application\n            // doesn't have a single container\n            return;\n        }\n        this._register(addDisposableListener(reduceMotionMatcher, 'change', () => {\n            this._systemMotionReduced = reduceMotionMatcher.matches;\n            if (this._configMotionReduced === 'auto') {\n                this._onDidChangeReducedMotion.fire();\n            }\n        }));\n        const updateRootClasses = () => {\n            const reduce = this.isMotionReduced();\n            this._layoutService.container.classList.toggle('reduce-motion', reduce);\n            this._layoutService.container.classList.toggle('enable-motion', !reduce);\n        };\n        updateRootClasses();\n        this._register(this.onDidChangeReducedMotion(() => updateRootClasses()));\n    }\n    get onDidChangeScreenReaderOptimized() {\n        return this._onDidChangeScreenReaderOptimized.event;\n    }\n    isScreenReaderOptimized() {\n        const config = this._configurationService.getValue('editor.accessibilitySupport');\n        return config === 'on' || (config === 'auto' && this._accessibilitySupport === 2 /* AccessibilitySupport.Enabled */);\n    }\n    get onDidChangeReducedMotion() {\n        return this._onDidChangeReducedMotion.event;\n    }\n    isMotionReduced() {\n        const config = this._configMotionReduced;\n        return config === 'on' || (config === 'auto' && this._systemMotionReduced);\n    }\n    getAccessibilitySupport() {\n        return this._accessibilitySupport;\n    }\n};\nAccessibilityService = __decorate([\n    __param(0, IContextKeyService),\n    __param(1, ILayoutService),\n    __param(2, IConfigurationService)\n], AccessibilityService);\nexport { AccessibilityService };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Node {\n    constructor(data) {\n        this.incoming = new Map();\n        this.outgoing = new Map();\n        this.data = data;\n    }\n}\nexport class Graph {\n    constructor(_hashFn) {\n        this._hashFn = _hashFn;\n        this._nodes = new Map();\n        // empty\n    }\n    roots() {\n        const ret = [];\n        for (const node of this._nodes.values()) {\n            if (node.outgoing.size === 0) {\n                ret.push(node);\n            }\n        }\n        return ret;\n    }\n    insertEdge(from, to) {\n        const fromNode = this.lookupOrInsertNode(from);\n        const toNode = this.lookupOrInsertNode(to);\n        fromNode.outgoing.set(this._hashFn(to), toNode);\n        toNode.incoming.set(this._hashFn(from), fromNode);\n    }\n    removeNode(data) {\n        const key = this._hashFn(data);\n        this._nodes.delete(key);\n        for (const node of this._nodes.values()) {\n            node.outgoing.delete(key);\n            node.incoming.delete(key);\n        }\n    }\n    lookupOrInsertNode(data) {\n        const key = this._hashFn(data);\n        let node = this._nodes.get(key);\n        if (!node) {\n            node = new Node(data);\n            this._nodes.set(key, node);\n        }\n        return node;\n    }\n    isEmpty() {\n        return this._nodes.size === 0;\n    }\n    toString() {\n        const data = [];\n        for (const [key, value] of this._nodes) {\n            data.push(`${key}, (incoming)[${[...value.incoming.keys()].join(', ')}], (outgoing)[${[...value.outgoing.keys()].join(',')}]`);\n        }\n        return data.join('\\n');\n    }\n    /**\n     * This is brute force and slow and **only** be used\n     * to trouble shoot.\n     */\n    findCycleSlow() {\n        for (const [id, node] of this._nodes) {\n            const seen = new Set([id]);\n            const res = this._findCycle(node, seen);\n            if (res) {\n                return res;\n            }\n        }\n        return undefined;\n    }\n    _findCycle(node, seen) {\n        for (const [id, outgoing] of node.outgoing) {\n            if (seen.has(id)) {\n                return [...seen, id].join(' -> ');\n            }\n            seen.add(id);\n            const value = this._findCycle(outgoing, seen);\n            if (value) {\n                return value;\n            }\n            seen.delete(id);\n        }\n        return undefined;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\n// TRACING\nconst _enableTracing = false;\nclass CyclicDependencyError extends Error {\n    constructor(graph) {\n        var _a;\n        super('cyclic dependency between services');\n        this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n    }\n}\nexport class InstantiationService {\n    constructor(services = new ServiceCollection(), strict = false, parent) {\n        this._activeInstantiations = new Set();\n        this._services = services;\n        this._strict = strict;\n        this._parent = parent;\n        this._services.set(IInstantiationService, this);\n    }\n    createChild(services) {\n        return new InstantiationService(services, this._strict, this);\n    }\n    invokeFunction(fn, ...args) {\n        const _trace = Trace.traceInvocation(fn);\n        let _done = false;\n        try {\n            const accessor = {\n                get: (id) => {\n                    if (_done) {\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\n                    }\n                    const result = this._getOrCreateServiceInstance(id, _trace);\n                    if (!result) {\n                        throw new Error(`[invokeFunction] unknown service '${id}'`);\n                    }\n                    return result;\n                }\n            };\n            return fn(accessor, ...args);\n        }\n        finally {\n            _done = true;\n            _trace.stop();\n        }\n    }\n    createInstance(ctorOrDescriptor, ...rest) {\n        let _trace;\n        let result;\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\n            _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n        }\n        else {\n            _trace = Trace.traceCreation(ctorOrDescriptor);\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\n        }\n        _trace.stop();\n        return result;\n    }\n    _createInstance(ctor, args = [], _trace) {\n        // arguments defined by service decorators\n        const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n        const serviceArgs = [];\n        for (const dependency of serviceDependencies) {\n            const service = this._getOrCreateServiceInstance(dependency.id, _trace);\n            if (!service) {\n                this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n            }\n            serviceArgs.push(service);\n        }\n        const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n        // check for argument mismatches, adjust static args if needed\n        if (args.length !== firstServiceArgPos) {\n            console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n            const delta = firstServiceArgPos - args.length;\n            if (delta > 0) {\n                args = args.concat(new Array(delta));\n            }\n            else {\n                args = args.slice(0, firstServiceArgPos);\n            }\n        }\n        // now create the instance\n        return new ctor(...[...args, ...serviceArgs]);\n    }\n    _setServiceInstance(id, instance) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            this._services.set(id, instance);\n        }\n        else if (this._parent) {\n            this._parent._setServiceInstance(id, instance);\n        }\n        else {\n            throw new Error('illegalState - setting UNKNOWN service instance');\n        }\n    }\n    _getServiceInstanceOrDescriptor(id) {\n        const instanceOrDesc = this._services.get(id);\n        if (!instanceOrDesc && this._parent) {\n            return this._parent._getServiceInstanceOrDescriptor(id);\n        }\n        else {\n            return instanceOrDesc;\n        }\n    }\n    _getOrCreateServiceInstance(id, _trace) {\n        const thing = this._getServiceInstanceOrDescriptor(id);\n        if (thing instanceof SyncDescriptor) {\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n        }\n        else {\n            _trace.branch(id, false);\n            return thing;\n        }\n    }\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n        if (this._activeInstantiations.has(id)) {\n            throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n        }\n        this._activeInstantiations.add(id);\n        try {\n            return this._createAndCacheServiceInstance(id, desc, _trace);\n        }\n        finally {\n            this._activeInstantiations.delete(id);\n        }\n    }\n    _createAndCacheServiceInstance(id, desc, _trace) {\n        const graph = new Graph(data => data.id.toString());\n        let cycleCount = 0;\n        const stack = [{ id, desc, _trace }];\n        while (stack.length) {\n            const item = stack.pop();\n            graph.lookupOrInsertNode(item);\n            // a weak but working heuristic for cycle checks\n            if (cycleCount++ > 1000) {\n                throw new CyclicDependencyError(graph);\n            }\n            // check all dependencies for existence and if they need to be created first\n            for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                if (!instanceOrDesc) {\n                    this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n                }\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                    graph.insertEdge(item, d);\n                    stack.push(d);\n                }\n            }\n        }\n        while (true) {\n            const roots = graph.roots();\n            // if there is no more roots but still\n            // nodes in the graph we have a cycle\n            if (roots.length === 0) {\n                if (!graph.isEmpty()) {\n                    throw new CyclicDependencyError(graph);\n                }\n                break;\n            }\n            for (const { data } of roots) {\n                // Repeat the check for this still being a service sync descriptor. That's because\n                // instantiating a dependency might have side-effect and recursively trigger instantiation\n                // so that some dependencies are now fullfilled already.\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    // create instance and overwrite the service collections\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                    this._setServiceInstance(data.id, instance);\n                }\n                graph.removeNode(data);\n            }\n        }\n        return this._getServiceInstanceOrDescriptor(id);\n    }\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else if (this._parent) {\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else {\n            throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n        }\n    }\n    _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {\n        if (!_supportsDelayedInstantiation) {\n            // eager instantiation\n            return this._createInstance(ctor, args, _trace);\n        }\n        else {\n            // Return a proxy object that's backed by an idle value. That\n            // strategy is to instantiate services in our idle time or when actually\n            // needed but not when injected into a consumer\n            const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\n            return new Proxy(Object.create(null), {\n                get(target, key) {\n                    if (key in target) {\n                        return target[key];\n                    }\n                    const obj = idle.value;\n                    let prop = obj[key];\n                    if (typeof prop !== 'function') {\n                        return prop;\n                    }\n                    prop = prop.bind(obj);\n                    target[key] = prop;\n                    return prop;\n                },\n                set(_target, p, value) {\n                    idle.value[p] = value;\n                    return true;\n                }\n            });\n        }\n    }\n    _throwIfStrict(msg, printWarning) {\n        if (printWarning) {\n            console.warn(msg);\n        }\n        if (this._strict) {\n            throw new Error(msg);\n        }\n    }\n}\nexport class Trace {\n    constructor(type, name) {\n        this.type = type;\n        this.name = name;\n        this._start = Date.now();\n        this._dep = [];\n    }\n    static traceInvocation(ctor) {\n        return !_enableTracing ? Trace._None : new Trace(1 /* TraceType.Invocation */, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n    }\n    static traceCreation(ctor) {\n        return !_enableTracing ? Trace._None : new Trace(0 /* TraceType.Creation */, ctor.name);\n    }\n    branch(id, first) {\n        const child = new Trace(2 /* TraceType.Branch */, id.toString());\n        this._dep.push([id, first, child]);\n        return child;\n    }\n    stop() {\n        const dur = Date.now() - this._start;\n        Trace._totals += dur;\n        let causedCreation = false;\n        function printChild(n, trace) {\n            const res = [];\n            const prefix = new Array(n + 1).join('\\t');\n            for (const [id, first, child] of trace._dep) {\n                if (first && child) {\n                    causedCreation = true;\n                    res.push(`${prefix}CREATES -> ${id}`);\n                    const nested = printChild(n + 1, child);\n                    if (nested) {\n                        res.push(nested);\n                    }\n                }\n                else {\n                    res.push(`${prefix}uses -> ${id}`);\n                }\n            }\n            return res.join('\\n');\n        }\n        const lines = [\n            `${this.type === 0 /* TraceType.Creation */ ? 'CREATE' : 'CALL'} ${this.name}`,\n            `${printChild(1, this)}`,\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n        ];\n        if (dur > 2 || causedCreation) {\n            console.log(lines.join('\\n'));\n        }\n    }\n}\nTrace._None = new class extends Trace {\n    constructor() { super(-1, null); }\n    stop() { }\n    branch() { return this; }\n};\nTrace._totals = 0;\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isFalsyOrEmpty, isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { DebounceEmitter } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { MarkerSeverity } from './markers.js';\nclass DoubleResourceMap {\n    constructor() {\n        this._byResource = new ResourceMap();\n        this._byOwner = new Map();\n    }\n    set(resource, owner, value) {\n        let ownerMap = this._byResource.get(resource);\n        if (!ownerMap) {\n            ownerMap = new Map();\n            this._byResource.set(resource, ownerMap);\n        }\n        ownerMap.set(owner, value);\n        let resourceMap = this._byOwner.get(owner);\n        if (!resourceMap) {\n            resourceMap = new ResourceMap();\n            this._byOwner.set(owner, resourceMap);\n        }\n        resourceMap.set(resource, value);\n    }\n    get(resource, owner) {\n        const ownerMap = this._byResource.get(resource);\n        return ownerMap === null || ownerMap === void 0 ? void 0 : ownerMap.get(owner);\n    }\n    delete(resource, owner) {\n        let removedA = false;\n        let removedB = false;\n        const ownerMap = this._byResource.get(resource);\n        if (ownerMap) {\n            removedA = ownerMap.delete(owner);\n        }\n        const resourceMap = this._byOwner.get(owner);\n        if (resourceMap) {\n            removedB = resourceMap.delete(resource);\n        }\n        if (removedA !== removedB) {\n            throw new Error('illegal state');\n        }\n        return removedA && removedB;\n    }\n    values(key) {\n        var _a, _b, _c, _d;\n        if (typeof key === 'string') {\n            return (_b = (_a = this._byOwner.get(key)) === null || _a === void 0 ? void 0 : _a.values()) !== null && _b !== void 0 ? _b : Iterable.empty();\n        }\n        if (URI.isUri(key)) {\n            return (_d = (_c = this._byResource.get(key)) === null || _c === void 0 ? void 0 : _c.values()) !== null && _d !== void 0 ? _d : Iterable.empty();\n        }\n        return Iterable.map(Iterable.concat(...this._byOwner.values()), map => map[1]);\n    }\n}\nclass MarkerStats {\n    constructor(service) {\n        this.errors = 0;\n        this.infos = 0;\n        this.warnings = 0;\n        this.unknowns = 0;\n        this._data = new ResourceMap();\n        this._service = service;\n        this._subscription = service.onMarkerChanged(this._update, this);\n    }\n    dispose() {\n        this._subscription.dispose();\n    }\n    _update(resources) {\n        for (const resource of resources) {\n            const oldStats = this._data.get(resource);\n            if (oldStats) {\n                this._substract(oldStats);\n            }\n            const newStats = this._resourceStats(resource);\n            this._add(newStats);\n            this._data.set(resource, newStats);\n        }\n    }\n    _resourceStats(resource) {\n        const result = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };\n        // TODO this is a hack\n        if (resource.scheme === Schemas.inMemory || resource.scheme === Schemas.walkThrough || resource.scheme === Schemas.walkThroughSnippet || resource.scheme === Schemas.vscodeSourceControl) {\n            return result;\n        }\n        for (const { severity } of this._service.read({ resource })) {\n            if (severity === MarkerSeverity.Error) {\n                result.errors += 1;\n            }\n            else if (severity === MarkerSeverity.Warning) {\n                result.warnings += 1;\n            }\n            else if (severity === MarkerSeverity.Info) {\n                result.infos += 1;\n            }\n            else {\n                result.unknowns += 1;\n            }\n        }\n        return result;\n    }\n    _substract(op) {\n        this.errors -= op.errors;\n        this.warnings -= op.warnings;\n        this.infos -= op.infos;\n        this.unknowns -= op.unknowns;\n    }\n    _add(op) {\n        this.errors += op.errors;\n        this.warnings += op.warnings;\n        this.infos += op.infos;\n        this.unknowns += op.unknowns;\n    }\n}\nexport class MarkerService {\n    constructor() {\n        this._onMarkerChanged = new DebounceEmitter({\n            delay: 0,\n            merge: MarkerService._merge\n        });\n        this.onMarkerChanged = this._onMarkerChanged.event;\n        this._data = new DoubleResourceMap();\n        this._stats = new MarkerStats(this);\n    }\n    dispose() {\n        this._stats.dispose();\n        this._onMarkerChanged.dispose();\n    }\n    remove(owner, resources) {\n        for (const resource of resources || []) {\n            this.changeOne(owner, resource, []);\n        }\n    }\n    changeOne(owner, resource, markerData) {\n        if (isFalsyOrEmpty(markerData)) {\n            // remove marker for this (owner,resource)-tuple\n            const removed = this._data.delete(resource, owner);\n            if (removed) {\n                this._onMarkerChanged.fire([resource]);\n            }\n        }\n        else {\n            // insert marker for this (owner,resource)-tuple\n            const markers = [];\n            for (const data of markerData) {\n                const marker = MarkerService._toMarker(owner, resource, data);\n                if (marker) {\n                    markers.push(marker);\n                }\n            }\n            this._data.set(resource, owner, markers);\n            this._onMarkerChanged.fire([resource]);\n        }\n    }\n    static _toMarker(owner, resource, data) {\n        let { code, severity, message, source, startLineNumber, startColumn, endLineNumber, endColumn, relatedInformation, tags, } = data;\n        if (!message) {\n            return undefined;\n        }\n        // santize data\n        startLineNumber = startLineNumber > 0 ? startLineNumber : 1;\n        startColumn = startColumn > 0 ? startColumn : 1;\n        endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;\n        endColumn = endColumn > 0 ? endColumn : startColumn;\n        return {\n            resource,\n            owner,\n            code,\n            severity,\n            message,\n            source,\n            startLineNumber,\n            startColumn,\n            endLineNumber,\n            endColumn,\n            relatedInformation,\n            tags,\n        };\n    }\n    changeAll(owner, data) {\n        const changes = [];\n        // remove old marker\n        const existing = this._data.values(owner);\n        if (existing) {\n            for (const data of existing) {\n                const first = Iterable.first(data);\n                if (first) {\n                    changes.push(first.resource);\n                    this._data.delete(first.resource, owner);\n                }\n            }\n        }\n        // add new markers\n        if (isNonEmptyArray(data)) {\n            // group by resource\n            const groups = new ResourceMap();\n            for (const { resource, marker: markerData } of data) {\n                const marker = MarkerService._toMarker(owner, resource, markerData);\n                if (!marker) {\n                    // filter bad markers\n                    continue;\n                }\n                const array = groups.get(resource);\n                if (!array) {\n                    groups.set(resource, [marker]);\n                    changes.push(resource);\n                }\n                else {\n                    array.push(marker);\n                }\n            }\n            // insert all\n            for (const [resource, value] of groups) {\n                this._data.set(resource, owner, value);\n            }\n        }\n        if (changes.length > 0) {\n            this._onMarkerChanged.fire(changes);\n        }\n    }\n    read(filter = Object.create(null)) {\n        let { owner, resource, severities, take } = filter;\n        if (!take || take < 0) {\n            take = -1;\n        }\n        if (owner && resource) {\n            // exactly one owner AND resource\n            const data = this._data.get(resource, owner);\n            if (!data) {\n                return [];\n            }\n            else {\n                const result = [];\n                for (const marker of data) {\n                    if (MarkerService._accept(marker, severities)) {\n                        const newLen = result.push(marker);\n                        if (take > 0 && newLen === take) {\n                            break;\n                        }\n                    }\n                }\n                return result;\n            }\n        }\n        else if (!owner && !resource) {\n            // all\n            const result = [];\n            for (const markers of this._data.values()) {\n                for (const data of markers) {\n                    if (MarkerService._accept(data, severities)) {\n                        const newLen = result.push(data);\n                        if (take > 0 && newLen === take) {\n                            return result;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n        else {\n            // of one resource OR owner\n            const iterable = this._data.values(resource !== null && resource !== void 0 ? resource : owner);\n            const result = [];\n            for (const markers of iterable) {\n                for (const data of markers) {\n                    if (MarkerService._accept(data, severities)) {\n                        const newLen = result.push(data);\n                        if (take > 0 && newLen === take) {\n                            return result;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n    }\n    static _accept(marker, severities) {\n        return severities === undefined || (severities & marker.severity) === marker.severity;\n    }\n    // --- event debounce logic\n    static _merge(all) {\n        const set = new ResourceMap();\n        for (const array of all) {\n            for (const item of array) {\n                set.set(item, true);\n            }\n        }\n        return Array.from(set.keys());\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport '../../common/languages/languageConfigurationRegistry.js';\nimport './standaloneCodeEditorService.js';\nimport './standaloneLayoutService.js';\nimport '../../../platform/undoRedo/common/undoRedoService.js';\nimport '../../common/services/languageFeatureDebounce.js';\nimport * as strings from '../../../base/common/strings.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { SimpleKeybinding, createKeybinding } from '../../../base/common/keybindings.js';\nimport { ImmortalReference, toDisposable, DisposableStore, Disposable } from '../../../base/common/lifecycle.js';\nimport { OS, isLinux, isMacintosh } from '../../../base/common/platform.js';\nimport Severity from '../../../base/common/severity.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IBulkEditService, ResourceTextEdit } from '../../browser/services/bulkEditService.js';\nimport { isDiffEditorConfigurationKey, isEditorConfigurationKey } from '../../common/config/editorConfigurationSchema.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position as Pos } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { ITextModelService } from '../../common/services/resolverService.js';\nimport { ITextResourceConfigurationService, ITextResourcePropertiesService } from '../../common/services/textResourceConfiguration.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { Configuration, ConfigurationModel, ConfigurationChangeEvent } from '../../../platform/configuration/common/configurationModels.js';\nimport { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IDialogService } from '../../../platform/dialogs/common/dialogs.js';\nimport { createDecorator, IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { AbstractKeybindingService } from '../../../platform/keybinding/common/abstractKeybindingService.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\nimport { KeybindingResolver } from '../../../platform/keybinding/common/keybindingResolver.js';\nimport { KeybindingsRegistry } from '../../../platform/keybinding/common/keybindingsRegistry.js';\nimport { ResolvedKeybindingItem } from '../../../platform/keybinding/common/resolvedKeybindingItem.js';\nimport { USLayoutResolvedKeybinding } from '../../../platform/keybinding/common/usLayoutResolvedKeybinding.js';\nimport { ILabelService } from '../../../platform/label/common/label.js';\nimport { INotificationService, NoOpNotification } from '../../../platform/notification/common/notification.js';\nimport { IEditorProgressService, IProgressService } from '../../../platform/progress/common/progress.js';\nimport { ITelemetryService } from '../../../platform/telemetry/common/telemetry.js';\nimport { IWorkspaceContextService, WorkspaceFolder } from '../../../platform/workspace/common/workspace.js';\nimport { ILayoutService } from '../../../platform/layout/browser/layoutService.js';\nimport { StandaloneServicesNLS } from '../../common/standaloneStrings.js';\nimport { basename } from '../../../base/common/resources.js';\nimport { ICodeEditorService } from '../../browser/services/codeEditorService.js';\nimport { ConsoleLogger, ILogService, LogService } from '../../../platform/log/common/log.js';\nimport { IWorkspaceTrustManagementService } from '../../../platform/workspace/common/workspaceTrust.js';\nimport { IContextMenuService, IContextViewService } from '../../../platform/contextview/browser/contextView.js';\nimport { ContextViewService } from '../../../platform/contextview/browser/contextViewService.js';\nimport { LanguageService } from '../../common/services/languageService.js';\nimport { ContextMenuService } from '../../../platform/contextview/browser/contextMenuService.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { getSingletonServiceDescriptors, registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { OpenerService } from '../../browser/services/openerService.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorker.js';\nimport { EditorWorkerService } from '../../browser/services/editorWorkerService.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nimport { MarkerDecorationsService } from '../../common/services/markerDecorationsService.js';\nimport { IMarkerDecorationsService } from '../../common/services/markerDecorations.js';\nimport { ModelService } from '../../common/services/modelService.js';\nimport { StandaloneQuickInputService } from './quickInput/standaloneQuickInputService.js';\nimport { StandaloneThemeService } from './standaloneThemeService.js';\nimport { IStandaloneThemeService } from '../common/standaloneTheme.js';\nimport { AccessibilityService } from '../../../platform/accessibility/browser/accessibilityService.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { IMenuService } from '../../../platform/actions/common/actions.js';\nimport { MenuService } from '../../../platform/actions/common/menuService.js';\nimport { BrowserClipboardService } from '../../../platform/clipboard/browser/clipboardService.js';\nimport { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';\nimport { ContextKeyService } from '../../../platform/contextkey/browser/contextKeyService.js';\nimport { SyncDescriptor } from '../../../platform/instantiation/common/descriptors.js';\nimport { InstantiationService } from '../../../platform/instantiation/common/instantiationService.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { IListService, ListService } from '../../../platform/list/browser/listService.js';\nimport { IMarkerService } from '../../../platform/markers/common/markers.js';\nimport { MarkerService } from '../../../platform/markers/common/markerService.js';\nimport { IOpenerService } from '../../../platform/opener/common/opener.js';\nimport { IQuickInputService } from '../../../platform/quickinput/common/quickInput.js';\nimport { IStorageService, InMemoryStorageService } from '../../../platform/storage/common/storage.js';\nimport '../../common/services/languageFeaturesService.js';\nimport { DefaultConfigurationModel } from '../../../platform/configuration/common/configurations.js';\nclass SimpleModel {\n    constructor(model) {\n        this.disposed = false;\n        this.model = model;\n        this._onWillDispose = new Emitter();\n    }\n    get textEditorModel() {\n        return this.model;\n    }\n    dispose() {\n        this.disposed = true;\n        this._onWillDispose.fire();\n    }\n}\nlet StandaloneTextModelService = class StandaloneTextModelService {\n    constructor(modelService) {\n        this.modelService = modelService;\n    }\n    createModelReference(resource) {\n        const model = this.modelService.getModel(resource);\n        if (!model) {\n            return Promise.reject(new Error(`Model not found`));\n        }\n        return Promise.resolve(new ImmortalReference(new SimpleModel(model)));\n    }\n};\nStandaloneTextModelService = __decorate([\n    __param(0, IModelService)\n], StandaloneTextModelService);\nclass StandaloneEditorProgressService {\n    show() {\n        return StandaloneEditorProgressService.NULL_PROGRESS_RUNNER;\n    }\n    showWhile(promise, delay) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield promise;\n        });\n    }\n}\nStandaloneEditorProgressService.NULL_PROGRESS_RUNNER = {\n    done: () => { },\n    total: () => { },\n    worked: () => { }\n};\nclass StandaloneProgressService {\n    withProgress(_options, task, onDidCancel) {\n        return task({\n            report: () => { },\n        });\n    }\n}\nclass StandaloneDialogService {\n    confirm(confirmation) {\n        return this.doConfirm(confirmation).then(confirmed => {\n            return {\n                confirmed,\n                checkboxChecked: false // unsupported\n            };\n        });\n    }\n    doConfirm(confirmation) {\n        let messageText = confirmation.message;\n        if (confirmation.detail) {\n            messageText = messageText + '\\n\\n' + confirmation.detail;\n        }\n        return Promise.resolve(window.confirm(messageText));\n    }\n    show(severity, message, buttons, options) {\n        return Promise.resolve({ choice: 0 });\n    }\n}\nexport class StandaloneNotificationService {\n    info(message) {\n        return this.notify({ severity: Severity.Info, message });\n    }\n    warn(message) {\n        return this.notify({ severity: Severity.Warning, message });\n    }\n    error(error) {\n        return this.notify({ severity: Severity.Error, message: error });\n    }\n    notify(notification) {\n        switch (notification.severity) {\n            case Severity.Error:\n                console.error(notification.message);\n                break;\n            case Severity.Warning:\n                console.warn(notification.message);\n                break;\n            default:\n                console.log(notification.message);\n                break;\n        }\n        return StandaloneNotificationService.NO_OP;\n    }\n    status(message, options) {\n        return Disposable.None;\n    }\n}\nStandaloneNotificationService.NO_OP = new NoOpNotification();\nlet StandaloneCommandService = class StandaloneCommandService {\n    constructor(instantiationService) {\n        this._onWillExecuteCommand = new Emitter();\n        this._onDidExecuteCommand = new Emitter();\n        this.onWillExecuteCommand = this._onWillExecuteCommand.event;\n        this.onDidExecuteCommand = this._onDidExecuteCommand.event;\n        this._instantiationService = instantiationService;\n    }\n    executeCommand(id, ...args) {\n        const command = CommandsRegistry.getCommand(id);\n        if (!command) {\n            return Promise.reject(new Error(`command '${id}' not found`));\n        }\n        try {\n            this._onWillExecuteCommand.fire({ commandId: id, args });\n            const result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler, ...args]);\n            this._onDidExecuteCommand.fire({ commandId: id, args });\n            return Promise.resolve(result);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n};\nStandaloneCommandService = __decorate([\n    __param(0, IInstantiationService)\n], StandaloneCommandService);\nexport { StandaloneCommandService };\nlet StandaloneKeybindingService = class StandaloneKeybindingService extends AbstractKeybindingService {\n    constructor(contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService) {\n        super(contextKeyService, commandService, telemetryService, notificationService, logService);\n        this._cachedResolver = null;\n        this._dynamicKeybindings = [];\n        this._domNodeListeners = [];\n        const addContainer = (domNode) => {\n            const disposables = new DisposableStore();\n            // for standard keybindings\n            disposables.add(dom.addDisposableListener(domNode, dom.EventType.KEY_DOWN, (e) => {\n                const keyEvent = new StandardKeyboardEvent(e);\n                const shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);\n                if (shouldPreventDefault) {\n                    keyEvent.preventDefault();\n                    keyEvent.stopPropagation();\n                }\n            }));\n            // for single modifier chord keybindings (e.g. shift shift)\n            disposables.add(dom.addDisposableListener(domNode, dom.EventType.KEY_UP, (e) => {\n                const keyEvent = new StandardKeyboardEvent(e);\n                const shouldPreventDefault = this._singleModifierDispatch(keyEvent, keyEvent.target);\n                if (shouldPreventDefault) {\n                    keyEvent.preventDefault();\n                }\n            }));\n            this._domNodeListeners.push(new DomNodeListeners(domNode, disposables));\n        };\n        const removeContainer = (domNode) => {\n            for (let i = 0; i < this._domNodeListeners.length; i++) {\n                const domNodeListeners = this._domNodeListeners[i];\n                if (domNodeListeners.domNode === domNode) {\n                    this._domNodeListeners.splice(i, 1);\n                    domNodeListeners.dispose();\n                }\n            }\n        };\n        const addCodeEditor = (codeEditor) => {\n            if (codeEditor.getOption(56 /* EditorOption.inDiffEditor */)) {\n                return;\n            }\n            addContainer(codeEditor.getContainerDomNode());\n        };\n        const removeCodeEditor = (codeEditor) => {\n            if (codeEditor.getOption(56 /* EditorOption.inDiffEditor */)) {\n                return;\n            }\n            removeContainer(codeEditor.getContainerDomNode());\n        };\n        this._register(codeEditorService.onCodeEditorAdd(addCodeEditor));\n        this._register(codeEditorService.onCodeEditorRemove(removeCodeEditor));\n        codeEditorService.listCodeEditors().forEach(addCodeEditor);\n        const addDiffEditor = (diffEditor) => {\n            addContainer(diffEditor.getContainerDomNode());\n        };\n        const removeDiffEditor = (diffEditor) => {\n            removeContainer(diffEditor.getContainerDomNode());\n        };\n        this._register(codeEditorService.onDiffEditorAdd(addDiffEditor));\n        this._register(codeEditorService.onDiffEditorRemove(removeDiffEditor));\n        codeEditorService.listDiffEditors().forEach(addDiffEditor);\n    }\n    addDynamicKeybinding(commandId, _keybinding, handler, when) {\n        const keybinding = createKeybinding(_keybinding, OS);\n        const toDispose = new DisposableStore();\n        if (keybinding) {\n            this._dynamicKeybindings.push({\n                keybinding: keybinding.parts,\n                command: commandId,\n                when: when,\n                weight1: 1000,\n                weight2: 0,\n                extensionId: null,\n                isBuiltinExtension: false\n            });\n            toDispose.add(toDisposable(() => {\n                for (let i = 0; i < this._dynamicKeybindings.length; i++) {\n                    const kb = this._dynamicKeybindings[i];\n                    if (kb.command === commandId) {\n                        this._dynamicKeybindings.splice(i, 1);\n                        this.updateResolver();\n                        return;\n                    }\n                }\n            }));\n        }\n        toDispose.add(CommandsRegistry.registerCommand(commandId, handler));\n        this.updateResolver();\n        return toDispose;\n    }\n    updateResolver() {\n        this._cachedResolver = null;\n        this._onDidUpdateKeybindings.fire();\n    }\n    _getResolver() {\n        if (!this._cachedResolver) {\n            const defaults = this._toNormalizedKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);\n            const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);\n            this._cachedResolver = new KeybindingResolver(defaults, overrides, (str) => this._log(str));\n        }\n        return this._cachedResolver;\n    }\n    _documentHasFocus() {\n        return document.hasFocus();\n    }\n    _toNormalizedKeybindingItems(items, isDefault) {\n        const result = [];\n        let resultLen = 0;\n        for (const item of items) {\n            const when = item.when || undefined;\n            const keybinding = item.keybinding;\n            if (!keybinding) {\n                // This might be a removal keybinding item in user settings => accept it\n                result[resultLen++] = new ResolvedKeybindingItem(undefined, item.command, item.commandArgs, when, isDefault, null, false);\n            }\n            else {\n                const resolvedKeybindings = USLayoutResolvedKeybinding.resolveUserBinding(keybinding, OS);\n                for (const resolvedKeybinding of resolvedKeybindings) {\n                    result[resultLen++] = new ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault, null, false);\n                }\n            }\n        }\n        return result;\n    }\n    resolveKeyboardEvent(keyboardEvent) {\n        const keybinding = new SimpleKeybinding(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode).toChord();\n        return new USLayoutResolvedKeybinding(keybinding, OS);\n    }\n};\nStandaloneKeybindingService = __decorate([\n    __param(0, IContextKeyService),\n    __param(1, ICommandService),\n    __param(2, ITelemetryService),\n    __param(3, INotificationService),\n    __param(4, ILogService),\n    __param(5, ICodeEditorService)\n], StandaloneKeybindingService);\nexport { StandaloneKeybindingService };\nclass DomNodeListeners extends Disposable {\n    constructor(domNode, disposables) {\n        super();\n        this.domNode = domNode;\n        this._register(disposables);\n    }\n}\nfunction isConfigurationOverrides(thing) {\n    return thing\n        && typeof thing === 'object'\n        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')\n        && (!thing.resource || thing.resource instanceof URI);\n}\nexport class StandaloneConfigurationService {\n    constructor() {\n        this._onDidChangeConfiguration = new Emitter();\n        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;\n        this._configuration = new Configuration(new DefaultConfigurationModel(), new ConfigurationModel(), new ConfigurationModel(), new ConfigurationModel());\n    }\n    getValue(arg1, arg2) {\n        const section = typeof arg1 === 'string' ? arg1 : undefined;\n        const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : {};\n        return this._configuration.getValue(section, overrides, undefined);\n    }\n    updateValues(values) {\n        const previous = { data: this._configuration.toData() };\n        const changedKeys = [];\n        for (const entry of values) {\n            const [key, value] = entry;\n            if (this.getValue(key) === value) {\n                continue;\n            }\n            this._configuration.updateValue(key, value);\n            changedKeys.push(key);\n        }\n        if (changedKeys.length > 0) {\n            const configurationChangeEvent = new ConfigurationChangeEvent({ keys: changedKeys, overrides: [] }, previous, this._configuration);\n            configurationChangeEvent.source = 8 /* ConfigurationTarget.MEMORY */;\n            configurationChangeEvent.sourceConfig = null;\n            this._onDidChangeConfiguration.fire(configurationChangeEvent);\n        }\n        return Promise.resolve();\n    }\n    updateValue(key, value, arg3, arg4) {\n        return this.updateValues([[key, value]]);\n    }\n    inspect(key, options = {}) {\n        return this._configuration.inspect(key, options, undefined);\n    }\n}\nlet StandaloneResourceConfigurationService = class StandaloneResourceConfigurationService {\n    constructor(configurationService) {\n        this.configurationService = configurationService;\n        this._onDidChangeConfiguration = new Emitter();\n        this.configurationService.onDidChangeConfiguration((e) => {\n            this._onDidChangeConfiguration.fire({ affectedKeys: e.affectedKeys, affectsConfiguration: (resource, configuration) => e.affectsConfiguration(configuration) });\n        });\n    }\n    getValue(resource, arg2, arg3) {\n        const position = Pos.isIPosition(arg2) ? arg2 : null;\n        const section = position ? (typeof arg3 === 'string' ? arg3 : undefined) : (typeof arg2 === 'string' ? arg2 : undefined);\n        if (typeof section === 'undefined') {\n            return this.configurationService.getValue();\n        }\n        return this.configurationService.getValue(section);\n    }\n};\nStandaloneResourceConfigurationService = __decorate([\n    __param(0, IConfigurationService)\n], StandaloneResourceConfigurationService);\nlet StandaloneResourcePropertiesService = class StandaloneResourcePropertiesService {\n    constructor(configurationService) {\n        this.configurationService = configurationService;\n    }\n    getEOL(resource, language) {\n        const eol = this.configurationService.getValue('files.eol', { overrideIdentifier: language, resource });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return (isLinux || isMacintosh) ? '\\n' : '\\r\\n';\n    }\n};\nStandaloneResourcePropertiesService = __decorate([\n    __param(0, IConfigurationService)\n], StandaloneResourcePropertiesService);\nclass StandaloneTelemetryService {\n    publicLog(eventName, data) {\n        return Promise.resolve(undefined);\n    }\n    publicLog2(eventName, data) {\n        return this.publicLog(eventName, data);\n    }\n}\nclass StandaloneWorkspaceContextService {\n    constructor() {\n        const resource = URI.from({ scheme: StandaloneWorkspaceContextService.SCHEME, authority: 'model', path: '/' });\n        this.workspace = { id: '4064f6ec-cb38-4ad0-af64-ee6467e63c82', folders: [new WorkspaceFolder({ uri: resource, name: '', index: 0 })] };\n    }\n    getWorkspace() {\n        return this.workspace;\n    }\n    getWorkspaceFolder(resource) {\n        return resource && resource.scheme === StandaloneWorkspaceContextService.SCHEME ? this.workspace.folders[0] : null;\n    }\n}\nStandaloneWorkspaceContextService.SCHEME = 'inmemory';\nexport function updateConfigurationService(configurationService, source, isDiffEditor) {\n    if (!source) {\n        return;\n    }\n    if (!(configurationService instanceof StandaloneConfigurationService)) {\n        return;\n    }\n    const toUpdate = [];\n    Object.keys(source).forEach((key) => {\n        if (isEditorConfigurationKey(key)) {\n            toUpdate.push([`editor.${key}`, source[key]]);\n        }\n        if (isDiffEditor && isDiffEditorConfigurationKey(key)) {\n            toUpdate.push([`diffEditor.${key}`, source[key]]);\n        }\n    });\n    if (toUpdate.length > 0) {\n        configurationService.updateValues(toUpdate);\n    }\n}\nlet StandaloneBulkEditService = class StandaloneBulkEditService {\n    constructor(_modelService) {\n        this._modelService = _modelService;\n        //\n    }\n    hasPreviewHandler() {\n        return false;\n    }\n    apply(edits, _options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const textEdits = new Map();\n            for (const edit of edits) {\n                if (!(edit instanceof ResourceTextEdit)) {\n                    throw new Error('bad edit - only text edits are supported');\n                }\n                const model = this._modelService.getModel(edit.resource);\n                if (!model) {\n                    throw new Error('bad edit - model not found');\n                }\n                if (typeof edit.versionId === 'number' && model.getVersionId() !== edit.versionId) {\n                    throw new Error('bad state - model changed in the meantime');\n                }\n                let array = textEdits.get(model);\n                if (!array) {\n                    array = [];\n                    textEdits.set(model, array);\n                }\n                array.push(EditOperation.replaceMove(Range.lift(edit.textEdit.range), edit.textEdit.text));\n            }\n            let totalEdits = 0;\n            let totalFiles = 0;\n            for (const [model, edits] of textEdits) {\n                model.pushStackElement();\n                model.pushEditOperations([], edits, () => []);\n                model.pushStackElement();\n                totalFiles += 1;\n                totalEdits += edits.length;\n            }\n            return {\n                ariaSummary: strings.format(StandaloneServicesNLS.bulkEditServiceSummary, totalEdits, totalFiles)\n            };\n        });\n    }\n};\nStandaloneBulkEditService = __decorate([\n    __param(0, IModelService)\n], StandaloneBulkEditService);\nclass StandaloneUriLabelService {\n    getUriLabel(resource, options) {\n        if (resource.scheme === 'file') {\n            return resource.fsPath;\n        }\n        return resource.path;\n    }\n    getUriBasenameLabel(resource) {\n        return basename(resource);\n    }\n}\nlet StandaloneContextViewService = class StandaloneContextViewService extends ContextViewService {\n    constructor(layoutService, _codeEditorService) {\n        super(layoutService);\n        this._codeEditorService = _codeEditorService;\n    }\n    showContextView(delegate, container, shadowRoot) {\n        if (!container) {\n            const codeEditor = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();\n            if (codeEditor) {\n                container = codeEditor.getContainerDomNode();\n            }\n        }\n        return super.showContextView(delegate, container, shadowRoot);\n    }\n};\nStandaloneContextViewService = __decorate([\n    __param(0, ILayoutService),\n    __param(1, ICodeEditorService)\n], StandaloneContextViewService);\nclass StandaloneWorkspaceTrustManagementService {\n    constructor() {\n        this._neverEmitter = new Emitter();\n        this.onDidChangeTrust = this._neverEmitter.event;\n    }\n    isWorkspaceTrusted() {\n        return true;\n    }\n}\nclass StandaloneLanguageService extends LanguageService {\n    constructor() {\n        super();\n    }\n}\nclass StandaloneLogService extends LogService {\n    constructor() {\n        super(new ConsoleLogger());\n    }\n}\nlet StandaloneContextMenuService = class StandaloneContextMenuService extends ContextMenuService {\n    constructor(telemetryService, notificationService, contextViewService, keybindingService, themeService) {\n        super(telemetryService, notificationService, contextViewService, keybindingService, themeService);\n        this.configure({ blockMouse: false }); // we do not want that in the standalone editor\n    }\n};\nStandaloneContextMenuService = __decorate([\n    __param(0, ITelemetryService),\n    __param(1, INotificationService),\n    __param(2, IContextViewService),\n    __param(3, IKeybindingService),\n    __param(4, IThemeService)\n], StandaloneContextMenuService);\nregisterSingleton(IConfigurationService, StandaloneConfigurationService);\nregisterSingleton(ITextResourceConfigurationService, StandaloneResourceConfigurationService);\nregisterSingleton(ITextResourcePropertiesService, StandaloneResourcePropertiesService);\nregisterSingleton(IWorkspaceContextService, StandaloneWorkspaceContextService);\nregisterSingleton(ILabelService, StandaloneUriLabelService);\nregisterSingleton(ITelemetryService, StandaloneTelemetryService);\nregisterSingleton(IDialogService, StandaloneDialogService);\nregisterSingleton(INotificationService, StandaloneNotificationService);\nregisterSingleton(IMarkerService, MarkerService);\nregisterSingleton(ILanguageService, StandaloneLanguageService);\nregisterSingleton(IStandaloneThemeService, StandaloneThemeService);\nregisterSingleton(ILogService, StandaloneLogService);\nregisterSingleton(IModelService, ModelService);\nregisterSingleton(IMarkerDecorationsService, MarkerDecorationsService);\nregisterSingleton(IContextKeyService, ContextKeyService);\nregisterSingleton(IProgressService, StandaloneProgressService);\nregisterSingleton(IEditorProgressService, StandaloneEditorProgressService);\nregisterSingleton(IStorageService, InMemoryStorageService);\nregisterSingleton(IEditorWorkerService, EditorWorkerService);\nregisterSingleton(IBulkEditService, StandaloneBulkEditService);\nregisterSingleton(IWorkspaceTrustManagementService, StandaloneWorkspaceTrustManagementService);\nregisterSingleton(ITextModelService, StandaloneTextModelService);\nregisterSingleton(IAccessibilityService, AccessibilityService);\nregisterSingleton(IListService, ListService);\nregisterSingleton(ICommandService, StandaloneCommandService);\nregisterSingleton(IKeybindingService, StandaloneKeybindingService);\nregisterSingleton(IQuickInputService, StandaloneQuickInputService);\nregisterSingleton(IContextViewService, StandaloneContextViewService);\nregisterSingleton(IOpenerService, OpenerService);\nregisterSingleton(IClipboardService, BrowserClipboardService);\nregisterSingleton(IContextMenuService, StandaloneContextMenuService);\nregisterSingleton(IMenuService, MenuService);\n/**\n * We don't want to eagerly instantiate services because embedders get a one time chance\n * to override services when they create the first editor.\n */\nexport var StandaloneServices;\n(function (StandaloneServices) {\n    const serviceCollection = new ServiceCollection();\n    for (const [id, descriptor] of getSingletonServiceDescriptors()) {\n        serviceCollection.set(id, descriptor);\n    }\n    const instantiationService = new InstantiationService(serviceCollection, true);\n    serviceCollection.set(IInstantiationService, instantiationService);\n    function get(serviceId) {\n        const r = serviceCollection.get(serviceId);\n        if (!r) {\n            throw new Error('Missing service ' + serviceId);\n        }\n        if (r instanceof SyncDescriptor) {\n            return instantiationService.invokeFunction((accessor) => accessor.get(serviceId));\n        }\n        else {\n            return r;\n        }\n    }\n    StandaloneServices.get = get;\n    let initialized = false;\n    function initialize(overrides) {\n        if (initialized) {\n            return instantiationService;\n        }\n        initialized = true;\n        // Add singletons that were registered after this module loaded\n        for (const [id, descriptor] of getSingletonServiceDescriptors()) {\n            if (!serviceCollection.get(id)) {\n                serviceCollection.set(id, descriptor);\n            }\n        }\n        // Initialize the service collection with the overrides, but only if the\n        // service was not instantiated in the meantime.\n        for (const serviceId in overrides) {\n            if (overrides.hasOwnProperty(serviceId)) {\n                const serviceIdentifier = createDecorator(serviceId);\n                const r = serviceCollection.get(serviceIdentifier);\n                if (r instanceof SyncDescriptor) {\n                    serviceCollection.set(serviceIdentifier, overrides[serviceId]);\n                }\n            }\n        }\n        return instantiationService;\n    }\n    StandaloneServices.initialize = initialize;\n})(StandaloneServices || (StandaloneServices = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as aria from '../../../base/browser/ui/aria/aria.js';\nimport { Disposable, toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { ICodeEditorService } from '../../browser/services/codeEditorService.js';\nimport { CodeEditorWidget } from '../../browser/widget/codeEditorWidget.js';\nimport { DiffEditorWidget } from '../../browser/widget/diffEditorWidget.js';\nimport { InternalEditorAction } from '../../common/editorAction.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorker.js';\nimport { StandaloneKeybindingService, updateConfigurationService } from './standaloneServices.js';\nimport { IStandaloneThemeService } from '../common/standaloneTheme.js';\nimport { MenuId, MenuRegistry } from '../../../platform/actions/common/actions.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ContextKeyExpr, IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IContextMenuService } from '../../../platform/contextview/browser/contextView.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\nimport { INotificationService } from '../../../platform/notification/common/notification.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { StandaloneCodeEditorNLS } from '../../common/standaloneStrings.js';\nimport { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';\nimport { IEditorProgressService } from '../../../platform/progress/common/progress.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nimport { StandaloneCodeEditorService } from './standaloneCodeEditorService.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../../common/languages/modesRegistry.js';\nimport { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry.js';\nimport { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';\nlet LAST_GENERATED_COMMAND_ID = 0;\nlet ariaDomNodeCreated = false;\n/**\n * Create ARIA dom node inside parent,\n * or only for the first editor instantiation inside document.body.\n * @param parent container element for ARIA dom node\n */\nfunction createAriaDomNode(parent) {\n    if (!parent) {\n        if (ariaDomNodeCreated) {\n            return;\n        }\n        ariaDomNodeCreated = true;\n    }\n    aria.setARIAContainer(parent || document.body);\n}\n/**\n * A code editor to be used both by the standalone editor and the standalone diff editor.\n */\nlet StandaloneCodeEditor = class StandaloneCodeEditor extends CodeEditorWidget {\n    constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {\n        const options = Object.assign({}, _options);\n        options.ariaLabel = options.ariaLabel || StandaloneCodeEditorNLS.editorViewAccessibleLabel;\n        options.ariaLabel = options.ariaLabel + ';' + (StandaloneCodeEditorNLS.accessibilityHelpMessage);\n        super(domElement, options, {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);\n        if (keybindingService instanceof StandaloneKeybindingService) {\n            this._standaloneKeybindingService = keybindingService;\n        }\n        else {\n            this._standaloneKeybindingService = null;\n        }\n        createAriaDomNode(options.ariaContainerElement);\n    }\n    addCommand(keybinding, handler, context) {\n        if (!this._standaloneKeybindingService) {\n            console.warn('Cannot add command because the editor is configured with an unrecognized KeybindingService');\n            return null;\n        }\n        const commandId = 'DYNAMIC_' + (++LAST_GENERATED_COMMAND_ID);\n        const whenExpression = ContextKeyExpr.deserialize(context);\n        this._standaloneKeybindingService.addDynamicKeybinding(commandId, keybinding, handler, whenExpression);\n        return commandId;\n    }\n    createContextKey(key, defaultValue) {\n        return this._contextKeyService.createKey(key, defaultValue);\n    }\n    addAction(_descriptor) {\n        if ((typeof _descriptor.id !== 'string') || (typeof _descriptor.label !== 'string') || (typeof _descriptor.run !== 'function')) {\n            throw new Error('Invalid action descriptor, `id`, `label` and `run` are required properties!');\n        }\n        if (!this._standaloneKeybindingService) {\n            console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');\n            return Disposable.None;\n        }\n        // Read descriptor options\n        const id = _descriptor.id;\n        const label = _descriptor.label;\n        const precondition = ContextKeyExpr.and(ContextKeyExpr.equals('editorId', this.getId()), ContextKeyExpr.deserialize(_descriptor.precondition));\n        const keybindings = _descriptor.keybindings;\n        const keybindingsWhen = ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(_descriptor.keybindingContext));\n        const contextMenuGroupId = _descriptor.contextMenuGroupId || null;\n        const contextMenuOrder = _descriptor.contextMenuOrder || 0;\n        const run = (accessor, ...args) => {\n            return Promise.resolve(_descriptor.run(this, ...args));\n        };\n        const toDispose = new DisposableStore();\n        // Generate a unique id to allow the same descriptor.id across multiple editor instances\n        const uniqueId = this.getId() + ':' + id;\n        // Register the command\n        toDispose.add(CommandsRegistry.registerCommand(uniqueId, run));\n        // Register the context menu item\n        if (contextMenuGroupId) {\n            const menuItem = {\n                command: {\n                    id: uniqueId,\n                    title: label\n                },\n                when: precondition,\n                group: contextMenuGroupId,\n                order: contextMenuOrder\n            };\n            toDispose.add(MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem));\n        }\n        // Register the keybindings\n        if (Array.isArray(keybindings)) {\n            for (const kb of keybindings) {\n                toDispose.add(this._standaloneKeybindingService.addDynamicKeybinding(uniqueId, kb, run, keybindingsWhen));\n            }\n        }\n        // Finally, register an internal editor action\n        const internalAction = new InternalEditorAction(uniqueId, label, label, precondition, run, this._contextKeyService);\n        // Store it under the original id, such that trigger with the original id will work\n        this._actions[id] = internalAction;\n        toDispose.add(toDisposable(() => {\n            delete this._actions[id];\n        }));\n        return toDispose;\n    }\n    _triggerCommand(handlerId, payload) {\n        if (this._codeEditorService instanceof StandaloneCodeEditorService) {\n            // Help commands find this editor as the active editor\n            try {\n                this._codeEditorService.setActiveCodeEditor(this);\n                super._triggerCommand(handlerId, payload);\n            }\n            finally {\n                this._codeEditorService.setActiveCodeEditor(null);\n            }\n        }\n        else {\n            super._triggerCommand(handlerId, payload);\n        }\n    }\n};\nStandaloneCodeEditor = __decorate([\n    __param(2, IInstantiationService),\n    __param(3, ICodeEditorService),\n    __param(4, ICommandService),\n    __param(5, IContextKeyService),\n    __param(6, IKeybindingService),\n    __param(7, IThemeService),\n    __param(8, INotificationService),\n    __param(9, IAccessibilityService),\n    __param(10, ILanguageConfigurationService),\n    __param(11, ILanguageFeaturesService)\n], StandaloneCodeEditor);\nexport { StandaloneCodeEditor };\nlet StandaloneEditor = class StandaloneEditor extends StandaloneCodeEditor {\n    constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, configurationService, accessibilityService, modelService, languageService, languageConfigurationService, languageFeaturesService) {\n        const options = Object.assign({}, _options);\n        updateConfigurationService(configurationService, options, false);\n        const themeDomRegistration = themeService.registerEditorContainer(domElement);\n        if (typeof options.theme === 'string') {\n            themeService.setTheme(options.theme);\n        }\n        if (typeof options.autoDetectHighContrast !== 'undefined') {\n            themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));\n        }\n        const _model = options.model;\n        delete options.model;\n        super(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);\n        this._configurationService = configurationService;\n        this._standaloneThemeService = themeService;\n        this._register(themeDomRegistration);\n        let model;\n        if (typeof _model === 'undefined') {\n            const languageId = languageService.getLanguageIdByMimeType(options.language) || options.language || PLAINTEXT_LANGUAGE_ID;\n            model = createTextModel(modelService, languageService, options.value || '', languageId, undefined);\n            this._ownsModel = true;\n        }\n        else {\n            model = _model;\n            this._ownsModel = false;\n        }\n        this._attachModel(model);\n        if (model) {\n            const e = {\n                oldModelUrl: null,\n                newModelUrl: model.uri\n            };\n            this._onDidChangeModel.fire(e);\n        }\n    }\n    dispose() {\n        super.dispose();\n    }\n    updateOptions(newOptions) {\n        updateConfigurationService(this._configurationService, newOptions, false);\n        if (typeof newOptions.theme === 'string') {\n            this._standaloneThemeService.setTheme(newOptions.theme);\n        }\n        if (typeof newOptions.autoDetectHighContrast !== 'undefined') {\n            this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));\n        }\n        super.updateOptions(newOptions);\n    }\n    _postDetachModelCleanup(detachedModel) {\n        super._postDetachModelCleanup(detachedModel);\n        if (detachedModel && this._ownsModel) {\n            detachedModel.dispose();\n            this._ownsModel = false;\n        }\n    }\n};\nStandaloneEditor = __decorate([\n    __param(2, IInstantiationService),\n    __param(3, ICodeEditorService),\n    __param(4, ICommandService),\n    __param(5, IContextKeyService),\n    __param(6, IKeybindingService),\n    __param(7, IStandaloneThemeService),\n    __param(8, INotificationService),\n    __param(9, IConfigurationService),\n    __param(10, IAccessibilityService),\n    __param(11, IModelService),\n    __param(12, ILanguageService),\n    __param(13, ILanguageConfigurationService),\n    __param(14, ILanguageFeaturesService)\n], StandaloneEditor);\nexport { StandaloneEditor };\nlet StandaloneDiffEditor = class StandaloneDiffEditor extends DiffEditorWidget {\n    constructor(domElement, _options, instantiationService, contextKeyService, editorWorkerService, codeEditorService, themeService, notificationService, configurationService, contextMenuService, editorProgressService, clipboardService) {\n        const options = Object.assign({}, _options);\n        updateConfigurationService(configurationService, options, true);\n        const themeDomRegistration = themeService.registerEditorContainer(domElement);\n        if (typeof options.theme === 'string') {\n            themeService.setTheme(options.theme);\n        }\n        if (typeof options.autoDetectHighContrast !== 'undefined') {\n            themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));\n        }\n        super(domElement, options, {}, clipboardService, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, editorProgressService);\n        this._configurationService = configurationService;\n        this._standaloneThemeService = themeService;\n        this._register(themeDomRegistration);\n    }\n    dispose() {\n        super.dispose();\n    }\n    updateOptions(newOptions) {\n        updateConfigurationService(this._configurationService, newOptions, true);\n        if (typeof newOptions.theme === 'string') {\n            this._standaloneThemeService.setTheme(newOptions.theme);\n        }\n        if (typeof newOptions.autoDetectHighContrast !== 'undefined') {\n            this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));\n        }\n        super.updateOptions(newOptions);\n    }\n    _createInnerEditor(instantiationService, container, options) {\n        return instantiationService.createInstance(StandaloneCodeEditor, container, options);\n    }\n    getOriginalEditor() {\n        return super.getOriginalEditor();\n    }\n    getModifiedEditor() {\n        return super.getModifiedEditor();\n    }\n    addCommand(keybinding, handler, context) {\n        return this.getModifiedEditor().addCommand(keybinding, handler, context);\n    }\n    createContextKey(key, defaultValue) {\n        return this.getModifiedEditor().createContextKey(key, defaultValue);\n    }\n    addAction(descriptor) {\n        return this.getModifiedEditor().addAction(descriptor);\n    }\n};\nStandaloneDiffEditor = __decorate([\n    __param(2, IInstantiationService),\n    __param(3, IContextKeyService),\n    __param(4, IEditorWorkerService),\n    __param(5, ICodeEditorService),\n    __param(6, IStandaloneThemeService),\n    __param(7, INotificationService),\n    __param(8, IConfigurationService),\n    __param(9, IContextMenuService),\n    __param(10, IEditorProgressService),\n    __param(11, IClipboardService)\n], StandaloneDiffEditor);\nexport { StandaloneDiffEditor };\n/**\n * @internal\n */\nexport function createTextModel(modelService, languageService, value, languageId, uri) {\n    value = value || '';\n    if (!languageId) {\n        const firstLF = value.indexOf('\\n');\n        let firstLine = value;\n        if (firstLF !== -1) {\n            firstLine = value.substring(0, firstLF);\n        }\n        return doCreateModel(modelService, value, languageService.createByFilepathOrFirstLine(uri || null, firstLine), uri);\n    }\n    return doCreateModel(modelService, value, languageService.createById(languageId), uri);\n}\n/**\n * @internal\n */\nfunction doCreateModel(modelService, value, languageSelection, uri) {\n    return modelService.createModel(value, languageSelection, uri);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './standalone-tokens.css';\nimport { splitLines } from '../../../base/common/strings.js';\nimport { FontMeasurements } from '../../browser/config/fontMeasurements.js';\nimport { ICodeEditorService } from '../../browser/services/codeEditorService.js';\nimport { DiffNavigator } from '../../browser/widget/diffNavigator.js';\nimport { ApplyUpdateResult, ConfigurationChangedEvent, EditorOptions } from '../../common/config/editorOptions.js';\nimport { BareFontInfo, FontInfo } from '../../common/config/fontInfo.js';\nimport { EditorType } from '../../common/editorCommon.js';\nimport { FindMatch, TextModelResolvedOptions } from '../../common/model.js';\nimport * as languages from '../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry.js';\nimport { NullState, nullTokenize } from '../../common/languages/nullTokenize.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { createWebWorker as actualCreateWebWorker } from '../../browser/services/webWorker.js';\nimport * as standaloneEnums from '../../common/standalone/standaloneEnums.js';\nimport { Colorizer } from './colorizer.js';\nimport { createTextModel, StandaloneDiffEditor, StandaloneEditor } from './standaloneCodeEditor.js';\nimport { StandaloneServices } from './standaloneServices.js';\nimport { IStandaloneThemeService } from '../common/standaloneTheme.js';\nimport { CommandsRegistry } from '../../../platform/commands/common/commands.js';\nimport { IMarkerService } from '../../../platform/markers/common/markers.js';\n/**\n * Create a new editor under `domElement`.\n * `domElement` should be empty (not contain other dom nodes).\n * The editor will read the size of `domElement`.\n */\nexport function create(domElement, options, override) {\n    const instantiationService = StandaloneServices.initialize(override || {});\n    return instantiationService.createInstance(StandaloneEditor, domElement, options);\n}\n/**\n * Emitted when an editor is created.\n * Creating a diff editor might cause this listener to be invoked with the two editors.\n * @event\n */\nexport function onDidCreateEditor(listener) {\n    const codeEditorService = StandaloneServices.get(ICodeEditorService);\n    return codeEditorService.onCodeEditorAdd((editor) => {\n        listener(editor);\n    });\n}\n/**\n * Emitted when an diff editor is created.\n * @event\n */\nexport function onDidCreateDiffEditor(listener) {\n    const codeEditorService = StandaloneServices.get(ICodeEditorService);\n    return codeEditorService.onDiffEditorAdd((editor) => {\n        listener(editor);\n    });\n}\n/**\n * Get all the created editors.\n */\nexport function getEditors() {\n    const codeEditorService = StandaloneServices.get(ICodeEditorService);\n    return codeEditorService.listCodeEditors();\n}\n/**\n * Get all the created diff editors.\n */\nexport function getDiffEditors() {\n    const codeEditorService = StandaloneServices.get(ICodeEditorService);\n    return codeEditorService.listDiffEditors();\n}\n/**\n * Create a new diff editor under `domElement`.\n * `domElement` should be empty (not contain other dom nodes).\n * The editor will read the size of `domElement`.\n */\nexport function createDiffEditor(domElement, options, override) {\n    const instantiationService = StandaloneServices.initialize(override || {});\n    return instantiationService.createInstance(StandaloneDiffEditor, domElement, options);\n}\nexport function createDiffNavigator(diffEditor, opts) {\n    return new DiffNavigator(diffEditor, opts);\n}\n/**\n * Create a new editor model.\n * You can specify the language that should be set for this model or let the language be inferred from the `uri`.\n */\nexport function createModel(value, language, uri) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    const languageId = languageService.getLanguageIdByMimeType(language) || language;\n    return createTextModel(StandaloneServices.get(IModelService), languageService, value, languageId, uri);\n}\n/**\n * Change the language for a model.\n */\nexport function setModelLanguage(model, languageId) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    const modelService = StandaloneServices.get(IModelService);\n    modelService.setMode(model, languageService.createById(languageId));\n}\n/**\n * Set the markers for a model.\n */\nexport function setModelMarkers(model, owner, markers) {\n    if (model) {\n        const markerService = StandaloneServices.get(IMarkerService);\n        markerService.changeOne(owner, model.uri, markers);\n    }\n}\n/**\n * Remove all markers of an owner.\n */\nexport function removeAllMarkers(owner) {\n    const markerService = StandaloneServices.get(IMarkerService);\n    markerService.changeAll(owner, []);\n}\n/**\n * Get markers for owner and/or resource\n *\n * @returns list of markers\n */\nexport function getModelMarkers(filter) {\n    const markerService = StandaloneServices.get(IMarkerService);\n    return markerService.read(filter);\n}\n/**\n * Emitted when markers change for a model.\n * @event\n */\nexport function onDidChangeMarkers(listener) {\n    const markerService = StandaloneServices.get(IMarkerService);\n    return markerService.onMarkerChanged(listener);\n}\n/**\n * Get the model that has `uri` if it exists.\n */\nexport function getModel(uri) {\n    const modelService = StandaloneServices.get(IModelService);\n    return modelService.getModel(uri);\n}\n/**\n * Get all the created models.\n */\nexport function getModels() {\n    const modelService = StandaloneServices.get(IModelService);\n    return modelService.getModels();\n}\n/**\n * Emitted when a model is created.\n * @event\n */\nexport function onDidCreateModel(listener) {\n    const modelService = StandaloneServices.get(IModelService);\n    return modelService.onModelAdded(listener);\n}\n/**\n * Emitted right before a model is disposed.\n * @event\n */\nexport function onWillDisposeModel(listener) {\n    const modelService = StandaloneServices.get(IModelService);\n    return modelService.onModelRemoved(listener);\n}\n/**\n * Emitted when a different language is set to a model.\n * @event\n */\nexport function onDidChangeModelLanguage(listener) {\n    const modelService = StandaloneServices.get(IModelService);\n    return modelService.onModelLanguageChanged((e) => {\n        listener({\n            model: e.model,\n            oldLanguage: e.oldLanguageId\n        });\n    });\n}\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker(opts) {\n    return actualCreateWebWorker(StandaloneServices.get(IModelService), StandaloneServices.get(ILanguageConfigurationService), opts);\n}\n/**\n * Colorize the contents of `domNode` using attribute `data-lang`.\n */\nexport function colorizeElement(domNode, options) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    const themeService = StandaloneServices.get(IStandaloneThemeService);\n    themeService.registerEditorContainer(domNode);\n    return Colorizer.colorizeElement(themeService, languageService, domNode, options);\n}\n/**\n * Colorize `text` using language `languageId`.\n */\nexport function colorize(text, languageId, options) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    const themeService = StandaloneServices.get(IStandaloneThemeService);\n    themeService.registerEditorContainer(document.body);\n    return Colorizer.colorize(languageService, text, languageId, options);\n}\n/**\n * Colorize a line in a model.\n */\nexport function colorizeModelLine(model, lineNumber, tabSize = 4) {\n    const themeService = StandaloneServices.get(IStandaloneThemeService);\n    themeService.registerEditorContainer(document.body);\n    return Colorizer.colorizeModelLine(model, lineNumber, tabSize);\n}\n/**\n * @internal\n */\nfunction getSafeTokenizationSupport(language) {\n    const tokenizationSupport = languages.TokenizationRegistry.get(language);\n    if (tokenizationSupport) {\n        return tokenizationSupport;\n    }\n    return {\n        getInitialState: () => NullState,\n        tokenize: (line, hasEOL, state) => nullTokenize(language, state)\n    };\n}\n/**\n * Tokenize `text` using language `languageId`\n */\nexport function tokenize(text, languageId) {\n    // Needed in order to get the mode registered for subsequent look-ups\n    languages.TokenizationRegistry.getOrCreate(languageId);\n    const tokenizationSupport = getSafeTokenizationSupport(languageId);\n    const lines = splitLines(text);\n    const result = [];\n    let state = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        const tokenizationResult = tokenizationSupport.tokenize(line, true, state);\n        result[i] = tokenizationResult.tokens;\n        state = tokenizationResult.endState;\n    }\n    return result;\n}\n/**\n * Define a new theme or update an existing theme.\n */\nexport function defineTheme(themeName, themeData) {\n    const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);\n    standaloneThemeService.defineTheme(themeName, themeData);\n}\n/**\n * Switches to a theme.\n */\nexport function setTheme(themeName) {\n    const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);\n    standaloneThemeService.setTheme(themeName);\n}\n/**\n * Clears all cached font measurements and triggers re-measurement.\n */\nexport function remeasureFonts() {\n    FontMeasurements.clearAllFontInfos();\n}\n/**\n * Register a command.\n */\nexport function registerCommand(id, handler) {\n    return CommandsRegistry.registerCommand({ id, handler });\n}\n/**\n * @internal\n */\nexport function createMonacoEditorAPI() {\n    return {\n        // methods\n        create: create,\n        getEditors: getEditors,\n        getDiffEditors: getDiffEditors,\n        onDidCreateEditor: onDidCreateEditor,\n        onDidCreateDiffEditor: onDidCreateDiffEditor,\n        createDiffEditor: createDiffEditor,\n        createDiffNavigator: createDiffNavigator,\n        createModel: createModel,\n        setModelLanguage: setModelLanguage,\n        setModelMarkers: setModelMarkers,\n        getModelMarkers: getModelMarkers,\n        removeAllMarkers: removeAllMarkers,\n        onDidChangeMarkers: onDidChangeMarkers,\n        getModels: getModels,\n        getModel: getModel,\n        onDidCreateModel: onDidCreateModel,\n        onWillDisposeModel: onWillDisposeModel,\n        onDidChangeModelLanguage: onDidChangeModelLanguage,\n        createWebWorker: createWebWorker,\n        colorizeElement: colorizeElement,\n        colorize: colorize,\n        colorizeModelLine: colorizeModelLine,\n        tokenize: tokenize,\n        defineTheme: defineTheme,\n        setTheme: setTheme,\n        remeasureFonts: remeasureFonts,\n        registerCommand: registerCommand,\n        // enums\n        AccessibilitySupport: standaloneEnums.AccessibilitySupport,\n        ContentWidgetPositionPreference: standaloneEnums.ContentWidgetPositionPreference,\n        CursorChangeReason: standaloneEnums.CursorChangeReason,\n        DefaultEndOfLine: standaloneEnums.DefaultEndOfLine,\n        EditorAutoIndentStrategy: standaloneEnums.EditorAutoIndentStrategy,\n        EditorOption: standaloneEnums.EditorOption,\n        EndOfLinePreference: standaloneEnums.EndOfLinePreference,\n        EndOfLineSequence: standaloneEnums.EndOfLineSequence,\n        MinimapPosition: standaloneEnums.MinimapPosition,\n        MouseTargetType: standaloneEnums.MouseTargetType,\n        OverlayWidgetPositionPreference: standaloneEnums.OverlayWidgetPositionPreference,\n        OverviewRulerLane: standaloneEnums.OverviewRulerLane,\n        RenderLineNumbersType: standaloneEnums.RenderLineNumbersType,\n        RenderMinimap: standaloneEnums.RenderMinimap,\n        ScrollbarVisibility: standaloneEnums.ScrollbarVisibility,\n        ScrollType: standaloneEnums.ScrollType,\n        TextEditorCursorBlinkingStyle: standaloneEnums.TextEditorCursorBlinkingStyle,\n        TextEditorCursorStyle: standaloneEnums.TextEditorCursorStyle,\n        TrackedRangeStickiness: standaloneEnums.TrackedRangeStickiness,\n        WrappingIndent: standaloneEnums.WrappingIndent,\n        InjectedTextCursorStops: standaloneEnums.InjectedTextCursorStops,\n        PositionAffinity: standaloneEnums.PositionAffinity,\n        // classes\n        ConfigurationChangedEvent: ConfigurationChangedEvent,\n        BareFontInfo: BareFontInfo,\n        FontInfo: FontInfo,\n        TextModelResolvedOptions: TextModelResolvedOptions,\n        FindMatch: FindMatch,\n        ApplyUpdateResult: ApplyUpdateResult,\n        // vars\n        EditorType: EditorType,\n        EditorOptions: EditorOptions\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/*\n * This module only exports 'compile' which compiles a JSON language definition\n * into a typed and checked ILexer definition.\n */\nimport * as monarchCommon from './monarchCommon.js';\n/*\n * Type helpers\n *\n * Note: this is just for sanity checks on the JSON description which is\n * helpful for the programmer. No checks are done anymore once the lexer is\n * already 'compiled and checked'.\n *\n */\nfunction isArrayOf(elemType, obj) {\n    if (!obj) {\n        return false;\n    }\n    if (!(Array.isArray(obj))) {\n        return false;\n    }\n    for (const el of obj) {\n        if (!(elemType(el))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction bool(prop, defValue) {\n    if (typeof prop === 'boolean') {\n        return prop;\n    }\n    return defValue;\n}\nfunction string(prop, defValue) {\n    if (typeof (prop) === 'string') {\n        return prop;\n    }\n    return defValue;\n}\nfunction arrayToHash(array) {\n    const result = {};\n    for (const e of array) {\n        result[e] = true;\n    }\n    return result;\n}\nfunction createKeywordMatcher(arr, caseInsensitive = false) {\n    if (caseInsensitive) {\n        arr = arr.map(function (x) { return x.toLowerCase(); });\n    }\n    const hash = arrayToHash(arr);\n    if (caseInsensitive) {\n        return function (word) {\n            return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n        };\n    }\n    else {\n        return function (word) {\n            return hash[word] !== undefined && hash.hasOwnProperty(word);\n        };\n    }\n}\n// Lexer helpers\n/**\n * Compiles a regular expression string, adding the 'i' flag if 'ignoreCase' is set, and the 'u' flag if 'unicode' is set.\n * Also replaces @\\w+ or sequences with the content of the specified attribute\n * @\\w+ replacement can be avoided by escaping `@` signs with another `@` sign.\n * @example /@attr/ will be replaced with the value of lexer[attr]\n * @example /@@text/ will not be replaced and will become /@text/.\n */\nfunction compileRegExp(lexer, str) {\n    // @@ must be interpreted as a literal @, so we replace all occurences of @@ with a placeholder character\n    str = str.replace(/@@/g, `\\x01`);\n    let n = 0;\n    let hadExpansion;\n    do {\n        hadExpansion = false;\n        str = str.replace(/@(\\w+)/g, function (s, attr) {\n            hadExpansion = true;\n            let sub = '';\n            if (typeof (lexer[attr]) === 'string') {\n                sub = lexer[attr];\n            }\n            else if (lexer[attr] && lexer[attr] instanceof RegExp) {\n                sub = lexer[attr].source;\n            }\n            else {\n                if (lexer[attr] === undefined) {\n                    throw monarchCommon.createError(lexer, 'language definition does not contain attribute \\'' + attr + '\\', used at: ' + str);\n                }\n                else {\n                    throw monarchCommon.createError(lexer, 'attribute reference \\'' + attr + '\\' must be a string, used at: ' + str);\n                }\n            }\n            return (monarchCommon.empty(sub) ? '' : '(?:' + sub + ')');\n        });\n        n++;\n    } while (hadExpansion && n < 5);\n    // handle escaped @@\n    str = str.replace(/\\x01/g, '@');\n    const flags = (lexer.ignoreCase ? 'i' : '') + (lexer.unicode ? 'u' : '');\n    return new RegExp(str, flags);\n}\n/**\n * Compiles guard functions for case matches.\n * This compiles 'cases' attributes into efficient match functions.\n *\n */\nfunction selectScrutinee(id, matches, state, num) {\n    if (num < 0) {\n        return id;\n    }\n    if (num < matches.length) {\n        return matches[num];\n    }\n    if (num >= 100) {\n        num = num - 100;\n        const parts = state.split('.');\n        parts.unshift(state);\n        if (num < parts.length) {\n            return parts[num];\n        }\n    }\n    return null;\n}\nfunction createGuard(lexer, ruleName, tkey, val) {\n    // get the scrutinee and pattern\n    let scrut = -1; // -1: $!, 0-99: $n, 100+n: $Sn\n    let oppat = tkey;\n    let matches = tkey.match(/^\\$(([sS]?)(\\d\\d?)|#)(.*)$/);\n    if (matches) {\n        if (matches[3]) { // if digits\n            scrut = parseInt(matches[3]);\n            if (matches[2]) {\n                scrut = scrut + 100; // if [sS] present\n            }\n        }\n        oppat = matches[4];\n    }\n    // get operator\n    let op = '~';\n    let pat = oppat;\n    if (!oppat || oppat.length === 0) {\n        op = '!=';\n        pat = '';\n    }\n    else if (/^\\w*$/.test(pat)) { // just a word\n        op = '==';\n    }\n    else {\n        matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);\n        if (matches) {\n            op = matches[1];\n            pat = matches[2];\n        }\n    }\n    // set the tester function\n    let tester;\n    // special case a regexp that matches just words\n    if ((op === '~' || op === '!~') && /^(\\w|\\|)*$/.test(pat)) {\n        const inWords = createKeywordMatcher(pat.split('|'), lexer.ignoreCase);\n        tester = function (s) { return (op === '~' ? inWords(s) : !inWords(s)); };\n    }\n    else if (op === '@' || op === '!@') {\n        const words = lexer[pat];\n        if (!words) {\n            throw monarchCommon.createError(lexer, 'the @ match target \\'' + pat + '\\' is not defined, in rule: ' + ruleName);\n        }\n        if (!(isArrayOf(function (elem) { return (typeof (elem) === 'string'); }, words))) {\n            throw monarchCommon.createError(lexer, 'the @ match target \\'' + pat + '\\' must be an array of strings, in rule: ' + ruleName);\n        }\n        const inWords = createKeywordMatcher(words, lexer.ignoreCase);\n        tester = function (s) { return (op === '@' ? inWords(s) : !inWords(s)); };\n    }\n    else if (op === '~' || op === '!~') {\n        if (pat.indexOf('$') < 0) {\n            // precompile regular expression\n            const re = compileRegExp(lexer, '^' + pat + '$');\n            tester = function (s) { return (op === '~' ? re.test(s) : !re.test(s)); };\n        }\n        else {\n            tester = function (s, id, matches, state) {\n                const re = compileRegExp(lexer, '^' + monarchCommon.substituteMatches(lexer, pat, id, matches, state) + '$');\n                return re.test(s);\n            };\n        }\n    }\n    else { // if (op==='==' || op==='!=') {\n        if (pat.indexOf('$') < 0) {\n            const patx = monarchCommon.fixCase(lexer, pat);\n            tester = function (s) { return (op === '==' ? s === patx : s !== patx); };\n        }\n        else {\n            const patx = monarchCommon.fixCase(lexer, pat);\n            tester = function (s, id, matches, state, eos) {\n                const patexp = monarchCommon.substituteMatches(lexer, patx, id, matches, state);\n                return (op === '==' ? s === patexp : s !== patexp);\n            };\n        }\n    }\n    // return the branch object\n    if (scrut === -1) {\n        return {\n            name: tkey, value: val, test: function (id, matches, state, eos) {\n                return tester(id, id, matches, state, eos);\n            }\n        };\n    }\n    else {\n        return {\n            name: tkey, value: val, test: function (id, matches, state, eos) {\n                const scrutinee = selectScrutinee(id, matches, state, scrut);\n                return tester(!scrutinee ? '' : scrutinee, id, matches, state, eos);\n            }\n        };\n    }\n}\n/**\n * Compiles an action: i.e. optimize regular expressions and case matches\n * and do many sanity checks.\n *\n * This is called only during compilation but if the lexer definition\n * contains user functions as actions (which is usually not allowed), then this\n * may be called during lexing. It is important therefore to compile common cases efficiently\n */\nfunction compileAction(lexer, ruleName, action) {\n    if (!action) {\n        return { token: '' };\n    }\n    else if (typeof (action) === 'string') {\n        return action; // { token: action };\n    }\n    else if (action.token || action.token === '') {\n        if (typeof (action.token) !== 'string') {\n            throw monarchCommon.createError(lexer, 'a \\'token\\' attribute must be of type string, in rule: ' + ruleName);\n        }\n        else {\n            // only copy specific typed fields (only happens once during compile Lexer)\n            const newAction = { token: action.token };\n            if (action.token.indexOf('$') >= 0) {\n                newAction.tokenSubst = true;\n            }\n            if (typeof (action.bracket) === 'string') {\n                if (action.bracket === '@open') {\n                    newAction.bracket = 1 /* monarchCommon.MonarchBracket.Open */;\n                }\n                else if (action.bracket === '@close') {\n                    newAction.bracket = -1 /* monarchCommon.MonarchBracket.Close */;\n                }\n                else {\n                    throw monarchCommon.createError(lexer, 'a \\'bracket\\' attribute must be either \\'@open\\' or \\'@close\\', in rule: ' + ruleName);\n                }\n            }\n            if (action.next) {\n                if (typeof (action.next) !== 'string') {\n                    throw monarchCommon.createError(lexer, 'the next state must be a string value in rule: ' + ruleName);\n                }\n                else {\n                    let next = action.next;\n                    if (!/^(@pop|@push|@popall)$/.test(next)) {\n                        if (next[0] === '@') {\n                            next = next.substr(1); // peel off starting @ sign\n                        }\n                        if (next.indexOf('$') < 0) { // no dollar substitution, we can check if the state exists\n                            if (!monarchCommon.stateExists(lexer, monarchCommon.substituteMatches(lexer, next, '', [], ''))) {\n                                throw monarchCommon.createError(lexer, 'the next state \\'' + action.next + '\\' is not defined in rule: ' + ruleName);\n                            }\n                        }\n                    }\n                    newAction.next = next;\n                }\n            }\n            if (typeof (action.goBack) === 'number') {\n                newAction.goBack = action.goBack;\n            }\n            if (typeof (action.switchTo) === 'string') {\n                newAction.switchTo = action.switchTo;\n            }\n            if (typeof (action.log) === 'string') {\n                newAction.log = action.log;\n            }\n            if (typeof (action.nextEmbedded) === 'string') {\n                newAction.nextEmbedded = action.nextEmbedded;\n                lexer.usesEmbedded = true;\n            }\n            return newAction;\n        }\n    }\n    else if (Array.isArray(action)) {\n        const results = [];\n        for (let i = 0, len = action.length; i < len; i++) {\n            results[i] = compileAction(lexer, ruleName, action[i]);\n        }\n        return { group: results };\n    }\n    else if (action.cases) {\n        // build an array of test cases\n        const cases = [];\n        // for each case, push a test function and result value\n        for (const tkey in action.cases) {\n            if (action.cases.hasOwnProperty(tkey)) {\n                const val = compileAction(lexer, ruleName, action.cases[tkey]);\n                // what kind of case\n                if (tkey === '@default' || tkey === '@' || tkey === '') {\n                    cases.push({ test: undefined, value: val, name: tkey });\n                }\n                else if (tkey === '@eos') {\n                    cases.push({ test: function (id, matches, state, eos) { return eos; }, value: val, name: tkey });\n                }\n                else {\n                    cases.push(createGuard(lexer, ruleName, tkey, val)); // call separate function to avoid local variable capture\n                }\n            }\n        }\n        // create a matching function\n        const def = lexer.defaultToken;\n        return {\n            test: function (id, matches, state, eos) {\n                for (const _case of cases) {\n                    const didmatch = (!_case.test || _case.test(id, matches, state, eos));\n                    if (didmatch) {\n                        return _case.value;\n                    }\n                }\n                return def;\n            }\n        };\n    }\n    else {\n        throw monarchCommon.createError(lexer, 'an action must be a string, an object with a \\'token\\' or \\'cases\\' attribute, or an array of actions; in rule: ' + ruleName);\n    }\n}\n/**\n * Helper class for creating matching rules\n */\nclass Rule {\n    constructor(name) {\n        this.regex = new RegExp('');\n        this.action = { token: '' };\n        this.matchOnlyAtLineStart = false;\n        this.name = '';\n        this.name = name;\n    }\n    setRegex(lexer, re) {\n        let sregex;\n        if (typeof (re) === 'string') {\n            sregex = re;\n        }\n        else if (re instanceof RegExp) {\n            sregex = re.source;\n        }\n        else {\n            throw monarchCommon.createError(lexer, 'rules must start with a match string or regular expression: ' + this.name);\n        }\n        this.matchOnlyAtLineStart = (sregex.length > 0 && sregex[0] === '^');\n        this.name = this.name + ': ' + sregex;\n        this.regex = compileRegExp(lexer, '^(?:' + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ')');\n    }\n    setAction(lexer, act) {\n        this.action = compileAction(lexer, this.name, act);\n    }\n}\n/**\n * Compiles a json description function into json where all regular expressions,\n * case matches etc, are compiled and all include rules are expanded.\n * We also compile the bracket definitions, supply defaults, and do many sanity checks.\n * If the 'jsonStrict' parameter is 'false', we allow at certain locations\n * regular expression objects and functions that get called during lexing.\n * (Currently we have no samples that need this so perhaps we should always have\n * jsonStrict to true).\n */\nexport function compile(languageId, json) {\n    if (!json || typeof (json) !== 'object') {\n        throw new Error('Monarch: expecting a language definition object');\n    }\n    // Create our lexer\n    const lexer = {};\n    lexer.languageId = languageId;\n    lexer.includeLF = bool(json.includeLF, false);\n    lexer.noThrow = false; // raise exceptions during compilation\n    lexer.maxStack = 100;\n    // Set standard fields: be defensive about types\n    lexer.start = (typeof json.start === 'string' ? json.start : null);\n    lexer.ignoreCase = bool(json.ignoreCase, false);\n    lexer.unicode = bool(json.unicode, false);\n    lexer.tokenPostfix = string(json.tokenPostfix, '.' + lexer.languageId);\n    lexer.defaultToken = string(json.defaultToken, 'source');\n    lexer.usesEmbedded = false; // becomes true if we find a nextEmbedded action\n    // For calling compileAction later on\n    const lexerMin = json;\n    lexerMin.languageId = languageId;\n    lexerMin.includeLF = lexer.includeLF;\n    lexerMin.ignoreCase = lexer.ignoreCase;\n    lexerMin.unicode = lexer.unicode;\n    lexerMin.noThrow = lexer.noThrow;\n    lexerMin.usesEmbedded = lexer.usesEmbedded;\n    lexerMin.stateNames = json.tokenizer;\n    lexerMin.defaultToken = lexer.defaultToken;\n    // Compile an array of rules into newrules where RegExp objects are created.\n    function addRules(state, newrules, rules) {\n        for (const rule of rules) {\n            let include = rule.include;\n            if (include) {\n                if (typeof (include) !== 'string') {\n                    throw monarchCommon.createError(lexer, 'an \\'include\\' attribute must be a string at: ' + state);\n                }\n                if (include[0] === '@') {\n                    include = include.substr(1); // peel off starting @\n                }\n                if (!json.tokenizer[include]) {\n                    throw monarchCommon.createError(lexer, 'include target \\'' + include + '\\' is not defined at: ' + state);\n                }\n                addRules(state + '.' + include, newrules, json.tokenizer[include]);\n            }\n            else {\n                const newrule = new Rule(state);\n                // Set up new rule attributes\n                if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {\n                    newrule.setRegex(lexerMin, rule[0]);\n                    if (rule.length >= 3) {\n                        if (typeof (rule[1]) === 'string') {\n                            newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });\n                        }\n                        else if (typeof (rule[1]) === 'object') {\n                            const rule1 = rule[1];\n                            rule1.next = rule[2];\n                            newrule.setAction(lexerMin, rule1);\n                        }\n                        else {\n                            throw monarchCommon.createError(lexer, 'a next state as the last element of a rule can only be given if the action is either an object or a string, at: ' + state);\n                        }\n                    }\n                    else {\n                        newrule.setAction(lexerMin, rule[1]);\n                    }\n                }\n                else {\n                    if (!rule.regex) {\n                        throw monarchCommon.createError(lexer, 'a rule must either be an array, or an object with a \\'regex\\' or \\'include\\' field at: ' + state);\n                    }\n                    if (rule.name) {\n                        if (typeof rule.name === 'string') {\n                            newrule.name = rule.name;\n                        }\n                    }\n                    if (rule.matchOnlyAtStart) {\n                        newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, false);\n                    }\n                    newrule.setRegex(lexerMin, rule.regex);\n                    newrule.setAction(lexerMin, rule.action);\n                }\n                newrules.push(newrule);\n            }\n        }\n    }\n    // compile the tokenizer rules\n    if (!json.tokenizer || typeof (json.tokenizer) !== 'object') {\n        throw monarchCommon.createError(lexer, 'a language definition must define the \\'tokenizer\\' attribute as an object');\n    }\n    lexer.tokenizer = [];\n    for (const key in json.tokenizer) {\n        if (json.tokenizer.hasOwnProperty(key)) {\n            if (!lexer.start) {\n                lexer.start = key;\n            }\n            const rules = json.tokenizer[key];\n            lexer.tokenizer[key] = new Array();\n            addRules('tokenizer.' + key, lexer.tokenizer[key], rules);\n        }\n    }\n    lexer.usesEmbedded = lexerMin.usesEmbedded; // can be set during compileAction\n    // Set simple brackets\n    if (json.brackets) {\n        if (!(Array.isArray(json.brackets))) {\n            throw monarchCommon.createError(lexer, 'the \\'brackets\\' attribute must be defined as an array');\n        }\n    }\n    else {\n        json.brackets = [\n            { open: '{', close: '}', token: 'delimiter.curly' },\n            { open: '[', close: ']', token: 'delimiter.square' },\n            { open: '(', close: ')', token: 'delimiter.parenthesis' },\n            { open: '<', close: '>', token: 'delimiter.angle' }\n        ];\n    }\n    const brackets = [];\n    for (const el of json.brackets) {\n        let desc = el;\n        if (desc && Array.isArray(desc) && desc.length === 3) {\n            desc = { token: desc[2], open: desc[0], close: desc[1] };\n        }\n        if (desc.open === desc.close) {\n            throw monarchCommon.createError(lexer, 'open and close brackets in a \\'brackets\\' attribute must be different: ' + desc.open +\n                '\\n hint: use the \\'bracket\\' attribute if matching on equal brackets is required.');\n        }\n        if (typeof desc.open === 'string' && typeof desc.token === 'string' && typeof desc.close === 'string') {\n            brackets.push({\n                token: desc.token + lexer.tokenPostfix,\n                open: monarchCommon.fixCase(lexer, desc.open),\n                close: monarchCommon.fixCase(lexer, desc.close)\n            });\n        }\n        else {\n            throw monarchCommon.createError(lexer, 'every element in the \\'brackets\\' array must be a \\'{open,close,token}\\' object or array');\n        }\n    }\n    lexer.brackets = brackets;\n    // Disable throw so the syntax highlighter goes, no matter what\n    lexer.noThrow = true;\n    return lexer;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Color } from '../../../base/common/color.js';\nimport { Range } from '../../common/core/range.js';\nimport * as languages from '../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry.js';\nimport { ModesRegistry } from '../../common/languages/modesRegistry.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nimport * as standaloneEnums from '../../common/standalone/standaloneEnums.js';\nimport { StandaloneServices } from './standaloneServices.js';\nimport { compile } from '../common/monarch/monarchCompile.js';\nimport { MonarchTokenizer } from '../common/monarch/monarchLexer.js';\nimport { IStandaloneThemeService } from '../common/standaloneTheme.js';\nimport { IMarkerService } from '../../../platform/markers/common/markers.js';\nimport { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\n/**\n * Register information about a new language.\n */\nexport function register(language) {\n    // Intentionally using the `ModesRegistry` here to avoid\n    // instantiating services too quickly in the standalone editor.\n    ModesRegistry.registerLanguage(language);\n}\n/**\n * Get the information of all the registered languages.\n */\nexport function getLanguages() {\n    let result = [];\n    result = result.concat(ModesRegistry.getLanguages());\n    return result;\n}\nexport function getEncodedLanguageId(languageId) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    return languageService.languageIdCodec.encodeLanguageId(languageId);\n}\n/**\n * An event emitted when a language is needed for the first time (e.g. a model has it set).\n * @event\n */\nexport function onLanguage(languageId, callback) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    const disposable = languageService.onDidEncounterLanguage((encounteredLanguageId) => {\n        if (encounteredLanguageId === languageId) {\n            // stop listening\n            disposable.dispose();\n            // invoke actual listener\n            callback();\n        }\n    });\n    return disposable;\n}\n/**\n * Set the editing configuration for a language.\n */\nexport function setLanguageConfiguration(languageId, configuration) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    if (!languageService.isRegisteredLanguageId(languageId)) {\n        throw new Error(`Cannot set configuration for unknown language ${languageId}`);\n    }\n    const languageConfigurationService = StandaloneServices.get(ILanguageConfigurationService);\n    return languageConfigurationService.register(languageId, configuration, 100);\n}\n/**\n * @internal\n */\nexport class EncodedTokenizationSupportAdapter {\n    constructor(languageId, actual) {\n        this._languageId = languageId;\n        this._actual = actual;\n    }\n    getInitialState() {\n        return this._actual.getInitialState();\n    }\n    tokenize(line, hasEOL, state) {\n        if (typeof this._actual.tokenize === 'function') {\n            return TokenizationSupportAdapter.adaptTokenize(this._languageId, this._actual, line, state);\n        }\n        throw new Error('Not supported!');\n    }\n    tokenizeEncoded(line, hasEOL, state) {\n        const result = this._actual.tokenizeEncoded(line, state);\n        return new languages.EncodedTokenizationResult(result.tokens, result.endState);\n    }\n}\n/**\n * @internal\n */\nexport class TokenizationSupportAdapter {\n    constructor(_languageId, _actual, _languageService, _standaloneThemeService) {\n        this._languageId = _languageId;\n        this._actual = _actual;\n        this._languageService = _languageService;\n        this._standaloneThemeService = _standaloneThemeService;\n    }\n    getInitialState() {\n        return this._actual.getInitialState();\n    }\n    static _toClassicTokens(tokens, language) {\n        const result = [];\n        let previousStartIndex = 0;\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const t = tokens[i];\n            let startIndex = t.startIndex;\n            // Prevent issues stemming from a buggy external tokenizer.\n            if (i === 0) {\n                // Force first token to start at first index!\n                startIndex = 0;\n            }\n            else if (startIndex < previousStartIndex) {\n                // Force tokens to be after one another!\n                startIndex = previousStartIndex;\n            }\n            result[i] = new languages.Token(startIndex, t.scopes, language);\n            previousStartIndex = startIndex;\n        }\n        return result;\n    }\n    static adaptTokenize(language, actual, line, state) {\n        const actualResult = actual.tokenize(line, state);\n        const tokens = TokenizationSupportAdapter._toClassicTokens(actualResult.tokens, language);\n        let endState;\n        // try to save an object if possible\n        if (actualResult.endState.equals(state)) {\n            endState = state;\n        }\n        else {\n            endState = actualResult.endState;\n        }\n        return new languages.TokenizationResult(tokens, endState);\n    }\n    tokenize(line, hasEOL, state) {\n        return TokenizationSupportAdapter.adaptTokenize(this._languageId, this._actual, line, state);\n    }\n    _toBinaryTokens(languageIdCodec, tokens) {\n        const languageId = languageIdCodec.encodeLanguageId(this._languageId);\n        const tokenTheme = this._standaloneThemeService.getColorTheme().tokenTheme;\n        const result = [];\n        let resultLen = 0;\n        let previousStartIndex = 0;\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const t = tokens[i];\n            const metadata = tokenTheme.match(languageId, t.scopes);\n            if (resultLen > 0 && result[resultLen - 1] === metadata) {\n                // same metadata\n                continue;\n            }\n            let startIndex = t.startIndex;\n            // Prevent issues stemming from a buggy external tokenizer.\n            if (i === 0) {\n                // Force first token to start at first index!\n                startIndex = 0;\n            }\n            else if (startIndex < previousStartIndex) {\n                // Force tokens to be after one another!\n                startIndex = previousStartIndex;\n            }\n            result[resultLen++] = startIndex;\n            result[resultLen++] = metadata;\n            previousStartIndex = startIndex;\n        }\n        const actualResult = new Uint32Array(resultLen);\n        for (let i = 0; i < resultLen; i++) {\n            actualResult[i] = result[i];\n        }\n        return actualResult;\n    }\n    tokenizeEncoded(line, hasEOL, state) {\n        const actualResult = this._actual.tokenize(line, state);\n        const tokens = this._toBinaryTokens(this._languageService.languageIdCodec, actualResult.tokens);\n        let endState;\n        // try to save an object if possible\n        if (actualResult.endState.equals(state)) {\n            endState = state;\n        }\n        else {\n            endState = actualResult.endState;\n        }\n        return new languages.EncodedTokenizationResult(tokens, endState);\n    }\n}\nfunction isATokensProvider(provider) {\n    return (typeof provider.getInitialState === 'function');\n}\nfunction isEncodedTokensProvider(provider) {\n    return 'tokenizeEncoded' in provider;\n}\nfunction isThenable(obj) {\n    return obj && typeof obj.then === 'function';\n}\n/**\n * Change the color map that is used for token colors.\n * Supported formats (hex): #RRGGBB, $RRGGBBAA, #RGB, #RGBA\n */\nexport function setColorMap(colorMap) {\n    const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);\n    if (colorMap) {\n        const result = [null];\n        for (let i = 1, len = colorMap.length; i < len; i++) {\n            result[i] = Color.fromHex(colorMap[i]);\n        }\n        standaloneThemeService.setColorMapOverride(result);\n    }\n    else {\n        standaloneThemeService.setColorMapOverride(null);\n    }\n}\n/**\n * @internal\n */\nfunction createTokenizationSupportAdapter(languageId, provider) {\n    if (isEncodedTokensProvider(provider)) {\n        return new EncodedTokenizationSupportAdapter(languageId, provider);\n    }\n    else {\n        return new TokenizationSupportAdapter(languageId, provider, StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService));\n    }\n}\n/**\n * Register a tokens provider factory for a language. This tokenizer will be exclusive with a tokenizer\n * set using `setTokensProvider` or one created using `setMonarchTokensProvider`, but will work together\n * with a tokens provider set using `registerDocumentSemanticTokensProvider` or `registerDocumentRangeSemanticTokensProvider`.\n */\nexport function registerTokensProviderFactory(languageId, factory) {\n    const adaptedFactory = {\n        createTokenizationSupport: () => __awaiter(this, void 0, void 0, function* () {\n            const result = yield Promise.resolve(factory.create());\n            if (!result) {\n                return null;\n            }\n            if (isATokensProvider(result)) {\n                return createTokenizationSupportAdapter(languageId, result);\n            }\n            return new MonarchTokenizer(StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService), languageId, compile(languageId, result), StandaloneServices.get(IConfigurationService));\n        })\n    };\n    return languages.TokenizationRegistry.registerFactory(languageId, adaptedFactory);\n}\n/**\n * Set the tokens provider for a language (manual implementation). This tokenizer will be exclusive\n * with a tokenizer created using `setMonarchTokensProvider`, or with `registerTokensProviderFactory`,\n * but will work together with a tokens provider set using `registerDocumentSemanticTokensProvider`\n * or `registerDocumentRangeSemanticTokensProvider`.\n */\nexport function setTokensProvider(languageId, provider) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    if (!languageService.isRegisteredLanguageId(languageId)) {\n        throw new Error(`Cannot set tokens provider for unknown language ${languageId}`);\n    }\n    if (isThenable(provider)) {\n        return registerTokensProviderFactory(languageId, { create: () => provider });\n    }\n    return languages.TokenizationRegistry.register(languageId, createTokenizationSupportAdapter(languageId, provider));\n}\n/**\n * Set the tokens provider for a language (monarch implementation). This tokenizer will be exclusive\n * with a tokenizer set using `setTokensProvider`, or with `registerTokensProviderFactory`, but will\n * work together with a tokens provider set using `registerDocumentSemanticTokensProvider` or\n * `registerDocumentRangeSemanticTokensProvider`.\n */\nexport function setMonarchTokensProvider(languageId, languageDef) {\n    const create = (languageDef) => {\n        return new MonarchTokenizer(StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService), languageId, compile(languageId, languageDef), StandaloneServices.get(IConfigurationService));\n    };\n    if (isThenable(languageDef)) {\n        return registerTokensProviderFactory(languageId, { create: () => languageDef });\n    }\n    return languages.TokenizationRegistry.register(languageId, create(languageDef));\n}\n/**\n * Register a reference provider (used by e.g. reference search).\n */\nexport function registerReferenceProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.referenceProvider.register(languageSelector, provider);\n}\n/**\n * Register a rename provider (used by e.g. rename symbol).\n */\nexport function registerRenameProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.renameProvider.register(languageSelector, provider);\n}\n/**\n * Register a signature help provider (used by e.g. parameter hints).\n */\nexport function registerSignatureHelpProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.signatureHelpProvider.register(languageSelector, provider);\n}\n/**\n * Register a hover provider (used by e.g. editor hover).\n */\nexport function registerHoverProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.hoverProvider.register(languageSelector, {\n        provideHover: (model, position, token) => {\n            const word = model.getWordAtPosition(position);\n            return Promise.resolve(provider.provideHover(model, position, token)).then((value) => {\n                if (!value) {\n                    return undefined;\n                }\n                if (!value.range && word) {\n                    value.range = new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);\n                }\n                if (!value.range) {\n                    value.range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);\n                }\n                return value;\n            });\n        }\n    });\n}\n/**\n * Register a document symbol provider (used by e.g. outline).\n */\nexport function registerDocumentSymbolProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentSymbolProvider.register(languageSelector, provider);\n}\n/**\n * Register a document highlight provider (used by e.g. highlight occurrences).\n */\nexport function registerDocumentHighlightProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentHighlightProvider.register(languageSelector, provider);\n}\n/**\n * Register an linked editing range provider.\n */\nexport function registerLinkedEditingRangeProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.linkedEditingRangeProvider.register(languageSelector, provider);\n}\n/**\n * Register a definition provider (used by e.g. go to definition).\n */\nexport function registerDefinitionProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.definitionProvider.register(languageSelector, provider);\n}\n/**\n * Register a implementation provider (used by e.g. go to implementation).\n */\nexport function registerImplementationProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.implementationProvider.register(languageSelector, provider);\n}\n/**\n * Register a type definition provider (used by e.g. go to type definition).\n */\nexport function registerTypeDefinitionProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.typeDefinitionProvider.register(languageSelector, provider);\n}\n/**\n * Register a code lens provider (used by e.g. inline code lenses).\n */\nexport function registerCodeLensProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.codeLensProvider.register(languageSelector, provider);\n}\n/**\n * Register a code action provider (used by e.g. quick fix).\n */\nexport function registerCodeActionProvider(languageSelector, provider, metadata) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.codeActionProvider.register(languageSelector, {\n        providedCodeActionKinds: metadata === null || metadata === void 0 ? void 0 : metadata.providedCodeActionKinds,\n        documentation: metadata === null || metadata === void 0 ? void 0 : metadata.documentation,\n        provideCodeActions: (model, range, context, token) => {\n            const markerService = StandaloneServices.get(IMarkerService);\n            const markers = markerService.read({ resource: model.uri }).filter(m => {\n                return Range.areIntersectingOrTouching(m, range);\n            });\n            return provider.provideCodeActions(model, range, { markers, only: context.only, trigger: context.trigger }, token);\n        },\n        resolveCodeAction: provider.resolveCodeAction\n    });\n}\n/**\n * Register a formatter that can handle only entire models.\n */\nexport function registerDocumentFormattingEditProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentFormattingEditProvider.register(languageSelector, provider);\n}\n/**\n * Register a formatter that can handle a range inside a model.\n */\nexport function registerDocumentRangeFormattingEditProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentRangeFormattingEditProvider.register(languageSelector, provider);\n}\n/**\n * Register a formatter than can do formatting as the user types.\n */\nexport function registerOnTypeFormattingEditProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.onTypeFormattingEditProvider.register(languageSelector, provider);\n}\n/**\n * Register a link provider that can find links in text.\n */\nexport function registerLinkProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.linkProvider.register(languageSelector, provider);\n}\n/**\n * Register a completion item provider (use by e.g. suggestions).\n */\nexport function registerCompletionItemProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.completionProvider.register(languageSelector, provider);\n}\n/**\n * Register a document color provider (used by Color Picker, Color Decorator).\n */\nexport function registerColorProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.colorProvider.register(languageSelector, provider);\n}\n/**\n * Register a folding range provider\n */\nexport function registerFoldingRangeProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.foldingRangeProvider.register(languageSelector, provider);\n}\n/**\n * Register a declaration provider\n */\nexport function registerDeclarationProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.declarationProvider.register(languageSelector, provider);\n}\n/**\n * Register a selection range provider\n */\nexport function registerSelectionRangeProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.selectionRangeProvider.register(languageSelector, provider);\n}\n/**\n * Register a document semantic tokens provider. A semantic tokens provider will complement and enhance a\n * simple top-down tokenizer. Simple top-down tokenizers can be set either via `setMonarchTokensProvider`\n * or `setTokensProvider`.\n *\n * For the best user experience, register both a semantic tokens provider and a top-down tokenizer.\n */\nexport function registerDocumentSemanticTokensProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentSemanticTokensProvider.register(languageSelector, provider);\n}\n/**\n * Register a document range semantic tokens provider. A semantic tokens provider will complement and enhance a\n * simple top-down tokenizer. Simple top-down tokenizers can be set either via `setMonarchTokensProvider`\n * or `setTokensProvider`.\n *\n * For the best user experience, register both a semantic tokens provider and a top-down tokenizer.\n */\nexport function registerDocumentRangeSemanticTokensProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentRangeSemanticTokensProvider.register(languageSelector, provider);\n}\n/**\n * Register an inline completions provider.\n */\nexport function registerInlineCompletionsProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.inlineCompletionsProvider.register(languageSelector, provider);\n}\n/**\n * Register an inlay hints provider.\n */\nexport function registerInlayHintsProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.inlayHintsProvider.register(languageSelector, provider);\n}\n/**\n * @internal\n */\nexport function createMonacoLanguagesAPI() {\n    return {\n        register: register,\n        getLanguages: getLanguages,\n        onLanguage: onLanguage,\n        getEncodedLanguageId: getEncodedLanguageId,\n        // provider methods\n        setLanguageConfiguration: setLanguageConfiguration,\n        setColorMap: setColorMap,\n        registerTokensProviderFactory: registerTokensProviderFactory,\n        setTokensProvider: setTokensProvider,\n        setMonarchTokensProvider: setMonarchTokensProvider,\n        registerReferenceProvider: registerReferenceProvider,\n        registerRenameProvider: registerRenameProvider,\n        registerCompletionItemProvider: registerCompletionItemProvider,\n        registerSignatureHelpProvider: registerSignatureHelpProvider,\n        registerHoverProvider: registerHoverProvider,\n        registerDocumentSymbolProvider: registerDocumentSymbolProvider,\n        registerDocumentHighlightProvider: registerDocumentHighlightProvider,\n        registerLinkedEditingRangeProvider: registerLinkedEditingRangeProvider,\n        registerDefinitionProvider: registerDefinitionProvider,\n        registerImplementationProvider: registerImplementationProvider,\n        registerTypeDefinitionProvider: registerTypeDefinitionProvider,\n        registerCodeLensProvider: registerCodeLensProvider,\n        registerCodeActionProvider: registerCodeActionProvider,\n        registerDocumentFormattingEditProvider: registerDocumentFormattingEditProvider,\n        registerDocumentRangeFormattingEditProvider: registerDocumentRangeFormattingEditProvider,\n        registerOnTypeFormattingEditProvider: registerOnTypeFormattingEditProvider,\n        registerLinkProvider: registerLinkProvider,\n        registerColorProvider: registerColorProvider,\n        registerFoldingRangeProvider: registerFoldingRangeProvider,\n        registerDeclarationProvider: registerDeclarationProvider,\n        registerSelectionRangeProvider: registerSelectionRangeProvider,\n        registerDocumentSemanticTokensProvider: registerDocumentSemanticTokensProvider,\n        registerDocumentRangeSemanticTokensProvider: registerDocumentRangeSemanticTokensProvider,\n        registerInlineCompletionsProvider: registerInlineCompletionsProvider,\n        registerInlayHintsProvider: registerInlayHintsProvider,\n        // enums\n        DocumentHighlightKind: standaloneEnums.DocumentHighlightKind,\n        CompletionItemKind: standaloneEnums.CompletionItemKind,\n        CompletionItemTag: standaloneEnums.CompletionItemTag,\n        CompletionItemInsertTextRule: standaloneEnums.CompletionItemInsertTextRule,\n        SymbolKind: standaloneEnums.SymbolKind,\n        SymbolTag: standaloneEnums.SymbolTag,\n        IndentAction: standaloneEnums.IndentAction,\n        CompletionTriggerKind: standaloneEnums.CompletionTriggerKind,\n        SignatureHelpTriggerKind: standaloneEnums.SignatureHelpTriggerKind,\n        InlayHintKind: standaloneEnums.InlayHintKind,\n        InlineCompletionTriggerKind: standaloneEnums.InlineCompletionTriggerKind,\n        CodeActionTriggerType: standaloneEnums.CodeActionTriggerType,\n        // classes\n        FoldingRangeKind: languages.FoldingRangeKind,\n    };\n}\n","/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.34.0(9d278685b078158491964f8fd7ac9628fffa0f30)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../editor/editor.api.js\";\n\n// src/basic-languages/_.contribution.ts\nvar languageDefinitions = {};\nvar lazyLanguageLoaders = {};\nvar LazyLanguageLoader = class {\n  static getOrCreate(languageId) {\n    if (!lazyLanguageLoaders[languageId]) {\n      lazyLanguageLoaders[languageId] = new LazyLanguageLoader(languageId);\n    }\n    return lazyLanguageLoaders[languageId];\n  }\n  _languageId;\n  _loadingTriggered;\n  _lazyLoadPromise;\n  _lazyLoadPromiseResolve;\n  _lazyLoadPromiseReject;\n  constructor(languageId) {\n    this._languageId = languageId;\n    this._loadingTriggered = false;\n    this._lazyLoadPromise = new Promise((resolve, reject) => {\n      this._lazyLoadPromiseResolve = resolve;\n      this._lazyLoadPromiseReject = reject;\n    });\n  }\n  load() {\n    if (!this._loadingTriggered) {\n      this._loadingTriggered = true;\n      languageDefinitions[this._languageId].loader().then((mod) => this._lazyLoadPromiseResolve(mod), (err) => this._lazyLoadPromiseReject(err));\n    }\n    return this._lazyLoadPromise;\n  }\n};\nasync function loadLanguage(languageId) {\n  await LazyLanguageLoader.getOrCreate(languageId).load();\n  const model = monaco_editor_core_exports.editor.createModel(\"\", languageId);\n  model.dispose();\n}\nfunction registerLanguage(def) {\n  const languageId = def.id;\n  languageDefinitions[languageId] = def;\n  monaco_editor_core_exports.languages.register(def);\n  const lazyLanguageLoader = LazyLanguageLoader.getOrCreate(languageId);\n  monaco_editor_core_exports.languages.registerTokensProviderFactory(languageId, {\n    create: async () => {\n      const mod = await lazyLanguageLoader.load();\n      return mod.language;\n    }\n  });\n  monaco_editor_core_exports.languages.onLanguage(languageId, async () => {\n    const mod = await lazyLanguageLoader.load();\n    monaco_editor_core_exports.languages.setLanguageConfiguration(languageId, mod.conf);\n  });\n}\nexport {\n  loadLanguage,\n  registerLanguage\n};\n","import '../../editor/editor.api.js';\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.34.0(9d278685b078158491964f8fd7ac9628fffa0f30)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/language/css/monaco.contribution.ts\nvar LanguageServiceDefaultsImpl = class {\n  _onDidChange = new monaco_editor_core_exports.Emitter();\n  _options;\n  _modeConfiguration;\n  _languageId;\n  constructor(languageId, options, modeConfiguration) {\n    this._languageId = languageId;\n    this.setOptions(options);\n    this.setModeConfiguration(modeConfiguration);\n  }\n  get onDidChange() {\n    return this._onDidChange.event;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get modeConfiguration() {\n    return this._modeConfiguration;\n  }\n  get diagnosticsOptions() {\n    return this.options;\n  }\n  get options() {\n    return this._options;\n  }\n  setOptions(options) {\n    this._options = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n  setDiagnosticsOptions(options) {\n    this.setOptions(options);\n  }\n  setModeConfiguration(modeConfiguration) {\n    this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n};\nvar optionsDefault = {\n  validate: true,\n  lint: {\n    compatibleVendorPrefixes: \"ignore\",\n    vendorPrefix: \"warning\",\n    duplicateProperties: \"warning\",\n    emptyRules: \"warning\",\n    importStatement: \"ignore\",\n    boxModel: \"ignore\",\n    universalSelector: \"ignore\",\n    zeroUnits: \"ignore\",\n    fontFaceProperties: \"warning\",\n    hexColorLength: \"error\",\n    argumentsInColorFunction: \"error\",\n    unknownProperties: \"warning\",\n    ieHack: \"ignore\",\n    unknownVendorSpecificProperties: \"ignore\",\n    propertyIgnoredDueToDisplay: \"warning\",\n    important: \"ignore\",\n    float: \"ignore\",\n    idSelector: \"ignore\"\n  },\n  data: { useDefaultDataProvider: true },\n  format: {\n    newlineBetweenSelectors: true,\n    newlineBetweenRules: true,\n    spaceAroundSelectorSeparator: false,\n    braceStyle: \"collapse\",\n    maxPreserveNewLines: void 0,\n    preserveNewLines: true\n  }\n};\nvar modeConfigurationDefault = {\n  completionItems: true,\n  hovers: true,\n  documentSymbols: true,\n  definitions: true,\n  references: true,\n  documentHighlights: true,\n  rename: true,\n  colors: true,\n  foldingRanges: true,\n  diagnostics: true,\n  selectionRanges: true,\n  documentFormattingEdits: true,\n  documentRangeFormattingEdits: true\n};\nvar cssDefaults = new LanguageServiceDefaultsImpl(\"css\", optionsDefault, modeConfigurationDefault);\nvar scssDefaults = new LanguageServiceDefaultsImpl(\"scss\", optionsDefault, modeConfigurationDefault);\nvar lessDefaults = new LanguageServiceDefaultsImpl(\"less\", optionsDefault, modeConfigurationDefault);\nmonaco_editor_core_exports.languages.css = { cssDefaults, lessDefaults, scssDefaults };\nfunction getMode() {\n  if (false) {\n    return new Promise((resolve, reject) => {\n      __require([\"vs/language/css/cssMode\"], resolve, reject);\n    });\n  } else {\n    return import(\"./cssMode.js\");\n  }\n}\nmonaco_editor_core_exports.languages.onLanguage(\"less\", () => {\n  getMode().then((mode) => mode.setupMode(lessDefaults));\n});\nmonaco_editor_core_exports.languages.onLanguage(\"scss\", () => {\n  getMode().then((mode) => mode.setupMode(scssDefaults));\n});\nmonaco_editor_core_exports.languages.onLanguage(\"css\", () => {\n  getMode().then((mode) => mode.setupMode(cssDefaults));\n});\nexport {\n  cssDefaults,\n  lessDefaults,\n  scssDefaults\n};\n","import '../../editor/editor.api.js';\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.34.0(9d278685b078158491964f8fd7ac9628fffa0f30)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/language/html/monaco.contribution.ts\nvar LanguageServiceDefaultsImpl = class {\n  _onDidChange = new monaco_editor_core_exports.Emitter();\n  _options;\n  _modeConfiguration;\n  _languageId;\n  constructor(languageId, options, modeConfiguration) {\n    this._languageId = languageId;\n    this.setOptions(options);\n    this.setModeConfiguration(modeConfiguration);\n  }\n  get onDidChange() {\n    return this._onDidChange.event;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get options() {\n    return this._options;\n  }\n  get modeConfiguration() {\n    return this._modeConfiguration;\n  }\n  setOptions(options) {\n    this._options = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n  setModeConfiguration(modeConfiguration) {\n    this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n};\nvar formatDefaults = {\n  tabSize: 4,\n  insertSpaces: false,\n  wrapLineLength: 120,\n  unformatted: 'default\": \"a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, select, small, span, strong, sub, sup, textarea, tt, var',\n  contentUnformatted: \"pre\",\n  indentInnerHtml: false,\n  preserveNewLines: true,\n  maxPreserveNewLines: void 0,\n  indentHandlebars: false,\n  endWithNewline: false,\n  extraLiners: \"head, body, /html\",\n  wrapAttributes: \"auto\"\n};\nvar optionsDefault = {\n  format: formatDefaults,\n  suggest: {},\n  data: { useDefaultDataProvider: true }\n};\nfunction getConfigurationDefault(languageId) {\n  return {\n    completionItems: true,\n    hovers: true,\n    documentSymbols: true,\n    links: true,\n    documentHighlights: true,\n    rename: true,\n    colors: true,\n    foldingRanges: true,\n    selectionRanges: true,\n    diagnostics: languageId === htmlLanguageId,\n    documentFormattingEdits: languageId === htmlLanguageId,\n    documentRangeFormattingEdits: languageId === htmlLanguageId\n  };\n}\nvar htmlLanguageId = \"html\";\nvar handlebarsLanguageId = \"handlebars\";\nvar razorLanguageId = \"razor\";\nvar htmlLanguageService = registerHTMLLanguageService(htmlLanguageId, optionsDefault, getConfigurationDefault(htmlLanguageId));\nvar htmlDefaults = htmlLanguageService.defaults;\nvar handlebarLanguageService = registerHTMLLanguageService(handlebarsLanguageId, optionsDefault, getConfigurationDefault(handlebarsLanguageId));\nvar handlebarDefaults = handlebarLanguageService.defaults;\nvar razorLanguageService = registerHTMLLanguageService(razorLanguageId, optionsDefault, getConfigurationDefault(razorLanguageId));\nvar razorDefaults = razorLanguageService.defaults;\nmonaco_editor_core_exports.languages.html = {\n  htmlDefaults,\n  razorDefaults,\n  handlebarDefaults,\n  htmlLanguageService,\n  handlebarLanguageService,\n  razorLanguageService,\n  registerHTMLLanguageService\n};\nfunction getMode() {\n  if (false) {\n    return new Promise((resolve, reject) => {\n      __require([\"vs/language/html/htmlMode\"], resolve, reject);\n    });\n  } else {\n    return import(\"./htmlMode.js\");\n  }\n}\nfunction registerHTMLLanguageService(languageId, options = optionsDefault, modeConfiguration = getConfigurationDefault(languageId)) {\n  const defaults = new LanguageServiceDefaultsImpl(languageId, options, modeConfiguration);\n  let mode;\n  const onLanguageListener = monaco_editor_core_exports.languages.onLanguage(languageId, async () => {\n    mode = (await getMode()).setupMode(defaults);\n  });\n  return {\n    defaults,\n    dispose() {\n      onLanguageListener.dispose();\n      mode?.dispose();\n      mode = void 0;\n    }\n  };\n}\nexport {\n  handlebarDefaults,\n  handlebarLanguageService,\n  htmlDefaults,\n  htmlLanguageService,\n  razorDefaults,\n  razorLanguageService,\n  registerHTMLLanguageService\n};\n","import '../../editor/editor.api.js';\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.34.0(9d278685b078158491964f8fd7ac9628fffa0f30)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/language/json/monaco.contribution.ts\nvar LanguageServiceDefaultsImpl = class {\n  _onDidChange = new monaco_editor_core_exports.Emitter();\n  _diagnosticsOptions;\n  _modeConfiguration;\n  _languageId;\n  constructor(languageId, diagnosticsOptions, modeConfiguration) {\n    this._languageId = languageId;\n    this.setDiagnosticsOptions(diagnosticsOptions);\n    this.setModeConfiguration(modeConfiguration);\n  }\n  get onDidChange() {\n    return this._onDidChange.event;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get modeConfiguration() {\n    return this._modeConfiguration;\n  }\n  get diagnosticsOptions() {\n    return this._diagnosticsOptions;\n  }\n  setDiagnosticsOptions(options) {\n    this._diagnosticsOptions = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n  setModeConfiguration(modeConfiguration) {\n    this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n};\nvar diagnosticDefault = {\n  validate: true,\n  allowComments: true,\n  schemas: [],\n  enableSchemaRequest: false,\n  schemaRequest: \"warning\",\n  schemaValidation: \"warning\",\n  comments: \"error\",\n  trailingCommas: \"error\"\n};\nvar modeConfigurationDefault = {\n  documentFormattingEdits: true,\n  documentRangeFormattingEdits: true,\n  completionItems: true,\n  hovers: true,\n  documentSymbols: true,\n  tokens: true,\n  colors: true,\n  foldingRanges: true,\n  diagnostics: true,\n  selectionRanges: true\n};\nvar jsonDefaults = new LanguageServiceDefaultsImpl(\"json\", diagnosticDefault, modeConfigurationDefault);\nmonaco_editor_core_exports.languages.json = { jsonDefaults };\nfunction getMode() {\n  if (false) {\n    return new Promise((resolve, reject) => {\n      __require([\"vs/language/json/jsonMode\"], resolve, reject);\n    });\n  } else {\n    return import(\"./jsonMode.js\");\n  }\n}\nmonaco_editor_core_exports.languages.register({\n  id: \"json\",\n  extensions: [\".json\", \".bowerrc\", \".jshintrc\", \".jscsrc\", \".eslintrc\", \".babelrc\", \".har\"],\n  aliases: [\"JSON\", \"json\"],\n  mimetypes: [\"application/json\"]\n});\nmonaco_editor_core_exports.languages.onLanguage(\"json\", () => {\n  getMode().then((mode) => mode.setupMode(jsonDefaults));\n});\nexport {\n  jsonDefaults\n};\n","import '../../editor/editor.api.js';\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.34.0(9d278685b078158491964f8fd7ac9628fffa0f30)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/language/typescript/lib/typescriptServicesMetadata.ts\nvar typescriptVersion = \"4.5.5\";\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/language/typescript/monaco.contribution.ts\nvar ModuleKind = /* @__PURE__ */ ((ModuleKind2) => {\n  ModuleKind2[ModuleKind2[\"None\"] = 0] = \"None\";\n  ModuleKind2[ModuleKind2[\"CommonJS\"] = 1] = \"CommonJS\";\n  ModuleKind2[ModuleKind2[\"AMD\"] = 2] = \"AMD\";\n  ModuleKind2[ModuleKind2[\"UMD\"] = 3] = \"UMD\";\n  ModuleKind2[ModuleKind2[\"System\"] = 4] = \"System\";\n  ModuleKind2[ModuleKind2[\"ES2015\"] = 5] = \"ES2015\";\n  ModuleKind2[ModuleKind2[\"ESNext\"] = 99] = \"ESNext\";\n  return ModuleKind2;\n})(ModuleKind || {});\nvar JsxEmit = /* @__PURE__ */ ((JsxEmit2) => {\n  JsxEmit2[JsxEmit2[\"None\"] = 0] = \"None\";\n  JsxEmit2[JsxEmit2[\"Preserve\"] = 1] = \"Preserve\";\n  JsxEmit2[JsxEmit2[\"React\"] = 2] = \"React\";\n  JsxEmit2[JsxEmit2[\"ReactNative\"] = 3] = \"ReactNative\";\n  JsxEmit2[JsxEmit2[\"ReactJSX\"] = 4] = \"ReactJSX\";\n  JsxEmit2[JsxEmit2[\"ReactJSXDev\"] = 5] = \"ReactJSXDev\";\n  return JsxEmit2;\n})(JsxEmit || {});\nvar NewLineKind = /* @__PURE__ */ ((NewLineKind2) => {\n  NewLineKind2[NewLineKind2[\"CarriageReturnLineFeed\"] = 0] = \"CarriageReturnLineFeed\";\n  NewLineKind2[NewLineKind2[\"LineFeed\"] = 1] = \"LineFeed\";\n  return NewLineKind2;\n})(NewLineKind || {});\nvar ScriptTarget = /* @__PURE__ */ ((ScriptTarget2) => {\n  ScriptTarget2[ScriptTarget2[\"ES3\"] = 0] = \"ES3\";\n  ScriptTarget2[ScriptTarget2[\"ES5\"] = 1] = \"ES5\";\n  ScriptTarget2[ScriptTarget2[\"ES2015\"] = 2] = \"ES2015\";\n  ScriptTarget2[ScriptTarget2[\"ES2016\"] = 3] = \"ES2016\";\n  ScriptTarget2[ScriptTarget2[\"ES2017\"] = 4] = \"ES2017\";\n  ScriptTarget2[ScriptTarget2[\"ES2018\"] = 5] = \"ES2018\";\n  ScriptTarget2[ScriptTarget2[\"ES2019\"] = 6] = \"ES2019\";\n  ScriptTarget2[ScriptTarget2[\"ES2020\"] = 7] = \"ES2020\";\n  ScriptTarget2[ScriptTarget2[\"ESNext\"] = 99] = \"ESNext\";\n  ScriptTarget2[ScriptTarget2[\"JSON\"] = 100] = \"JSON\";\n  ScriptTarget2[ScriptTarget2[\"Latest\"] = 99 /* ESNext */] = \"Latest\";\n  return ScriptTarget2;\n})(ScriptTarget || {});\nvar ModuleResolutionKind = /* @__PURE__ */ ((ModuleResolutionKind2) => {\n  ModuleResolutionKind2[ModuleResolutionKind2[\"Classic\"] = 1] = \"Classic\";\n  ModuleResolutionKind2[ModuleResolutionKind2[\"NodeJs\"] = 2] = \"NodeJs\";\n  return ModuleResolutionKind2;\n})(ModuleResolutionKind || {});\nvar LanguageServiceDefaultsImpl = class {\n  _onDidChange = new monaco_editor_core_exports.Emitter();\n  _onDidExtraLibsChange = new monaco_editor_core_exports.Emitter();\n  _extraLibs;\n  _removedExtraLibs;\n  _eagerModelSync;\n  _compilerOptions;\n  _diagnosticsOptions;\n  _workerOptions;\n  _onDidExtraLibsChangeTimeout;\n  _inlayHintsOptions;\n  constructor(compilerOptions, diagnosticsOptions, workerOptions, inlayHintsOptions) {\n    this._extraLibs = /* @__PURE__ */ Object.create(null);\n    this._removedExtraLibs = /* @__PURE__ */ Object.create(null);\n    this._eagerModelSync = false;\n    this.setCompilerOptions(compilerOptions);\n    this.setDiagnosticsOptions(diagnosticsOptions);\n    this.setWorkerOptions(workerOptions);\n    this.setInlayHintsOptions(inlayHintsOptions);\n    this._onDidExtraLibsChangeTimeout = -1;\n  }\n  get onDidChange() {\n    return this._onDidChange.event;\n  }\n  get onDidExtraLibsChange() {\n    return this._onDidExtraLibsChange.event;\n  }\n  get workerOptions() {\n    return this._workerOptions;\n  }\n  get inlayHintsOptions() {\n    return this._inlayHintsOptions;\n  }\n  getExtraLibs() {\n    return this._extraLibs;\n  }\n  addExtraLib(content, _filePath) {\n    let filePath;\n    if (typeof _filePath === \"undefined\") {\n      filePath = `ts:extralib-${Math.random().toString(36).substring(2, 15)}`;\n    } else {\n      filePath = _filePath;\n    }\n    if (this._extraLibs[filePath] && this._extraLibs[filePath].content === content) {\n      return {\n        dispose: () => {\n        }\n      };\n    }\n    let myVersion = 1;\n    if (this._removedExtraLibs[filePath]) {\n      myVersion = this._removedExtraLibs[filePath] + 1;\n    }\n    if (this._extraLibs[filePath]) {\n      myVersion = this._extraLibs[filePath].version + 1;\n    }\n    this._extraLibs[filePath] = {\n      content,\n      version: myVersion\n    };\n    this._fireOnDidExtraLibsChangeSoon();\n    return {\n      dispose: () => {\n        let extraLib = this._extraLibs[filePath];\n        if (!extraLib) {\n          return;\n        }\n        if (extraLib.version !== myVersion) {\n          return;\n        }\n        delete this._extraLibs[filePath];\n        this._removedExtraLibs[filePath] = myVersion;\n        this._fireOnDidExtraLibsChangeSoon();\n      }\n    };\n  }\n  setExtraLibs(libs) {\n    for (const filePath in this._extraLibs) {\n      this._removedExtraLibs[filePath] = this._extraLibs[filePath].version;\n    }\n    this._extraLibs = /* @__PURE__ */ Object.create(null);\n    if (libs && libs.length > 0) {\n      for (const lib of libs) {\n        const filePath = lib.filePath || `ts:extralib-${Math.random().toString(36).substring(2, 15)}`;\n        const content = lib.content;\n        let myVersion = 1;\n        if (this._removedExtraLibs[filePath]) {\n          myVersion = this._removedExtraLibs[filePath] + 1;\n        }\n        this._extraLibs[filePath] = {\n          content,\n          version: myVersion\n        };\n      }\n    }\n    this._fireOnDidExtraLibsChangeSoon();\n  }\n  _fireOnDidExtraLibsChangeSoon() {\n    if (this._onDidExtraLibsChangeTimeout !== -1) {\n      return;\n    }\n    this._onDidExtraLibsChangeTimeout = window.setTimeout(() => {\n      this._onDidExtraLibsChangeTimeout = -1;\n      this._onDidExtraLibsChange.fire(void 0);\n    }, 0);\n  }\n  getCompilerOptions() {\n    return this._compilerOptions;\n  }\n  setCompilerOptions(options) {\n    this._compilerOptions = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(void 0);\n  }\n  getDiagnosticsOptions() {\n    return this._diagnosticsOptions;\n  }\n  setDiagnosticsOptions(options) {\n    this._diagnosticsOptions = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(void 0);\n  }\n  setWorkerOptions(options) {\n    this._workerOptions = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(void 0);\n  }\n  setInlayHintsOptions(options) {\n    this._inlayHintsOptions = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(void 0);\n  }\n  setMaximumWorkerIdleTime(value) {\n  }\n  setEagerModelSync(value) {\n    this._eagerModelSync = value;\n  }\n  getEagerModelSync() {\n    return this._eagerModelSync;\n  }\n};\nvar typescriptVersion2 = typescriptVersion;\nvar typescriptDefaults = new LanguageServiceDefaultsImpl({ allowNonTsExtensions: true, target: 99 /* Latest */ }, { noSemanticValidation: false, noSyntaxValidation: false, onlyVisible: false }, {}, {});\nvar javascriptDefaults = new LanguageServiceDefaultsImpl({ allowNonTsExtensions: true, allowJs: true, target: 99 /* Latest */ }, { noSemanticValidation: true, noSyntaxValidation: false, onlyVisible: false }, {}, {});\nvar getTypeScriptWorker = () => {\n  return getMode().then((mode) => mode.getTypeScriptWorker());\n};\nvar getJavaScriptWorker = () => {\n  return getMode().then((mode) => mode.getJavaScriptWorker());\n};\nmonaco_editor_core_exports.languages.typescript = {\n  ModuleKind,\n  JsxEmit,\n  NewLineKind,\n  ScriptTarget,\n  ModuleResolutionKind,\n  typescriptVersion: typescriptVersion2,\n  typescriptDefaults,\n  javascriptDefaults,\n  getTypeScriptWorker,\n  getJavaScriptWorker\n};\nfunction getMode() {\n  if (false) {\n    return new Promise((resolve, reject) => {\n      __require([\"vs/language/typescript/tsMode\"], resolve, reject);\n    });\n  } else {\n    return import(\"./tsMode\");\n  }\n}\nmonaco_editor_core_exports.languages.onLanguage(\"typescript\", () => {\n  return getMode().then((mode) => mode.setupTypeScript(typescriptDefaults));\n});\nmonaco_editor_core_exports.languages.onLanguage(\"javascript\", () => {\n  return getMode().then((mode) => mode.setupJavaScript(javascriptDefaults));\n});\nexport {\n  JsxEmit,\n  ModuleKind,\n  ModuleResolutionKind,\n  NewLineKind,\n  ScriptTarget,\n  getJavaScriptWorker,\n  getTypeScriptWorker,\n  javascriptDefaults,\n  typescriptDefaults,\n  typescriptVersion2 as typescriptVersion\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as dom from '../../../../base/browser/dom.js';\nimport { Gesture } from '../../../../base/browser/touch.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport './lightBulbWidget.css';\nimport { computeIndentLevel } from '../../../common/model/utils.js';\nimport * as nls from '../../../../nls.js';\nimport { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';\nimport { editorBackground, editorLightBulbAutoFixForeground, editorLightBulbForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nvar LightBulbState;\n(function (LightBulbState) {\n    LightBulbState.Hidden = { type: 0 /* Type.Hidden */ };\n    class Showing {\n        constructor(actions, trigger, editorPosition, widgetPosition) {\n            this.actions = actions;\n            this.trigger = trigger;\n            this.editorPosition = editorPosition;\n            this.widgetPosition = widgetPosition;\n            this.type = 1 /* Type.Showing */;\n        }\n    }\n    LightBulbState.Showing = Showing;\n})(LightBulbState || (LightBulbState = {}));\nlet LightBulbWidget = class LightBulbWidget extends Disposable {\n    constructor(_editor, _quickFixActionId, _preferredFixActionId, _keybindingService) {\n        super();\n        this._editor = _editor;\n        this._quickFixActionId = _quickFixActionId;\n        this._preferredFixActionId = _preferredFixActionId;\n        this._keybindingService = _keybindingService;\n        this._onClick = this._register(new Emitter());\n        this.onClick = this._onClick.event;\n        this._state = LightBulbState.Hidden;\n        this._domNode = document.createElement('div');\n        this._domNode.className = Codicon.lightBulb.classNames;\n        this._editor.addContentWidget(this);\n        this._register(this._editor.onDidChangeModelContent(_ => {\n            // cancel when the line in question has been removed\n            const editorModel = this._editor.getModel();\n            if (this.state.type !== 1 /* LightBulbState.Type.Showing */ || !editorModel || this.state.editorPosition.lineNumber >= editorModel.getLineCount()) {\n                this.hide();\n            }\n        }));\n        Gesture.ignoreTarget(this._domNode);\n        this._register(dom.addStandardDisposableGenericMouseDownListener(this._domNode, e => {\n            if (this.state.type !== 1 /* LightBulbState.Type.Showing */) {\n                return;\n            }\n            // Make sure that focus / cursor location is not lost when clicking widget icon\n            this._editor.focus();\n            e.preventDefault();\n            // a bit of extra work to make sure the menu\n            // doesn't cover the line-text\n            const { top, height } = dom.getDomNodePagePosition(this._domNode);\n            const lineHeight = this._editor.getOption(61 /* EditorOption.lineHeight */);\n            let pad = Math.floor(lineHeight / 3);\n            if (this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber) {\n                pad += lineHeight;\n            }\n            this._onClick.fire({\n                x: e.posx,\n                y: top + height + pad,\n                actions: this.state.actions,\n                trigger: this.state.trigger,\n            });\n        }));\n        this._register(dom.addDisposableListener(this._domNode, 'mouseenter', (e) => {\n            if ((e.buttons & 1) !== 1) {\n                return;\n            }\n            // mouse enters lightbulb while the primary/left button\n            // is being pressed -> hide the lightbulb\n            this.hide();\n        }));\n        this._register(this._editor.onDidChangeConfiguration(e => {\n            // hide when told to do so\n            if (e.hasChanged(59 /* EditorOption.lightbulb */) && !this._editor.getOption(59 /* EditorOption.lightbulb */).enabled) {\n                this.hide();\n            }\n        }));\n        this._updateLightBulbTitleAndIcon();\n        this._register(this._keybindingService.onDidUpdateKeybindings(this._updateLightBulbTitleAndIcon, this));\n    }\n    dispose() {\n        super.dispose();\n        this._editor.removeContentWidget(this);\n    }\n    getId() {\n        return 'LightBulbWidget';\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    getPosition() {\n        return this._state.type === 1 /* LightBulbState.Type.Showing */ ? this._state.widgetPosition : null;\n    }\n    update(actions, trigger, atPosition) {\n        if (actions.validActions.length <= 0) {\n            return this.hide();\n        }\n        const options = this._editor.getOptions();\n        if (!options.get(59 /* EditorOption.lightbulb */).enabled) {\n            return this.hide();\n        }\n        const model = this._editor.getModel();\n        if (!model) {\n            return this.hide();\n        }\n        const { lineNumber, column } = model.validatePosition(atPosition);\n        const tabSize = model.getOptions().tabSize;\n        const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n        const lineContent = model.getLineContent(lineNumber);\n        const indent = computeIndentLevel(lineContent, tabSize);\n        const lineHasSpace = fontInfo.spaceWidth * indent > 22;\n        const isFolded = (lineNumber) => {\n            return lineNumber > 2 && this._editor.getTopForLineNumber(lineNumber) === this._editor.getTopForLineNumber(lineNumber - 1);\n        };\n        let effectiveLineNumber = lineNumber;\n        if (!lineHasSpace) {\n            if (lineNumber > 1 && !isFolded(lineNumber - 1)) {\n                effectiveLineNumber -= 1;\n            }\n            else if (!isFolded(lineNumber + 1)) {\n                effectiveLineNumber += 1;\n            }\n            else if (column * fontInfo.spaceWidth < 22) {\n                // cannot show lightbulb above/below and showing\n                // it inline would overlay the cursor...\n                return this.hide();\n            }\n        }\n        this.state = new LightBulbState.Showing(actions, trigger, atPosition, {\n            position: { lineNumber: effectiveLineNumber, column: 1 },\n            preference: LightBulbWidget._posPref\n        });\n        this._editor.layoutContentWidget(this);\n    }\n    hide() {\n        this.state = LightBulbState.Hidden;\n        this._editor.layoutContentWidget(this);\n    }\n    get state() { return this._state; }\n    set state(value) {\n        this._state = value;\n        this._updateLightBulbTitleAndIcon();\n    }\n    _updateLightBulbTitleAndIcon() {\n        if (this.state.type === 1 /* LightBulbState.Type.Showing */ && this.state.actions.hasAutoFix) {\n            // update icon\n            this._domNode.classList.remove(...Codicon.lightBulb.classNamesArray);\n            this._domNode.classList.add(...Codicon.lightbulbAutofix.classNamesArray);\n            const preferredKb = this._keybindingService.lookupKeybinding(this._preferredFixActionId);\n            if (preferredKb) {\n                this.title = nls.localize('preferredcodeActionWithKb', \"Show Code Actions. Preferred Quick Fix Available ({0})\", preferredKb.getLabel());\n                return;\n            }\n        }\n        // update icon\n        this._domNode.classList.remove(...Codicon.lightbulbAutofix.classNamesArray);\n        this._domNode.classList.add(...Codicon.lightBulb.classNamesArray);\n        const kb = this._keybindingService.lookupKeybinding(this._quickFixActionId);\n        if (kb) {\n            this.title = nls.localize('codeActionWithKb', \"Show Code Actions ({0})\", kb.getLabel());\n        }\n        else {\n            this.title = nls.localize('codeAction', \"Show Code Actions\");\n        }\n    }\n    set title(value) {\n        this._domNode.title = value;\n    }\n};\nLightBulbWidget._posPref = [0 /* ContentWidgetPositionPreference.EXACT */];\nLightBulbWidget = __decorate([\n    __param(3, IKeybindingService)\n], LightBulbWidget);\nexport { LightBulbWidget };\nregisterThemingParticipant((theme, collector) => {\n    var _a;\n    const editorBackgroundColor = (_a = theme.getColor(editorBackground)) === null || _a === void 0 ? void 0 : _a.transparent(0.7);\n    // Lightbulb Icon\n    const editorLightBulbForegroundColor = theme.getColor(editorLightBulbForeground);\n    if (editorLightBulbForegroundColor) {\n        collector.addRule(`\n\t\t.monaco-editor .contentWidgets ${Codicon.lightBulb.cssSelector} {\n\t\t\tcolor: ${editorLightBulbForegroundColor};\n\t\t\tbackground-color: ${editorBackgroundColor};\n\t\t}`);\n    }\n    // Lightbulb Auto Fix Icon\n    const editorLightBulbAutoFixForegroundColor = theme.getColor(editorLightBulbAutoFixForeground);\n    if (editorLightBulbAutoFixForegroundColor) {\n        collector.addRule(`\n\t\t.monaco-editor .contentWidgets ${Codicon.lightbulbAutofix.cssSelector} {\n\t\t\tcolor: ${editorLightBulbAutoFixForegroundColor};\n\t\t\tbackground-color: ${editorBackgroundColor};\n\t\t}`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CodeActionUi_disposed;\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { Lazy } from '../../../../base/common/lazy.js';\nimport { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { MessageController } from '../../message/browser/messageController.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { CodeActionMenu } from './codeActionMenu.js';\nimport { LightBulbWidget } from './lightBulbWidget.js';\nlet CodeActionUi = class CodeActionUi extends Disposable {\n    constructor(_editor, quickFixActionId, preferredFixActionId, delegate, instantiationService) {\n        super();\n        this._editor = _editor;\n        this.delegate = delegate;\n        this._activeCodeActions = this._register(new MutableDisposable());\n        this.previewOn = false;\n        _CodeActionUi_disposed.set(this, false);\n        this._codeActionWidget = new Lazy(() => {\n            return this._register(instantiationService.createInstance(CodeActionMenu, this._editor, {\n                onSelectCodeAction: (action, trigger) => __awaiter(this, void 0, void 0, function* () {\n                    if (this.previewOn) {\n                        this.delegate.applyCodeAction(action, /* retrigger */ true, Boolean(this.previewOn));\n                    }\n                    else {\n                        this.delegate.applyCodeAction(action, /* retrigger */ true, Boolean(trigger.preview));\n                    }\n                    this.previewOn = false;\n                })\n            }));\n        });\n        this._lightBulbWidget = new Lazy(() => {\n            const widget = this._register(instantiationService.createInstance(LightBulbWidget, this._editor, quickFixActionId, preferredFixActionId));\n            this._register(widget.onClick(e => this.showCodeActionList(e.trigger, e.actions, e, { includeDisabledActions: false, fromLightbulb: true })));\n            return widget;\n        });\n    }\n    dispose() {\n        __classPrivateFieldSet(this, _CodeActionUi_disposed, true, \"f\");\n        super.dispose();\n    }\n    hideCodeActionWidget() {\n        if (this._codeActionWidget.hasValue()) {\n            this._codeActionWidget.getValue().hideCodeActionWidget();\n        }\n    }\n    onEnter() {\n        if (this._codeActionWidget.hasValue()) {\n            this._codeActionWidget.getValue().onEnterSet();\n        }\n    }\n    onPreviewEnter() {\n        this.previewOn = true;\n        this.onEnter();\n    }\n    navigateList(navUp) {\n        if (this._codeActionWidget.hasValue()) {\n            if (navUp) {\n                this._codeActionWidget.getValue().navigateListWithKeysUp();\n            }\n            else {\n                this._codeActionWidget.getValue().navigateListWithKeysDown();\n            }\n        }\n    }\n    update(newState) {\n        var _a, _b, _c, _d, _e;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (newState.type !== 1 /* CodeActionsState.Type.Triggered */) {\n                (_a = this._lightBulbWidget.rawValue) === null || _a === void 0 ? void 0 : _a.hide();\n                return;\n            }\n            let actions;\n            try {\n                actions = yield newState.actions;\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return;\n            }\n            if (__classPrivateFieldGet(this, _CodeActionUi_disposed, \"f\")) {\n                return;\n            }\n            this._lightBulbWidget.getValue().update(actions, newState.trigger, newState.position);\n            if (newState.trigger.type === 1 /* CodeActionTriggerType.Invoke */) {\n                if ((_b = newState.trigger.filter) === null || _b === void 0 ? void 0 : _b.include) { // Triggered for specific scope\n                    // Check to see if we want to auto apply.\n                    const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions);\n                    if (validActionToApply) {\n                        try {\n                            this._lightBulbWidget.getValue().hide();\n                            yield this.delegate.applyCodeAction(validActionToApply, false, false);\n                        }\n                        finally {\n                            actions.dispose();\n                        }\n                        return;\n                    }\n                    // Check to see if there is an action that we would have applied were it not invalid\n                    if (newState.trigger.context) {\n                        const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions);\n                        if (invalidAction && invalidAction.action.disabled) {\n                            (_c = MessageController.get(this._editor)) === null || _c === void 0 ? void 0 : _c.showMessage(invalidAction.action.disabled, newState.trigger.context.position);\n                            actions.dispose();\n                            return;\n                        }\n                    }\n                }\n                const includeDisabledActions = !!((_d = newState.trigger.filter) === null || _d === void 0 ? void 0 : _d.include);\n                if (newState.trigger.context) {\n                    if (!actions.allActions.length || !includeDisabledActions && !actions.validActions.length) {\n                        (_e = MessageController.get(this._editor)) === null || _e === void 0 ? void 0 : _e.showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);\n                        this._activeCodeActions.value = actions;\n                        actions.dispose();\n                        return;\n                    }\n                }\n                this._activeCodeActions.value = actions;\n                this._codeActionWidget.getValue().show(newState.trigger, actions, newState.position, { includeDisabledActions, fromLightbulb: false });\n            }\n            else {\n                // auto magically triggered\n                if (this._codeActionWidget.getValue().isVisible) {\n                    // TODO: Figure out if we should update the showing menu?\n                    actions.dispose();\n                }\n                else {\n                    this._activeCodeActions.value = actions;\n                }\n            }\n        });\n    }\n    getInvalidActionThatWouldHaveBeenApplied(trigger, actions) {\n        if (!actions.allActions.length) {\n            return undefined;\n        }\n        if ((trigger.autoApply === \"first\" /* CodeActionAutoApply.First */ && actions.validActions.length === 0)\n            || (trigger.autoApply === \"ifSingle\" /* CodeActionAutoApply.IfSingle */ && actions.allActions.length === 1)) {\n            return actions.allActions.find(({ action }) => action.disabled);\n        }\n        return undefined;\n    }\n    tryGetValidActionToApply(trigger, actions) {\n        if (!actions.validActions.length) {\n            return undefined;\n        }\n        if ((trigger.autoApply === \"first\" /* CodeActionAutoApply.First */ && actions.validActions.length > 0)\n            || (trigger.autoApply === \"ifSingle\" /* CodeActionAutoApply.IfSingle */ && actions.validActions.length === 1)) {\n            return actions.validActions[0];\n        }\n        return undefined;\n    }\n    showCodeActionList(trigger, actions, at, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._codeActionWidget.getValue().show(trigger, actions, at, options);\n        });\n    }\n};\n_CodeActionUi_disposed = new WeakMap();\nCodeActionUi = __decorate([\n    __param(4, IInstantiationService)\n], CodeActionUi);\nexport { CodeActionUi };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createCancelablePromise, disposableTimeout, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { hash } from '../../../../base/common/hash.js';\nimport { DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { StableEditorScrollState } from '../../../browser/stableEditorScroll.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution } from '../../../browser/editorExtensions.js';\nimport { EDITOR_FONT_DEFAULTS } from '../../../common/config/editorOptions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { getCodeLensModel } from './codelens.js';\nimport { ICodeLensCache } from './codeLensCache.js';\nimport { CodeLensHelper, CodeLensWidget } from './codelensWidget.js';\nimport { localize } from '../../../../nls.js';\nimport { ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nlet CodeLensContribution = class CodeLensContribution {\n    constructor(_editor, _languageFeaturesService, debounceService, _commandService, _notificationService, _codeLensCache) {\n        this._editor = _editor;\n        this._languageFeaturesService = _languageFeaturesService;\n        this._commandService = _commandService;\n        this._notificationService = _notificationService;\n        this._codeLensCache = _codeLensCache;\n        this._disposables = new DisposableStore();\n        this._localToDispose = new DisposableStore();\n        this._lenses = [];\n        this._oldCodeLensModels = new DisposableStore();\n        this._provideCodeLensDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, 'CodeLensProvide', { min: 250 });\n        this._resolveCodeLensesDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, 'CodeLensResolve', { min: 250, salt: 'resolve' });\n        this._resolveCodeLensesScheduler = new RunOnceScheduler(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDebounce.default());\n        this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange()));\n        this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));\n        this._disposables.add(this._editor.onDidChangeConfiguration((e) => {\n            if (e.hasChanged(46 /* EditorOption.fontInfo */) || e.hasChanged(16 /* EditorOption.codeLensFontSize */) || e.hasChanged(15 /* EditorOption.codeLensFontFamily */)) {\n                this._updateLensStyle();\n            }\n            if (e.hasChanged(14 /* EditorOption.codeLens */)) {\n                this._onModelChange();\n            }\n        }));\n        this._disposables.add(_languageFeaturesService.codeLensProvider.onDidChange(this._onModelChange, this));\n        this._onModelChange();\n        this._styleClassName = '_' + hash(this._editor.getId()).toString(16);\n        this._styleElement = dom.createStyleSheet(dom.isInShadowDOM(this._editor.getContainerDomNode())\n            ? this._editor.getContainerDomNode()\n            : undefined);\n        this._updateLensStyle();\n    }\n    dispose() {\n        var _a;\n        this._localDispose();\n        this._disposables.dispose();\n        this._oldCodeLensModels.dispose();\n        (_a = this._currentCodeLensModel) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._styleElement.remove();\n    }\n    _getLayoutInfo() {\n        const lineHeightFactor = Math.max(1.3, this._editor.getOption(61 /* EditorOption.lineHeight */) / this._editor.getOption(48 /* EditorOption.fontSize */));\n        let fontSize = this._editor.getOption(16 /* EditorOption.codeLensFontSize */);\n        if (!fontSize || fontSize < 5) {\n            fontSize = (this._editor.getOption(48 /* EditorOption.fontSize */) * .9) | 0;\n        }\n        return {\n            fontSize,\n            codeLensHeight: (fontSize * lineHeightFactor) | 0,\n        };\n    }\n    _updateLensStyle() {\n        const { codeLensHeight, fontSize } = this._getLayoutInfo();\n        const fontFamily = this._editor.getOption(15 /* EditorOption.codeLensFontFamily */);\n        const editorFontInfo = this._editor.getOption(46 /* EditorOption.fontInfo */);\n        const fontFamilyVar = `--codelens-font-family${this._styleClassName}`;\n        const fontFeaturesVar = `--codelens-font-features${this._styleClassName}`;\n        let newStyle = `\n\t\t.monaco-editor .codelens-decoration.${this._styleClassName} { line-height: ${codeLensHeight}px; font-size: ${fontSize}px; padding-right: ${Math.round(fontSize * 0.5)}px; font-feature-settings: var(${fontFeaturesVar}) }\n\t\t.monaco-editor .codelens-decoration.${this._styleClassName} span.codicon { line-height: ${codeLensHeight}px; font-size: ${fontSize}px; }\n\t\t`;\n        if (fontFamily) {\n            newStyle += `.monaco-editor .codelens-decoration.${this._styleClassName} { font-family: var(${fontFamilyVar}), ${EDITOR_FONT_DEFAULTS.fontFamily}}`;\n        }\n        this._styleElement.textContent = newStyle;\n        this._editor.getContainerDomNode().style.setProperty(fontFamilyVar, fontFamily !== null && fontFamily !== void 0 ? fontFamily : 'inherit');\n        this._editor.getContainerDomNode().style.setProperty(fontFeaturesVar, editorFontInfo.fontFeatureSettings);\n        //\n        this._editor.changeViewZones(accessor => {\n            for (const lens of this._lenses) {\n                lens.updateHeight(codeLensHeight, accessor);\n            }\n        });\n    }\n    _localDispose() {\n        var _a, _b, _c;\n        (_a = this._getCodeLensModelPromise) === null || _a === void 0 ? void 0 : _a.cancel();\n        this._getCodeLensModelPromise = undefined;\n        (_b = this._resolveCodeLensesPromise) === null || _b === void 0 ? void 0 : _b.cancel();\n        this._resolveCodeLensesPromise = undefined;\n        this._localToDispose.clear();\n        this._oldCodeLensModels.clear();\n        (_c = this._currentCodeLensModel) === null || _c === void 0 ? void 0 : _c.dispose();\n    }\n    _onModelChange() {\n        this._localDispose();\n        const model = this._editor.getModel();\n        if (!model) {\n            return;\n        }\n        if (!this._editor.getOption(14 /* EditorOption.codeLens */)) {\n            return;\n        }\n        const cachedLenses = this._codeLensCache.get(model);\n        if (cachedLenses) {\n            this._renderCodeLensSymbols(cachedLenses);\n        }\n        if (!this._languageFeaturesService.codeLensProvider.has(model)) {\n            // no provider -> return but check with\n            // cached lenses. they expire after 30 seconds\n            if (cachedLenses) {\n                this._localToDispose.add(disposableTimeout(() => {\n                    const cachedLensesNow = this._codeLensCache.get(model);\n                    if (cachedLenses === cachedLensesNow) {\n                        this._codeLensCache.delete(model);\n                        this._onModelChange();\n                    }\n                }, 30 * 1000));\n            }\n            return;\n        }\n        for (const provider of this._languageFeaturesService.codeLensProvider.all(model)) {\n            if (typeof provider.onDidChange === 'function') {\n                const registration = provider.onDidChange(() => scheduler.schedule());\n                this._localToDispose.add(registration);\n            }\n        }\n        const scheduler = new RunOnceScheduler(() => {\n            var _a;\n            const t1 = Date.now();\n            (_a = this._getCodeLensModelPromise) === null || _a === void 0 ? void 0 : _a.cancel();\n            this._getCodeLensModelPromise = createCancelablePromise(token => getCodeLensModel(this._languageFeaturesService.codeLensProvider, model, token));\n            this._getCodeLensModelPromise.then(result => {\n                if (this._currentCodeLensModel) {\n                    this._oldCodeLensModels.add(this._currentCodeLensModel);\n                }\n                this._currentCodeLensModel = result;\n                // cache model to reduce flicker\n                this._codeLensCache.put(model, result);\n                // update moving average\n                const newDelay = this._provideCodeLensDebounce.update(model, Date.now() - t1);\n                scheduler.delay = newDelay;\n                // render lenses\n                this._renderCodeLensSymbols(result);\n                // dom.scheduleAtNextAnimationFrame(() => this._resolveCodeLensesInViewport());\n                this._resolveCodeLensesInViewportSoon();\n            }, onUnexpectedError);\n        }, this._provideCodeLensDebounce.get(model));\n        this._localToDispose.add(scheduler);\n        this._localToDispose.add(toDisposable(() => this._resolveCodeLensesScheduler.cancel()));\n        this._localToDispose.add(this._editor.onDidChangeModelContent(() => {\n            this._editor.changeDecorations(decorationsAccessor => {\n                this._editor.changeViewZones(viewZonesAccessor => {\n                    const toDispose = [];\n                    let lastLensLineNumber = -1;\n                    this._lenses.forEach((lens) => {\n                        if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {\n                            // invalid -> lens collapsed, attach range doesn't exist anymore\n                            // line_number -> lenses should never be on the same line\n                            toDispose.push(lens);\n                        }\n                        else {\n                            lens.update(viewZonesAccessor);\n                            lastLensLineNumber = lens.getLineNumber();\n                        }\n                    });\n                    const helper = new CodeLensHelper();\n                    toDispose.forEach((l) => {\n                        l.dispose(helper, viewZonesAccessor);\n                        this._lenses.splice(this._lenses.indexOf(l), 1);\n                    });\n                    helper.commit(decorationsAccessor);\n                });\n            });\n            // Ask for all references again\n            scheduler.schedule();\n        }));\n        this._localToDispose.add(this._editor.onDidFocusEditorWidget(() => {\n            scheduler.schedule();\n        }));\n        this._localToDispose.add(this._editor.onDidScrollChange(e => {\n            if (e.scrollTopChanged && this._lenses.length > 0) {\n                this._resolveCodeLensesInViewportSoon();\n            }\n        }));\n        this._localToDispose.add(this._editor.onDidLayoutChange(() => {\n            this._resolveCodeLensesInViewportSoon();\n        }));\n        this._localToDispose.add(toDisposable(() => {\n            if (this._editor.getModel()) {\n                const scrollState = StableEditorScrollState.capture(this._editor);\n                this._editor.changeDecorations(decorationsAccessor => {\n                    this._editor.changeViewZones(viewZonesAccessor => {\n                        this._disposeAllLenses(decorationsAccessor, viewZonesAccessor);\n                    });\n                });\n                scrollState.restore(this._editor);\n            }\n            else {\n                // No accessors available\n                this._disposeAllLenses(undefined, undefined);\n            }\n        }));\n        this._localToDispose.add(this._editor.onMouseDown(e => {\n            if (e.target.type !== 9 /* MouseTargetType.CONTENT_WIDGET */) {\n                return;\n            }\n            let target = e.target.element;\n            if ((target === null || target === void 0 ? void 0 : target.tagName) === 'SPAN') {\n                target = target.parentElement;\n            }\n            if ((target === null || target === void 0 ? void 0 : target.tagName) === 'A') {\n                for (const lens of this._lenses) {\n                    const command = lens.getCommand(target);\n                    if (command) {\n                        this._commandService.executeCommand(command.id, ...(command.arguments || [])).catch(err => this._notificationService.error(err));\n                        break;\n                    }\n                }\n            }\n        }));\n        scheduler.schedule();\n    }\n    _disposeAllLenses(decChangeAccessor, viewZoneChangeAccessor) {\n        const helper = new CodeLensHelper();\n        for (const lens of this._lenses) {\n            lens.dispose(helper, viewZoneChangeAccessor);\n        }\n        if (decChangeAccessor) {\n            helper.commit(decChangeAccessor);\n        }\n        this._lenses.length = 0;\n    }\n    _renderCodeLensSymbols(symbols) {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        const maxLineNumber = this._editor.getModel().getLineCount();\n        const groups = [];\n        let lastGroup;\n        for (const symbol of symbols.lenses) {\n            const line = symbol.symbol.range.startLineNumber;\n            if (line < 1 || line > maxLineNumber) {\n                // invalid code lens\n                continue;\n            }\n            else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {\n                // on same line as previous\n                lastGroup.push(symbol);\n            }\n            else {\n                // on later line as previous\n                lastGroup = [symbol];\n                groups.push(lastGroup);\n            }\n        }\n        const scrollState = StableEditorScrollState.capture(this._editor);\n        const layoutInfo = this._getLayoutInfo();\n        this._editor.changeDecorations(decorationsAccessor => {\n            this._editor.changeViewZones(viewZoneAccessor => {\n                const helper = new CodeLensHelper();\n                let codeLensIndex = 0;\n                let groupsIndex = 0;\n                while (groupsIndex < groups.length && codeLensIndex < this._lenses.length) {\n                    const symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;\n                    const codeLensLineNumber = this._lenses[codeLensIndex].getLineNumber();\n                    if (codeLensLineNumber < symbolsLineNumber) {\n                        this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);\n                        this._lenses.splice(codeLensIndex, 1);\n                    }\n                    else if (codeLensLineNumber === symbolsLineNumber) {\n                        this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);\n                        groupsIndex++;\n                        codeLensIndex++;\n                    }\n                    else {\n                        this._lenses.splice(codeLensIndex, 0, new CodeLensWidget(groups[groupsIndex], this._editor, this._styleClassName, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));\n                        codeLensIndex++;\n                        groupsIndex++;\n                    }\n                }\n                // Delete extra code lenses\n                while (codeLensIndex < this._lenses.length) {\n                    this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);\n                    this._lenses.splice(codeLensIndex, 1);\n                }\n                // Create extra symbols\n                while (groupsIndex < groups.length) {\n                    this._lenses.push(new CodeLensWidget(groups[groupsIndex], this._editor, this._styleClassName, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));\n                    groupsIndex++;\n                }\n                helper.commit(decorationsAccessor);\n            });\n        });\n        scrollState.restore(this._editor);\n    }\n    _resolveCodeLensesInViewportSoon() {\n        const model = this._editor.getModel();\n        if (model) {\n            this._resolveCodeLensesScheduler.schedule();\n        }\n    }\n    _resolveCodeLensesInViewport() {\n        var _a;\n        (_a = this._resolveCodeLensesPromise) === null || _a === void 0 ? void 0 : _a.cancel();\n        this._resolveCodeLensesPromise = undefined;\n        const model = this._editor.getModel();\n        if (!model) {\n            return;\n        }\n        const toResolve = [];\n        const lenses = [];\n        this._lenses.forEach((lens) => {\n            const request = lens.computeIfNecessary(model);\n            if (request) {\n                toResolve.push(request);\n                lenses.push(lens);\n            }\n        });\n        if (toResolve.length === 0) {\n            return;\n        }\n        const t1 = Date.now();\n        const resolvePromise = createCancelablePromise(token => {\n            const promises = toResolve.map((request, i) => {\n                const resolvedSymbols = new Array(request.length);\n                const promises = request.map((request, i) => {\n                    if (!request.symbol.command && typeof request.provider.resolveCodeLens === 'function') {\n                        return Promise.resolve(request.provider.resolveCodeLens(model, request.symbol, token)).then(symbol => {\n                            resolvedSymbols[i] = symbol;\n                        }, onUnexpectedExternalError);\n                    }\n                    else {\n                        resolvedSymbols[i] = request.symbol;\n                        return Promise.resolve(undefined);\n                    }\n                });\n                return Promise.all(promises).then(() => {\n                    if (!token.isCancellationRequested && !lenses[i].isDisposed()) {\n                        lenses[i].updateCommands(resolvedSymbols);\n                    }\n                });\n            });\n            return Promise.all(promises);\n        });\n        this._resolveCodeLensesPromise = resolvePromise;\n        this._resolveCodeLensesPromise.then(() => {\n            // update moving average\n            const newDelay = this._resolveCodeLensesDebounce.update(model, Date.now() - t1);\n            this._resolveCodeLensesScheduler.delay = newDelay;\n            if (this._currentCodeLensModel) { // update the cached state with new resolved items\n                this._codeLensCache.put(model, this._currentCodeLensModel);\n            }\n            this._oldCodeLensModels.clear(); // dispose old models once we have updated the UI with the current model\n            if (resolvePromise === this._resolveCodeLensesPromise) {\n                this._resolveCodeLensesPromise = undefined;\n            }\n        }, err => {\n            onUnexpectedError(err); // can also be cancellation!\n            if (resolvePromise === this._resolveCodeLensesPromise) {\n                this._resolveCodeLensesPromise = undefined;\n            }\n        });\n    }\n    getModel() {\n        return this._currentCodeLensModel;\n    }\n};\nCodeLensContribution.ID = 'css.editor.codeLens';\nCodeLensContribution = __decorate([\n    __param(1, ILanguageFeaturesService),\n    __param(2, ILanguageFeatureDebounceService),\n    __param(3, ICommandService),\n    __param(4, INotificationService),\n    __param(5, ICodeLensCache)\n], CodeLensContribution);\nexport { CodeLensContribution };\nregisterEditorContribution(CodeLensContribution.ID, CodeLensContribution);\nregisterEditorAction(class ShowLensesInCurrentLine extends EditorAction {\n    constructor() {\n        super({\n            id: 'codelens.showLensesInCurrentLine',\n            precondition: EditorContextKeys.hasCodeLensProvider,\n            label: localize('showLensOnLine', \"Show CodeLens Commands For Current Line\"),\n            alias: 'Show CodeLens Commands For Current Line',\n        });\n    }\n    run(accessor, editor) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!editor.hasModel()) {\n                return;\n            }\n            const quickInputService = accessor.get(IQuickInputService);\n            const commandService = accessor.get(ICommandService);\n            const notificationService = accessor.get(INotificationService);\n            const lineNumber = editor.getSelection().positionLineNumber;\n            const codelensController = editor.getContribution(CodeLensContribution.ID);\n            if (!codelensController) {\n                return;\n            }\n            const model = codelensController.getModel();\n            if (!model) {\n                // nothing\n                return;\n            }\n            const items = [];\n            for (const lens of model.lenses) {\n                if (lens.symbol.command && lens.symbol.range.startLineNumber === lineNumber) {\n                    items.push({\n                        label: lens.symbol.command.title,\n                        command: lens.symbol.command\n                    });\n                }\n            }\n            if (items.length === 0) {\n                // We dont want an empty picker\n                return;\n            }\n            const item = yield quickInputService.pick(items, { canPickMany: false });\n            if (!item) {\n                // Nothing picked\n                return;\n            }\n            if (model.isDisposed) {\n                // retry whenever the model has been disposed\n                return yield commandService.executeCommand(this.id);\n            }\n            try {\n                yield commandService.executeCommand(item.command.id, ...(item.command.arguments || []));\n            }\n            catch (err) {\n                notificationService.error(err);\n            }\n        });\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { $, addDisposableListener, append, asCSSUrl, EventType, ModifierKeyEmitter, prepend } from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { ActionViewItem, BaseActionViewItem } from '../../../base/browser/ui/actionbar/actionViewItems.js';\nimport { DropdownMenuActionViewItem } from '../../../base/browser/ui/dropdown/dropdownActionViewItem.js';\nimport { ActionRunner, Separator, SubmenuAction } from '../../../base/common/actions.js';\nimport { UILabelProvider } from '../../../base/common/keybindingLabels.js';\nimport { combinedDisposable, DisposableStore, MutableDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { isLinux, isWindows, OS } from '../../../base/common/platform.js';\nimport './menuEntryActionViewItem.css';\nimport { localize } from '../../../nls.js';\nimport { IMenuService, MenuItemAction, SubmenuItemAction } from '../common/actions.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport { IContextMenuService } from '../../contextview/browser/contextView.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IStorageService } from '../../storage/common/storage.js';\nimport { IThemeService, ThemeIcon } from '../../theme/common/themeService.js';\nimport { isDark } from '../../theme/common/theme.js';\nimport { assertType } from '../../../base/common/types.js';\nexport function createAndFillInActionBarActions(menu, options, target, primaryGroup, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions) {\n    const groups = menu.getActions(options);\n    const isPrimaryAction = typeof primaryGroup === 'string' ? (actionGroup) => actionGroup === primaryGroup : primaryGroup;\n    // Action bars handle alternative actions on their own so the alternative actions should be ignored\n    fillInActions(groups, target, false, isPrimaryAction, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions);\n    return asDisposable(groups);\n}\nfunction asDisposable(groups) {\n    const disposables = new DisposableStore();\n    for (const [, actions] of groups) {\n        for (const action of actions) {\n            disposables.add(action);\n        }\n    }\n    return disposables;\n}\nfunction fillInActions(groups, target, useAlternativeActions, isPrimaryAction = actionGroup => actionGroup === 'navigation', primaryMaxCount = Number.MAX_SAFE_INTEGER, shouldInlineSubmenu = () => false, useSeparatorsInPrimaryActions = false) {\n    let primaryBucket;\n    let secondaryBucket;\n    if (Array.isArray(target)) {\n        primaryBucket = target;\n        secondaryBucket = target;\n    }\n    else {\n        primaryBucket = target.primary;\n        secondaryBucket = target.secondary;\n    }\n    const submenuInfo = new Set();\n    for (const [group, actions] of groups) {\n        let target;\n        if (isPrimaryAction(group)) {\n            target = primaryBucket;\n            if (target.length > 0 && useSeparatorsInPrimaryActions) {\n                target.push(new Separator());\n            }\n        }\n        else {\n            target = secondaryBucket;\n            if (target.length > 0) {\n                target.push(new Separator());\n            }\n        }\n        for (let action of actions) {\n            if (useAlternativeActions) {\n                action = action instanceof MenuItemAction && action.alt ? action.alt : action;\n            }\n            const newLen = target.push(action);\n            // keep submenu info for later inlining\n            if (action instanceof SubmenuAction) {\n                submenuInfo.add({ group, action, index: newLen - 1 });\n            }\n        }\n    }\n    // ask the outside if submenu should be inlined or not. only ask when\n    // there would be enough space\n    for (const { group, action, index } of submenuInfo) {\n        const target = isPrimaryAction(group) ? primaryBucket : secondaryBucket;\n        // inlining submenus with length 0 or 1 is easy,\n        // larger submenus need to be checked with the overall limit\n        const submenuActions = action.actions;\n        if ((submenuActions.length <= 1 || target.length + submenuActions.length - 2 <= primaryMaxCount) && shouldInlineSubmenu(action, group, target.length)) {\n            target.splice(index, 1, ...submenuActions);\n        }\n    }\n    // overflow items from the primary group into the secondary bucket\n    if (primaryBucket !== secondaryBucket && primaryBucket.length > primaryMaxCount) {\n        const overflow = primaryBucket.splice(primaryMaxCount, primaryBucket.length - primaryMaxCount);\n        secondaryBucket.unshift(...overflow, new Separator());\n    }\n}\nlet MenuEntryActionViewItem = class MenuEntryActionViewItem extends ActionViewItem {\n    constructor(action, options, _keybindingService, _notificationService, _contextKeyService, _themeService, _contextMenuService) {\n        super(undefined, action, { icon: !!(action.class || action.item.icon), label: !action.class && !action.item.icon, draggable: options === null || options === void 0 ? void 0 : options.draggable, keybinding: options === null || options === void 0 ? void 0 : options.keybinding, hoverDelegate: options === null || options === void 0 ? void 0 : options.hoverDelegate });\n        this._keybindingService = _keybindingService;\n        this._notificationService = _notificationService;\n        this._contextKeyService = _contextKeyService;\n        this._themeService = _themeService;\n        this._contextMenuService = _contextMenuService;\n        this._wantsAltCommand = false;\n        this._itemClassDispose = this._register(new MutableDisposable());\n        this._altKey = ModifierKeyEmitter.getInstance();\n    }\n    get _menuItemAction() {\n        return this._action;\n    }\n    get _commandAction() {\n        return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;\n    }\n    onClick(event) {\n        return __awaiter(this, void 0, void 0, function* () {\n            event.preventDefault();\n            event.stopPropagation();\n            try {\n                yield this.actionRunner.run(this._commandAction, this._context);\n            }\n            catch (err) {\n                this._notificationService.error(err);\n            }\n        });\n    }\n    render(container) {\n        super.render(container);\n        container.classList.add('menu-entry');\n        this._updateItemClass(this._menuItemAction.item);\n        let mouseOver = false;\n        let alternativeKeyDown = this._altKey.keyStatus.altKey || ((isWindows || isLinux) && this._altKey.keyStatus.shiftKey);\n        const updateAltState = () => {\n            var _a;\n            const wantsAltCommand = mouseOver && alternativeKeyDown && !!((_a = this._commandAction.alt) === null || _a === void 0 ? void 0 : _a.enabled);\n            if (wantsAltCommand !== this._wantsAltCommand) {\n                this._wantsAltCommand = wantsAltCommand;\n                this.updateLabel();\n                this.updateTooltip();\n                this.updateClass();\n            }\n        };\n        if (this._menuItemAction.alt) {\n            this._register(this._altKey.event(value => {\n                alternativeKeyDown = value.altKey || ((isWindows || isLinux) && value.shiftKey);\n                updateAltState();\n            }));\n        }\n        this._register(addDisposableListener(container, 'mouseleave', _ => {\n            mouseOver = false;\n            updateAltState();\n        }));\n        this._register(addDisposableListener(container, 'mouseenter', _ => {\n            mouseOver = true;\n            updateAltState();\n        }));\n    }\n    updateLabel() {\n        if (this.options.label && this.label) {\n            this.label.textContent = this._commandAction.label;\n        }\n    }\n    getTooltip() {\n        var _a;\n        const keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService);\n        const keybindingLabel = keybinding && keybinding.getLabel();\n        const tooltip = this._commandAction.tooltip || this._commandAction.label;\n        let title = keybindingLabel\n            ? localize('titleAndKb', \"{0} ({1})\", tooltip, keybindingLabel)\n            : tooltip;\n        if (!this._wantsAltCommand && ((_a = this._menuItemAction.alt) === null || _a === void 0 ? void 0 : _a.enabled)) {\n            const altTooltip = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label;\n            const altKeybinding = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService);\n            const altKeybindingLabel = altKeybinding && altKeybinding.getLabel();\n            const altTitleSection = altKeybindingLabel\n                ? localize('titleAndKb', \"{0} ({1})\", altTooltip, altKeybindingLabel)\n                : altTooltip;\n            title = localize('titleAndKbAndAlt', \"{0}\\n[{1}] {2}\", title, UILabelProvider.modifierLabels[OS].altKey, altTitleSection);\n        }\n        return title;\n    }\n    updateClass() {\n        if (this.options.icon) {\n            if (this._commandAction !== this._menuItemAction) {\n                if (this._menuItemAction.alt) {\n                    this._updateItemClass(this._menuItemAction.alt.item);\n                }\n            }\n            else {\n                this._updateItemClass(this._menuItemAction.item);\n            }\n        }\n    }\n    _updateItemClass(item) {\n        var _a;\n        this._itemClassDispose.value = undefined;\n        const { element, label } = this;\n        if (!element || !label) {\n            return;\n        }\n        const icon = this._commandAction.checked && ((_a = item.toggled) === null || _a === void 0 ? void 0 : _a.icon) ? item.toggled.icon : item.icon;\n        if (!icon) {\n            return;\n        }\n        if (ThemeIcon.isThemeIcon(icon)) {\n            // theme icons\n            const iconClasses = ThemeIcon.asClassNameArray(icon);\n            label.classList.add(...iconClasses);\n            this._itemClassDispose.value = toDisposable(() => {\n                label.classList.remove(...iconClasses);\n            });\n        }\n        else {\n            // icon path/url\n            label.style.backgroundImage = (isDark(this._themeService.getColorTheme().type)\n                ? asCSSUrl(icon.dark)\n                : asCSSUrl(icon.light));\n            label.classList.add('icon');\n            this._itemClassDispose.value = combinedDisposable(toDisposable(() => {\n                label.style.backgroundImage = '';\n                label.classList.remove('icon');\n            }), this._themeService.onDidColorThemeChange(() => {\n                // refresh when the theme changes in case we go between dark <-> light\n                this.updateClass();\n            }));\n        }\n    }\n};\nMenuEntryActionViewItem = __decorate([\n    __param(2, IKeybindingService),\n    __param(3, INotificationService),\n    __param(4, IContextKeyService),\n    __param(5, IThemeService),\n    __param(6, IContextMenuService)\n], MenuEntryActionViewItem);\nexport { MenuEntryActionViewItem };\nlet SubmenuEntryActionViewItem = class SubmenuEntryActionViewItem extends DropdownMenuActionViewItem {\n    constructor(action, options, _contextMenuService, _themeService) {\n        var _a, _b;\n        const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : Object.create(null), {\n            menuAsChild: (_a = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a !== void 0 ? _a : false,\n            classNames: (_b = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b !== void 0 ? _b : (ThemeIcon.isThemeIcon(action.item.icon) ? ThemeIcon.asClassName(action.item.icon) : undefined),\n        });\n        super(action, { getActions: () => action.actions }, _contextMenuService, dropdownOptions);\n        this._contextMenuService = _contextMenuService;\n        this._themeService = _themeService;\n    }\n    render(container) {\n        super.render(container);\n        assertType(this.element);\n        container.classList.add('menu-entry');\n        const action = this._action;\n        const { icon } = action.item;\n        if (icon && !ThemeIcon.isThemeIcon(icon)) {\n            this.element.classList.add('icon');\n            const setBackgroundImage = () => {\n                if (this.element) {\n                    this.element.style.backgroundImage = (isDark(this._themeService.getColorTheme().type)\n                        ? asCSSUrl(icon.dark)\n                        : asCSSUrl(icon.light));\n                }\n            };\n            setBackgroundImage();\n            this._register(this._themeService.onDidColorThemeChange(() => {\n                // refresh when the theme changes in case we go between dark <-> light\n                setBackgroundImage();\n            }));\n        }\n    }\n};\nSubmenuEntryActionViewItem = __decorate([\n    __param(2, IContextMenuService),\n    __param(3, IThemeService)\n], SubmenuEntryActionViewItem);\nexport { SubmenuEntryActionViewItem };\nlet DropdownWithDefaultActionViewItem = class DropdownWithDefaultActionViewItem extends BaseActionViewItem {\n    constructor(submenuAction, options, _keybindingService, _notificationService, _contextMenuService, _menuService, _instaService, _storageService) {\n        var _a, _b, _c;\n        super(null, submenuAction);\n        this._keybindingService = _keybindingService;\n        this._notificationService = _notificationService;\n        this._contextMenuService = _contextMenuService;\n        this._menuService = _menuService;\n        this._instaService = _instaService;\n        this._storageService = _storageService;\n        this._container = null;\n        this._options = options;\n        this._storageKey = `${submenuAction.item.submenu.id}_lastActionId`;\n        // determine default action\n        let defaultAction;\n        const defaultActionId = _storageService.get(this._storageKey, 1 /* StorageScope.WORKSPACE */);\n        if (defaultActionId) {\n            defaultAction = submenuAction.actions.find(a => defaultActionId === a.id);\n        }\n        if (!defaultAction) {\n            defaultAction = submenuAction.actions[0];\n        }\n        this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, defaultAction, { keybinding: this._getDefaultActionKeybindingLabel(defaultAction) });\n        const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : Object.create(null), {\n            menuAsChild: (_a = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a !== void 0 ? _a : true,\n            classNames: (_b = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b !== void 0 ? _b : ['codicon', 'codicon-chevron-down'],\n            actionRunner: (_c = options === null || options === void 0 ? void 0 : options.actionRunner) !== null && _c !== void 0 ? _c : new ActionRunner()\n        });\n        this._dropdown = new DropdownMenuActionViewItem(submenuAction, submenuAction.actions, this._contextMenuService, dropdownOptions);\n        this._dropdown.actionRunner.onDidRun((e) => {\n            if (e.action instanceof MenuItemAction) {\n                this.update(e.action);\n            }\n        });\n    }\n    update(lastAction) {\n        this._storageService.store(this._storageKey, lastAction.id, 1 /* StorageScope.WORKSPACE */, 0 /* StorageTarget.USER */);\n        this._defaultAction.dispose();\n        this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, lastAction, { keybinding: this._getDefaultActionKeybindingLabel(lastAction) });\n        this._defaultAction.actionRunner = new class extends ActionRunner {\n            runAction(action, context) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    yield action.run(undefined);\n                });\n            }\n        }();\n        if (this._container) {\n            this._defaultAction.render(prepend(this._container, $('.action-container')));\n        }\n    }\n    _getDefaultActionKeybindingLabel(defaultAction) {\n        var _a;\n        let defaultActionKeybinding;\n        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.renderKeybindingWithDefaultActionLabel) {\n            const kb = this._keybindingService.lookupKeybinding(defaultAction.id);\n            if (kb) {\n                defaultActionKeybinding = `(${kb.getLabel()})`;\n            }\n        }\n        return defaultActionKeybinding;\n    }\n    setActionContext(newContext) {\n        super.setActionContext(newContext);\n        this._defaultAction.setActionContext(newContext);\n        this._dropdown.setActionContext(newContext);\n    }\n    render(container) {\n        this._container = container;\n        super.render(this._container);\n        this._container.classList.add('monaco-dropdown-with-default');\n        const primaryContainer = $('.action-container');\n        this._defaultAction.render(append(this._container, primaryContainer));\n        this._register(addDisposableListener(primaryContainer, EventType.KEY_DOWN, (e) => {\n            const event = new StandardKeyboardEvent(e);\n            if (event.equals(17 /* KeyCode.RightArrow */)) {\n                this._defaultAction.element.tabIndex = -1;\n                this._dropdown.focus();\n                event.stopPropagation();\n            }\n        }));\n        const dropdownContainer = $('.dropdown-action-container');\n        this._dropdown.render(append(this._container, dropdownContainer));\n        this._register(addDisposableListener(dropdownContainer, EventType.KEY_DOWN, (e) => {\n            var _a;\n            const event = new StandardKeyboardEvent(e);\n            if (event.equals(15 /* KeyCode.LeftArrow */)) {\n                this._defaultAction.element.tabIndex = 0;\n                this._dropdown.setFocusable(false);\n                (_a = this._defaultAction.element) === null || _a === void 0 ? void 0 : _a.focus();\n                event.stopPropagation();\n            }\n        }));\n    }\n    focus(fromRight) {\n        if (fromRight) {\n            this._dropdown.focus();\n        }\n        else {\n            this._defaultAction.element.tabIndex = 0;\n            this._defaultAction.element.focus();\n        }\n    }\n    blur() {\n        this._defaultAction.element.tabIndex = -1;\n        this._dropdown.blur();\n        this._container.blur();\n    }\n    setFocusable(focusable) {\n        if (focusable) {\n            this._defaultAction.element.tabIndex = 0;\n        }\n        else {\n            this._defaultAction.element.tabIndex = -1;\n            this._dropdown.setFocusable(false);\n        }\n    }\n    dispose() {\n        this._defaultAction.dispose();\n        this._dropdown.dispose();\n        super.dispose();\n    }\n};\nDropdownWithDefaultActionViewItem = __decorate([\n    __param(2, IKeybindingService),\n    __param(3, INotificationService),\n    __param(4, IContextMenuService),\n    __param(5, IMenuService),\n    __param(6, IInstantiationService),\n    __param(7, IStorageService)\n], DropdownWithDefaultActionViewItem);\nexport { DropdownWithDefaultActionViewItem };\n/**\n * Creates action view items for menu actions or submenu actions.\n */\nexport function createActionViewItem(instaService, action, options) {\n    if (action instanceof MenuItemAction) {\n        return instaService.createInstance(MenuEntryActionViewItem, action, options);\n    }\n    else if (action instanceof SubmenuItemAction) {\n        if (action.item.rememberDefaultAction) {\n            return instaService.createInstance(DropdownWithDefaultActionViewItem, action, options);\n        }\n        else {\n            return instaService.createInstance(SubmenuEntryActionViewItem, action, options);\n        }\n    }\n    else {\n        return undefined;\n    }\n}\n","/**\n * marked - a markdown parser\n * Copyright (c) 2011-2022, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n// ESM-uncomment-begin\nlet __marked_exports = {};\n(function() {\n  function define(deps, factory) {\n    factory(__marked_exports);\n  }\n  define.amd = true;\n// ESM-uncomment-end\n\n (function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));\n})(this, (function (exports) { 'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function getDefaults() {\n    return {\n      baseUrl: null,\n      breaks: false,\n      extensions: null,\n      gfm: true,\n      headerIds: true,\n      headerPrefix: '',\n      highlight: null,\n      langPrefix: 'language-',\n      mangle: true,\n      pedantic: false,\n      renderer: null,\n      sanitize: false,\n      sanitizer: null,\n      silent: false,\n      smartLists: false,\n      smartypants: false,\n      tokenizer: null,\n      walkTokens: null,\n      xhtml: false\n    };\n  }\n  exports.defaults = getDefaults();\n  function changeDefaults(newDefaults) {\n    exports.defaults = newDefaults;\n  }\n\n  /**\n   * Helpers\n   */\n  var escapeTest = /[&<>\"']/;\n  var escapeReplace = /[&<>\"']/g;\n  var escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\n  var escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n  var escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  var getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n  };\n\n  function escape(html, encode) {\n    if (encode) {\n      if (escapeTest.test(html)) {\n        return html.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html)) {\n        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n\n    return html;\n  }\n  var unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n  /**\n   * @param {string} html\n   */\n\n  function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function (_, n) {\n      n = n.toLowerCase();\n      if (n === 'colon') return ':';\n\n      if (n.charAt(0) === '#') {\n        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n\n      return '';\n    });\n  }\n  var caret = /(^|[^\\[])\\^/g;\n  /**\n   * @param {string | RegExp} regex\n   * @param {string} opt\n   */\n\n  function edit(regex, opt) {\n    regex = typeof regex === 'string' ? regex : regex.source;\n    opt = opt || '';\n    var obj = {\n      replace: function replace(name, val) {\n        val = val.source || val;\n        val = val.replace(caret, '$1');\n        regex = regex.replace(name, val);\n        return obj;\n      },\n      getRegex: function getRegex() {\n        return new RegExp(regex, opt);\n      }\n    };\n    return obj;\n  }\n  var nonWordAndColonTest = /[^\\w:]/g;\n  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n  /**\n   * @param {boolean} sanitize\n   * @param {string} base\n   * @param {string} href\n   */\n\n  function cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n      var prot;\n\n      try {\n        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();\n      } catch (e) {\n        return null;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    }\n\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n\n    try {\n      href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n      return null;\n    }\n\n    return href;\n  }\n  var baseUrls = {};\n  var justDomain = /^[^:]+:\\/*[^/]*$/;\n  var protocol = /^([^:]+:)[\\s\\S]*$/;\n  var domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n  /**\n   * @param {string} base\n   * @param {string} href\n   */\n\n  function resolveUrl(base, href) {\n    if (!baseUrls[' ' + base]) {\n      // we can ignore everything in base after the last slash of its path component,\n      // but we might need to add _that_\n      // https://tools.ietf.org/html/rfc3986#section-3\n      if (justDomain.test(base)) {\n        baseUrls[' ' + base] = base + '/';\n      } else {\n        baseUrls[' ' + base] = rtrim(base, '/', true);\n      }\n    }\n\n    base = baseUrls[' ' + base];\n    var relativeBase = base.indexOf(':') === -1;\n\n    if (href.substring(0, 2) === '//') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(protocol, '$1') + href;\n    } else if (href.charAt(0) === '/') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(domain, '$1') + href;\n    } else {\n      return base + href;\n    }\n  }\n  var noopTest = {\n    exec: function noopTest() {}\n  };\n  function merge(obj) {\n    var i = 1,\n        target,\n        key;\n\n    for (; i < arguments.length; i++) {\n      target = arguments[i];\n\n      for (key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n          obj[key] = target[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n  function splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n      var escaped = false,\n          curr = offset;\n\n      while (--curr >= 0 && str[curr] === '\\\\') {\n        escaped = !escaped;\n      }\n\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n        cells = row.split(/ \\|/);\n    var i = 0; // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n\n    if (!cells[0].trim()) {\n      cells.shift();\n    }\n\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n      cells.pop();\n    }\n\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) {\n        cells.push('');\n      }\n    }\n\n    for (; i < cells.length; i++) {\n      // leading or trailing whitespace is ignored per the gfm spec\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n\n    return cells;\n  }\n  /**\n   * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n   * /c*$/ is vulnerable to REDOS.\n   *\n   * @param {string} str\n   * @param {string} c\n   * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.\n   */\n\n  function rtrim(str, c, invert) {\n    var l = str.length;\n\n    if (l === 0) {\n      return '';\n    } // Length of suffix matching the invert condition.\n\n\n    var suffLen = 0; // Step left until we fail to match the invert condition.\n\n    while (suffLen < l) {\n      var currChar = str.charAt(l - suffLen - 1);\n\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n\n    return str.slice(0, l - suffLen);\n  }\n  function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n\n    var l = str.length;\n    var level = 0,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (str[i] === '\\\\') {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n  function checkSanitizeDeprecation(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n    }\n  } // copied from https://stackoverflow.com/a/5450113/806777\n\n  /**\n   * @param {string} pattern\n   * @param {number} count\n   */\n\n  function repeatString(pattern, count) {\n    if (count < 1) {\n      return '';\n    }\n\n    var result = '';\n\n    while (count > 1) {\n      if (count & 1) {\n        result += pattern;\n      }\n\n      count >>= 1;\n      pattern += pattern;\n    }\n\n    return result + pattern;\n  }\n\n  function outputLink(cap, link, raw, lexer) {\n    var href = link.href;\n    var title = link.title ? escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n      lexer.state.inLink = true;\n      var token = {\n        type: 'link',\n        raw: raw,\n        href: href,\n        title: title,\n        text: text,\n        tokens: lexer.inlineTokens(text, [])\n      };\n      lexer.state.inLink = false;\n      return token;\n    }\n\n    return {\n      type: 'image',\n      raw: raw,\n      href: href,\n      title: title,\n      text: escape(text)\n    };\n  }\n\n  function indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n      return text;\n    }\n\n    var indentToCode = matchIndentToCode[1];\n    return text.split('\\n').map(function (node) {\n      var matchIndentInNode = node.match(/^\\s+/);\n\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      var indentInNode = matchIndentInNode[0];\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    }).join('\\n');\n  }\n  /**\n   * Tokenizer\n   */\n\n\n  var Tokenizer = /*#__PURE__*/function () {\n    function Tokenizer(options) {\n      this.options = options || exports.defaults;\n    }\n\n    var _proto = Tokenizer.prototype;\n\n    _proto.space = function space(src) {\n      var cap = this.rules.block.newline.exec(src);\n\n      if (cap && cap[0].length > 0) {\n        return {\n          type: 'space',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.code = function code(src) {\n      var cap = this.rules.block.code.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ {1,4}/gm, '');\n        return {\n          type: 'code',\n          raw: cap[0],\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic ? rtrim(text, '\\n') : text\n        };\n      }\n    };\n\n    _proto.fences = function fences(src) {\n      var cap = this.rules.block.fences.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var text = indentCodeCompensation(raw, cap[3] || '');\n        return {\n          type: 'code',\n          raw: raw,\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: text\n        };\n      }\n    };\n\n    _proto.heading = function heading(src) {\n      var cap = this.rules.block.heading.exec(src);\n\n      if (cap) {\n        var text = cap[2].trim(); // remove trailing #s\n\n        if (/#$/.test(text)) {\n          var trimmed = rtrim(text, '#');\n\n          if (this.options.pedantic) {\n            text = trimmed.trim();\n          } else if (!trimmed || / $/.test(trimmed)) {\n            // CommonMark requires space before trailing #s\n            text = trimmed.trim();\n          }\n        }\n\n        var token = {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[1].length,\n          text: text,\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.hr = function hr(src) {\n      var cap = this.rules.block.hr.exec(src);\n\n      if (cap) {\n        return {\n          type: 'hr',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.blockquote = function blockquote(src) {\n      var cap = this.rules.block.blockquote.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ *>[ \\t]?/gm, '');\n        return {\n          type: 'blockquote',\n          raw: cap[0],\n          tokens: this.lexer.blockTokens(text, []),\n          text: text\n        };\n      }\n    };\n\n    _proto.list = function list(src) {\n      var cap = this.rules.block.list.exec(src);\n\n      if (cap) {\n        var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;\n        var bull = cap[1].trim();\n        var isordered = bull.length > 1;\n        var list = {\n          type: 'list',\n          raw: '',\n          ordered: isordered,\n          start: isordered ? +bull.slice(0, -1) : '',\n          loose: false,\n          items: []\n        };\n        bull = isordered ? \"\\\\d{1,9}\\\\\" + bull.slice(-1) : \"\\\\\" + bull;\n\n        if (this.options.pedantic) {\n          bull = isordered ? bull : '[*+-]';\n        } // Get next list item\n\n\n        var itemRegex = new RegExp(\"^( {0,3}\" + bull + \")((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))\"); // Check if current bullet point can start a new List Item\n\n        while (src) {\n          endEarly = false;\n\n          if (!(cap = itemRegex.exec(src))) {\n            break;\n          }\n\n          if (this.rules.block.hr.test(src)) {\n            // End list if bullet was actually HR (possibly move into itemRegex?)\n            break;\n          }\n\n          raw = cap[0];\n          src = src.substring(raw.length);\n          line = cap[2].split('\\n', 1)[0];\n          nextLine = src.split('\\n', 1)[0];\n\n          if (this.options.pedantic) {\n            indent = 2;\n            itemContents = line.trimLeft();\n          } else {\n            indent = cap[2].search(/[^ ]/); // Find first non-space char\n\n            indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n\n            itemContents = line.slice(indent);\n            indent += cap[1].length;\n          }\n\n          blankLine = false;\n\n          if (!line && /^ *$/.test(nextLine)) {\n            // Items begin with at most one blank line\n            raw += nextLine + '\\n';\n            src = src.substring(nextLine.length + 1);\n            endEarly = true;\n          }\n\n          if (!endEarly) {\n            var nextBulletRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}(?:[*+-]|\\\\d{1,9}[.)])((?: [^\\\\n]*)?(?:\\\\n|$))\");\n            var hrRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)\"); // Check if following lines should be included in List Item\n\n            while (src) {\n              rawLine = src.split('\\n', 1)[0];\n              line = rawLine; // Re-align to follow commonmark nesting rules\n\n              if (this.options.pedantic) {\n                line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n              } // End list item if found start of new bullet\n\n\n              if (nextBulletRegex.test(line)) {\n                break;\n              } // Horizontal rule found\n\n\n              if (hrRegex.test(src)) {\n                break;\n              }\n\n              if (line.search(/[^ ]/) >= indent || !line.trim()) {\n                // Dedent if possible\n                itemContents += '\\n' + line.slice(indent);\n              } else if (!blankLine) {\n                // Until blank line, item doesn't need indentation\n                itemContents += '\\n' + line;\n              } else {\n                // Otherwise, improper indentation ends this item\n                break;\n              }\n\n              if (!blankLine && !line.trim()) {\n                // Check if current line is blank\n                blankLine = true;\n              }\n\n              raw += rawLine + '\\n';\n              src = src.substring(rawLine.length + 1);\n            }\n          }\n\n          if (!list.loose) {\n            // If the previous item ended with a blank line, the list is loose\n            if (endsWithBlankLine) {\n              list.loose = true;\n            } else if (/\\n *\\n *$/.test(raw)) {\n              endsWithBlankLine = true;\n            }\n          } // Check for task list items\n\n\n          if (this.options.gfm) {\n            istask = /^\\[[ xX]\\] /.exec(itemContents);\n\n            if (istask) {\n              ischecked = istask[0] !== '[ ] ';\n              itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n            }\n          }\n\n          list.items.push({\n            type: 'list_item',\n            raw: raw,\n            task: !!istask,\n            checked: ischecked,\n            loose: false,\n            text: itemContents\n          });\n          list.raw += raw;\n        } // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n\n\n        list.items[list.items.length - 1].raw = raw.trimRight();\n        list.items[list.items.length - 1].text = itemContents.trimRight();\n        list.raw = list.raw.trimRight();\n        var l = list.items.length; // Item child tokens handled here at end because we needed to have the final item to trim it first\n\n        for (i = 0; i < l; i++) {\n          this.lexer.state.top = false;\n          list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n          var spacers = list.items[i].tokens.filter(function (t) {\n            return t.type === 'space';\n          });\n          var hasMultipleLineBreaks = spacers.every(function (t) {\n            var chars = t.raw.split('');\n            var lineBreaks = 0;\n\n            for (var _iterator = _createForOfIteratorHelperLoose(chars), _step; !(_step = _iterator()).done;) {\n              var _char = _step.value;\n\n              if (_char === '\\n') {\n                lineBreaks += 1;\n              }\n\n              if (lineBreaks > 1) {\n                return true;\n              }\n            }\n\n            return false;\n          });\n\n          if (!list.loose && spacers.length && hasMultipleLineBreaks) {\n            // Having a single line break doesn't mean a list is loose. A single line break is terminating the last list item\n            list.loose = true;\n            list.items[i].loose = true;\n          }\n        }\n\n        return list;\n      }\n    };\n\n    _proto.html = function html(src) {\n      var cap = this.rules.block.html.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'html',\n          raw: cap[0],\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: cap[0]\n        };\n\n        if (this.options.sanitize) {\n          token.type = 'paragraph';\n          token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n          token.tokens = [];\n          this.lexer.inline(token.text, token.tokens);\n        }\n\n        return token;\n      }\n    };\n\n    _proto.def = function def(src) {\n      var cap = this.rules.block.def.exec(src);\n\n      if (cap) {\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        var tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        return {\n          type: 'def',\n          tag: tag,\n          raw: cap[0],\n          href: cap[2],\n          title: cap[3]\n        };\n      }\n    };\n\n    _proto.table = function table(src) {\n      var cap = this.rules.block.table.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells(cap[1]).map(function (c) {\n            return {\n              text: c\n            };\n          }),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          item.raw = cap[0];\n          var l = item.align.length;\n          var i, j, k, row;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.rows.length;\n\n          for (i = 0; i < l; i++) {\n            item.rows[i] = splitCells(item.rows[i], item.header.length).map(function (c) {\n              return {\n                text: c\n              };\n            });\n          } // parse child tokens inside headers and cells\n          // header child tokens\n\n\n          l = item.header.length;\n\n          for (j = 0; j < l; j++) {\n            item.header[j].tokens = [];\n            this.lexer.inline(item.header[j].text, item.header[j].tokens);\n          } // cell child tokens\n\n\n          l = item.rows.length;\n\n          for (j = 0; j < l; j++) {\n            row = item.rows[j];\n\n            for (k = 0; k < row.length; k++) {\n              row[k].tokens = [];\n              this.lexer.inline(row[k].text, row[k].tokens);\n            }\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.lheading = function lheading(src) {\n      var cap = this.rules.block.lheading.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.paragraph = function paragraph(src) {\n      var cap = this.rules.block.paragraph.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'paragraph',\n          raw: cap[0],\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.text = function text(src) {\n      var cap = this.rules.block.text.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'text',\n          raw: cap[0],\n          text: cap[0],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.escape = function escape$1(src) {\n      var cap = this.rules.inline.escape.exec(src);\n\n      if (cap) {\n        return {\n          type: 'escape',\n          raw: cap[0],\n          text: escape(cap[1])\n        };\n      }\n    };\n\n    _proto.tag = function tag(src) {\n      var cap = this.rules.inline.tag.exec(src);\n\n      if (cap) {\n        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n          this.lexer.state.inLink = true;\n        } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n          this.lexer.state.inLink = false;\n        }\n\n        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.lexer.state.inRawBlock = true;\n        } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.lexer.state.inRawBlock = false;\n        }\n\n        return {\n          type: this.options.sanitize ? 'text' : 'html',\n          raw: cap[0],\n          inLink: this.lexer.state.inLink,\n          inRawBlock: this.lexer.state.inRawBlock,\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.link = function link(src) {\n      var cap = this.rules.inline.link.exec(src);\n\n      if (cap) {\n        var trimmedUrl = cap[2].trim();\n\n        if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n          // commonmark requires matching angle brackets\n          if (!/>$/.test(trimmedUrl)) {\n            return;\n          } // ending angle bracket cannot be escaped\n\n\n          var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n\n          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n            return;\n          }\n        } else {\n          // find closing parenthesis\n          var lastParenIndex = findClosingBracket(cap[2], '()');\n\n          if (lastParenIndex > -1) {\n            var start = cap[0].indexOf('!') === 0 ? 5 : 4;\n            var linkLen = start + cap[1].length + lastParenIndex;\n            cap[2] = cap[2].substring(0, lastParenIndex);\n            cap[0] = cap[0].substring(0, linkLen).trim();\n            cap[3] = '';\n          }\n        }\n\n        var href = cap[2];\n        var title = '';\n\n        if (this.options.pedantic) {\n          // split pedantic href and title\n          var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n\n        href = href.trim();\n\n        if (/^</.test(href)) {\n          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n            // pedantic allows starting angle bracket without ending angle bracket\n            href = href.slice(1);\n          } else {\n            href = href.slice(1, -1);\n          }\n        }\n\n        return outputLink(cap, {\n          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n          title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n        }, cap[0], this.lexer);\n      }\n    };\n\n    _proto.reflink = function reflink(src, links) {\n      var cap;\n\n      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n        var link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = links[link.toLowerCase()];\n\n        if (!link || !link.href) {\n          var text = cap[0].charAt(0);\n          return {\n            type: 'text',\n            raw: text,\n            text: text\n          };\n        }\n\n        return outputLink(cap, link, cap[0], this.lexer);\n      }\n    };\n\n    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.emStrong.lDelim.exec(src);\n      if (!match) return; // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n\n      if (match[3] && prevChar.match(/(?:[0-9A-Za-z\\xAA\\xB2\\xB3\\xB5\\xB9\\xBA\\xBC-\\xBE\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u0660-\\u0669\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07C0-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0966-\\u096F\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09E6-\\u09F1\\u09F4-\\u09F9\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A6F\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AE6-\\u0AEF\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B71-\\u0B77\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0BE6-\\u0BF2\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D58-\\u0D61\\u0D66-\\u0D78\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DE6-\\u0DEF\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F20-\\u0F33\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F-\\u1049\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1090-\\u1099\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1369-\\u137C\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B50-\\u1B59\\u1B83-\\u1BA0\\u1BAE-\\u1BE5\\u1C00-\\u1C23\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2070\\u2071\\u2074-\\u2079\\u207F-\\u2089\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2150-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2CFD\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u3192-\\u3195\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA830-\\uA835\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uA9E0-\\uA9E4\\uA9E6-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD07-\\uDD33\\uDD40-\\uDD78\\uDD8A\\uDD8B\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE1-\\uDEFB\\uDF00-\\uDF23\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC58-\\uDC76\\uDC79-\\uDC9E\\uDCA7-\\uDCAF\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDCFB-\\uDD1B\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBC-\\uDDCF\\uDDD2-\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE40-\\uDE48\\uDE60-\\uDE7E\\uDE80-\\uDE9F\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDEEB-\\uDEEF\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF58-\\uDF72\\uDF78-\\uDF91\\uDFA9-\\uDFAF]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDCFA-\\uDD23\\uDD30-\\uDD39\\uDE60-\\uDE7E\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF27\\uDF30-\\uDF45\\uDF51-\\uDF54\\uDF70-\\uDF81\\uDFB0-\\uDFCB\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC52-\\uDC6F\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD03-\\uDD26\\uDD36-\\uDD3F\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDD0-\\uDDDA\\uDDDC\\uDDE1-\\uDDF4\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDEF0-\\uDEF9\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC50-\\uDC59\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEAA\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF30-\\uDF3B\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCF2\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC50-\\uDC6C\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF2\\uDFB0\\uDFC0-\\uDFD4]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF5B-\\uDF61\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE96\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD834[\\uDEE0-\\uDEF3\\uDF60-\\uDF78]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD837[\\uDF00-\\uDF1E]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB\\uDEF0-\\uDEF9]|\\uD839[\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCC7-\\uDCCF\\uDD00-\\uDD43\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDC71-\\uDCAB\\uDCAD-\\uDCAF\\uDCB1-\\uDCB4\\uDD01-\\uDD2D\\uDD2F-\\uDD3D\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83C[\\uDD00-\\uDD0C]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF38\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])/)) return;\n      var nextChar = match[1] || match[2] || '';\n\n      if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {\n        var lLength = match[0].length - 1;\n        var rDelim,\n            rLength,\n            delimTotal = lLength,\n            midDelimTotal = 0;\n        var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n        endReg.lastIndex = 0; // Clip maskedSrc to same section of string as src (move to lexer?)\n\n        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n          if (!rDelim) continue; // skip single * in __abc*abc__\n\n          rLength = rDelim.length;\n\n          if (match[3] || match[4]) {\n            // found another Left Delim\n            delimTotal += rLength;\n            continue;\n          } else if (match[5] || match[6]) {\n            // either Left or Right Delim\n            if (lLength % 3 && !((lLength + rLength) % 3)) {\n              midDelimTotal += rLength;\n              continue; // CommonMark Emphasis Rules 9-10\n            }\n          }\n\n          delimTotal -= rLength;\n          if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n          // Remove extra characters. *a*** -> *a*\n\n          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal); // Create `em` if smallest delimiter has odd char count. *a***\n\n          if (Math.min(lLength, rLength) % 2) {\n            var _text = src.slice(1, lLength + match.index + rLength);\n\n            return {\n              type: 'em',\n              raw: src.slice(0, lLength + match.index + rLength + 1),\n              text: _text,\n              tokens: this.lexer.inlineTokens(_text, [])\n            };\n          } // Create 'strong' if smallest delimiter has even char count. **a***\n\n\n          var text = src.slice(2, lLength + match.index + rLength - 1);\n          return {\n            type: 'strong',\n            raw: src.slice(0, lLength + match.index + rLength + 1),\n            text: text,\n            tokens: this.lexer.inlineTokens(text, [])\n          };\n        }\n      }\n    };\n\n    _proto.codespan = function codespan(src) {\n      var cap = this.rules.inline.code.exec(src);\n\n      if (cap) {\n        var text = cap[2].replace(/\\n/g, ' ');\n        var hasNonSpaceChars = /[^ ]/.test(text);\n        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n\n        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n          text = text.substring(1, text.length - 1);\n        }\n\n        text = escape(text, true);\n        return {\n          type: 'codespan',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.br = function br(src) {\n      var cap = this.rules.inline.br.exec(src);\n\n      if (cap) {\n        return {\n          type: 'br',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.del = function del(src) {\n      var cap = this.rules.inline.del.exec(src);\n\n      if (cap) {\n        return {\n          type: 'del',\n          raw: cap[0],\n          text: cap[2],\n          tokens: this.lexer.inlineTokens(cap[2], [])\n        };\n      }\n    };\n\n    _proto.autolink = function autolink(src, mangle) {\n      var cap = this.rules.inline.autolink.exec(src);\n\n      if (cap) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n          href = 'mailto:' + text;\n        } else {\n          text = escape(cap[1]);\n          href = text;\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.url = function url(src, mangle) {\n      var cap;\n\n      if (cap = this.rules.inline.url.exec(src)) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          var prevCapZero;\n\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n\n          text = escape(cap[0]);\n\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.inlineText = function inlineText(src, smartypants) {\n      var cap = this.rules.inline.text.exec(src);\n\n      if (cap) {\n        var text;\n\n        if (this.lexer.state.inRawBlock) {\n          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];\n        } else {\n          text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    return Tokenizer;\n  }();\n\n  /**\n   * Block-Level Grammar\n   */\n\n  var block = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n    html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')',\n    def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?<?([^\\s>]+)>?(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n  };\n  block._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n  block._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n  block.def = edit(block.def).replace('label', block._label).replace('title', block._title).getRegex();\n  block.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n  block.listItemStart = edit(/^( *)(bull) */).replace('bull', block.bullet).getRegex();\n  block.list = edit(block.list).replace(/bull/g, block.bullet).replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))').replace('def', '\\\\n+(?=' + block.def.source + ')').getRegex();\n  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';\n  block._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\n  block.html = edit(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n  block.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n  block.blockquote = edit(block.blockquote).replace('paragraph', block.paragraph).getRegex();\n  /**\n   * Normal Block Grammar\n   */\n\n  block.normal = merge({}, block);\n  /**\n   * GFM Block Grammar\n   */\n\n  block.gfm = merge({}, block.normal, {\n    table: '^ *([^\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n\n  });\n  block.gfm.table = edit(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  block.gfm.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('table', block.gfm.table) // interrupt paragraphs with table\n  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n  /**\n   * Pedantic grammar (original John Gruber's loose markdown specification)\n   */\n\n  block.pedantic = merge({}, block.normal, {\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    // fences not supported\n    paragraph: edit(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()\n  });\n  /**\n   * Inline-Level Grammar\n   */\n\n  var inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: '^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>',\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n    nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n    reflinkSearch: 'reflink|nolink(?!\\\\()',\n    emStrong: {\n      lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n      //          () Skip orphan inside strong  () Consume to delim (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n      rDelimAst: /^[^_*]*?\\_\\_[^_*]*?\\*[^_*]*?(?=\\_\\_)|[^*]+(?=[^*])|[punct_](\\*+)(?=[\\s]|$)|[^punct*_\\s](\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|[^punct*_\\s](\\*+)(?=[^punct*_\\s])/,\n      rDelimUnd: /^[^_*]*?\\*\\*[^_*]*?\\_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|[punct*](\\_+)(?=[\\s]|$)|[^punct*_\\s](\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\spunctuation])/\n  }; // list of punctuation marks from CommonMark spec\n  // without * and _ to handle the different emphasis markers * and _\n\n  inline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\n  inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>\n\n  inline.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n  inline.escapedEmSt = /\\\\\\*|\\\\_/g;\n  inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();\n  inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();\n  inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g').replace(/punct/g, inline._punctuation).getRegex();\n  inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g').replace(/punct/g, inline._punctuation).getRegex();\n  inline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n  inline.autolink = edit(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();\n  inline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n  inline.tag = edit(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();\n  inline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n  inline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\n  inline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n  inline.link = edit(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();\n  inline.reflink = edit(inline.reflink).replace('label', inline._label).replace('ref', block._label).getRegex();\n  inline.nolink = edit(inline.nolink).replace('ref', block._label).getRegex();\n  inline.reflinkSearch = edit(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();\n  /**\n   * Normal Inline Grammar\n   */\n\n  inline.normal = merge({}, inline);\n  /**\n   * Pedantic Inline Grammar\n   */\n\n  inline.pedantic = merge({}, inline.normal, {\n    strong: {\n      start: /^__|\\*\\*/,\n      middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n      endAst: /\\*\\*(?!\\*)/g,\n      endUnd: /__(?!_)/g\n    },\n    em: {\n      start: /^_|\\*/,\n      middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n      endAst: /\\*(?!\\*)/g,\n      endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', inline._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', inline._label).getRegex()\n  });\n  /**\n   * GFM Inline Grammar\n   */\n\n  inline.gfm = merge({}, inline.normal, {\n    escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n  });\n  inline.gfm.url = edit(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();\n  /**\n   * GFM + Line Breaks Inline Grammar\n   */\n\n  inline.breaks = merge({}, inline.gfm, {\n    br: edit(inline.br).replace('{2,}', '*').getRegex(),\n    text: edit(inline.gfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n  });\n\n  /**\n   * smartypants text replacement\n   * @param {string} text\n   */\n\n  function smartypants(text) {\n    return text // em-dashes\n    .replace(/---/g, \"\\u2014\") // en-dashes\n    .replace(/--/g, \"\\u2013\") // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\\u2018\") // closing singles & apostrophes\n    .replace(/'/g, \"\\u2019\") // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\\u201C\") // closing doubles\n    .replace(/\"/g, \"\\u201D\") // ellipses\n    .replace(/\\.{3}/g, \"\\u2026\");\n  }\n  /**\n   * mangle email addresses\n   * @param {string} text\n   */\n\n\n  function mangle(text) {\n    var out = '',\n        i,\n        ch;\n    var l = text.length;\n\n    for (i = 0; i < l; i++) {\n      ch = text.charCodeAt(i);\n\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  }\n  /**\n   * Block Lexer\n   */\n\n\n  var Lexer = /*#__PURE__*/function () {\n    function Lexer(options) {\n      this.tokens = [];\n      this.tokens.links = Object.create(null);\n      this.options = options || exports.defaults;\n      this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n      this.tokenizer = this.options.tokenizer;\n      this.tokenizer.options = this.options;\n      this.tokenizer.lexer = this;\n      this.inlineQueue = [];\n      this.state = {\n        inLink: false,\n        inRawBlock: false,\n        top: true\n      };\n      var rules = {\n        block: block.normal,\n        inline: inline.normal\n      };\n\n      if (this.options.pedantic) {\n        rules.block = block.pedantic;\n        rules.inline = inline.pedantic;\n      } else if (this.options.gfm) {\n        rules.block = block.gfm;\n\n        if (this.options.breaks) {\n          rules.inline = inline.breaks;\n        } else {\n          rules.inline = inline.gfm;\n        }\n      }\n\n      this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n\n\n    /**\n     * Static Lex Method\n     */\n    Lexer.lex = function lex(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    ;\n\n    Lexer.lexInline = function lexInline(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    ;\n\n    var _proto = Lexer.prototype;\n\n    _proto.lex = function lex(src) {\n      src = src.replace(/\\r\\n|\\r/g, '\\n');\n      this.blockTokens(src, this.tokens);\n      var next;\n\n      while (next = this.inlineQueue.shift()) {\n        this.inlineTokens(next.src, next.tokens);\n      }\n\n      return this.tokens;\n    }\n    /**\n     * Lexing\n     */\n    ;\n\n    _proto.blockTokens = function blockTokens(src, tokens) {\n      var _this = this;\n\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (this.options.pedantic) {\n        src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n      } else {\n        src = src.replace(/^( *)(\\t+)/gm, function (_, leading, tabs) {\n          return leading + '    '.repeat(tabs.length);\n        });\n      }\n\n      var token, lastToken, cutSrc, lastParagraphClipped;\n\n      while (src) {\n        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {\n          if (token = extTokenizer.call({\n            lexer: _this\n          }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n\n          return false;\n        })) {\n          continue;\n        } // newline\n\n\n        if (token = this.tokenizer.space(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.raw.length === 1 && tokens.length > 0) {\n            // if there's a single \\n as a spacer, it's terminating the last line,\n            // so move it there so that we don't get unecessary paragraph tags\n            tokens[tokens.length - 1].raw += '\\n';\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.code(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.\n\n          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // fences\n\n\n        if (token = this.tokenizer.fences(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // heading\n\n\n        if (token = this.tokenizer.heading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // hr\n\n\n        if (token = this.tokenizer.hr(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // blockquote\n\n\n        if (token = this.tokenizer.blockquote(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // list\n\n\n        if (token = this.tokenizer.list(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // html\n\n\n        if (token = this.tokenizer.html(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // def\n\n\n        if (token = this.tokenizer.def(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.raw;\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else if (!this.tokens.links[token.tag]) {\n            this.tokens.links[token.tag] = {\n              href: token.href,\n              title: token.title\n            };\n          }\n\n          continue;\n        } // table (gfm)\n\n\n        if (token = this.tokenizer.table(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // lheading\n\n\n        if (token = this.tokenizer.lheading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // top-level paragraph\n        // prevent paragraph consuming extensions by clipping 'src' to extension start\n\n\n        cutSrc = src;\n\n        if (this.options.extensions && this.options.extensions.startBlock) {\n          (function () {\n            var startIndex = Infinity;\n            var tempSrc = src.slice(1);\n            var tempStart = void 0;\n\n            _this.options.extensions.startBlock.forEach(function (getStartIndex) {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          })();\n        }\n\n        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastParagraphClipped && lastToken.type === 'paragraph') {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue.pop();\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          lastParagraphClipped = cutSrc.length !== src.length;\n          src = src.substring(token.raw.length);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.text(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === 'text') {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue.pop();\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      this.state.top = true;\n      return tokens;\n    };\n\n    _proto.inline = function inline(src, tokens) {\n      this.inlineQueue.push({\n        src: src,\n        tokens: tokens\n      });\n    }\n    /**\n     * Lexing/Compiling\n     */\n    ;\n\n    _proto.inlineTokens = function inlineTokens(src, tokens) {\n      var _this2 = this;\n\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      var token, lastToken, cutSrc; // String with links masked to avoid interference with em and strong\n\n      var maskedSrc = src;\n      var match;\n      var keepPrevChar, prevChar; // Mask out reflinks\n\n      if (this.tokens.links) {\n        var links = Object.keys(this.tokens.links);\n\n        if (links.length > 0) {\n          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n            }\n          }\n        }\n      } // Mask out other blocks\n\n\n      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n      } // Mask out escaped em & strong delimiters\n\n\n      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n      }\n\n      while (src) {\n        if (!keepPrevChar) {\n          prevChar = '';\n        }\n\n        keepPrevChar = false; // extensions\n\n        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {\n          if (token = extTokenizer.call({\n            lexer: _this2\n          }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n\n          return false;\n        })) {\n          continue;\n        } // escape\n\n\n        if (token = this.tokenizer.escape(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // tag\n\n\n        if (token = this.tokenizer.tag(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // link\n\n\n        if (token = this.tokenizer.link(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // reflink, nolink\n\n\n        if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // em & strong\n\n\n        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.codespan(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // br\n\n\n        if (token = this.tokenizer.br(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // del (gfm)\n\n\n        if (token = this.tokenizer.del(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // autolink\n\n\n        if (token = this.tokenizer.autolink(src, mangle)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // url (gfm)\n\n\n        if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n        // prevent inlineText consuming extensions by clipping 'src' to extension start\n\n\n        cutSrc = src;\n\n        if (this.options.extensions && this.options.extensions.startInline) {\n          (function () {\n            var startIndex = Infinity;\n            var tempSrc = src.slice(1);\n            var tempStart = void 0;\n\n            _this2.options.extensions.startInline.forEach(function (getStartIndex) {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          })();\n        }\n\n        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n          src = src.substring(token.raw.length);\n\n          if (token.raw.slice(-1) !== '_') {\n            // Track prevChar before string of ____ started\n            prevChar = token.raw.slice(-1);\n          }\n\n          keepPrevChar = true;\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _createClass(Lexer, null, [{\n      key: \"rules\",\n      get: function get() {\n        return {\n          block: block,\n          inline: inline\n        };\n      }\n    }]);\n\n    return Lexer;\n  }();\n\n  /**\n   * Renderer\n   */\n\n  var Renderer = /*#__PURE__*/function () {\n    function Renderer(options) {\n      this.options = options || exports.defaults;\n    }\n\n    var _proto = Renderer.prototype;\n\n    _proto.code = function code(_code, infostring, escaped) {\n      var lang = (infostring || '').match(/\\S*/)[0];\n\n      if (this.options.highlight) {\n        var out = this.options.highlight(_code, lang);\n\n        if (out != null && out !== _code) {\n          escaped = true;\n          _code = out;\n        }\n      }\n\n      _code = _code.replace(/\\n$/, '') + '\\n';\n\n      if (!lang) {\n        return '<pre><code>' + (escaped ? _code : escape(_code, true)) + '</code></pre>\\n';\n      }\n\n      return '<pre><code class=\"' + this.options.langPrefix + escape(lang, true) + '\">' + (escaped ? _code : escape(_code, true)) + '</code></pre>\\n';\n    }\n    /**\n     * @param {string} quote\n     */\n    ;\n\n    _proto.blockquote = function blockquote(quote) {\n      return \"<blockquote>\\n\" + quote + \"</blockquote>\\n\";\n    };\n\n    _proto.html = function html(_html) {\n      return _html;\n    }\n    /**\n     * @param {string} text\n     * @param {string} level\n     * @param {string} raw\n     * @param {any} slugger\n     */\n    ;\n\n    _proto.heading = function heading(text, level, raw, slugger) {\n      if (this.options.headerIds) {\n        var id = this.options.headerPrefix + slugger.slug(raw);\n        return \"<h\" + level + \" id=\\\"\" + id + \"\\\">\" + text + \"</h\" + level + \">\\n\";\n      } // ignore IDs\n\n\n      return \"<h\" + level + \">\" + text + \"</h\" + level + \">\\n\";\n    };\n\n    _proto.hr = function hr() {\n      return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n    };\n\n    _proto.list = function list(body, ordered, start) {\n      var type = ordered ? 'ol' : 'ul',\n          startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n      return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    }\n    /**\n     * @param {string} text\n     */\n    ;\n\n    _proto.listitem = function listitem(text) {\n      return \"<li>\" + text + \"</li>\\n\";\n    };\n\n    _proto.checkbox = function checkbox(checked) {\n      return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? ' /' : '') + '> ';\n    }\n    /**\n     * @param {string} text\n     */\n    ;\n\n    _proto.paragraph = function paragraph(text) {\n      return \"<p>\" + text + \"</p>\\n\";\n    }\n    /**\n     * @param {string} header\n     * @param {string} body\n     */\n    ;\n\n    _proto.table = function table(header, body) {\n      if (body) body = \"<tbody>\" + body + \"</tbody>\";\n      return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n    }\n    /**\n     * @param {string} content\n     */\n    ;\n\n    _proto.tablerow = function tablerow(content) {\n      return \"<tr>\\n\" + content + \"</tr>\\n\";\n    };\n\n    _proto.tablecell = function tablecell(content, flags) {\n      var type = flags.header ? 'th' : 'td';\n      var tag = flags.align ? \"<\" + type + \" align=\\\"\" + flags.align + \"\\\">\" : \"<\" + type + \">\";\n      return tag + content + (\"</\" + type + \">\\n\");\n    }\n    /**\n     * span level renderer\n     * @param {string} text\n     */\n    ;\n\n    _proto.strong = function strong(text) {\n      return \"<strong>\" + text + \"</strong>\";\n    }\n    /**\n     * @param {string} text\n     */\n    ;\n\n    _proto.em = function em(text) {\n      return \"<em>\" + text + \"</em>\";\n    }\n    /**\n     * @param {string} text\n     */\n    ;\n\n    _proto.codespan = function codespan(text) {\n      return \"<code>\" + text + \"</code>\";\n    };\n\n    _proto.br = function br() {\n      return this.options.xhtml ? '<br/>' : '<br>';\n    }\n    /**\n     * @param {string} text\n     */\n    ;\n\n    _proto.del = function del(text) {\n      return \"<del>\" + text + \"</del>\";\n    }\n    /**\n     * @param {string} href\n     * @param {string} title\n     * @param {string} text\n     */\n    ;\n\n    _proto.link = function link(href, title, text) {\n      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<a href=\"' + escape(href) + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += '>' + text + '</a>';\n      return out;\n    }\n    /**\n     * @param {string} href\n     * @param {string} title\n     * @param {string} text\n     */\n    ;\n\n    _proto.image = function image(href, title, text) {\n      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = \"<img src=\\\"\" + href + \"\\\" alt=\\\"\" + text + \"\\\"\";\n\n      if (title) {\n        out += \" title=\\\"\" + title + \"\\\"\";\n      }\n\n      out += this.options.xhtml ? '/>' : '>';\n      return out;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    return Renderer;\n  }();\n\n  /**\n   * TextRenderer\n   * returns only the textual part of the token\n   */\n  var TextRenderer = /*#__PURE__*/function () {\n    function TextRenderer() {}\n\n    var _proto = TextRenderer.prototype;\n\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n      return text;\n    };\n\n    _proto.em = function em(text) {\n      return text;\n    };\n\n    _proto.codespan = function codespan(text) {\n      return text;\n    };\n\n    _proto.del = function del(text) {\n      return text;\n    };\n\n    _proto.html = function html(text) {\n      return text;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    _proto.link = function link(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.image = function image(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.br = function br() {\n      return '';\n    };\n\n    return TextRenderer;\n  }();\n\n  /**\n   * Slugger generates header id\n   */\n  var Slugger = /*#__PURE__*/function () {\n    function Slugger() {\n      this.seen = {};\n    }\n    /**\n     * @param {string} value\n     */\n\n\n    var _proto = Slugger.prototype;\n\n    _proto.serialize = function serialize(value) {\n      return value.toLowerCase().trim() // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '') // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '').replace(/\\s/g, '-');\n    }\n    /**\n     * Finds the next safe (unique) slug to use\n     * @param {string} originalSlug\n     * @param {boolean} isDryRun\n     */\n    ;\n\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n      var slug = originalSlug;\n      var occurenceAccumulator = 0;\n\n      if (this.seen.hasOwnProperty(slug)) {\n        occurenceAccumulator = this.seen[originalSlug];\n\n        do {\n          occurenceAccumulator++;\n          slug = originalSlug + '-' + occurenceAccumulator;\n        } while (this.seen.hasOwnProperty(slug));\n      }\n\n      if (!isDryRun) {\n        this.seen[originalSlug] = occurenceAccumulator;\n        this.seen[slug] = 0;\n      }\n\n      return slug;\n    }\n    /**\n     * Convert string to unique id\n     * @param {object} [options]\n     * @param {boolean} [options.dryrun] Generates the next unique slug without\n     * updating the internal accumulator.\n     */\n    ;\n\n    _proto.slug = function slug(value, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var slug = this.serialize(value);\n      return this.getNextSafeSlug(slug, options.dryrun);\n    };\n\n    return Slugger;\n  }();\n\n  /**\n   * Parsing & Compiling\n   */\n\n  var Parser = /*#__PURE__*/function () {\n    function Parser(options) {\n      this.options = options || exports.defaults;\n      this.options.renderer = this.options.renderer || new Renderer();\n      this.renderer = this.options.renderer;\n      this.renderer.options = this.options;\n      this.textRenderer = new TextRenderer();\n      this.slugger = new Slugger();\n    }\n    /**\n     * Static Parse Method\n     */\n\n\n    Parser.parse = function parse(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    ;\n\n    Parser.parseInline = function parseInline(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    ;\n\n    var _proto = Parser.prototype;\n\n    _proto.parse = function parse(tokens, top) {\n      if (top === void 0) {\n        top = true;\n      }\n\n      var out = '',\n          i,\n          j,\n          k,\n          l2,\n          l3,\n          row,\n          cell,\n          header,\n          body,\n          token,\n          ordered,\n          start,\n          loose,\n          itemBody,\n          item,\n          checked,\n          task,\n          checkbox,\n          ret;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i]; // Run any renderer extensions\n\n        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n          ret = this.options.extensions.renderers[token.type].call({\n            parser: this\n          }, token);\n\n          if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {\n            out += ret || '';\n            continue;\n          }\n        }\n\n        switch (token.type) {\n          case 'space':\n            {\n              continue;\n            }\n\n          case 'hr':\n            {\n              out += this.renderer.hr();\n              continue;\n            }\n\n          case 'heading':\n            {\n              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n              continue;\n            }\n\n          case 'code':\n            {\n              out += this.renderer.code(token.text, token.lang, token.escaped);\n              continue;\n            }\n\n          case 'table':\n            {\n              header = ''; // header\n\n              cell = '';\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {\n                  header: true,\n                  align: token.align[j]\n                });\n              }\n\n              header += this.renderer.tablerow(cell);\n              body = '';\n              l2 = token.rows.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.rows[j];\n                cell = '';\n                l3 = row.length;\n\n                for (k = 0; k < l3; k++) {\n                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                    header: false,\n                    align: token.align[k]\n                  });\n                }\n\n                body += this.renderer.tablerow(cell);\n              }\n\n              out += this.renderer.table(header, body);\n              continue;\n            }\n\n          case 'blockquote':\n            {\n              body = this.parse(token.tokens);\n              out += this.renderer.blockquote(body);\n              continue;\n            }\n\n          case 'list':\n            {\n              ordered = token.ordered;\n              start = token.start;\n              loose = token.loose;\n              l2 = token.items.length;\n              body = '';\n\n              for (j = 0; j < l2; j++) {\n                item = token.items[j];\n                checked = item.checked;\n                task = item.task;\n                itemBody = '';\n\n                if (item.task) {\n                  checkbox = this.renderer.checkbox(checked);\n\n                  if (loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\n                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                      }\n                    } else {\n                      item.tokens.unshift({\n                        type: 'text',\n                        text: checkbox\n                      });\n                    }\n                  } else {\n                    itemBody += checkbox;\n                  }\n                }\n\n                itemBody += this.parse(item.tokens, loose);\n                body += this.renderer.listitem(itemBody, task, checked);\n              }\n\n              out += this.renderer.list(body, ordered, start);\n              continue;\n            }\n\n          case 'html':\n            {\n              // TODO parse inline content if parameter markdown=1\n              out += this.renderer.html(token.text);\n              continue;\n            }\n\n          case 'paragraph':\n            {\n              out += this.renderer.paragraph(this.parseInline(token.tokens));\n              continue;\n            }\n\n          case 'text':\n            {\n              body = token.tokens ? this.parseInline(token.tokens) : token.text;\n\n              while (i + 1 < l && tokens[i + 1].type === 'text') {\n                token = tokens[++i];\n                body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n              }\n\n              out += top ? this.renderer.paragraph(body) : body;\n              continue;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    ;\n\n    _proto.parseInline = function parseInline(tokens, renderer) {\n      renderer = renderer || this.renderer;\n      var out = '',\n          i,\n          token,\n          ret;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i]; // Run any renderer extensions\n\n        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n          ret = this.options.extensions.renderers[token.type].call({\n            parser: this\n          }, token);\n\n          if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n            out += ret || '';\n            continue;\n          }\n        }\n\n        switch (token.type) {\n          case 'escape':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          case 'html':\n            {\n              out += renderer.html(token.text);\n              break;\n            }\n\n          case 'link':\n            {\n              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'image':\n            {\n              out += renderer.image(token.href, token.title, token.text);\n              break;\n            }\n\n          case 'strong':\n            {\n              out += renderer.strong(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'em':\n            {\n              out += renderer.em(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'codespan':\n            {\n              out += renderer.codespan(token.text);\n              break;\n            }\n\n          case 'br':\n            {\n              out += renderer.br();\n              break;\n            }\n\n          case 'del':\n            {\n              out += renderer.del(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'text':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    };\n\n    return Parser;\n  }();\n\n  /**\n   * Marked\n   */\n\n  function marked(src, opt, callback) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n\n    if (callback) {\n      var highlight = opt.highlight;\n      var tokens;\n\n      try {\n        tokens = Lexer.lex(src, opt);\n      } catch (e) {\n        return callback(e);\n      }\n\n      var done = function done(err) {\n        var out;\n\n        if (!err) {\n          try {\n            if (opt.walkTokens) {\n              marked.walkTokens(tokens, opt.walkTokens);\n            }\n\n            out = Parser.parse(tokens, opt);\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n      if (!tokens.length) return done();\n      var pending = 0;\n      marked.walkTokens(tokens, function (token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(function () {\n            highlight(token.text, token.lang, function (err, code) {\n              if (err) {\n                return done(err);\n              }\n\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    try {\n      var _tokens = Lexer.lex(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(_tokens, opt.walkTokens);\n      }\n\n      return Parser.parse(_tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Options\n   */\n\n  marked.options = marked.setOptions = function (opt) {\n    merge(marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n  };\n\n  marked.getDefaults = getDefaults;\n  marked.defaults = exports.defaults;\n  /**\n   * Use Extension\n   */\n\n  marked.use = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var opts = merge.apply(void 0, [{}].concat(args));\n    var extensions = marked.defaults.extensions || {\n      renderers: {},\n      childTokens: {}\n    };\n    var hasExtensions;\n    args.forEach(function (pack) {\n      // ==-- Parse \"addon\" extensions --== //\n      if (pack.extensions) {\n        hasExtensions = true;\n        pack.extensions.forEach(function (ext) {\n          if (!ext.name) {\n            throw new Error('extension name required');\n          }\n\n          if (ext.renderer) {\n            // Renderer extensions\n            var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;\n\n            if (prevRenderer) {\n              // Replace extension with func to run new extension but fall back if false\n              extensions.renderers[ext.name] = function () {\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n\n                var ret = ext.renderer.apply(this, args);\n\n                if (ret === false) {\n                  ret = prevRenderer.apply(this, args);\n                }\n\n                return ret;\n              };\n            } else {\n              extensions.renderers[ext.name] = ext.renderer;\n            }\n          }\n\n          if (ext.tokenizer) {\n            // Tokenizer Extensions\n            if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {\n              throw new Error(\"extension level must be 'block' or 'inline'\");\n            }\n\n            if (extensions[ext.level]) {\n              extensions[ext.level].unshift(ext.tokenizer);\n            } else {\n              extensions[ext.level] = [ext.tokenizer];\n            }\n\n            if (ext.start) {\n              // Function to check for start of token\n              if (ext.level === 'block') {\n                if (extensions.startBlock) {\n                  extensions.startBlock.push(ext.start);\n                } else {\n                  extensions.startBlock = [ext.start];\n                }\n              } else if (ext.level === 'inline') {\n                if (extensions.startInline) {\n                  extensions.startInline.push(ext.start);\n                } else {\n                  extensions.startInline = [ext.start];\n                }\n              }\n            }\n          }\n\n          if (ext.childTokens) {\n            // Child tokens to be visited by walkTokens\n            extensions.childTokens[ext.name] = ext.childTokens;\n          }\n        });\n      } // ==-- Parse \"overwrite\" extensions --== //\n\n\n      if (pack.renderer) {\n        (function () {\n          var renderer = marked.defaults.renderer || new Renderer();\n\n          var _loop = function _loop(prop) {\n            var prevRenderer = renderer[prop]; // Replace renderer with func to run extension, but fall back if false\n\n            renderer[prop] = function () {\n              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                args[_key3] = arguments[_key3];\n              }\n\n              var ret = pack.renderer[prop].apply(renderer, args);\n\n              if (ret === false) {\n                ret = prevRenderer.apply(renderer, args);\n              }\n\n              return ret;\n            };\n          };\n\n          for (var prop in pack.renderer) {\n            _loop(prop);\n          }\n\n          opts.renderer = renderer;\n        })();\n      }\n\n      if (pack.tokenizer) {\n        (function () {\n          var tokenizer = marked.defaults.tokenizer || new Tokenizer();\n\n          var _loop2 = function _loop2(prop) {\n            var prevTokenizer = tokenizer[prop]; // Replace tokenizer with func to run extension, but fall back if false\n\n            tokenizer[prop] = function () {\n              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                args[_key4] = arguments[_key4];\n              }\n\n              var ret = pack.tokenizer[prop].apply(tokenizer, args);\n\n              if (ret === false) {\n                ret = prevTokenizer.apply(tokenizer, args);\n              }\n\n              return ret;\n            };\n          };\n\n          for (var prop in pack.tokenizer) {\n            _loop2(prop);\n          }\n\n          opts.tokenizer = tokenizer;\n        })();\n      } // ==-- Parse WalkTokens extensions --== //\n\n\n      if (pack.walkTokens) {\n        var _walkTokens = marked.defaults.walkTokens;\n\n        opts.walkTokens = function (token) {\n          pack.walkTokens.call(this, token);\n\n          if (_walkTokens) {\n            _walkTokens.call(this, token);\n          }\n        };\n      }\n\n      if (hasExtensions) {\n        opts.extensions = extensions;\n      }\n\n      marked.setOptions(opts);\n    });\n  };\n  /**\n   * Run callback for every token\n   */\n\n\n  marked.walkTokens = function (tokens, callback) {\n    var _loop3 = function _loop3() {\n      var token = _step.value;\n      callback.call(marked, token);\n\n      switch (token.type) {\n        case 'table':\n          {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {\n              var cell = _step2.value;\n              marked.walkTokens(cell.tokens, callback);\n            }\n\n            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {\n              var row = _step3.value;\n\n              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {\n                var _cell = _step4.value;\n                marked.walkTokens(_cell.tokens, callback);\n              }\n            }\n\n            break;\n          }\n\n        case 'list':\n          {\n            marked.walkTokens(token.items, callback);\n            break;\n          }\n\n        default:\n          {\n            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {\n              // Walk any extensions\n              marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {\n                marked.walkTokens(token[childTokens], callback);\n              });\n            } else if (token.tokens) {\n              marked.walkTokens(token.tokens, callback);\n            }\n          }\n      }\n    };\n\n    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {\n      _loop3();\n    }\n  };\n  /**\n   * Parse Inline\n   * @param {string} src\n   */\n\n\n  marked.parseInline = function (src, opt) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked.parseInline(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n\n    try {\n      var tokens = Lexer.lexInline(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n\n      return Parser.parseInline(tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  };\n  /**\n   * Expose\n   */\n\n\n  marked.Parser = Parser;\n  marked.parser = Parser.parse;\n  marked.Renderer = Renderer;\n  marked.TextRenderer = TextRenderer;\n  marked.Lexer = Lexer;\n  marked.lexer = Lexer.lex;\n  marked.Tokenizer = Tokenizer;\n  marked.Slugger = Slugger;\n  marked.parse = marked;\n  var options = marked.options;\n  var setOptions = marked.setOptions;\n  var use = marked.use;\n  var walkTokens = marked.walkTokens;\n  var parseInline = marked.parseInline;\n  var parse = marked;\n  var parser = Parser.parse;\n  var lexer = Lexer.lex;\n\n  exports.Lexer = Lexer;\n  exports.Parser = Parser;\n  exports.Renderer = Renderer;\n  exports.Slugger = Slugger;\n  exports.TextRenderer = TextRenderer;\n  exports.Tokenizer = Tokenizer;\n  exports.getDefaults = getDefaults;\n  exports.lexer = lexer;\n  exports.marked = marked;\n  exports.options = options;\n  exports.parse = parse;\n  exports.parseInline = parseInline;\n  exports.parser = parser;\n  exports.setOptions = setOptions;\n  exports.use = use;\n  exports.walkTokens = walkTokens;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n// ESM-uncomment-begin\n})();\nexport var marked = (__marked_exports || exports);\n// ESM-uncomment-end\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Codicon } from '../../../base/common/codicons.js';\nimport Severity from '../../../base/common/severity.js';\nimport { problemsErrorIconForeground, problemsInfoIconForeground, problemsWarningIconForeground } from '../../theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../theme/common/themeService.js';\nexport var SeverityIcon;\n(function (SeverityIcon) {\n    function className(severity) {\n        switch (severity) {\n            case Severity.Ignore:\n                return 'severity-ignore ' + Codicon.info.classNames;\n            case Severity.Info:\n                return Codicon.info.classNames;\n            case Severity.Warning:\n                return Codicon.warning.classNames;\n            case Severity.Error:\n                return Codicon.error.classNames;\n            default:\n                return '';\n        }\n    }\n    SeverityIcon.className = className;\n})(SeverityIcon || (SeverityIcon = {}));\nregisterThemingParticipant((theme, collector) => {\n    const errorIconForeground = theme.getColor(problemsErrorIconForeground);\n    if (errorIconForeground) {\n        const errorCodiconSelector = Codicon.error.cssSelector;\n        collector.addRule(`\n\t\t\t.monaco-editor .zone-widget ${errorCodiconSelector},\n\t\t\t.markers-panel .marker-icon${errorCodiconSelector},\n\t\t\t.text-search-provider-messages .providerMessage ${errorCodiconSelector},\n\t\t\t.extensions-viewlet > .extensions ${errorCodiconSelector} {\n\t\t\t\tcolor: ${errorIconForeground};\n\t\t\t}\n\t\t`);\n    }\n    const warningIconForeground = theme.getColor(problemsWarningIconForeground);\n    if (warningIconForeground) {\n        const warningCodiconSelector = Codicon.warning.cssSelector;\n        collector.addRule(`\n\t\t\t.monaco-editor .zone-widget ${warningCodiconSelector},\n\t\t\t.markers-panel .marker-icon${warningCodiconSelector},\n\t\t\t.extensions-viewlet > .extensions ${warningCodiconSelector},\n\t\t\t.extension-editor ${warningCodiconSelector},\n\t\t\t.text-search-provider-messages .providerMessage ${warningCodiconSelector},\n\t\t\t.preferences-editor ${warningCodiconSelector} {\n\t\t\t\tcolor: ${warningIconForeground};\n\t\t\t}\n\t\t`);\n    }\n    const infoIconForeground = theme.getColor(problemsInfoIconForeground);\n    if (infoIconForeground) {\n        const infoCodiconSelector = Codicon.info.cssSelector;\n        collector.addRule(`\n\t\t\t.monaco-editor .zone-widget ${infoCodiconSelector},\n\t\t\t.markers-panel .marker-icon${infoCodiconSelector},\n\t\t\t.extensions-viewlet > .extensions ${infoCodiconSelector},\n\t\t\t.text-search-provider-messages .providerMessage ${infoCodiconSelector},\n\t\t\t.extension-editor ${infoCodiconSelector} {\n\t\t\t\tcolor: ${infoIconForeground};\n\t\t\t}\n\t\t`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as dom from '../../../../base/browser/dom.js';\nimport { ScrollableElement } from '../../../../base/browser/ui/scrollbar/scrollableElement.js';\nimport { isNonEmptyArray } from '../../../../base/common/arrays.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { DisposableStore, dispose } from '../../../../base/common/lifecycle.js';\nimport { basename } from '../../../../base/common/resources.js';\nimport { splitLines } from '../../../../base/common/strings.js';\nimport './media/gotoErrorWidget.css';\nimport { Range } from '../../../common/core/range.js';\nimport { peekViewTitleForeground, peekViewTitleInfoForeground, PeekViewWidget } from '../../peekView/browser/peekView.js';\nimport * as nls from '../../../../nls.js';\nimport { createAndFillInActionBarActions } from '../../../../platform/actions/browser/menuEntryActionViewItem.js';\nimport { IMenuService, MenuId } from '../../../../platform/actions/common/actions.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { MarkerSeverity } from '../../../../platform/markers/common/markers.js';\nimport { IOpenerService } from '../../../../platform/opener/common/opener.js';\nimport { SeverityIcon } from '../../../../platform/severityIcon/common/severityIcon.js';\nimport { contrastBorder, editorBackground, editorErrorBorder, editorErrorForeground, editorInfoBorder, editorInfoForeground, editorWarningBorder, editorWarningForeground, oneOf, registerColor, transparent } from '../../../../platform/theme/common/colorRegistry.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nclass MessageWidget {\n    constructor(parent, editor, onRelatedInformation, _openerService, _labelService) {\n        this._openerService = _openerService;\n        this._labelService = _labelService;\n        this._lines = 0;\n        this._longestLineLength = 0;\n        this._relatedDiagnostics = new WeakMap();\n        this._disposables = new DisposableStore();\n        this._editor = editor;\n        const domNode = document.createElement('div');\n        domNode.className = 'descriptioncontainer';\n        this._messageBlock = document.createElement('div');\n        this._messageBlock.classList.add('message');\n        this._messageBlock.setAttribute('aria-live', 'assertive');\n        this._messageBlock.setAttribute('role', 'alert');\n        domNode.appendChild(this._messageBlock);\n        this._relatedBlock = document.createElement('div');\n        domNode.appendChild(this._relatedBlock);\n        this._disposables.add(dom.addStandardDisposableListener(this._relatedBlock, 'click', event => {\n            event.preventDefault();\n            const related = this._relatedDiagnostics.get(event.target);\n            if (related) {\n                onRelatedInformation(related);\n            }\n        }));\n        this._scrollable = new ScrollableElement(domNode, {\n            horizontal: 1 /* ScrollbarVisibility.Auto */,\n            vertical: 1 /* ScrollbarVisibility.Auto */,\n            useShadows: false,\n            horizontalScrollbarSize: 6,\n            verticalScrollbarSize: 6\n        });\n        parent.appendChild(this._scrollable.getDomNode());\n        this._disposables.add(this._scrollable.onScroll(e => {\n            domNode.style.left = `-${e.scrollLeft}px`;\n            domNode.style.top = `-${e.scrollTop}px`;\n        }));\n        this._disposables.add(this._scrollable);\n    }\n    dispose() {\n        dispose(this._disposables);\n    }\n    update(marker) {\n        const { source, message, relatedInformation, code } = marker;\n        let sourceAndCodeLength = ((source === null || source === void 0 ? void 0 : source.length) || 0) + '()'.length;\n        if (code) {\n            if (typeof code === 'string') {\n                sourceAndCodeLength += code.length;\n            }\n            else {\n                sourceAndCodeLength += code.value.length;\n            }\n        }\n        const lines = splitLines(message);\n        this._lines = lines.length;\n        this._longestLineLength = 0;\n        for (const line of lines) {\n            this._longestLineLength = Math.max(line.length + sourceAndCodeLength, this._longestLineLength);\n        }\n        dom.clearNode(this._messageBlock);\n        this._messageBlock.setAttribute('aria-label', this.getAriaLabel(marker));\n        this._editor.applyFontInfo(this._messageBlock);\n        let lastLineElement = this._messageBlock;\n        for (const line of lines) {\n            lastLineElement = document.createElement('div');\n            lastLineElement.innerText = line;\n            if (line === '') {\n                lastLineElement.style.height = this._messageBlock.style.lineHeight;\n            }\n            this._messageBlock.appendChild(lastLineElement);\n        }\n        if (source || code) {\n            const detailsElement = document.createElement('span');\n            detailsElement.classList.add('details');\n            lastLineElement.appendChild(detailsElement);\n            if (source) {\n                const sourceElement = document.createElement('span');\n                sourceElement.innerText = source;\n                sourceElement.classList.add('source');\n                detailsElement.appendChild(sourceElement);\n            }\n            if (code) {\n                if (typeof code === 'string') {\n                    const codeElement = document.createElement('span');\n                    codeElement.innerText = `(${code})`;\n                    codeElement.classList.add('code');\n                    detailsElement.appendChild(codeElement);\n                }\n                else {\n                    this._codeLink = dom.$('a.code-link');\n                    this._codeLink.setAttribute('href', `${code.target.toString()}`);\n                    this._codeLink.onclick = (e) => {\n                        this._openerService.open(code.target, { allowCommands: true });\n                        e.preventDefault();\n                        e.stopPropagation();\n                    };\n                    const codeElement = dom.append(this._codeLink, dom.$('span'));\n                    codeElement.innerText = code.value;\n                    detailsElement.appendChild(this._codeLink);\n                }\n            }\n        }\n        dom.clearNode(this._relatedBlock);\n        this._editor.applyFontInfo(this._relatedBlock);\n        if (isNonEmptyArray(relatedInformation)) {\n            const relatedInformationNode = this._relatedBlock.appendChild(document.createElement('div'));\n            relatedInformationNode.style.paddingTop = `${Math.floor(this._editor.getOption(61 /* EditorOption.lineHeight */) * 0.66)}px`;\n            this._lines += 1;\n            for (const related of relatedInformation) {\n                const container = document.createElement('div');\n                const relatedResource = document.createElement('a');\n                relatedResource.classList.add('filename');\n                relatedResource.innerText = `${this._labelService.getUriBasenameLabel(related.resource)}(${related.startLineNumber}, ${related.startColumn}): `;\n                relatedResource.title = this._labelService.getUriLabel(related.resource);\n                this._relatedDiagnostics.set(relatedResource, related);\n                const relatedMessage = document.createElement('span');\n                relatedMessage.innerText = related.message;\n                container.appendChild(relatedResource);\n                container.appendChild(relatedMessage);\n                this._lines += 1;\n                relatedInformationNode.appendChild(container);\n            }\n        }\n        const fontInfo = this._editor.getOption(46 /* EditorOption.fontInfo */);\n        const scrollWidth = Math.ceil(fontInfo.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75);\n        const scrollHeight = fontInfo.lineHeight * this._lines;\n        this._scrollable.setScrollDimensions({ scrollWidth, scrollHeight });\n    }\n    layout(height, width) {\n        this._scrollable.getDomNode().style.height = `${height}px`;\n        this._scrollable.getDomNode().style.width = `${width}px`;\n        this._scrollable.setScrollDimensions({ width, height });\n    }\n    getHeightInLines() {\n        return Math.min(17, this._lines);\n    }\n    getAriaLabel(marker) {\n        let severityLabel = '';\n        switch (marker.severity) {\n            case MarkerSeverity.Error:\n                severityLabel = nls.localize('Error', \"Error\");\n                break;\n            case MarkerSeverity.Warning:\n                severityLabel = nls.localize('Warning', \"Warning\");\n                break;\n            case MarkerSeverity.Info:\n                severityLabel = nls.localize('Info', \"Info\");\n                break;\n            case MarkerSeverity.Hint:\n                severityLabel = nls.localize('Hint', \"Hint\");\n                break;\n        }\n        let ariaLabel = nls.localize('marker aria', \"{0} at {1}. \", severityLabel, marker.startLineNumber + ':' + marker.startColumn);\n        const model = this._editor.getModel();\n        if (model && (marker.startLineNumber <= model.getLineCount()) && (marker.startLineNumber >= 1)) {\n            const lineContent = model.getLineContent(marker.startLineNumber);\n            ariaLabel = `${lineContent}, ${ariaLabel}`;\n        }\n        return ariaLabel;\n    }\n}\nlet MarkerNavigationWidget = class MarkerNavigationWidget extends PeekViewWidget {\n    constructor(editor, _themeService, _openerService, _menuService, instantiationService, _contextKeyService, _labelService) {\n        super(editor, { showArrow: true, showFrame: true, isAccessible: true, frameWidth: 1 }, instantiationService);\n        this._themeService = _themeService;\n        this._openerService = _openerService;\n        this._menuService = _menuService;\n        this._contextKeyService = _contextKeyService;\n        this._labelService = _labelService;\n        this._callOnDispose = new DisposableStore();\n        this._onDidSelectRelatedInformation = new Emitter();\n        this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event;\n        this._severity = MarkerSeverity.Warning;\n        this._backgroundColor = Color.white;\n        this._applyTheme(_themeService.getColorTheme());\n        this._callOnDispose.add(_themeService.onDidColorThemeChange(this._applyTheme.bind(this)));\n        this.create();\n    }\n    _applyTheme(theme) {\n        this._backgroundColor = theme.getColor(editorMarkerNavigationBackground);\n        let colorId = editorMarkerNavigationError;\n        let headerBackground = editorMarkerNavigationErrorHeader;\n        if (this._severity === MarkerSeverity.Warning) {\n            colorId = editorMarkerNavigationWarning;\n            headerBackground = editorMarkerNavigationWarningHeader;\n        }\n        else if (this._severity === MarkerSeverity.Info) {\n            colorId = editorMarkerNavigationInfo;\n            headerBackground = editorMarkerNavigationInfoHeader;\n        }\n        const frameColor = theme.getColor(colorId);\n        const headerBg = theme.getColor(headerBackground);\n        this.style({\n            arrowColor: frameColor,\n            frameColor: frameColor,\n            headerBackgroundColor: headerBg,\n            primaryHeadingColor: theme.getColor(peekViewTitleForeground),\n            secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)\n        }); // style() will trigger _applyStyles\n    }\n    _applyStyles() {\n        if (this._parentContainer) {\n            this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : '';\n        }\n        super._applyStyles();\n    }\n    dispose() {\n        this._callOnDispose.dispose();\n        super.dispose();\n    }\n    _fillHead(container) {\n        super._fillHead(container);\n        this._disposables.add(this._actionbarWidget.actionRunner.onBeforeRun(e => this.editor.focus()));\n        const actions = [];\n        const menu = this._menuService.createMenu(MarkerNavigationWidget.TitleMenu, this._contextKeyService);\n        createAndFillInActionBarActions(menu, undefined, actions);\n        this._actionbarWidget.push(actions, { label: false, icon: true, index: 0 });\n        menu.dispose();\n    }\n    _fillTitleIcon(container) {\n        this._icon = dom.append(container, dom.$(''));\n    }\n    _fillBody(container) {\n        this._parentContainer = container;\n        container.classList.add('marker-widget');\n        this._parentContainer.tabIndex = 0;\n        this._parentContainer.setAttribute('role', 'tooltip');\n        this._container = document.createElement('div');\n        container.appendChild(this._container);\n        this._message = new MessageWidget(this._container, this.editor, related => this._onDidSelectRelatedInformation.fire(related), this._openerService, this._labelService);\n        this._disposables.add(this._message);\n    }\n    show() {\n        throw new Error('call showAtMarker');\n    }\n    showAtMarker(marker, markerIdx, markerCount) {\n        // update:\n        // * title\n        // * message\n        this._container.classList.remove('stale');\n        this._message.update(marker);\n        // update frame color (only applied on 'show')\n        this._severity = marker.severity;\n        this._applyTheme(this._themeService.getColorTheme());\n        // show\n        const range = Range.lift(marker);\n        const editorPosition = this.editor.getPosition();\n        const position = editorPosition && range.containsPosition(editorPosition) ? editorPosition : range.getStartPosition();\n        super.show(position, this.computeRequiredHeight());\n        const model = this.editor.getModel();\n        if (model) {\n            const detail = markerCount > 1\n                ? nls.localize('problems', \"{0} of {1} problems\", markerIdx, markerCount)\n                : nls.localize('change', \"{0} of {1} problem\", markerIdx, markerCount);\n            this.setTitle(basename(model.uri), detail);\n        }\n        this._icon.className = `codicon ${SeverityIcon.className(MarkerSeverity.toSeverity(this._severity))}`;\n        this.editor.revealPositionNearTop(position, 0 /* ScrollType.Smooth */);\n        this.editor.focus();\n    }\n    updateMarker(marker) {\n        this._container.classList.remove('stale');\n        this._message.update(marker);\n    }\n    showStale() {\n        this._container.classList.add('stale');\n        this._relayout();\n    }\n    _doLayoutBody(heightInPixel, widthInPixel) {\n        super._doLayoutBody(heightInPixel, widthInPixel);\n        this._heightInPixel = heightInPixel;\n        this._message.layout(heightInPixel, widthInPixel);\n        this._container.style.height = `${heightInPixel}px`;\n    }\n    _onWidth(widthInPixel) {\n        this._message.layout(this._heightInPixel, widthInPixel);\n    }\n    _relayout() {\n        super._relayout(this.computeRequiredHeight());\n    }\n    computeRequiredHeight() {\n        return 3 + this._message.getHeightInLines();\n    }\n};\nMarkerNavigationWidget.TitleMenu = new MenuId('gotoErrorTitleMenu');\nMarkerNavigationWidget = __decorate([\n    __param(1, IThemeService),\n    __param(2, IOpenerService),\n    __param(3, IMenuService),\n    __param(4, IInstantiationService),\n    __param(5, IContextKeyService),\n    __param(6, ILabelService)\n], MarkerNavigationWidget);\nexport { MarkerNavigationWidget };\n// theming\nconst errorDefault = oneOf(editorErrorForeground, editorErrorBorder);\nconst warningDefault = oneOf(editorWarningForeground, editorWarningBorder);\nconst infoDefault = oneOf(editorInfoForeground, editorInfoBorder);\nexport const editorMarkerNavigationError = registerColor('editorMarkerNavigationError.background', { dark: errorDefault, light: errorDefault, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorMarkerNavigationError', 'Editor marker navigation widget error color.'));\nexport const editorMarkerNavigationErrorHeader = registerColor('editorMarkerNavigationError.headerBackground', { dark: transparent(editorMarkerNavigationError, .1), light: transparent(editorMarkerNavigationError, .1), hcDark: null, hcLight: null }, nls.localize('editorMarkerNavigationErrorHeaderBackground', 'Editor marker navigation widget error heading background.'));\nexport const editorMarkerNavigationWarning = registerColor('editorMarkerNavigationWarning.background', { dark: warningDefault, light: warningDefault, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorMarkerNavigationWarning', 'Editor marker navigation widget warning color.'));\nexport const editorMarkerNavigationWarningHeader = registerColor('editorMarkerNavigationWarning.headerBackground', { dark: transparent(editorMarkerNavigationWarning, .1), light: transparent(editorMarkerNavigationWarning, .1), hcDark: '#0C141F', hcLight: transparent(editorMarkerNavigationWarning, .2) }, nls.localize('editorMarkerNavigationWarningBackground', 'Editor marker navigation widget warning heading background.'));\nexport const editorMarkerNavigationInfo = registerColor('editorMarkerNavigationInfo.background', { dark: infoDefault, light: infoDefault, hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorMarkerNavigationInfo', 'Editor marker navigation widget info color.'));\nexport const editorMarkerNavigationInfoHeader = registerColor('editorMarkerNavigationInfo.headerBackground', { dark: transparent(editorMarkerNavigationInfo, .1), light: transparent(editorMarkerNavigationInfo, .1), hcDark: null, hcLight: null }, nls.localize('editorMarkerNavigationInfoHeaderBackground', 'Editor marker navigation widget info heading background.'));\nexport const editorMarkerNavigationBackground = registerColor('editorMarkerNavigation.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorMarkerNavigationBackground', 'Editor marker navigation widget background.'));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DataTransfers } from '../../base/browser/dnd.js';\nimport { distinct } from '../../base/common/arrays.js';\nimport { createFileDataTransferItem, createStringDataTransferItem, VSDataTransfer } from '../../base/common/dataTransfer.js';\nimport { Mimes } from '../../base/common/mime.js';\nimport { URI } from '../../base/common/uri.js';\nimport { CodeDataTransfers, extractEditorsDropData } from '../../platform/dnd/browser/dnd.js';\nexport function toVSDataTransfer(dataTransfer) {\n    const vsDataTransfer = new VSDataTransfer();\n    for (const item of dataTransfer.items) {\n        const type = item.type;\n        if (item.kind === 'string') {\n            const asStringValue = new Promise(resolve => item.getAsString(resolve));\n            vsDataTransfer.append(type, createStringDataTransferItem(asStringValue));\n        }\n        else if (item.kind === 'file') {\n            const file = item.getAsFile();\n            if (file) {\n                vsDataTransfer.append(type, createFileDataTransferItemFromFile(file));\n            }\n        }\n    }\n    return vsDataTransfer;\n}\nexport function createFileDataTransferItemFromFile(file) {\n    const uri = file.path ? URI.parse(file.path) : undefined;\n    return createFileDataTransferItem(file.name, uri, () => __awaiter(this, void 0, void 0, function* () {\n        return new Uint8Array(yield file.arrayBuffer());\n    }));\n}\nconst INTERNAL_DND_MIME_TYPES = Object.freeze([\n    CodeDataTransfers.EDITORS,\n    CodeDataTransfers.FILES,\n    DataTransfers.RESOURCES,\n]);\nexport function addExternalEditorsDropData(dataTransfer, dragEvent, overwriteUriList = false) {\n    var _a;\n    if (dragEvent.dataTransfer && (overwriteUriList || !dataTransfer.has(Mimes.uriList))) {\n        const editorData = extractEditorsDropData(dragEvent)\n            .filter(input => input.resource)\n            .map(input => input.resource.toString());\n        // Also add in the files\n        for (const item of (_a = dragEvent.dataTransfer) === null || _a === void 0 ? void 0 : _a.items) {\n            const file = item.getAsFile();\n            if (file) {\n                editorData.push(file.path ? URI.file(file.path).toString() : file.name);\n            }\n        }\n        if (editorData.length) {\n            dataTransfer.replace(Mimes.uriList, createStringDataTransferItem(UriList.create(editorData)));\n        }\n    }\n    for (const internal of INTERNAL_DND_MIME_TYPES) {\n        dataTransfer.delete(internal);\n    }\n}\nexport const UriList = Object.freeze({\n    // http://amundsen.com/hypermedia/urilist/\n    create: (entries) => {\n        return distinct(entries.map(x => x.toString())).join('\\r\\n');\n    },\n    parse: (str) => {\n        return str.split('\\r\\n').filter(value => !value.startsWith('#'));\n    }\n});\n","import { hasDriveLetter } from './extpath.js';\nimport { isWindows } from './platform.js';\nexport function normalizeDriveLetter(path, isWindowsOS = isWindows) {\n    if (hasDriveLetter(path, isWindowsOS)) {\n        return path.charAt(0).toUpperCase() + path.slice(1);\n    }\n    return path;\n}\nlet normalizedUserHomeCached = Object.create(null);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport class LineCommentCommand {\n    constructor(languageConfigurationService, selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._selection = selection;\n        this._tabSize = tabSize;\n        this._type = type;\n        this._insertSpace = insertSpace;\n        this._selectionId = null;\n        this._deltaColumn = 0;\n        this._moveEndPositionDown = false;\n        this._ignoreEmptyLines = ignoreEmptyLines;\n        this._ignoreFirstLine = ignoreFirstLine || false;\n    }\n    /**\n     * Do an initial pass over the lines and gather info about the line comment string.\n     * Returns null if any of the lines doesn't support a line comment string.\n     */\n    static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {\n        model.tokenization.tokenizeIfCheap(startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n        const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        const commentStr = (config ? config.lineCommentToken : null);\n        if (!commentStr) {\n            // Mode does not support line comments\n            return null;\n        }\n        const lines = [];\n        for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n            lines[i] = {\n                ignore: false,\n                commentStr: commentStr,\n                commentStrOffset: 0,\n                commentStrLength: commentStr.length\n            };\n        }\n        return lines;\n    }\n    /**\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\n     */\n    static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n        let onlyWhitespaceLines = true;\n        let shouldRemoveComments;\n        if (type === 0 /* Type.Toggle */) {\n            shouldRemoveComments = true;\n        }\n        else if (type === 1 /* Type.ForceAdd */) {\n            shouldRemoveComments = false;\n        }\n        else {\n            shouldRemoveComments = true;\n        }\n        for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n            const lineData = lines[i];\n            const lineNumber = startLineNumber + i;\n            if (lineNumber === startLineNumber && ignoreFirstLine) {\n                // first line ignored\n                lineData.ignore = true;\n                continue;\n            }\n            const lineContent = model.getLineContent(lineNumber);\n            const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n            if (lineContentStartOffset === -1) {\n                // Empty or whitespace only line\n                lineData.ignore = ignoreEmptyLines;\n                lineData.commentStrOffset = lineContent.length;\n                continue;\n            }\n            onlyWhitespaceLines = false;\n            lineData.ignore = false;\n            lineData.commentStrOffset = lineContentStartOffset;\n            if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n                if (type === 0 /* Type.Toggle */) {\n                    // Every line so far has been a line comment, but this one is not\n                    shouldRemoveComments = false;\n                }\n                else if (type === 1 /* Type.ForceAdd */) {\n                    // Will not happen\n                }\n                else {\n                    lineData.ignore = true;\n                }\n            }\n            if (shouldRemoveComments && insertSpace) {\n                // Remove a following space if present\n                const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* CharCode.Space */) {\n                    lineData.commentStrLength += 1;\n                }\n            }\n        }\n        if (type === 0 /* Type.Toggle */ && onlyWhitespaceLines) {\n            // For only whitespace lines, we insert comments\n            shouldRemoveComments = false;\n            // Also, no longer ignore them\n            for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n                lines[i].ignore = false;\n            }\n        }\n        return {\n            supported: true,\n            shouldRemoveComments: shouldRemoveComments,\n            lines: lines\n        };\n    }\n    /**\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n     */\n    static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n        const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n        if (lines === null) {\n            return {\n                supported: false\n            };\n        }\n        return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);\n    }\n    /**\n     * Given a successful analysis, execute either insert line comments, either remove line comments\n     */\n    _executeLineComments(model, builder, data, s) {\n        let ops;\n        if (data.shouldRemoveComments) {\n            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        else {\n            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n            ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n        for (let i = 0, len = ops.length; i < len; i++) {\n            builder.addEditOperation(ops[i].range, ops[i].text);\n            if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n                const lineContent = model.getLineContent(cursorPosition.lineNumber);\n                if (lineContent.length + 1 === cursorPosition.column) {\n                    this._deltaColumn = (ops[i].text || '').length;\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    _attemptRemoveBlockComment(model, s, startToken, endToken) {\n        let startLineNumber = s.startLineNumber;\n        let endLineNumber = s.endLineNumber;\n        const startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n        let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n        let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n        if (startTokenIndex !== -1 && endTokenIndex === -1) {\n            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            endLineNumber = startLineNumber;\n        }\n        if (startTokenIndex === -1 && endTokenIndex !== -1) {\n            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n            startLineNumber = endLineNumber;\n        }\n        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n            if (startTokenIndex !== -1) {\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            }\n        }\n        // We have to adjust to possible inner white space.\n        // For Space after startToken, add Space to startToken - range math will work out.\n        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* CharCode.Space */) {\n            startToken += ' ';\n        }\n        // For Space before endToken, add Space before endToken and shift index one left.\n        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* CharCode.Space */) {\n            endToken = ' ' + endToken;\n            endTokenIndex -= 1;\n        }\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n        }\n        return null;\n    }\n    /**\n     * Given an unsuccessful analysis, delegate to the block comment command\n     */\n    _executeBlockComment(model, builder, s) {\n        model.tokenization.tokenizeIfCheap(s.startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n        const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n            // Mode does not support block comments\n            return;\n        }\n        const startToken = config.blockCommentStartToken;\n        const endToken = config.blockCommentEndToken;\n        let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n        if (!ops) {\n            if (s.isEmpty()) {\n                const lineContent = model.getLineContent(s.startLineNumber);\n                let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n                if (firstNonWhitespaceIndex === -1) {\n                    // Line is empty or contains only whitespace\n                    firstNonWhitespaceIndex = lineContent.length;\n                }\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n            }\n            else {\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n            }\n            if (ops.length === 1) {\n                // Leave cursor after token and Space\n                this._deltaColumn = startToken.length + 1;\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n        for (const op of ops) {\n            builder.addEditOperation(op.range, op.text);\n        }\n    }\n    getEditOperations(model, builder) {\n        let s = this._selection;\n        this._moveEndPositionDown = false;\n        if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n            builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n            this._selectionId = builder.trackSelection(s);\n            return;\n        }\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);\n        if (data.supported) {\n            return this._executeLineComments(model, builder, data, s);\n        }\n        return this._executeBlockComment(model, builder, s);\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n    }\n    /**\n     * Generate edit operations in the remove line comment case\n     */\n    static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n        const res = [];\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n        }\n        return res;\n    }\n    /**\n     * Generate edit operations in the add line comment case\n     */\n    _createAddLineCommentsOperations(lines, startLineNumber) {\n        const res = [];\n        const afterCommentStr = this._insertSpace ? ' ' : '';\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n        }\n        return res;\n    }\n    static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\n        if (isTab) {\n            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n        }\n        return currentVisibleColumn + columnSize;\n    }\n    /**\n     * Adjust insertion points to have them vertically aligned in the add line comment case\n     */\n    static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {\n        let minVisibleColumn = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        let j;\n        let lenJ;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n            }\n            if (currentVisibleColumn < minVisibleColumn) {\n                minVisibleColumn = currentVisibleColumn;\n            }\n        }\n        minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n            }\n            if (currentVisibleColumn > minVisibleColumn) {\n                lines[i].commentStrOffset = j - 1;\n            }\n            else {\n                lines[i].commentStrOffset = j;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { buildReplaceStringWithCasePreserved } from '../../../../base/common/search.js';\n/**\n * Assigned when the replace pattern is entirely static.\n */\nclass StaticValueReplacePattern {\n    constructor(staticValue) {\n        this.staticValue = staticValue;\n        this.kind = 0 /* ReplacePatternKind.StaticValue */;\n    }\n}\n/**\n * Assigned when the replace pattern has replacement patterns.\n */\nclass DynamicPiecesReplacePattern {\n    constructor(pieces) {\n        this.pieces = pieces;\n        this.kind = 1 /* ReplacePatternKind.DynamicPieces */;\n    }\n}\nexport class ReplacePattern {\n    constructor(pieces) {\n        if (!pieces || pieces.length === 0) {\n            this._state = new StaticValueReplacePattern('');\n        }\n        else if (pieces.length === 1 && pieces[0].staticValue !== null) {\n            this._state = new StaticValueReplacePattern(pieces[0].staticValue);\n        }\n        else {\n            this._state = new DynamicPiecesReplacePattern(pieces);\n        }\n    }\n    static fromStaticValue(value) {\n        return new ReplacePattern([ReplacePiece.staticValue(value)]);\n    }\n    get hasReplacementPatterns() {\n        return (this._state.kind === 1 /* ReplacePatternKind.DynamicPieces */);\n    }\n    buildReplaceString(matches, preserveCase) {\n        if (this._state.kind === 0 /* ReplacePatternKind.StaticValue */) {\n            if (preserveCase) {\n                return buildReplaceStringWithCasePreserved(matches, this._state.staticValue);\n            }\n            else {\n                return this._state.staticValue;\n            }\n        }\n        let result = '';\n        for (let i = 0, len = this._state.pieces.length; i < len; i++) {\n            const piece = this._state.pieces[i];\n            if (piece.staticValue !== null) {\n                // static value ReplacePiece\n                result += piece.staticValue;\n                continue;\n            }\n            // match index ReplacePiece\n            let match = ReplacePattern._substitute(piece.matchIndex, matches);\n            if (piece.caseOps !== null && piece.caseOps.length > 0) {\n                const repl = [];\n                const lenOps = piece.caseOps.length;\n                let opIdx = 0;\n                for (let idx = 0, len = match.length; idx < len; idx++) {\n                    if (opIdx >= lenOps) {\n                        repl.push(match.slice(idx));\n                        break;\n                    }\n                    switch (piece.caseOps[opIdx]) {\n                        case 'U':\n                            repl.push(match[idx].toUpperCase());\n                            break;\n                        case 'u':\n                            repl.push(match[idx].toUpperCase());\n                            opIdx++;\n                            break;\n                        case 'L':\n                            repl.push(match[idx].toLowerCase());\n                            break;\n                        case 'l':\n                            repl.push(match[idx].toLowerCase());\n                            opIdx++;\n                            break;\n                        default:\n                            repl.push(match[idx]);\n                    }\n                }\n                match = repl.join('');\n            }\n            result += match;\n        }\n        return result;\n    }\n    static _substitute(matchIndex, matches) {\n        if (matches === null) {\n            return '';\n        }\n        if (matchIndex === 0) {\n            return matches[0];\n        }\n        let remainder = '';\n        while (matchIndex > 0) {\n            if (matchIndex < matches.length) {\n                // A match can be undefined\n                const match = (matches[matchIndex] || '');\n                return match + remainder;\n            }\n            remainder = String(matchIndex % 10) + remainder;\n            matchIndex = Math.floor(matchIndex / 10);\n        }\n        return '$' + remainder;\n    }\n}\n/**\n * A replace piece can either be a static string or an index to a specific match.\n */\nexport class ReplacePiece {\n    constructor(staticValue, matchIndex, caseOps) {\n        this.staticValue = staticValue;\n        this.matchIndex = matchIndex;\n        if (!caseOps || caseOps.length === 0) {\n            this.caseOps = null;\n        }\n        else {\n            this.caseOps = caseOps.slice(0);\n        }\n    }\n    static staticValue(value) {\n        return new ReplacePiece(value, -1, null);\n    }\n    static caseOps(index, caseOps) {\n        return new ReplacePiece(null, index, caseOps);\n    }\n}\nclass ReplacePieceBuilder {\n    constructor(source) {\n        this._source = source;\n        this._lastCharIndex = 0;\n        this._result = [];\n        this._resultLen = 0;\n        this._currentStaticPiece = '';\n    }\n    emitUnchanged(toCharIndex) {\n        this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));\n        this._lastCharIndex = toCharIndex;\n    }\n    emitStatic(value, toCharIndex) {\n        this._emitStatic(value);\n        this._lastCharIndex = toCharIndex;\n    }\n    _emitStatic(value) {\n        if (value.length === 0) {\n            return;\n        }\n        this._currentStaticPiece += value;\n    }\n    emitMatchIndex(index, toCharIndex, caseOps) {\n        if (this._currentStaticPiece.length !== 0) {\n            this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);\n            this._currentStaticPiece = '';\n        }\n        this._result[this._resultLen++] = ReplacePiece.caseOps(index, caseOps);\n        this._lastCharIndex = toCharIndex;\n    }\n    finalize() {\n        this.emitUnchanged(this._source.length);\n        if (this._currentStaticPiece.length !== 0) {\n            this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);\n            this._currentStaticPiece = '';\n        }\n        return new ReplacePattern(this._result);\n    }\n}\n/**\n * \\n\t\t\t=> inserts a LF\n * \\t\t\t\t=> inserts a TAB\n * \\\\\t\t\t=> inserts a \"\\\".\n * \\u\t\t\t=> upper-cases one character in a match.\n * \\U\t\t\t=> upper-cases ALL remaining characters in a match.\n * \\l\t\t\t=> lower-cases one character in a match.\n * \\L\t\t\t=> lower-cases ALL remaining characters in a match.\n * $$\t\t\t=> inserts a \"$\".\n * $& and $0\t=> inserts the matched substring.\n * $n\t\t\t=> Where n is a non-negative integer lesser than 100, inserts the nth parenthesized submatch string\n * everything else stays untouched\n *\n * Also see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter\n */\nexport function parseReplaceString(replaceString) {\n    if (!replaceString || replaceString.length === 0) {\n        return new ReplacePattern(null);\n    }\n    const caseOps = [];\n    const result = new ReplacePieceBuilder(replaceString);\n    for (let i = 0, len = replaceString.length; i < len; i++) {\n        const chCode = replaceString.charCodeAt(i);\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = replaceString.charCodeAt(i);\n            // let replaceWithCharacter: string | null = null;\n            switch (nextChCode) {\n                case 92 /* CharCode.Backslash */:\n                    // \\\\ => inserts a \"\\\"\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('\\\\', i + 1);\n                    break;\n                case 110 /* CharCode.n */:\n                    // \\n => inserts a LF\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('\\n', i + 1);\n                    break;\n                case 116 /* CharCode.t */:\n                    // \\t => inserts a TAB\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('\\t', i + 1);\n                    break;\n                // Case modification of string replacements, patterned after Boost, but only applied\n                // to the replacement text, not subsequent content.\n                case 117 /* CharCode.u */:\n                // \\u => upper-cases one character.\n                case 85 /* CharCode.U */:\n                // \\U => upper-cases ALL following characters.\n                case 108 /* CharCode.l */:\n                // \\l => lower-cases one character.\n                case 76 /* CharCode.L */:\n                    // \\L => lower-cases ALL following characters.\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('', i + 1);\n                    caseOps.push(String.fromCharCode(nextChCode));\n                    break;\n            }\n            continue;\n        }\n        if (chCode === 36 /* CharCode.DollarSign */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a $\n                break;\n            }\n            const nextChCode = replaceString.charCodeAt(i);\n            if (nextChCode === 36 /* CharCode.DollarSign */) {\n                // $$ => inserts a \"$\"\n                result.emitUnchanged(i - 1);\n                result.emitStatic('$', i + 1);\n                continue;\n            }\n            if (nextChCode === 48 /* CharCode.Digit0 */ || nextChCode === 38 /* CharCode.Ampersand */) {\n                // $& and $0 => inserts the matched substring.\n                result.emitUnchanged(i - 1);\n                result.emitMatchIndex(0, i + 1, caseOps);\n                caseOps.length = 0;\n                continue;\n            }\n            if (49 /* CharCode.Digit1 */ <= nextChCode && nextChCode <= 57 /* CharCode.Digit9 */) {\n                // $n\n                let matchIndex = nextChCode - 48 /* CharCode.Digit0 */;\n                // peek next char to probe for $nn\n                if (i + 1 < len) {\n                    const nextNextChCode = replaceString.charCodeAt(i + 1);\n                    if (48 /* CharCode.Digit0 */ <= nextNextChCode && nextNextChCode <= 57 /* CharCode.Digit9 */) {\n                        // $nn\n                        // move to next char\n                        i++;\n                        matchIndex = matchIndex * 10 + (nextNextChCode - 48 /* CharCode.Digit0 */);\n                        result.emitUnchanged(i - 2);\n                        result.emitMatchIndex(matchIndex, i + 1, caseOps);\n                        caseOps.length = 0;\n                        continue;\n                    }\n                }\n                result.emitUnchanged(i - 1);\n                result.emitMatchIndex(matchIndex, i + 1, caseOps);\n                caseOps.length = 0;\n                continue;\n            }\n        }\n    }\n    return result.finalize();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findFirstInSorted } from '../../../../base/common/arrays.js';\nimport { RunOnceScheduler, TimeoutTimer } from '../../../../base/common/async.js';\nimport { DisposableStore, dispose } from '../../../../base/common/lifecycle.js';\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection } from '../../../common/commands/replaceCommand.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { SearchParams } from '../../../common/model/textModelSearch.js';\nimport { FindDecorations } from './findDecorations.js';\nimport { ReplaceAllCommand } from './replaceAllCommand.js';\nimport { parseReplaceString, ReplacePattern } from './replacePattern.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nexport const CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey('findWidgetVisible', false);\nexport const CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();\n// Keep ContextKey use of 'Focussed' to not break when clauses\nexport const CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey('findInputFocussed', false);\nexport const CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey('replaceInputFocussed', false);\nexport const ToggleCaseSensitiveKeybinding = {\n    primary: 512 /* KeyMod.Alt */ | 33 /* KeyCode.KeyC */,\n    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 33 /* KeyCode.KeyC */ }\n};\nexport const ToggleWholeWordKeybinding = {\n    primary: 512 /* KeyMod.Alt */ | 53 /* KeyCode.KeyW */,\n    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 53 /* KeyCode.KeyW */ }\n};\nexport const ToggleRegexKeybinding = {\n    primary: 512 /* KeyMod.Alt */ | 48 /* KeyCode.KeyR */,\n    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 48 /* KeyCode.KeyR */ }\n};\nexport const ToggleSearchScopeKeybinding = {\n    primary: 512 /* KeyMod.Alt */ | 42 /* KeyCode.KeyL */,\n    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 42 /* KeyCode.KeyL */ }\n};\nexport const TogglePreserveCaseKeybinding = {\n    primary: 512 /* KeyMod.Alt */ | 46 /* KeyCode.KeyP */,\n    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 46 /* KeyCode.KeyP */ }\n};\nexport const FIND_IDS = {\n    StartFindAction: 'actions.find',\n    StartFindWithSelection: 'actions.findWithSelection',\n    StartFindWithArgs: 'editor.actions.findWithArgs',\n    NextMatchFindAction: 'editor.action.nextMatchFindAction',\n    PreviousMatchFindAction: 'editor.action.previousMatchFindAction',\n    NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',\n    PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',\n    StartFindReplaceAction: 'editor.action.startFindReplaceAction',\n    CloseFindWidgetCommand: 'closeFindWidget',\n    ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',\n    ToggleWholeWordCommand: 'toggleFindWholeWord',\n    ToggleRegexCommand: 'toggleFindRegex',\n    ToggleSearchScopeCommand: 'toggleFindInSelection',\n    TogglePreserveCaseCommand: 'togglePreserveCase',\n    ReplaceOneAction: 'editor.action.replaceOne',\n    ReplaceAllAction: 'editor.action.replaceAll',\n    SelectAllMatchesAction: 'editor.action.selectAllMatches'\n};\nexport const MATCHES_LIMIT = 19999;\nconst RESEARCH_DELAY = 240;\nexport class FindModelBoundToEditorModel {\n    constructor(editor, state) {\n        this._toDispose = new DisposableStore();\n        this._editor = editor;\n        this._state = state;\n        this._isDisposed = false;\n        this._startSearchingTimer = new TimeoutTimer();\n        this._decorations = new FindDecorations(editor);\n        this._toDispose.add(this._decorations);\n        this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);\n        this._toDispose.add(this._updateDecorationsScheduler);\n        this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {\n            if (e.reason === 3 /* CursorChangeReason.Explicit */\n                || e.reason === 5 /* CursorChangeReason.Undo */\n                || e.reason === 6 /* CursorChangeReason.Redo */) {\n                this._decorations.setStartPosition(this._editor.getPosition());\n            }\n        }));\n        this._ignoreModelContentChanged = false;\n        this._toDispose.add(this._editor.onDidChangeModelContent((e) => {\n            if (this._ignoreModelContentChanged) {\n                return;\n            }\n            if (e.isFlush) {\n                // a model.setValue() was called\n                this._decorations.reset();\n            }\n            this._decorations.setStartPosition(this._editor.getPosition());\n            this._updateDecorationsScheduler.schedule();\n        }));\n        this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));\n        this.research(false, this._state.searchScope);\n    }\n    dispose() {\n        this._isDisposed = true;\n        dispose(this._startSearchingTimer);\n        this._toDispose.dispose();\n    }\n    _onStateChanged(e) {\n        if (this._isDisposed) {\n            // The find model is disposed during a find state changed event\n            return;\n        }\n        if (!this._editor.hasModel()) {\n            // The find model will be disposed momentarily\n            return;\n        }\n        if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {\n            const model = this._editor.getModel();\n            if (model.isTooLargeForSyncing()) {\n                this._startSearchingTimer.cancel();\n                this._startSearchingTimer.setIfNotSet(() => {\n                    if (e.searchScope) {\n                        this.research(e.moveCursor, this._state.searchScope);\n                    }\n                    else {\n                        this.research(e.moveCursor);\n                    }\n                }, RESEARCH_DELAY);\n            }\n            else {\n                if (e.searchScope) {\n                    this.research(e.moveCursor, this._state.searchScope);\n                }\n                else {\n                    this.research(e.moveCursor);\n                }\n            }\n        }\n    }\n    static _getSearchRange(model, findScope) {\n        // If we have set now or before a find scope, use it for computing the search range\n        if (findScope) {\n            return findScope;\n        }\n        return model.getFullModelRange();\n    }\n    research(moveCursor, newFindScope) {\n        let findScopes = null;\n        if (typeof newFindScope !== 'undefined') {\n            if (newFindScope !== null) {\n                if (!Array.isArray(newFindScope)) {\n                    findScopes = [newFindScope];\n                }\n                else {\n                    findScopes = newFindScope;\n                }\n            }\n        }\n        else {\n            findScopes = this._decorations.getFindScopes();\n        }\n        if (findScopes !== null) {\n            findScopes = findScopes.map(findScope => {\n                if (findScope.startLineNumber !== findScope.endLineNumber) {\n                    let endLineNumber = findScope.endLineNumber;\n                    if (findScope.endColumn === 1) {\n                        endLineNumber = endLineNumber - 1;\n                    }\n                    return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));\n                }\n                return findScope;\n            });\n        }\n        const findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);\n        this._decorations.set(findMatches, findScopes);\n        const editorSelection = this._editor.getSelection();\n        let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);\n        if (currentMatchesPosition === 0 && findMatches.length > 0) {\n            // current selection is not on top of a match\n            // try to find its nearest result from the top of the document\n            const matchAfterSelection = findFirstInSorted(findMatches.map(match => match.range), range => Range.compareRangesUsingStarts(range, editorSelection) >= 0);\n            currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 /** match position is one based */ : currentMatchesPosition;\n        }\n        this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), undefined);\n        if (moveCursor && this._editor.getOption(37 /* EditorOption.find */).cursorMoveOnType) {\n            this._moveToNextMatch(this._decorations.getStartPosition());\n        }\n    }\n    _hasMatches() {\n        return (this._state.matchesCount > 0);\n    }\n    _cannotFind() {\n        if (!this._hasMatches()) {\n            const findScope = this._decorations.getFindScope();\n            if (findScope) {\n                // Reveal the selection so user is reminded that 'selection find' is on.\n                this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0 /* ScrollType.Smooth */);\n            }\n            return true;\n        }\n        return false;\n    }\n    _setCurrentFindMatch(match) {\n        const matchesPosition = this._decorations.setCurrentFindMatch(match);\n        this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);\n        this._editor.setSelection(match);\n        this._editor.revealRangeInCenterIfOutsideViewport(match, 0 /* ScrollType.Smooth */);\n    }\n    _prevSearchPosition(before) {\n        const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0\n            || this._state.searchString.indexOf('$') >= 0);\n        let { lineNumber, column } = before;\n        const model = this._editor.getModel();\n        if (isUsingLineStops || column === 1) {\n            if (lineNumber === 1) {\n                lineNumber = model.getLineCount();\n            }\n            else {\n                lineNumber--;\n            }\n            column = model.getLineMaxColumn(lineNumber);\n        }\n        else {\n            column--;\n        }\n        return new Position(lineNumber, column);\n    }\n    _moveToPrevMatch(before, isRecursed = false) {\n        if (!this._state.canNavigateBack()) {\n            // we are beyond the first matched find result\n            // instead of doing nothing, we should refocus the first item\n            const nextMatchRange = this._decorations.matchAfterPosition(before);\n            if (nextMatchRange) {\n                this._setCurrentFindMatch(nextMatchRange);\n            }\n            return;\n        }\n        if (this._decorations.getCount() < MATCHES_LIMIT) {\n            let prevMatchRange = this._decorations.matchBeforePosition(before);\n            if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {\n                before = this._prevSearchPosition(before);\n                prevMatchRange = this._decorations.matchBeforePosition(before);\n            }\n            if (prevMatchRange) {\n                this._setCurrentFindMatch(prevMatchRange);\n            }\n            return;\n        }\n        if (this._cannotFind()) {\n            return;\n        }\n        const findScope = this._decorations.getFindScope();\n        const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n        // ...(----)...|...\n        if (searchRange.getEndPosition().isBefore(before)) {\n            before = searchRange.getEndPosition();\n        }\n        // ...|...(----)...\n        if (before.isBefore(searchRange.getStartPosition())) {\n            before = searchRange.getEndPosition();\n        }\n        const { lineNumber, column } = before;\n        const model = this._editor.getModel();\n        let position = new Position(lineNumber, column);\n        let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, false);\n        if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {\n            // Looks like we're stuck at this position, unacceptable!\n            position = this._prevSearchPosition(position);\n            prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, false);\n        }\n        if (!prevMatch) {\n            // there is precisely one match and selection is on top of it\n            return;\n        }\n        if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {\n            return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);\n        }\n        this._setCurrentFindMatch(prevMatch.range);\n    }\n    moveToPrevMatch() {\n        this._moveToPrevMatch(this._editor.getSelection().getStartPosition());\n    }\n    _nextSearchPosition(after) {\n        const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0\n            || this._state.searchString.indexOf('$') >= 0);\n        let { lineNumber, column } = after;\n        const model = this._editor.getModel();\n        if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber === model.getLineCount()) {\n                lineNumber = 1;\n            }\n            else {\n                lineNumber++;\n            }\n            column = 1;\n        }\n        else {\n            column++;\n        }\n        return new Position(lineNumber, column);\n    }\n    _moveToNextMatch(after) {\n        if (!this._state.canNavigateForward()) {\n            // we are beyond the last matched find result\n            // instead of doing nothing, we should refocus the last item\n            const prevMatchRange = this._decorations.matchBeforePosition(after);\n            if (prevMatchRange) {\n                this._setCurrentFindMatch(prevMatchRange);\n            }\n            return;\n        }\n        if (this._decorations.getCount() < MATCHES_LIMIT) {\n            let nextMatchRange = this._decorations.matchAfterPosition(after);\n            if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {\n                // Looks like we're stuck at this position, unacceptable!\n                after = this._nextSearchPosition(after);\n                nextMatchRange = this._decorations.matchAfterPosition(after);\n            }\n            if (nextMatchRange) {\n                this._setCurrentFindMatch(nextMatchRange);\n            }\n            return;\n        }\n        const nextMatch = this._getNextMatch(after, false, true);\n        if (nextMatch) {\n            this._setCurrentFindMatch(nextMatch.range);\n        }\n    }\n    _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {\n        if (this._cannotFind()) {\n            return null;\n        }\n        const findScope = this._decorations.getFindScope();\n        const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n        // ...(----)...|...\n        if (searchRange.getEndPosition().isBefore(after)) {\n            after = searchRange.getStartPosition();\n        }\n        // ...|...(----)...\n        if (after.isBefore(searchRange.getStartPosition())) {\n            after = searchRange.getStartPosition();\n        }\n        const { lineNumber, column } = after;\n        const model = this._editor.getModel();\n        let position = new Position(lineNumber, column);\n        let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, captureMatches);\n        if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {\n            // Looks like we're stuck at this position, unacceptable!\n            position = this._nextSearchPosition(position);\n            nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, captureMatches);\n        }\n        if (!nextMatch) {\n            // there is precisely one match and selection is on top of it\n            return null;\n        }\n        if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {\n            return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);\n        }\n        return nextMatch;\n    }\n    moveToNextMatch() {\n        this._moveToNextMatch(this._editor.getSelection().getEndPosition());\n    }\n    _getReplacePattern() {\n        if (this._state.isRegex) {\n            return parseReplaceString(this._state.replaceString);\n        }\n        return ReplacePattern.fromStaticValue(this._state.replaceString);\n    }\n    replace() {\n        if (!this._hasMatches()) {\n            return;\n        }\n        const replacePattern = this._getReplacePattern();\n        const selection = this._editor.getSelection();\n        const nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);\n        if (nextMatch) {\n            if (selection.equalsRange(nextMatch.range)) {\n                // selection sits on a find match => replace it!\n                const replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);\n                const command = new ReplaceCommand(selection, replaceString);\n                this._executeEditorCommand('replace', command);\n                this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));\n                this.research(true);\n            }\n            else {\n                this._decorations.setStartPosition(this._editor.getPosition());\n                this._setCurrentFindMatch(nextMatch.range);\n            }\n        }\n    }\n    _findMatches(findScopes, captureMatches, limitResultCount) {\n        const searchRanges = (findScopes || [null]).map((scope) => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));\n        return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, captureMatches, limitResultCount);\n    }\n    replaceAll() {\n        if (!this._hasMatches()) {\n            return;\n        }\n        const findScopes = this._decorations.getFindScopes();\n        if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {\n            // Doing a replace on the entire file that is over ${MATCHES_LIMIT} matches\n            this._largeReplaceAll();\n        }\n        else {\n            this._regularReplaceAll(findScopes);\n        }\n        this.research(false);\n    }\n    _largeReplaceAll() {\n        const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null);\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return;\n        }\n        let searchRegex = searchData.regex;\n        if (!searchRegex.multiline) {\n            let mod = 'mu';\n            if (searchRegex.ignoreCase) {\n                mod += 'i';\n            }\n            if (searchRegex.global) {\n                mod += 'g';\n            }\n            searchRegex = new RegExp(searchRegex.source, mod);\n        }\n        const model = this._editor.getModel();\n        const modelText = model.getValue(1 /* EndOfLinePreference.LF */);\n        const fullModelRange = model.getFullModelRange();\n        const replacePattern = this._getReplacePattern();\n        let resultText;\n        const preserveCase = this._state.preserveCase;\n        if (replacePattern.hasReplacementPatterns || preserveCase) {\n            resultText = modelText.replace(searchRegex, function () {\n                return replacePattern.buildReplaceString(arguments, preserveCase);\n            });\n        }\n        else {\n            resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));\n        }\n        const command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());\n        this._executeEditorCommand('replaceAll', command);\n    }\n    _regularReplaceAll(findScopes) {\n        const replacePattern = this._getReplacePattern();\n        // Get all the ranges (even more than the highlighted ones)\n        const matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        const replaceStrings = [];\n        for (let i = 0, len = matches.length; i < len; i++) {\n            replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);\n        }\n        const command = new ReplaceAllCommand(this._editor.getSelection(), matches.map(m => m.range), replaceStrings);\n        this._executeEditorCommand('replaceAll', command);\n    }\n    selectAllMatches() {\n        if (!this._hasMatches()) {\n            return;\n        }\n        const findScopes = this._decorations.getFindScopes();\n        // Get all the ranges (even more than the highlighted ones)\n        const matches = this._findMatches(findScopes, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        let selections = matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));\n        // If one of the ranges is the editor selection, then maintain it as primary\n        const editorSelection = this._editor.getSelection();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const sel = selections[i];\n            if (sel.equalsRange(editorSelection)) {\n                selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));\n                break;\n            }\n        }\n        this._editor.setSelections(selections);\n    }\n    _executeEditorCommand(source, command) {\n        try {\n            this._ignoreModelContentChanged = true;\n            this._editor.pushUndoStop();\n            this._editor.executeCommand(source, command);\n            this._editor.pushUndoStop();\n        }\n        finally {\n            this._ignoreModelContentChanged = false;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../../base/browser/dom.js';\nimport { CaseSensitiveToggle, RegexToggle, WholeWordsToggle } from '../../../../base/browser/ui/findinput/findInputToggles.js';\nimport { Widget } from '../../../../base/browser/ui/widget.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { FIND_IDS } from './findModel.js';\nimport { contrastBorder, editorWidgetBackground, editorWidgetForeground, inputActiveOptionBackground, inputActiveOptionBorder, inputActiveOptionForeground, widgetShadow } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class FindOptionsWidget extends Widget {\n    constructor(editor, state, keybindingService, themeService) {\n        super();\n        this._hideSoon = this._register(new RunOnceScheduler(() => this._hide(), 2000));\n        this._isVisible = false;\n        this._editor = editor;\n        this._state = state;\n        this._keybindingService = keybindingService;\n        this._domNode = document.createElement('div');\n        this._domNode.className = 'findOptionsWidget';\n        this._domNode.style.display = 'none';\n        this._domNode.style.top = '10px';\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        const inputActiveOptionBorderColor = themeService.getColorTheme().getColor(inputActiveOptionBorder);\n        const inputActiveOptionForegroundColor = themeService.getColorTheme().getColor(inputActiveOptionForeground);\n        const inputActiveOptionBackgroundColor = themeService.getColorTheme().getColor(inputActiveOptionBackground);\n        this.caseSensitive = this._register(new CaseSensitiveToggle({\n            appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),\n            isChecked: this._state.matchCase,\n            inputActiveOptionBorder: inputActiveOptionBorderColor,\n            inputActiveOptionForeground: inputActiveOptionForegroundColor,\n            inputActiveOptionBackground: inputActiveOptionBackgroundColor\n        }));\n        this._domNode.appendChild(this.caseSensitive.domNode);\n        this._register(this.caseSensitive.onChange(() => {\n            this._state.change({\n                matchCase: this.caseSensitive.checked\n            }, false);\n        }));\n        this.wholeWords = this._register(new WholeWordsToggle({\n            appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),\n            isChecked: this._state.wholeWord,\n            inputActiveOptionBorder: inputActiveOptionBorderColor,\n            inputActiveOptionForeground: inputActiveOptionForegroundColor,\n            inputActiveOptionBackground: inputActiveOptionBackgroundColor\n        }));\n        this._domNode.appendChild(this.wholeWords.domNode);\n        this._register(this.wholeWords.onChange(() => {\n            this._state.change({\n                wholeWord: this.wholeWords.checked\n            }, false);\n        }));\n        this.regex = this._register(new RegexToggle({\n            appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),\n            isChecked: this._state.isRegex,\n            inputActiveOptionBorder: inputActiveOptionBorderColor,\n            inputActiveOptionForeground: inputActiveOptionForegroundColor,\n            inputActiveOptionBackground: inputActiveOptionBackgroundColor\n        }));\n        this._domNode.appendChild(this.regex.domNode);\n        this._register(this.regex.onChange(() => {\n            this._state.change({\n                isRegex: this.regex.checked\n            }, false);\n        }));\n        this._editor.addOverlayWidget(this);\n        this._register(this._state.onFindReplaceStateChange((e) => {\n            let somethingChanged = false;\n            if (e.isRegex) {\n                this.regex.checked = this._state.isRegex;\n                somethingChanged = true;\n            }\n            if (e.wholeWord) {\n                this.wholeWords.checked = this._state.wholeWord;\n                somethingChanged = true;\n            }\n            if (e.matchCase) {\n                this.caseSensitive.checked = this._state.matchCase;\n                somethingChanged = true;\n            }\n            if (!this._state.isRevealed && somethingChanged) {\n                this._revealTemporarily();\n            }\n        }));\n        this._register(dom.addDisposableListener(this._domNode, dom.EventType.MOUSE_LEAVE, (e) => this._onMouseLeave()));\n        this._register(dom.addDisposableListener(this._domNode, 'mouseover', (e) => this._onMouseOver()));\n        this._applyTheme(themeService.getColorTheme());\n        this._register(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));\n    }\n    _keybindingLabelFor(actionId) {\n        const kb = this._keybindingService.lookupKeybinding(actionId);\n        if (!kb) {\n            return '';\n        }\n        return ` (${kb.getLabel()})`;\n    }\n    dispose() {\n        this._editor.removeOverlayWidget(this);\n        super.dispose();\n    }\n    // ----- IOverlayWidget API\n    getId() {\n        return FindOptionsWidget.ID;\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    getPosition() {\n        return {\n            preference: 0 /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */\n        };\n    }\n    highlightFindOptions() {\n        this._revealTemporarily();\n    }\n    _revealTemporarily() {\n        this._show();\n        this._hideSoon.schedule();\n    }\n    _onMouseLeave() {\n        this._hideSoon.schedule();\n    }\n    _onMouseOver() {\n        this._hideSoon.cancel();\n    }\n    _show() {\n        if (this._isVisible) {\n            return;\n        }\n        this._isVisible = true;\n        this._domNode.style.display = 'block';\n    }\n    _hide() {\n        if (!this._isVisible) {\n            return;\n        }\n        this._isVisible = false;\n        this._domNode.style.display = 'none';\n    }\n    _applyTheme(theme) {\n        const inputStyles = {\n            inputActiveOptionBorder: theme.getColor(inputActiveOptionBorder),\n            inputActiveOptionForeground: theme.getColor(inputActiveOptionForeground),\n            inputActiveOptionBackground: theme.getColor(inputActiveOptionBackground)\n        };\n        this.caseSensitive.style(inputStyles);\n        this.wholeWords.style(inputStyles);\n        this.regex.style(inputStyles);\n    }\n}\nFindOptionsWidget.ID = 'editor.contrib.findOptionsWidget';\nregisterThemingParticipant((theme, collector) => {\n    const widgetBackground = theme.getColor(editorWidgetBackground);\n    if (widgetBackground) {\n        collector.addRule(`.monaco-editor .findOptionsWidget { background-color: ${widgetBackground}; }`);\n    }\n    const widgetForeground = theme.getColor(editorWidgetForeground);\n    if (widgetForeground) {\n        collector.addRule(`.monaco-editor .findOptionsWidget { color: ${widgetForeground}; }`);\n    }\n    const widgetShadowColor = theme.getColor(widgetShadow);\n    if (widgetShadowColor) {\n        collector.addRule(`.monaco-editor .findOptionsWidget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);\n    }\n    const hcBorder = theme.getColor(contrastBorder);\n    if (hcBorder) {\n        collector.addRule(`.monaco-editor .findOptionsWidget { border: 2px solid ${hcBorder}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../../common/core/range.js';\nimport { MATCHES_LIMIT } from './findModel.js';\nfunction effectiveOptionValue(override, value) {\n    if (override === 1 /* FindOptionOverride.True */) {\n        return true;\n    }\n    if (override === 2 /* FindOptionOverride.False */) {\n        return false;\n    }\n    return value;\n}\nexport class FindReplaceState extends Disposable {\n    constructor() {\n        super();\n        this._onFindReplaceStateChange = this._register(new Emitter());\n        this.onFindReplaceStateChange = this._onFindReplaceStateChange.event;\n        this._searchString = '';\n        this._replaceString = '';\n        this._isRevealed = false;\n        this._isReplaceRevealed = false;\n        this._isRegex = false;\n        this._isRegexOverride = 0 /* FindOptionOverride.NotSet */;\n        this._wholeWord = false;\n        this._wholeWordOverride = 0 /* FindOptionOverride.NotSet */;\n        this._matchCase = false;\n        this._matchCaseOverride = 0 /* FindOptionOverride.NotSet */;\n        this._preserveCase = false;\n        this._preserveCaseOverride = 0 /* FindOptionOverride.NotSet */;\n        this._searchScope = null;\n        this._matchesPosition = 0;\n        this._matchesCount = 0;\n        this._currentMatch = null;\n        this._loop = true;\n        this._isSearching = false;\n        this._filters = null;\n    }\n    get searchString() { return this._searchString; }\n    get replaceString() { return this._replaceString; }\n    get isRevealed() { return this._isRevealed; }\n    get isReplaceRevealed() { return this._isReplaceRevealed; }\n    get isRegex() { return effectiveOptionValue(this._isRegexOverride, this._isRegex); }\n    get wholeWord() { return effectiveOptionValue(this._wholeWordOverride, this._wholeWord); }\n    get matchCase() { return effectiveOptionValue(this._matchCaseOverride, this._matchCase); }\n    get preserveCase() { return effectiveOptionValue(this._preserveCaseOverride, this._preserveCase); }\n    get actualIsRegex() { return this._isRegex; }\n    get actualWholeWord() { return this._wholeWord; }\n    get actualMatchCase() { return this._matchCase; }\n    get actualPreserveCase() { return this._preserveCase; }\n    get searchScope() { return this._searchScope; }\n    get matchesPosition() { return this._matchesPosition; }\n    get matchesCount() { return this._matchesCount; }\n    get currentMatch() { return this._currentMatch; }\n    changeMatchInfo(matchesPosition, matchesCount, currentMatch) {\n        const changeEvent = {\n            moveCursor: false,\n            updateHistory: false,\n            searchString: false,\n            replaceString: false,\n            isRevealed: false,\n            isReplaceRevealed: false,\n            isRegex: false,\n            wholeWord: false,\n            matchCase: false,\n            preserveCase: false,\n            searchScope: false,\n            matchesPosition: false,\n            matchesCount: false,\n            currentMatch: false,\n            loop: false,\n            isSearching: false,\n            filters: false\n        };\n        let somethingChanged = false;\n        if (matchesCount === 0) {\n            matchesPosition = 0;\n        }\n        if (matchesPosition > matchesCount) {\n            matchesPosition = matchesCount;\n        }\n        if (this._matchesPosition !== matchesPosition) {\n            this._matchesPosition = matchesPosition;\n            changeEvent.matchesPosition = true;\n            somethingChanged = true;\n        }\n        if (this._matchesCount !== matchesCount) {\n            this._matchesCount = matchesCount;\n            changeEvent.matchesCount = true;\n            somethingChanged = true;\n        }\n        if (typeof currentMatch !== 'undefined') {\n            if (!Range.equalsRange(this._currentMatch, currentMatch)) {\n                this._currentMatch = currentMatch;\n                changeEvent.currentMatch = true;\n                somethingChanged = true;\n            }\n        }\n        if (somethingChanged) {\n            this._onFindReplaceStateChange.fire(changeEvent);\n        }\n    }\n    change(newState, moveCursor, updateHistory = true) {\n        var _a;\n        const changeEvent = {\n            moveCursor: moveCursor,\n            updateHistory: updateHistory,\n            searchString: false,\n            replaceString: false,\n            isRevealed: false,\n            isReplaceRevealed: false,\n            isRegex: false,\n            wholeWord: false,\n            matchCase: false,\n            preserveCase: false,\n            searchScope: false,\n            matchesPosition: false,\n            matchesCount: false,\n            currentMatch: false,\n            loop: false,\n            isSearching: false,\n            filters: false\n        };\n        let somethingChanged = false;\n        const oldEffectiveIsRegex = this.isRegex;\n        const oldEffectiveWholeWords = this.wholeWord;\n        const oldEffectiveMatchCase = this.matchCase;\n        const oldEffectivePreserveCase = this.preserveCase;\n        if (typeof newState.searchString !== 'undefined') {\n            if (this._searchString !== newState.searchString) {\n                this._searchString = newState.searchString;\n                changeEvent.searchString = true;\n                somethingChanged = true;\n            }\n        }\n        if (typeof newState.replaceString !== 'undefined') {\n            if (this._replaceString !== newState.replaceString) {\n                this._replaceString = newState.replaceString;\n                changeEvent.replaceString = true;\n                somethingChanged = true;\n            }\n        }\n        if (typeof newState.isRevealed !== 'undefined') {\n            if (this._isRevealed !== newState.isRevealed) {\n                this._isRevealed = newState.isRevealed;\n                changeEvent.isRevealed = true;\n                somethingChanged = true;\n            }\n        }\n        if (typeof newState.isReplaceRevealed !== 'undefined') {\n            if (this._isReplaceRevealed !== newState.isReplaceRevealed) {\n                this._isReplaceRevealed = newState.isReplaceRevealed;\n                changeEvent.isReplaceRevealed = true;\n                somethingChanged = true;\n            }\n        }\n        if (typeof newState.isRegex !== 'undefined') {\n            this._isRegex = newState.isRegex;\n        }\n        if (typeof newState.wholeWord !== 'undefined') {\n            this._wholeWord = newState.wholeWord;\n        }\n        if (typeof newState.matchCase !== 'undefined') {\n            this._matchCase = newState.matchCase;\n        }\n        if (typeof newState.preserveCase !== 'undefined') {\n            this._preserveCase = newState.preserveCase;\n        }\n        if (typeof newState.searchScope !== 'undefined') {\n            if (!((_a = newState.searchScope) === null || _a === void 0 ? void 0 : _a.every((newSearchScope) => {\n                var _a;\n                return (_a = this._searchScope) === null || _a === void 0 ? void 0 : _a.some(existingSearchScope => {\n                    return !Range.equalsRange(existingSearchScope, newSearchScope);\n                });\n            }))) {\n                this._searchScope = newState.searchScope;\n                changeEvent.searchScope = true;\n                somethingChanged = true;\n            }\n        }\n        if (typeof newState.loop !== 'undefined') {\n            if (this._loop !== newState.loop) {\n                this._loop = newState.loop;\n                changeEvent.loop = true;\n                somethingChanged = true;\n            }\n        }\n        if (typeof newState.isSearching !== 'undefined') {\n            if (this._isSearching !== newState.isSearching) {\n                this._isSearching = newState.isSearching;\n                changeEvent.isSearching = true;\n                somethingChanged = true;\n            }\n        }\n        if (typeof newState.filters !== 'undefined') {\n            if (this._filters) {\n                this._filters.update(newState.filters);\n            }\n            else {\n                this._filters = newState.filters;\n            }\n            changeEvent.filters = true;\n            somethingChanged = true;\n        }\n        // Overrides get set when they explicitly come in and get reset anytime something else changes\n        this._isRegexOverride = (typeof newState.isRegexOverride !== 'undefined' ? newState.isRegexOverride : 0 /* FindOptionOverride.NotSet */);\n        this._wholeWordOverride = (typeof newState.wholeWordOverride !== 'undefined' ? newState.wholeWordOverride : 0 /* FindOptionOverride.NotSet */);\n        this._matchCaseOverride = (typeof newState.matchCaseOverride !== 'undefined' ? newState.matchCaseOverride : 0 /* FindOptionOverride.NotSet */);\n        this._preserveCaseOverride = (typeof newState.preserveCaseOverride !== 'undefined' ? newState.preserveCaseOverride : 0 /* FindOptionOverride.NotSet */);\n        if (oldEffectiveIsRegex !== this.isRegex) {\n            somethingChanged = true;\n            changeEvent.isRegex = true;\n        }\n        if (oldEffectiveWholeWords !== this.wholeWord) {\n            somethingChanged = true;\n            changeEvent.wholeWord = true;\n        }\n        if (oldEffectiveMatchCase !== this.matchCase) {\n            somethingChanged = true;\n            changeEvent.matchCase = true;\n        }\n        if (oldEffectivePreserveCase !== this.preserveCase) {\n            somethingChanged = true;\n            changeEvent.preserveCase = true;\n        }\n        if (somethingChanged) {\n            this._onFindReplaceStateChange.fire(changeEvent);\n        }\n    }\n    canNavigateBack() {\n        return this.canNavigateInLoop() || (this.matchesPosition !== 1);\n    }\n    canNavigateForward() {\n        return this.canNavigateInLoop() || (this.matchesPosition < this.matchesCount);\n    }\n    canNavigateInLoop() {\n        return this._loop || (this.matchesCount >= MATCHES_LIMIT);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function showHistoryKeybindingHint(keybindingService) {\n    var _a, _b;\n    return ((_a = keybindingService.lookupKeybinding('history.showPrevious')) === null || _a === void 0 ? void 0 : _a.getElectronAccelerator()) === 'Up' && ((_b = keybindingService.lookupKeybinding('history.showNext')) === null || _b === void 0 ? void 0 : _b.getElectronAccelerator()) === 'Down';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as dom from '../../../../base/browser/dom.js';\nimport { alert as alertFn } from '../../../../base/browser/ui/aria/aria.js';\nimport { Toggle } from '../../../../base/browser/ui/toggle/toggle.js';\nimport { Sash } from '../../../../base/browser/ui/sash/sash.js';\nimport { Widget } from '../../../../base/browser/ui/widget.js';\nimport { Delayer } from '../../../../base/common/async.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { toDisposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport './findWidget.css';\nimport { Range } from '../../../common/core/range.js';\nimport { CONTEXT_FIND_INPUT_FOCUSED, CONTEXT_REPLACE_INPUT_FOCUSED, FIND_IDS, MATCHES_LIMIT } from './findModel.js';\nimport * as nls from '../../../../nls.js';\nimport { ContextScopedFindInput, ContextScopedReplaceInput } from '../../../../platform/history/browser/contextScopedHistoryWidget.js';\nimport { showHistoryKeybindingHint } from '../../../../platform/history/browser/historyWidgetKeybindingHint.js';\nimport { contrastBorder, editorFindMatch, editorFindMatchBorder, editorFindMatchHighlight, editorFindMatchHighlightBorder, editorFindRangeHighlight, editorFindRangeHighlightBorder, editorWidgetBackground, editorWidgetBorder, editorWidgetForeground, editorWidgetResizeBorder, errorForeground, focusBorder, inputActiveOptionBackground, inputActiveOptionBorder, inputActiveOptionForeground, inputBackground, inputBorder, inputForeground, inputValidationErrorBackground, inputValidationErrorBorder, inputValidationErrorForeground, inputValidationInfoBackground, inputValidationInfoBorder, inputValidationInfoForeground, inputValidationWarningBackground, inputValidationWarningBorder, inputValidationWarningForeground, toolbarHoverBackground, widgetShadow } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerIcon, widgetClose } from '../../../../platform/theme/common/iconRegistry.js';\nimport { registerThemingParticipant, ThemeIcon } from '../../../../platform/theme/common/themeService.js';\nimport { isHighContrast } from '../../../../platform/theme/common/theme.js';\nconst findSelectionIcon = registerIcon('find-selection', Codicon.selection, nls.localize('findSelectionIcon', 'Icon for \\'Find in Selection\\' in the editor find widget.'));\nconst findCollapsedIcon = registerIcon('find-collapsed', Codicon.chevronRight, nls.localize('findCollapsedIcon', 'Icon to indicate that the editor find widget is collapsed.'));\nconst findExpandedIcon = registerIcon('find-expanded', Codicon.chevronDown, nls.localize('findExpandedIcon', 'Icon to indicate that the editor find widget is expanded.'));\nexport const findReplaceIcon = registerIcon('find-replace', Codicon.replace, nls.localize('findReplaceIcon', 'Icon for \\'Replace\\' in the editor find widget.'));\nexport const findReplaceAllIcon = registerIcon('find-replace-all', Codicon.replaceAll, nls.localize('findReplaceAllIcon', 'Icon for \\'Replace All\\' in the editor find widget.'));\nexport const findPreviousMatchIcon = registerIcon('find-previous-match', Codicon.arrowUp, nls.localize('findPreviousMatchIcon', 'Icon for \\'Find Previous\\' in the editor find widget.'));\nexport const findNextMatchIcon = registerIcon('find-next-match', Codicon.arrowDown, nls.localize('findNextMatchIcon', 'Icon for \\'Find Next\\' in the editor find widget.'));\nconst NLS_FIND_INPUT_LABEL = nls.localize('label.find', \"Find\");\nconst NLS_FIND_INPUT_PLACEHOLDER = nls.localize('placeholder.find', \"Find\");\nconst NLS_PREVIOUS_MATCH_BTN_LABEL = nls.localize('label.previousMatchButton', \"Previous Match\");\nconst NLS_NEXT_MATCH_BTN_LABEL = nls.localize('label.nextMatchButton', \"Next Match\");\nconst NLS_TOGGLE_SELECTION_FIND_TITLE = nls.localize('label.toggleSelectionFind', \"Find in Selection\");\nconst NLS_CLOSE_BTN_LABEL = nls.localize('label.closeButton', \"Close\");\nconst NLS_REPLACE_INPUT_LABEL = nls.localize('label.replace', \"Replace\");\nconst NLS_REPLACE_INPUT_PLACEHOLDER = nls.localize('placeholder.replace', \"Replace\");\nconst NLS_REPLACE_BTN_LABEL = nls.localize('label.replaceButton', \"Replace\");\nconst NLS_REPLACE_ALL_BTN_LABEL = nls.localize('label.replaceAllButton', \"Replace All\");\nconst NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = nls.localize('label.toggleReplaceButton', \"Toggle Replace\");\nconst NLS_MATCHES_COUNT_LIMIT_TITLE = nls.localize('title.matchesCountLimit', \"Only the first {0} results are highlighted, but all find operations work on the entire text.\", MATCHES_LIMIT);\nexport const NLS_MATCHES_LOCATION = nls.localize('label.matchesLocation', \"{0} of {1}\");\nexport const NLS_NO_RESULTS = nls.localize('label.noResults', \"No results\");\nconst FIND_WIDGET_INITIAL_WIDTH = 419;\nconst PART_WIDTH = 275;\nconst FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;\nlet MAX_MATCHES_COUNT_WIDTH = 69;\n// let FIND_ALL_CONTROLS_WIDTH = 17/** Find Input margin-left */ + (MAX_MATCHES_COUNT_WIDTH + 3 + 1) /** Match Results */ + 23 /** Button */ * 4 + 2/** sash */;\nconst FIND_INPUT_AREA_HEIGHT = 33; // The height of Find Widget when Replace Input is not visible.\nconst ctrlEnterReplaceAllWarningPromptedKey = 'ctrlEnterReplaceAll.windows.donotask';\nconst ctrlKeyMod = (platform.isMacintosh ? 256 /* KeyMod.WinCtrl */ : 2048 /* KeyMod.CtrlCmd */);\nexport class FindWidgetViewZone {\n    constructor(afterLineNumber) {\n        this.afterLineNumber = afterLineNumber;\n        this.heightInPx = FIND_INPUT_AREA_HEIGHT;\n        this.suppressMouseDown = false;\n        this.domNode = document.createElement('div');\n        this.domNode.className = 'dock-find-viewzone';\n    }\n}\nfunction stopPropagationForMultiLineUpwards(event, value, textarea) {\n    const isMultiline = !!value.match(/\\n/);\n    if (textarea && isMultiline && textarea.selectionStart > 0) {\n        event.stopPropagation();\n        return;\n    }\n}\nfunction stopPropagationForMultiLineDownwards(event, value, textarea) {\n    const isMultiline = !!value.match(/\\n/);\n    if (textarea && isMultiline && textarea.selectionEnd < textarea.value.length) {\n        event.stopPropagation();\n        return;\n    }\n}\nexport class FindWidget extends Widget {\n    constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService, storageService, notificationService) {\n        super();\n        this._cachedHeight = null;\n        this._revealTimeouts = [];\n        this._codeEditor = codeEditor;\n        this._controller = controller;\n        this._state = state;\n        this._contextViewProvider = contextViewProvider;\n        this._keybindingService = keybindingService;\n        this._contextKeyService = contextKeyService;\n        this._storageService = storageService;\n        this._notificationService = notificationService;\n        this._ctrlEnterReplaceAllWarningPrompted = !!storageService.getBoolean(ctrlEnterReplaceAllWarningPromptedKey, 0 /* StorageScope.PROFILE */);\n        this._isVisible = false;\n        this._isReplaceVisible = false;\n        this._ignoreChangeEvent = false;\n        this._updateHistoryDelayer = new Delayer(500);\n        this._register(toDisposable(() => this._updateHistoryDelayer.cancel()));\n        this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));\n        this._buildDomNode();\n        this._updateButtons();\n        this._tryUpdateWidgetWidth();\n        this._findInput.inputBox.layout();\n        this._register(this._codeEditor.onDidChangeConfiguration((e) => {\n            if (e.hasChanged(83 /* EditorOption.readOnly */)) {\n                if (this._codeEditor.getOption(83 /* EditorOption.readOnly */)) {\n                    // Hide replace part if editor becomes read only\n                    this._state.change({ isReplaceRevealed: false }, false);\n                }\n                this._updateButtons();\n            }\n            if (e.hasChanged(133 /* EditorOption.layoutInfo */)) {\n                this._tryUpdateWidgetWidth();\n            }\n            if (e.hasChanged(2 /* EditorOption.accessibilitySupport */)) {\n                this.updateAccessibilitySupport();\n            }\n            if (e.hasChanged(37 /* EditorOption.find */)) {\n                const addExtraSpaceOnTop = this._codeEditor.getOption(37 /* EditorOption.find */).addExtraSpaceOnTop;\n                if (addExtraSpaceOnTop && !this._viewZone) {\n                    this._viewZone = new FindWidgetViewZone(0);\n                    this._showViewZone();\n                }\n                if (!addExtraSpaceOnTop && this._viewZone) {\n                    this._removeViewZone();\n                }\n            }\n        }));\n        this.updateAccessibilitySupport();\n        this._register(this._codeEditor.onDidChangeCursorSelection(() => {\n            if (this._isVisible) {\n                this._updateToggleSelectionFindButton();\n            }\n        }));\n        this._register(this._codeEditor.onDidFocusEditorWidget(() => __awaiter(this, void 0, void 0, function* () {\n            if (this._isVisible) {\n                const globalBufferTerm = yield this._controller.getGlobalBufferTerm();\n                if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {\n                    this._state.change({ searchString: globalBufferTerm }, false);\n                    this._findInput.select();\n                }\n            }\n        })));\n        this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);\n        this._findFocusTracker = this._register(dom.trackFocus(this._findInput.inputBox.inputElement));\n        this._register(this._findFocusTracker.onDidFocus(() => {\n            this._findInputFocused.set(true);\n            this._updateSearchScope();\n        }));\n        this._register(this._findFocusTracker.onDidBlur(() => {\n            this._findInputFocused.set(false);\n        }));\n        this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);\n        this._replaceFocusTracker = this._register(dom.trackFocus(this._replaceInput.inputBox.inputElement));\n        this._register(this._replaceFocusTracker.onDidFocus(() => {\n            this._replaceInputFocused.set(true);\n            this._updateSearchScope();\n        }));\n        this._register(this._replaceFocusTracker.onDidBlur(() => {\n            this._replaceInputFocused.set(false);\n        }));\n        this._codeEditor.addOverlayWidget(this);\n        if (this._codeEditor.getOption(37 /* EditorOption.find */).addExtraSpaceOnTop) {\n            this._viewZone = new FindWidgetViewZone(0); // Put it before the first line then users can scroll beyond the first line.\n        }\n        this._applyTheme(themeService.getColorTheme());\n        this._register(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));\n        this._register(this._codeEditor.onDidChangeModel(() => {\n            if (!this._isVisible) {\n                return;\n            }\n            this._viewZoneId = undefined;\n        }));\n        this._register(this._codeEditor.onDidScrollChange((e) => {\n            if (e.scrollTopChanged) {\n                this._layoutViewZone();\n                return;\n            }\n            // for other scroll changes, layout the viewzone in next tick to avoid ruining current rendering.\n            setTimeout(() => {\n                this._layoutViewZone();\n            }, 0);\n        }));\n    }\n    // ----- IOverlayWidget API\n    getId() {\n        return FindWidget.ID;\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    getPosition() {\n        if (this._isVisible) {\n            return {\n                preference: 0 /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */\n            };\n        }\n        return null;\n    }\n    // ----- React to state changes\n    _onStateChanged(e) {\n        if (e.searchString) {\n            try {\n                this._ignoreChangeEvent = true;\n                this._findInput.setValue(this._state.searchString);\n            }\n            finally {\n                this._ignoreChangeEvent = false;\n            }\n            this._updateButtons();\n        }\n        if (e.replaceString) {\n            this._replaceInput.inputBox.value = this._state.replaceString;\n        }\n        if (e.isRevealed) {\n            if (this._state.isRevealed) {\n                this._reveal();\n            }\n            else {\n                this._hide(true);\n            }\n        }\n        if (e.isReplaceRevealed) {\n            if (this._state.isReplaceRevealed) {\n                if (!this._codeEditor.getOption(83 /* EditorOption.readOnly */) && !this._isReplaceVisible) {\n                    this._isReplaceVisible = true;\n                    this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n                    this._updateButtons();\n                    this._replaceInput.inputBox.layout();\n                }\n            }\n            else {\n                if (this._isReplaceVisible) {\n                    this._isReplaceVisible = false;\n                    this._updateButtons();\n                }\n            }\n        }\n        if ((e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed)) {\n            if (this._tryUpdateHeight()) {\n                this._showViewZone();\n            }\n        }\n        if (e.isRegex) {\n            this._findInput.setRegex(this._state.isRegex);\n        }\n        if (e.wholeWord) {\n            this._findInput.setWholeWords(this._state.wholeWord);\n        }\n        if (e.matchCase) {\n            this._findInput.setCaseSensitive(this._state.matchCase);\n        }\n        if (e.preserveCase) {\n            this._replaceInput.setPreserveCase(this._state.preserveCase);\n        }\n        if (e.searchScope) {\n            if (this._state.searchScope) {\n                this._toggleSelectionFind.checked = true;\n            }\n            else {\n                this._toggleSelectionFind.checked = false;\n            }\n            this._updateToggleSelectionFindButton();\n        }\n        if (e.searchString || e.matchesCount || e.matchesPosition) {\n            const showRedOutline = (this._state.searchString.length > 0 && this._state.matchesCount === 0);\n            this._domNode.classList.toggle('no-results', showRedOutline);\n            this._updateMatchesCount();\n            this._updateButtons();\n        }\n        if (e.searchString || e.currentMatch) {\n            this._layoutViewZone();\n        }\n        if (e.updateHistory) {\n            this._delayedUpdateHistory();\n        }\n        if (e.loop) {\n            this._updateButtons();\n        }\n    }\n    _delayedUpdateHistory() {\n        this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(undefined, onUnexpectedError);\n    }\n    _updateHistory() {\n        if (this._state.searchString) {\n            this._findInput.inputBox.addToHistory();\n        }\n        if (this._state.replaceString) {\n            this._replaceInput.inputBox.addToHistory();\n        }\n    }\n    _updateMatchesCount() {\n        this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + 'px';\n        if (this._state.matchesCount >= MATCHES_LIMIT) {\n            this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;\n        }\n        else {\n            this._matchesCount.title = '';\n        }\n        // remove previous content\n        if (this._matchesCount.firstChild) {\n            this._matchesCount.removeChild(this._matchesCount.firstChild);\n        }\n        let label;\n        if (this._state.matchesCount > 0) {\n            let matchesCount = String(this._state.matchesCount);\n            if (this._state.matchesCount >= MATCHES_LIMIT) {\n                matchesCount += '+';\n            }\n            let matchesPosition = String(this._state.matchesPosition);\n            if (matchesPosition === '0') {\n                matchesPosition = '?';\n            }\n            label = strings.format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);\n        }\n        else {\n            label = NLS_NO_RESULTS;\n        }\n        this._matchesCount.appendChild(document.createTextNode(label));\n        alertFn(this._getAriaLabel(label, this._state.currentMatch, this._state.searchString));\n        MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);\n    }\n    // ----- actions\n    _getAriaLabel(label, currentMatch, searchString) {\n        if (label === NLS_NO_RESULTS) {\n            return searchString === ''\n                ? nls.localize('ariaSearchNoResultEmpty', \"{0} found\", label)\n                : nls.localize('ariaSearchNoResult', \"{0} found for '{1}'\", label, searchString);\n        }\n        if (currentMatch) {\n            const ariaLabel = nls.localize('ariaSearchNoResultWithLineNum', \"{0} found for '{1}', at {2}\", label, searchString, currentMatch.startLineNumber + ':' + currentMatch.startColumn);\n            const model = this._codeEditor.getModel();\n            if (model && (currentMatch.startLineNumber <= model.getLineCount()) && (currentMatch.startLineNumber >= 1)) {\n                const lineContent = model.getLineContent(currentMatch.startLineNumber);\n                return `${lineContent}, ${ariaLabel}`;\n            }\n            return ariaLabel;\n        }\n        return nls.localize('ariaSearchNoResultWithLineNumNoCurrentMatch', \"{0} found for '{1}'\", label, searchString);\n    }\n    /**\n     * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').\n     * If 'selection find' is OFF we enable the button only if there is a selection.\n     */\n    _updateToggleSelectionFindButton() {\n        const selection = this._codeEditor.getSelection();\n        const isSelection = selection ? (selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn) : false;\n        const isChecked = this._toggleSelectionFind.checked;\n        if (this._isVisible && (isChecked || isSelection)) {\n            this._toggleSelectionFind.enable();\n        }\n        else {\n            this._toggleSelectionFind.disable();\n        }\n    }\n    _updateButtons() {\n        this._findInput.setEnabled(this._isVisible);\n        this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible);\n        this._updateToggleSelectionFindButton();\n        this._closeBtn.setEnabled(this._isVisible);\n        const findInputIsNonEmpty = (this._state.searchString.length > 0);\n        const matchesCount = this._state.matchesCount ? true : false;\n        this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateBack());\n        this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateForward());\n        this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);\n        this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);\n        this._domNode.classList.toggle('replaceToggled', this._isReplaceVisible);\n        this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);\n        const canReplace = !this._codeEditor.getOption(83 /* EditorOption.readOnly */);\n        this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);\n    }\n    _reveal() {\n        this._revealTimeouts.forEach(e => {\n            clearTimeout(e);\n        });\n        this._revealTimeouts = [];\n        if (!this._isVisible) {\n            this._isVisible = true;\n            const selection = this._codeEditor.getSelection();\n            switch (this._codeEditor.getOption(37 /* EditorOption.find */).autoFindInSelection) {\n                case 'always':\n                    this._toggleSelectionFind.checked = true;\n                    break;\n                case 'never':\n                    this._toggleSelectionFind.checked = false;\n                    break;\n                case 'multiline': {\n                    const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;\n                    this._toggleSelectionFind.checked = isSelectionMultipleLine;\n                    break;\n                }\n                default:\n                    break;\n            }\n            this._tryUpdateWidgetWidth();\n            this._updateButtons();\n            this._revealTimeouts.push(setTimeout(() => {\n                this._domNode.classList.add('visible');\n                this._domNode.setAttribute('aria-hidden', 'false');\n            }, 0));\n            // validate query again as it's being dismissed when we hide the find widget.\n            this._revealTimeouts.push(setTimeout(() => {\n                this._findInput.validate();\n            }, 200));\n            this._codeEditor.layoutOverlayWidget(this);\n            let adjustEditorScrollTop = true;\n            if (this._codeEditor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection && selection) {\n                const domNode = this._codeEditor.getDomNode();\n                if (domNode) {\n                    const editorCoords = dom.getDomNodePagePosition(domNode);\n                    const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());\n                    const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);\n                    const startTop = startCoords ? startCoords.top : 0;\n                    if (this._viewZone && startTop < this._viewZone.heightInPx) {\n                        if (selection.endLineNumber > selection.startLineNumber) {\n                            adjustEditorScrollTop = false;\n                        }\n                        const leftOfFindWidget = dom.getTopLeftOffset(this._domNode).left;\n                        if (startLeft > leftOfFindWidget) {\n                            adjustEditorScrollTop = false;\n                        }\n                        const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());\n                        const endLeft = editorCoords.left + (endCoords ? endCoords.left : 0);\n                        if (endLeft > leftOfFindWidget) {\n                            adjustEditorScrollTop = false;\n                        }\n                    }\n                }\n            }\n            this._showViewZone(adjustEditorScrollTop);\n        }\n    }\n    _hide(focusTheEditor) {\n        this._revealTimeouts.forEach(e => {\n            clearTimeout(e);\n        });\n        this._revealTimeouts = [];\n        if (this._isVisible) {\n            this._isVisible = false;\n            this._updateButtons();\n            this._domNode.classList.remove('visible');\n            this._domNode.setAttribute('aria-hidden', 'true');\n            this._findInput.clearMessage();\n            if (focusTheEditor) {\n                this._codeEditor.focus();\n            }\n            this._codeEditor.layoutOverlayWidget(this);\n            this._removeViewZone();\n        }\n    }\n    _layoutViewZone(targetScrollTop) {\n        const addExtraSpaceOnTop = this._codeEditor.getOption(37 /* EditorOption.find */).addExtraSpaceOnTop;\n        if (!addExtraSpaceOnTop) {\n            this._removeViewZone();\n            return;\n        }\n        if (!this._isVisible) {\n            return;\n        }\n        const viewZone = this._viewZone;\n        if (this._viewZoneId !== undefined || !viewZone) {\n            return;\n        }\n        this._codeEditor.changeViewZones((accessor) => {\n            viewZone.heightInPx = this._getHeight();\n            this._viewZoneId = accessor.addZone(viewZone);\n            // scroll top adjust to make sure the editor doesn't scroll when adding viewzone at the beginning.\n            this._codeEditor.setScrollTop(targetScrollTop || this._codeEditor.getScrollTop() + viewZone.heightInPx);\n        });\n    }\n    _showViewZone(adjustScroll = true) {\n        if (!this._isVisible) {\n            return;\n        }\n        const addExtraSpaceOnTop = this._codeEditor.getOption(37 /* EditorOption.find */).addExtraSpaceOnTop;\n        if (!addExtraSpaceOnTop) {\n            return;\n        }\n        if (this._viewZone === undefined) {\n            this._viewZone = new FindWidgetViewZone(0);\n        }\n        const viewZone = this._viewZone;\n        this._codeEditor.changeViewZones((accessor) => {\n            if (this._viewZoneId !== undefined) {\n                // the view zone already exists, we need to update the height\n                const newHeight = this._getHeight();\n                if (newHeight === viewZone.heightInPx) {\n                    return;\n                }\n                const scrollAdjustment = newHeight - viewZone.heightInPx;\n                viewZone.heightInPx = newHeight;\n                accessor.layoutZone(this._viewZoneId);\n                if (adjustScroll) {\n                    this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);\n                }\n                return;\n            }\n            else {\n                let scrollAdjustment = this._getHeight();\n                // if the editor has top padding, factor that into the zone height\n                scrollAdjustment -= this._codeEditor.getOption(77 /* EditorOption.padding */).top;\n                if (scrollAdjustment <= 0) {\n                    return;\n                }\n                viewZone.heightInPx = scrollAdjustment;\n                this._viewZoneId = accessor.addZone(viewZone);\n                if (adjustScroll) {\n                    this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);\n                }\n            }\n        });\n    }\n    _removeViewZone() {\n        this._codeEditor.changeViewZones((accessor) => {\n            if (this._viewZoneId !== undefined) {\n                accessor.removeZone(this._viewZoneId);\n                this._viewZoneId = undefined;\n                if (this._viewZone) {\n                    this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);\n                    this._viewZone = undefined;\n                }\n            }\n        });\n    }\n    _applyTheme(theme) {\n        const inputStyles = {\n            inputActiveOptionBorder: theme.getColor(inputActiveOptionBorder),\n            inputActiveOptionBackground: theme.getColor(inputActiveOptionBackground),\n            inputActiveOptionForeground: theme.getColor(inputActiveOptionForeground),\n            inputBackground: theme.getColor(inputBackground),\n            inputForeground: theme.getColor(inputForeground),\n            inputBorder: theme.getColor(inputBorder),\n            inputValidationInfoBackground: theme.getColor(inputValidationInfoBackground),\n            inputValidationInfoForeground: theme.getColor(inputValidationInfoForeground),\n            inputValidationInfoBorder: theme.getColor(inputValidationInfoBorder),\n            inputValidationWarningBackground: theme.getColor(inputValidationWarningBackground),\n            inputValidationWarningForeground: theme.getColor(inputValidationWarningForeground),\n            inputValidationWarningBorder: theme.getColor(inputValidationWarningBorder),\n            inputValidationErrorBackground: theme.getColor(inputValidationErrorBackground),\n            inputValidationErrorForeground: theme.getColor(inputValidationErrorForeground),\n            inputValidationErrorBorder: theme.getColor(inputValidationErrorBorder),\n        };\n        this._findInput.style(inputStyles);\n        this._replaceInput.style(inputStyles);\n        this._toggleSelectionFind.style(inputStyles);\n    }\n    _tryUpdateWidgetWidth() {\n        if (!this._isVisible) {\n            return;\n        }\n        if (!dom.isInDOM(this._domNode)) {\n            // the widget is not in the DOM\n            return;\n        }\n        const layoutInfo = this._codeEditor.getLayoutInfo();\n        const editorContentWidth = layoutInfo.contentWidth;\n        if (editorContentWidth <= 0) {\n            // for example, diff view original editor\n            this._domNode.classList.add('hiddenEditor');\n            return;\n        }\n        else if (this._domNode.classList.contains('hiddenEditor')) {\n            this._domNode.classList.remove('hiddenEditor');\n        }\n        const editorWidth = layoutInfo.width;\n        const minimapWidth = layoutInfo.minimap.minimapWidth;\n        let collapsedFindWidget = false;\n        let reducedFindWidget = false;\n        let narrowFindWidget = false;\n        if (this._resized) {\n            const widgetWidth = dom.getTotalWidth(this._domNode);\n            if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {\n                // as the widget is resized by users, we may need to change the max width of the widget as the editor width changes.\n                this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;\n                this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n                return;\n            }\n        }\n        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {\n            reducedFindWidget = true;\n        }\n        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {\n            narrowFindWidget = true;\n        }\n        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {\n            collapsedFindWidget = true;\n        }\n        this._domNode.classList.toggle('collapsed-find-widget', collapsedFindWidget);\n        this._domNode.classList.toggle('narrow-find-widget', narrowFindWidget);\n        this._domNode.classList.toggle('reduced-find-widget', reducedFindWidget);\n        if (!narrowFindWidget && !collapsedFindWidget) {\n            // the minimal left offset of findwidget is 15px.\n            this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;\n        }\n        if (this._resized) {\n            this._findInput.inputBox.layout();\n            const findInputWidth = this._findInput.inputBox.element.clientWidth;\n            if (findInputWidth > 0) {\n                this._replaceInput.width = findInputWidth;\n            }\n        }\n        else if (this._isReplaceVisible) {\n            this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n        }\n    }\n    _getHeight() {\n        let totalheight = 0;\n        // find input margin top\n        totalheight += 4;\n        // find input height\n        totalheight += this._findInput.inputBox.height + 2 /** input box border */;\n        if (this._isReplaceVisible) {\n            // replace input margin\n            totalheight += 4;\n            totalheight += this._replaceInput.inputBox.height + 2 /** input box border */;\n        }\n        // margin bottom\n        totalheight += 4;\n        return totalheight;\n    }\n    _tryUpdateHeight() {\n        const totalHeight = this._getHeight();\n        if (this._cachedHeight !== null && this._cachedHeight === totalHeight) {\n            return false;\n        }\n        this._cachedHeight = totalHeight;\n        this._domNode.style.height = `${totalHeight}px`;\n        return true;\n    }\n    // ----- Public\n    focusFindInput() {\n        this._findInput.select();\n        // Edge browser requires focus() in addition to select()\n        this._findInput.focus();\n    }\n    focusReplaceInput() {\n        this._replaceInput.select();\n        // Edge browser requires focus() in addition to select()\n        this._replaceInput.focus();\n    }\n    highlightFindOptions() {\n        this._findInput.highlightFindOptions();\n    }\n    _updateSearchScope() {\n        if (!this._codeEditor.hasModel()) {\n            return;\n        }\n        if (this._toggleSelectionFind.checked) {\n            const selections = this._codeEditor.getSelections();\n            selections.map(selection => {\n                if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {\n                    selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));\n                }\n                const currentMatch = this._state.currentMatch;\n                if (selection.startLineNumber !== selection.endLineNumber) {\n                    if (!Range.equalsRange(selection, currentMatch)) {\n                        return selection;\n                    }\n                }\n                return null;\n            }).filter(element => !!element);\n            if (selections.length) {\n                this._state.change({ searchScope: selections }, true);\n            }\n        }\n    }\n    _onFindInputMouseDown(e) {\n        // on linux, middle key does pasting.\n        if (e.middleButton) {\n            e.stopPropagation();\n        }\n    }\n    _onFindInputKeyDown(e) {\n        if (e.equals(ctrlKeyMod | 3 /* KeyCode.Enter */)) {\n            if (this._keybindingService.dispatchEvent(e, e.target)) {\n                e.preventDefault();\n                return;\n            }\n            else {\n                this._findInput.inputBox.insertAtCursor('\\n');\n                e.preventDefault();\n                return;\n            }\n        }\n        if (e.equals(2 /* KeyCode.Tab */)) {\n            if (this._isReplaceVisible) {\n                this._replaceInput.focus();\n            }\n            else {\n                this._findInput.focusOnCaseSensitive();\n            }\n            e.preventDefault();\n            return;\n        }\n        if (e.equals(2048 /* KeyMod.CtrlCmd */ | 18 /* KeyCode.DownArrow */)) {\n            this._codeEditor.focus();\n            e.preventDefault();\n            return;\n        }\n        if (e.equals(16 /* KeyCode.UpArrow */)) {\n            return stopPropagationForMultiLineUpwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector('textarea'));\n        }\n        if (e.equals(18 /* KeyCode.DownArrow */)) {\n            return stopPropagationForMultiLineDownwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector('textarea'));\n        }\n    }\n    _onReplaceInputKeyDown(e) {\n        if (e.equals(ctrlKeyMod | 3 /* KeyCode.Enter */)) {\n            if (this._keybindingService.dispatchEvent(e, e.target)) {\n                e.preventDefault();\n                return;\n            }\n            else {\n                if (platform.isWindows && platform.isNative && !this._ctrlEnterReplaceAllWarningPrompted) {\n                    // this is the first time when users press Ctrl + Enter to replace all\n                    this._notificationService.info(nls.localize('ctrlEnter.keybindingChanged', 'Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior.'));\n                    this._ctrlEnterReplaceAllWarningPrompted = true;\n                    this._storageService.store(ctrlEnterReplaceAllWarningPromptedKey, true, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n                }\n                this._replaceInput.inputBox.insertAtCursor('\\n');\n                e.preventDefault();\n                return;\n            }\n        }\n        if (e.equals(2 /* KeyCode.Tab */)) {\n            this._findInput.focusOnCaseSensitive();\n            e.preventDefault();\n            return;\n        }\n        if (e.equals(1024 /* KeyMod.Shift */ | 2 /* KeyCode.Tab */)) {\n            this._findInput.focus();\n            e.preventDefault();\n            return;\n        }\n        if (e.equals(2048 /* KeyMod.CtrlCmd */ | 18 /* KeyCode.DownArrow */)) {\n            this._codeEditor.focus();\n            e.preventDefault();\n            return;\n        }\n        if (e.equals(16 /* KeyCode.UpArrow */)) {\n            return stopPropagationForMultiLineUpwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector('textarea'));\n        }\n        if (e.equals(18 /* KeyCode.DownArrow */)) {\n            return stopPropagationForMultiLineDownwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector('textarea'));\n        }\n    }\n    // ----- sash\n    getVerticalSashLeft(_sash) {\n        return 0;\n    }\n    // ----- initialization\n    _keybindingLabelFor(actionId) {\n        const kb = this._keybindingService.lookupKeybinding(actionId);\n        if (!kb) {\n            return '';\n        }\n        return ` (${kb.getLabel()})`;\n    }\n    _buildDomNode() {\n        const flexibleHeight = true;\n        const flexibleWidth = true;\n        // Find input\n        this._findInput = this._register(new ContextScopedFindInput(null, this._contextViewProvider, {\n            width: FIND_INPUT_AREA_WIDTH,\n            label: NLS_FIND_INPUT_LABEL,\n            placeholder: NLS_FIND_INPUT_PLACEHOLDER,\n            appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),\n            appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),\n            appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),\n            validation: (value) => {\n                if (value.length === 0 || !this._findInput.getRegex()) {\n                    return null;\n                }\n                try {\n                    // use `g` and `u` which are also used by the TextModel search\n                    new RegExp(value, 'gu');\n                    return null;\n                }\n                catch (e) {\n                    return { content: e.message };\n                }\n            },\n            flexibleHeight,\n            flexibleWidth,\n            flexibleMaxHeight: 118,\n            showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService)\n        }, this._contextKeyService, true));\n        this._findInput.setRegex(!!this._state.isRegex);\n        this._findInput.setCaseSensitive(!!this._state.matchCase);\n        this._findInput.setWholeWords(!!this._state.wholeWord);\n        this._register(this._findInput.onKeyDown((e) => this._onFindInputKeyDown(e)));\n        this._register(this._findInput.inputBox.onDidChange(() => {\n            if (this._ignoreChangeEvent) {\n                return;\n            }\n            this._state.change({ searchString: this._findInput.getValue() }, true);\n        }));\n        this._register(this._findInput.onDidOptionChange(() => {\n            this._state.change({\n                isRegex: this._findInput.getRegex(),\n                wholeWord: this._findInput.getWholeWords(),\n                matchCase: this._findInput.getCaseSensitive()\n            }, true);\n        }));\n        this._register(this._findInput.onCaseSensitiveKeyDown((e) => {\n            if (e.equals(1024 /* KeyMod.Shift */ | 2 /* KeyCode.Tab */)) {\n                if (this._isReplaceVisible) {\n                    this._replaceInput.focus();\n                    e.preventDefault();\n                }\n            }\n        }));\n        this._register(this._findInput.onRegexKeyDown((e) => {\n            if (e.equals(2 /* KeyCode.Tab */)) {\n                if (this._isReplaceVisible) {\n                    this._replaceInput.focusOnPreserve();\n                    e.preventDefault();\n                }\n            }\n        }));\n        this._register(this._findInput.inputBox.onDidHeightChange((e) => {\n            if (this._tryUpdateHeight()) {\n                this._showViewZone();\n            }\n        }));\n        if (platform.isLinux) {\n            this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));\n        }\n        this._matchesCount = document.createElement('div');\n        this._matchesCount.className = 'matchesCount';\n        this._updateMatchesCount();\n        // Previous button\n        this._prevBtn = this._register(new SimpleButton({\n            label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),\n            icon: findPreviousMatchIcon,\n            onTrigger: () => {\n                this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction).run().then(undefined, onUnexpectedError);\n            }\n        }));\n        // Next button\n        this._nextBtn = this._register(new SimpleButton({\n            label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),\n            icon: findNextMatchIcon,\n            onTrigger: () => {\n                this._codeEditor.getAction(FIND_IDS.NextMatchFindAction).run().then(undefined, onUnexpectedError);\n            }\n        }));\n        const findPart = document.createElement('div');\n        findPart.className = 'find-part';\n        findPart.appendChild(this._findInput.domNode);\n        const actionsContainer = document.createElement('div');\n        actionsContainer.className = 'find-actions';\n        findPart.appendChild(actionsContainer);\n        actionsContainer.appendChild(this._matchesCount);\n        actionsContainer.appendChild(this._prevBtn.domNode);\n        actionsContainer.appendChild(this._nextBtn.domNode);\n        // Toggle selection button\n        this._toggleSelectionFind = this._register(new Toggle({\n            icon: findSelectionIcon,\n            title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),\n            isChecked: false\n        }));\n        this._register(this._toggleSelectionFind.onChange(() => {\n            if (this._toggleSelectionFind.checked) {\n                if (this._codeEditor.hasModel()) {\n                    const selections = this._codeEditor.getSelections();\n                    selections.map(selection => {\n                        if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {\n                            selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));\n                        }\n                        if (!selection.isEmpty()) {\n                            return selection;\n                        }\n                        return null;\n                    }).filter(element => !!element);\n                    if (selections.length) {\n                        this._state.change({ searchScope: selections }, true);\n                    }\n                }\n            }\n            else {\n                this._state.change({ searchScope: null }, true);\n            }\n        }));\n        actionsContainer.appendChild(this._toggleSelectionFind.domNode);\n        // Close button\n        this._closeBtn = this._register(new SimpleButton({\n            label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),\n            icon: widgetClose,\n            onTrigger: () => {\n                this._state.change({ isRevealed: false, searchScope: null }, false);\n            },\n            onKeyDown: (e) => {\n                if (e.equals(2 /* KeyCode.Tab */)) {\n                    if (this._isReplaceVisible) {\n                        if (this._replaceBtn.isEnabled()) {\n                            this._replaceBtn.focus();\n                        }\n                        else {\n                            this._codeEditor.focus();\n                        }\n                        e.preventDefault();\n                    }\n                }\n            }\n        }));\n        actionsContainer.appendChild(this._closeBtn.domNode);\n        // Replace input\n        this._replaceInput = this._register(new ContextScopedReplaceInput(null, undefined, {\n            label: NLS_REPLACE_INPUT_LABEL,\n            placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,\n            appendPreserveCaseLabel: this._keybindingLabelFor(FIND_IDS.TogglePreserveCaseCommand),\n            history: [],\n            flexibleHeight,\n            flexibleWidth,\n            flexibleMaxHeight: 118,\n            showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService)\n        }, this._contextKeyService, true));\n        this._replaceInput.setPreserveCase(!!this._state.preserveCase);\n        this._register(this._replaceInput.onKeyDown((e) => this._onReplaceInputKeyDown(e)));\n        this._register(this._replaceInput.inputBox.onDidChange(() => {\n            this._state.change({ replaceString: this._replaceInput.inputBox.value }, false);\n        }));\n        this._register(this._replaceInput.inputBox.onDidHeightChange((e) => {\n            if (this._isReplaceVisible && this._tryUpdateHeight()) {\n                this._showViewZone();\n            }\n        }));\n        this._register(this._replaceInput.onDidOptionChange(() => {\n            this._state.change({\n                preserveCase: this._replaceInput.getPreserveCase()\n            }, true);\n        }));\n        this._register(this._replaceInput.onPreserveCaseKeyDown((e) => {\n            if (e.equals(2 /* KeyCode.Tab */)) {\n                if (this._prevBtn.isEnabled()) {\n                    this._prevBtn.focus();\n                }\n                else if (this._nextBtn.isEnabled()) {\n                    this._nextBtn.focus();\n                }\n                else if (this._toggleSelectionFind.enabled) {\n                    this._toggleSelectionFind.focus();\n                }\n                else if (this._closeBtn.isEnabled()) {\n                    this._closeBtn.focus();\n                }\n                e.preventDefault();\n            }\n        }));\n        // Replace one button\n        this._replaceBtn = this._register(new SimpleButton({\n            label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),\n            icon: findReplaceIcon,\n            onTrigger: () => {\n                this._controller.replace();\n            },\n            onKeyDown: (e) => {\n                if (e.equals(1024 /* KeyMod.Shift */ | 2 /* KeyCode.Tab */)) {\n                    this._closeBtn.focus();\n                    e.preventDefault();\n                }\n            }\n        }));\n        // Replace all button\n        this._replaceAllBtn = this._register(new SimpleButton({\n            label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),\n            icon: findReplaceAllIcon,\n            onTrigger: () => {\n                this._controller.replaceAll();\n            }\n        }));\n        const replacePart = document.createElement('div');\n        replacePart.className = 'replace-part';\n        replacePart.appendChild(this._replaceInput.domNode);\n        const replaceActionsContainer = document.createElement('div');\n        replaceActionsContainer.className = 'replace-actions';\n        replacePart.appendChild(replaceActionsContainer);\n        replaceActionsContainer.appendChild(this._replaceBtn.domNode);\n        replaceActionsContainer.appendChild(this._replaceAllBtn.domNode);\n        // Toggle replace button\n        this._toggleReplaceBtn = this._register(new SimpleButton({\n            label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,\n            className: 'codicon toggle left',\n            onTrigger: () => {\n                this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, false);\n                if (this._isReplaceVisible) {\n                    this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n                    this._replaceInput.inputBox.layout();\n                }\n                this._showViewZone();\n            }\n        }));\n        this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);\n        // Widget\n        this._domNode = document.createElement('div');\n        this._domNode.className = 'editor-widget find-widget';\n        this._domNode.setAttribute('aria-hidden', 'true');\n        // We need to set this explicitly, otherwise on IE11, the width inheritence of flex doesn't work.\n        this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;\n        this._domNode.appendChild(this._toggleReplaceBtn.domNode);\n        this._domNode.appendChild(findPart);\n        this._domNode.appendChild(replacePart);\n        this._resizeSash = new Sash(this._domNode, this, { orientation: 0 /* Orientation.VERTICAL */, size: 2 });\n        this._resized = false;\n        let originalWidth = FIND_WIDGET_INITIAL_WIDTH;\n        this._register(this._resizeSash.onDidStart(() => {\n            originalWidth = dom.getTotalWidth(this._domNode);\n        }));\n        this._register(this._resizeSash.onDidChange((evt) => {\n            this._resized = true;\n            const width = originalWidth + evt.startX - evt.currentX;\n            if (width < FIND_WIDGET_INITIAL_WIDTH) {\n                // narrow down the find widget should be handled by CSS.\n                return;\n            }\n            const maxWidth = parseFloat(dom.getComputedStyle(this._domNode).maxWidth) || 0;\n            if (width > maxWidth) {\n                return;\n            }\n            this._domNode.style.width = `${width}px`;\n            if (this._isReplaceVisible) {\n                this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n            }\n            this._findInput.inputBox.layout();\n            this._tryUpdateHeight();\n        }));\n        this._register(this._resizeSash.onDidReset(() => {\n            // users double click on the sash\n            const currentWidth = dom.getTotalWidth(this._domNode);\n            if (currentWidth < FIND_WIDGET_INITIAL_WIDTH) {\n                // The editor is narrow and the width of the find widget is controlled fully by CSS.\n                return;\n            }\n            let width = FIND_WIDGET_INITIAL_WIDTH;\n            if (!this._resized || currentWidth === FIND_WIDGET_INITIAL_WIDTH) {\n                // 1. never resized before, double click should maximizes it\n                // 2. users resized it already but its width is the same as default\n                const layoutInfo = this._codeEditor.getLayoutInfo();\n                width = layoutInfo.width - 28 - layoutInfo.minimap.minimapWidth - 15;\n                this._resized = true;\n            }\n            else {\n                /**\n                 * no op, the find widget should be shrinked to its default size.\n                 */\n            }\n            this._domNode.style.width = `${width}px`;\n            if (this._isReplaceVisible) {\n                this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n            }\n            this._findInput.inputBox.layout();\n        }));\n    }\n    updateAccessibilitySupport() {\n        const value = this._codeEditor.getOption(2 /* EditorOption.accessibilitySupport */);\n        this._findInput.setFocusInputOnOptionClick(value !== 2 /* AccessibilitySupport.Enabled */);\n    }\n}\nFindWidget.ID = 'editor.contrib.findWidget';\nexport class SimpleButton extends Widget {\n    constructor(opts) {\n        super();\n        this._opts = opts;\n        let className = 'button';\n        if (this._opts.className) {\n            className = className + ' ' + this._opts.className;\n        }\n        if (this._opts.icon) {\n            className = className + ' ' + ThemeIcon.asClassName(this._opts.icon);\n        }\n        this._domNode = document.createElement('div');\n        this._domNode.title = this._opts.label;\n        this._domNode.tabIndex = 0;\n        this._domNode.className = className;\n        this._domNode.setAttribute('role', 'button');\n        this._domNode.setAttribute('aria-label', this._opts.label);\n        this.onclick(this._domNode, (e) => {\n            this._opts.onTrigger();\n            e.preventDefault();\n        });\n        this.onkeydown(this._domNode, (e) => {\n            var _a, _b;\n            if (e.equals(10 /* KeyCode.Space */) || e.equals(3 /* KeyCode.Enter */)) {\n                this._opts.onTrigger();\n                e.preventDefault();\n                return;\n            }\n            (_b = (_a = this._opts).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        });\n    }\n    get domNode() {\n        return this._domNode;\n    }\n    isEnabled() {\n        return (this._domNode.tabIndex >= 0);\n    }\n    focus() {\n        this._domNode.focus();\n    }\n    setEnabled(enabled) {\n        this._domNode.classList.toggle('disabled', !enabled);\n        this._domNode.setAttribute('aria-disabled', String(!enabled));\n        this._domNode.tabIndex = enabled ? 0 : -1;\n    }\n    setExpanded(expanded) {\n        this._domNode.setAttribute('aria-expanded', String(!!expanded));\n        if (expanded) {\n            this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findCollapsedIcon));\n            this._domNode.classList.add(...ThemeIcon.asClassNameArray(findExpandedIcon));\n        }\n        else {\n            this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findExpandedIcon));\n            this._domNode.classList.add(...ThemeIcon.asClassNameArray(findCollapsedIcon));\n        }\n    }\n}\n// theming\nregisterThemingParticipant((theme, collector) => {\n    const addBackgroundColorRule = (selector, color) => {\n        if (color) {\n            collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);\n        }\n    };\n    addBackgroundColorRule('.findMatch', theme.getColor(editorFindMatchHighlight));\n    addBackgroundColorRule('.currentFindMatch', theme.getColor(editorFindMatch));\n    addBackgroundColorRule('.findScope', theme.getColor(editorFindRangeHighlight));\n    const widgetBackground = theme.getColor(editorWidgetBackground);\n    addBackgroundColorRule('.find-widget', widgetBackground);\n    const widgetShadowColor = theme.getColor(widgetShadow);\n    if (widgetShadowColor) {\n        collector.addRule(`.monaco-editor .find-widget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);\n    }\n    const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);\n    if (findMatchHighlightBorder) {\n        collector.addRule(`.monaco-editor .findMatch { border: 1px ${isHighContrast(theme.type) ? 'dotted' : 'solid'} ${findMatchHighlightBorder}; box-sizing: border-box; }`);\n    }\n    const findMatchBorder = theme.getColor(editorFindMatchBorder);\n    if (findMatchBorder) {\n        collector.addRule(`.monaco-editor .currentFindMatch { border: 2px solid ${findMatchBorder}; padding: 1px; box-sizing: border-box; }`);\n    }\n    const findRangeHighlightBorder = theme.getColor(editorFindRangeHighlightBorder);\n    if (findRangeHighlightBorder) {\n        collector.addRule(`.monaco-editor .findScope { border: 1px ${isHighContrast(theme.type) ? 'dashed' : 'solid'} ${findRangeHighlightBorder}; }`);\n    }\n    const hcBorder = theme.getColor(contrastBorder);\n    if (hcBorder) {\n        collector.addRule(`.monaco-editor .find-widget { border: 1px solid ${hcBorder}; }`);\n    }\n    const foreground = theme.getColor(editorWidgetForeground);\n    if (foreground) {\n        collector.addRule(`.monaco-editor .find-widget { color: ${foreground}; }`);\n    }\n    const error = theme.getColor(errorForeground);\n    if (error) {\n        collector.addRule(`.monaco-editor .find-widget.no-results .matchesCount { color: ${error}; }`);\n    }\n    const resizeBorderBackground = theme.getColor(editorWidgetResizeBorder);\n    if (resizeBorderBackground) {\n        collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${resizeBorderBackground}; }`);\n    }\n    else {\n        const border = theme.getColor(editorWidgetBorder);\n        if (border) {\n            collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${border}; }`);\n        }\n    }\n    // Action bars\n    const toolbarHoverBackgroundColor = theme.getColor(toolbarHoverBackground);\n    if (toolbarHoverBackgroundColor) {\n        collector.addRule(`\n\t\t.monaco-editor .find-widget .button:not(.disabled):hover,\n\t\t.monaco-editor .find-widget .codicon-find-selection:hover {\n\t\t\tbackground-color: ${toolbarHoverBackgroundColor} !important;\n\t\t}\n\t`);\n    }\n    // This rule is used to override the outline color for synthetic-focus find input.\n    const focusOutline = theme.getColor(focusBorder);\n    if (focusOutline) {\n        collector.addRule(`.monaco-editor .find-widget .monaco-inputbox.synthetic-focus { outline-color: ${focusOutline}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Delayer } from '../../../../base/common/async.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditorAction, EditorCommand, MultiEditorAction, registerEditorAction, registerEditorCommand, registerEditorContribution, registerMultiEditorAction } from '../../../browser/editorExtensions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { CONTEXT_FIND_INPUT_FOCUSED, CONTEXT_FIND_WIDGET_VISIBLE, CONTEXT_REPLACE_INPUT_FOCUSED, FindModelBoundToEditorModel, FIND_IDS, ToggleCaseSensitiveKeybinding, TogglePreserveCaseKeybinding, ToggleRegexKeybinding, ToggleSearchScopeKeybinding, ToggleWholeWordKeybinding } from './findModel.js';\nimport { FindOptionsWidget } from './findOptionsWidget.js';\nimport { FindReplaceState } from './findState.js';\nimport { FindWidget } from './findWidget.js';\nimport * as nls from '../../../../nls.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { IClipboardService } from '../../../../platform/clipboard/common/clipboardService.js';\nimport { ContextKeyExpr, IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IContextViewService } from '../../../../platform/contextview/browser/contextView.js';\nimport { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nimport { IStorageService } from '../../../../platform/storage/common/storage.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nconst SEARCH_STRING_MAX_LENGTH = 524288;\nexport function getSelectionSearchString(editor, seedSearchStringFromSelection = 'single', seedSearchStringFromNonEmptySelection = false) {\n    if (!editor.hasModel()) {\n        return null;\n    }\n    const selection = editor.getSelection();\n    // if selection spans multiple lines, default search string to empty\n    if ((seedSearchStringFromSelection === 'single' && selection.startLineNumber === selection.endLineNumber)\n        || seedSearchStringFromSelection === 'multiple') {\n        if (selection.isEmpty()) {\n            const wordAtPosition = editor.getConfiguredWordAtPosition(selection.getStartPosition());\n            if (wordAtPosition && (false === seedSearchStringFromNonEmptySelection)) {\n                return wordAtPosition.word;\n            }\n        }\n        else {\n            if (editor.getModel().getValueLengthInRange(selection) < SEARCH_STRING_MAX_LENGTH) {\n                return editor.getModel().getValueInRange(selection);\n            }\n        }\n    }\n    return null;\n}\nlet CommonFindController = class CommonFindController extends Disposable {\n    constructor(editor, contextKeyService, storageService, clipboardService) {\n        super();\n        this._editor = editor;\n        this._findWidgetVisible = CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);\n        this._contextKeyService = contextKeyService;\n        this._storageService = storageService;\n        this._clipboardService = clipboardService;\n        this._updateHistoryDelayer = new Delayer(500);\n        this._state = this._register(new FindReplaceState());\n        this.loadQueryState();\n        this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));\n        this._model = null;\n        this._register(this._editor.onDidChangeModel(() => {\n            const shouldRestartFind = (this._editor.getModel() && this._state.isRevealed);\n            this.disposeModel();\n            this._state.change({\n                searchScope: null,\n                matchCase: this._storageService.getBoolean('editor.matchCase', 1 /* StorageScope.WORKSPACE */, false),\n                wholeWord: this._storageService.getBoolean('editor.wholeWord', 1 /* StorageScope.WORKSPACE */, false),\n                isRegex: this._storageService.getBoolean('editor.isRegex', 1 /* StorageScope.WORKSPACE */, false),\n                preserveCase: this._storageService.getBoolean('editor.preserveCase', 1 /* StorageScope.WORKSPACE */, false)\n            }, false);\n            if (shouldRestartFind) {\n                this._start({\n                    forceRevealReplace: false,\n                    seedSearchStringFromSelection: 'none',\n                    seedSearchStringFromNonEmptySelection: false,\n                    seedSearchStringFromGlobalClipboard: false,\n                    shouldFocus: 0 /* FindStartFocusAction.NoFocusChange */,\n                    shouldAnimate: false,\n                    updateSearchScope: false,\n                    loop: this._editor.getOption(37 /* EditorOption.find */).loop\n                });\n            }\n        }));\n    }\n    get editor() {\n        return this._editor;\n    }\n    static get(editor) {\n        return editor.getContribution(CommonFindController.ID);\n    }\n    dispose() {\n        this.disposeModel();\n        super.dispose();\n    }\n    disposeModel() {\n        if (this._model) {\n            this._model.dispose();\n            this._model = null;\n        }\n    }\n    _onStateChanged(e) {\n        this.saveQueryState(e);\n        if (e.isRevealed) {\n            if (this._state.isRevealed) {\n                this._findWidgetVisible.set(true);\n            }\n            else {\n                this._findWidgetVisible.reset();\n                this.disposeModel();\n            }\n        }\n        if (e.searchString) {\n            this.setGlobalBufferTerm(this._state.searchString);\n        }\n    }\n    saveQueryState(e) {\n        if (e.isRegex) {\n            this._storageService.store('editor.isRegex', this._state.actualIsRegex, 1 /* StorageScope.WORKSPACE */, 0 /* StorageTarget.USER */);\n        }\n        if (e.wholeWord) {\n            this._storageService.store('editor.wholeWord', this._state.actualWholeWord, 1 /* StorageScope.WORKSPACE */, 0 /* StorageTarget.USER */);\n        }\n        if (e.matchCase) {\n            this._storageService.store('editor.matchCase', this._state.actualMatchCase, 1 /* StorageScope.WORKSPACE */, 0 /* StorageTarget.USER */);\n        }\n        if (e.preserveCase) {\n            this._storageService.store('editor.preserveCase', this._state.actualPreserveCase, 1 /* StorageScope.WORKSPACE */, 0 /* StorageTarget.USER */);\n        }\n    }\n    loadQueryState() {\n        this._state.change({\n            matchCase: this._storageService.getBoolean('editor.matchCase', 1 /* StorageScope.WORKSPACE */, this._state.matchCase),\n            wholeWord: this._storageService.getBoolean('editor.wholeWord', 1 /* StorageScope.WORKSPACE */, this._state.wholeWord),\n            isRegex: this._storageService.getBoolean('editor.isRegex', 1 /* StorageScope.WORKSPACE */, this._state.isRegex),\n            preserveCase: this._storageService.getBoolean('editor.preserveCase', 1 /* StorageScope.WORKSPACE */, this._state.preserveCase)\n        }, false);\n    }\n    isFindInputFocused() {\n        return !!CONTEXT_FIND_INPUT_FOCUSED.getValue(this._contextKeyService);\n    }\n    getState() {\n        return this._state;\n    }\n    closeFindWidget() {\n        this._state.change({\n            isRevealed: false,\n            searchScope: null\n        }, false);\n        this._editor.focus();\n    }\n    toggleCaseSensitive() {\n        this._state.change({ matchCase: !this._state.matchCase }, false);\n        if (!this._state.isRevealed) {\n            this.highlightFindOptions();\n        }\n    }\n    toggleWholeWords() {\n        this._state.change({ wholeWord: !this._state.wholeWord }, false);\n        if (!this._state.isRevealed) {\n            this.highlightFindOptions();\n        }\n    }\n    toggleRegex() {\n        this._state.change({ isRegex: !this._state.isRegex }, false);\n        if (!this._state.isRevealed) {\n            this.highlightFindOptions();\n        }\n    }\n    togglePreserveCase() {\n        this._state.change({ preserveCase: !this._state.preserveCase }, false);\n        if (!this._state.isRevealed) {\n            this.highlightFindOptions();\n        }\n    }\n    toggleSearchScope() {\n        if (this._state.searchScope) {\n            this._state.change({ searchScope: null }, true);\n        }\n        else {\n            if (this._editor.hasModel()) {\n                const selections = this._editor.getSelections();\n                selections.map(selection => {\n                    if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {\n                        selection = selection.setEndPosition(selection.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(selection.endLineNumber - 1));\n                    }\n                    if (!selection.isEmpty()) {\n                        return selection;\n                    }\n                    return null;\n                }).filter(element => !!element);\n                if (selections.length) {\n                    this._state.change({ searchScope: selections }, true);\n                }\n            }\n        }\n    }\n    setSearchString(searchString) {\n        if (this._state.isRegex) {\n            searchString = strings.escapeRegExpCharacters(searchString);\n        }\n        this._state.change({ searchString: searchString }, false);\n    }\n    highlightFindOptions(ignoreWhenVisible = false) {\n        // overwritten in subclass\n    }\n    _start(opts, newState) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.disposeModel();\n            if (!this._editor.hasModel()) {\n                // cannot do anything with an editor that doesn't have a model...\n                return;\n            }\n            const stateChanges = Object.assign(Object.assign({}, newState), { isRevealed: true });\n            if (opts.seedSearchStringFromSelection === 'single') {\n                const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection, opts.seedSearchStringFromNonEmptySelection);\n                if (selectionSearchString) {\n                    if (this._state.isRegex) {\n                        stateChanges.searchString = strings.escapeRegExpCharacters(selectionSearchString);\n                    }\n                    else {\n                        stateChanges.searchString = selectionSearchString;\n                    }\n                }\n            }\n            else if (opts.seedSearchStringFromSelection === 'multiple' && !opts.updateSearchScope) {\n                const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection);\n                if (selectionSearchString) {\n                    stateChanges.searchString = selectionSearchString;\n                }\n            }\n            if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {\n                const selectionSearchString = yield this.getGlobalBufferTerm();\n                if (!this._editor.hasModel()) {\n                    // the editor has lost its model in the meantime\n                    return;\n                }\n                if (selectionSearchString) {\n                    stateChanges.searchString = selectionSearchString;\n                }\n            }\n            // Overwrite isReplaceRevealed\n            if (opts.forceRevealReplace || stateChanges.isReplaceRevealed) {\n                stateChanges.isReplaceRevealed = true;\n            }\n            else if (!this._findWidgetVisible.get()) {\n                stateChanges.isReplaceRevealed = false;\n            }\n            if (opts.updateSearchScope) {\n                const currentSelections = this._editor.getSelections();\n                if (currentSelections.some(selection => !selection.isEmpty())) {\n                    stateChanges.searchScope = currentSelections;\n                }\n            }\n            stateChanges.loop = opts.loop;\n            this._state.change(stateChanges, false);\n            if (!this._model) {\n                this._model = new FindModelBoundToEditorModel(this._editor, this._state);\n            }\n        });\n    }\n    start(opts, newState) {\n        return this._start(opts, newState);\n    }\n    moveToNextMatch() {\n        if (this._model) {\n            this._model.moveToNextMatch();\n            return true;\n        }\n        return false;\n    }\n    moveToPrevMatch() {\n        if (this._model) {\n            this._model.moveToPrevMatch();\n            return true;\n        }\n        return false;\n    }\n    replace() {\n        if (this._model) {\n            this._model.replace();\n            return true;\n        }\n        return false;\n    }\n    replaceAll() {\n        if (this._model) {\n            this._model.replaceAll();\n            return true;\n        }\n        return false;\n    }\n    selectAllMatches() {\n        if (this._model) {\n            this._model.selectAllMatches();\n            this._editor.focus();\n            return true;\n        }\n        return false;\n    }\n    getGlobalBufferTerm() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._editor.getOption(37 /* EditorOption.find */).globalFindClipboard\n                && this._editor.hasModel()\n                && !this._editor.getModel().isTooLargeForSyncing()) {\n                return this._clipboardService.readFindText();\n            }\n            return '';\n        });\n    }\n    setGlobalBufferTerm(text) {\n        if (this._editor.getOption(37 /* EditorOption.find */).globalFindClipboard\n            && this._editor.hasModel()\n            && !this._editor.getModel().isTooLargeForSyncing()) {\n            // intentionally not awaited\n            this._clipboardService.writeFindText(text);\n        }\n    }\n};\nCommonFindController.ID = 'editor.contrib.findController';\nCommonFindController = __decorate([\n    __param(1, IContextKeyService),\n    __param(2, IStorageService),\n    __param(3, IClipboardService)\n], CommonFindController);\nexport { CommonFindController };\nlet FindController = class FindController extends CommonFindController {\n    constructor(editor, _contextViewService, _contextKeyService, _keybindingService, _themeService, _notificationService, _storageService, clipboardService) {\n        super(editor, _contextKeyService, _storageService, clipboardService);\n        this._contextViewService = _contextViewService;\n        this._keybindingService = _keybindingService;\n        this._themeService = _themeService;\n        this._notificationService = _notificationService;\n        this._widget = null;\n        this._findOptionsWidget = null;\n    }\n    _start(opts, newState) {\n        const _super = Object.create(null, {\n            _start: { get: () => super._start }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._widget) {\n                this._createFindWidget();\n            }\n            const selection = this._editor.getSelection();\n            let updateSearchScope = false;\n            switch (this._editor.getOption(37 /* EditorOption.find */).autoFindInSelection) {\n                case 'always':\n                    updateSearchScope = true;\n                    break;\n                case 'never':\n                    updateSearchScope = false;\n                    break;\n                case 'multiline': {\n                    const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;\n                    updateSearchScope = isSelectionMultipleLine;\n                    break;\n                }\n                default:\n                    break;\n            }\n            opts.updateSearchScope = opts.updateSearchScope || updateSearchScope;\n            yield _super._start.call(this, opts, newState);\n            if (this._widget) {\n                if (opts.shouldFocus === 2 /* FindStartFocusAction.FocusReplaceInput */) {\n                    this._widget.focusReplaceInput();\n                }\n                else if (opts.shouldFocus === 1 /* FindStartFocusAction.FocusFindInput */) {\n                    this._widget.focusFindInput();\n                }\n            }\n        });\n    }\n    highlightFindOptions(ignoreWhenVisible = false) {\n        if (!this._widget) {\n            this._createFindWidget();\n        }\n        if (this._state.isRevealed && !ignoreWhenVisible) {\n            this._widget.highlightFindOptions();\n        }\n        else {\n            this._findOptionsWidget.highlightFindOptions();\n        }\n    }\n    _createFindWidget() {\n        this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService));\n        this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService, this._themeService));\n    }\n};\nFindController = __decorate([\n    __param(1, IContextViewService),\n    __param(2, IContextKeyService),\n    __param(3, IKeybindingService),\n    __param(4, IThemeService),\n    __param(5, INotificationService),\n    __param(6, IStorageService),\n    __param(7, IClipboardService)\n], FindController);\nexport { FindController };\nexport const StartFindAction = registerMultiEditorAction(new MultiEditorAction({\n    id: FIND_IDS.StartFindAction,\n    label: nls.localize('startFindAction', \"Find\"),\n    alias: 'Find',\n    precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has('editorIsOpen')),\n    kbOpts: {\n        kbExpr: null,\n        primary: 2048 /* KeyMod.CtrlCmd */ | 36 /* KeyCode.KeyF */,\n        weight: 100 /* KeybindingWeight.EditorContrib */\n    },\n    menuOpts: {\n        menuId: MenuId.MenubarEditMenu,\n        group: '3_find',\n        title: nls.localize({ key: 'miFind', comment: ['&& denotes a mnemonic'] }, \"&&Find\"),\n        order: 1\n    }\n}));\nStartFindAction.addImplementation(0, (accessor, editor, args) => {\n    const controller = CommonFindController.get(editor);\n    if (!controller) {\n        return false;\n    }\n    return controller.start({\n        forceRevealReplace: false,\n        seedSearchStringFromSelection: editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection !== 'never' ? 'single' : 'none',\n        seedSearchStringFromNonEmptySelection: editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection === 'selection',\n        seedSearchStringFromGlobalClipboard: editor.getOption(37 /* EditorOption.find */).globalFindClipboard,\n        shouldFocus: 1 /* FindStartFocusAction.FocusFindInput */,\n        shouldAnimate: true,\n        updateSearchScope: false,\n        loop: editor.getOption(37 /* EditorOption.find */).loop\n    });\n});\nconst findArgDescription = {\n    description: 'Open a new In-Editor Find Widget.',\n    args: [{\n            name: 'Open a new In-Editor Find Widget args',\n            schema: {\n                properties: {\n                    searchString: { type: 'string' },\n                    replaceString: { type: 'string' },\n                    regex: { type: 'boolean' },\n                    regexOverride: {\n                        type: 'number',\n                        description: nls.localize('actions.find.isRegexOverride', 'Overrides \"Use Regular Expression\" flag.\\nThe flag will not be saved for the future.\\n0: Do Nothing\\n1: True\\n2: False')\n                    },\n                    wholeWord: { type: 'boolean' },\n                    wholeWordOverride: {\n                        type: 'number',\n                        description: nls.localize('actions.find.wholeWordOverride', 'Overrides \"Match Whole Word\" flag.\\nThe flag will not be saved for the future.\\n0: Do Nothing\\n1: True\\n2: False')\n                    },\n                    matchCase: { type: 'boolean' },\n                    matchCaseOverride: {\n                        type: 'number',\n                        description: nls.localize('actions.find.matchCaseOverride', 'Overrides \"Math Case\" flag.\\nThe flag will not be saved for the future.\\n0: Do Nothing\\n1: True\\n2: False')\n                    },\n                    preserveCase: { type: 'boolean' },\n                    preserveCaseOverride: {\n                        type: 'number',\n                        description: nls.localize('actions.find.preserveCaseOverride', 'Overrides \"Preserve Case\" flag.\\nThe flag will not be saved for the future.\\n0: Do Nothing\\n1: True\\n2: False')\n                    },\n                    findInSelection: { type: 'boolean' },\n                }\n            }\n        }]\n};\nexport class StartFindWithArgsAction extends EditorAction {\n    constructor() {\n        super({\n            id: FIND_IDS.StartFindWithArgs,\n            label: nls.localize('startFindWithArgsAction', \"Find With Arguments\"),\n            alias: 'Find With Arguments',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: null,\n                primary: 0,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            description: findArgDescription\n        });\n    }\n    run(accessor, editor, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const controller = CommonFindController.get(editor);\n            if (controller) {\n                const newState = args ? {\n                    searchString: args.searchString,\n                    replaceString: args.replaceString,\n                    isReplaceRevealed: args.replaceString !== undefined,\n                    isRegex: args.isRegex,\n                    // isRegexOverride: args.regexOverride,\n                    wholeWord: args.matchWholeWord,\n                    // wholeWordOverride: args.wholeWordOverride,\n                    matchCase: args.isCaseSensitive,\n                    // matchCaseOverride: args.matchCaseOverride,\n                    preserveCase: args.preserveCase,\n                    // preserveCaseOverride: args.preserveCaseOverride,\n                } : {};\n                yield controller.start({\n                    forceRevealReplace: false,\n                    seedSearchStringFromSelection: (controller.getState().searchString.length === 0) && editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection !== 'never' ? 'single' : 'none',\n                    seedSearchStringFromNonEmptySelection: editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection === 'selection',\n                    seedSearchStringFromGlobalClipboard: true,\n                    shouldFocus: 1 /* FindStartFocusAction.FocusFindInput */,\n                    shouldAnimate: true,\n                    updateSearchScope: (args === null || args === void 0 ? void 0 : args.findInSelection) || false,\n                    loop: editor.getOption(37 /* EditorOption.find */).loop\n                }, newState);\n                controller.setGlobalBufferTerm(controller.getState().searchString);\n            }\n        });\n    }\n}\nexport class StartFindWithSelectionAction extends EditorAction {\n    constructor() {\n        super({\n            id: FIND_IDS.StartFindWithSelection,\n            label: nls.localize('startFindWithSelectionAction', \"Find With Selection\"),\n            alias: 'Find With Selection',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: null,\n                primary: 0,\n                mac: {\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 35 /* KeyCode.KeyE */,\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(accessor, editor) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const controller = CommonFindController.get(editor);\n            if (controller) {\n                yield controller.start({\n                    forceRevealReplace: false,\n                    seedSearchStringFromSelection: 'multiple',\n                    seedSearchStringFromNonEmptySelection: false,\n                    seedSearchStringFromGlobalClipboard: false,\n                    shouldFocus: 0 /* FindStartFocusAction.NoFocusChange */,\n                    shouldAnimate: true,\n                    updateSearchScope: false,\n                    loop: editor.getOption(37 /* EditorOption.find */).loop\n                });\n                controller.setGlobalBufferTerm(controller.getState().searchString);\n            }\n        });\n    }\n}\nexport class MatchFindAction extends EditorAction {\n    run(accessor, editor) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const controller = CommonFindController.get(editor);\n            if (controller && !this._run(controller)) {\n                yield controller.start({\n                    forceRevealReplace: false,\n                    seedSearchStringFromSelection: (controller.getState().searchString.length === 0) && editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection !== 'never' ? 'single' : 'none',\n                    seedSearchStringFromNonEmptySelection: editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection === 'selection',\n                    seedSearchStringFromGlobalClipboard: true,\n                    shouldFocus: 0 /* FindStartFocusAction.NoFocusChange */,\n                    shouldAnimate: true,\n                    updateSearchScope: false,\n                    loop: editor.getOption(37 /* EditorOption.find */).loop\n                });\n                this._run(controller);\n            }\n        });\n    }\n}\nexport class NextMatchFindAction extends MatchFindAction {\n    constructor() {\n        super({\n            id: FIND_IDS.NextMatchFindAction,\n            label: nls.localize('findNextMatchAction', \"Find Next\"),\n            alias: 'Find Next',\n            precondition: undefined,\n            kbOpts: [{\n                    kbExpr: EditorContextKeys.focus,\n                    primary: 61 /* KeyCode.F3 */,\n                    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 37 /* KeyCode.KeyG */, secondary: [61 /* KeyCode.F3 */] },\n                    weight: 100 /* KeybindingWeight.EditorContrib */\n                }, {\n                    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),\n                    primary: 3 /* KeyCode.Enter */,\n                    weight: 100 /* KeybindingWeight.EditorContrib */\n                }]\n        });\n    }\n    _run(controller) {\n        const result = controller.moveToNextMatch();\n        if (result) {\n            controller.editor.pushUndoStop();\n            return true;\n        }\n        return false;\n    }\n}\nexport class PreviousMatchFindAction extends MatchFindAction {\n    constructor() {\n        super({\n            id: FIND_IDS.PreviousMatchFindAction,\n            label: nls.localize('findPreviousMatchAction', \"Find Previous\"),\n            alias: 'Find Previous',\n            precondition: undefined,\n            kbOpts: [{\n                    kbExpr: EditorContextKeys.focus,\n                    primary: 1024 /* KeyMod.Shift */ | 61 /* KeyCode.F3 */,\n                    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 37 /* KeyCode.KeyG */, secondary: [1024 /* KeyMod.Shift */ | 61 /* KeyCode.F3 */] },\n                    weight: 100 /* KeybindingWeight.EditorContrib */\n                }, {\n                    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),\n                    primary: 1024 /* KeyMod.Shift */ | 3 /* KeyCode.Enter */,\n                    weight: 100 /* KeybindingWeight.EditorContrib */\n                }\n            ]\n        });\n    }\n    _run(controller) {\n        return controller.moveToPrevMatch();\n    }\n}\nexport class SelectionMatchFindAction extends EditorAction {\n    run(accessor, editor) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const controller = CommonFindController.get(editor);\n            if (!controller) {\n                return;\n            }\n            const seedSearchStringFromNonEmptySelection = editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection === 'selection';\n            let selectionSearchString = null;\n            if (editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection !== 'never') {\n                selectionSearchString = getSelectionSearchString(editor, 'single', seedSearchStringFromNonEmptySelection);\n            }\n            if (selectionSearchString) {\n                controller.setSearchString(selectionSearchString);\n            }\n            if (!this._run(controller)) {\n                yield controller.start({\n                    forceRevealReplace: false,\n                    seedSearchStringFromSelection: editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection !== 'never' ? 'single' : 'none',\n                    seedSearchStringFromNonEmptySelection: seedSearchStringFromNonEmptySelection,\n                    seedSearchStringFromGlobalClipboard: false,\n                    shouldFocus: 0 /* FindStartFocusAction.NoFocusChange */,\n                    shouldAnimate: true,\n                    updateSearchScope: false,\n                    loop: editor.getOption(37 /* EditorOption.find */).loop\n                });\n                this._run(controller);\n            }\n        });\n    }\n}\nexport class NextSelectionMatchFindAction extends SelectionMatchFindAction {\n    constructor() {\n        super({\n            id: FIND_IDS.NextSelectionMatchFindAction,\n            label: nls.localize('nextSelectionMatchFindAction', \"Find Next Selection\"),\n            alias: 'Find Next Selection',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.focus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 61 /* KeyCode.F3 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    _run(controller) {\n        return controller.moveToNextMatch();\n    }\n}\nexport class PreviousSelectionMatchFindAction extends SelectionMatchFindAction {\n    constructor() {\n        super({\n            id: FIND_IDS.PreviousSelectionMatchFindAction,\n            label: nls.localize('previousSelectionMatchFindAction', \"Find Previous Selection\"),\n            alias: 'Find Previous Selection',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.focus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 61 /* KeyCode.F3 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    _run(controller) {\n        return controller.moveToPrevMatch();\n    }\n}\nexport const StartFindReplaceAction = registerMultiEditorAction(new MultiEditorAction({\n    id: FIND_IDS.StartFindReplaceAction,\n    label: nls.localize('startReplace', \"Replace\"),\n    alias: 'Replace',\n    precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has('editorIsOpen')),\n    kbOpts: {\n        kbExpr: null,\n        primary: 2048 /* KeyMod.CtrlCmd */ | 38 /* KeyCode.KeyH */,\n        mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 36 /* KeyCode.KeyF */ },\n        weight: 100 /* KeybindingWeight.EditorContrib */\n    },\n    menuOpts: {\n        menuId: MenuId.MenubarEditMenu,\n        group: '3_find',\n        title: nls.localize({ key: 'miReplace', comment: ['&& denotes a mnemonic'] }, \"&&Replace\"),\n        order: 2\n    }\n}));\nStartFindReplaceAction.addImplementation(0, (accessor, editor, args) => {\n    if (!editor.hasModel() || editor.getOption(83 /* EditorOption.readOnly */)) {\n        return false;\n    }\n    const controller = CommonFindController.get(editor);\n    if (!controller) {\n        return false;\n    }\n    const currentSelection = editor.getSelection();\n    const findInputFocused = controller.isFindInputFocused();\n    // we only seed search string from selection when the current selection is single line and not empty,\n    // + the find input is not focused\n    const seedSearchStringFromSelection = !currentSelection.isEmpty()\n        && currentSelection.startLineNumber === currentSelection.endLineNumber\n        && (editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection !== 'never')\n        && !findInputFocused;\n    /*\n    * if the existing search string in find widget is empty and we don't seed search string from selection, it means the Find Input is still empty, so we should focus the Find Input instead of Replace Input.\n\n    * findInputFocused true -> seedSearchStringFromSelection false, FocusReplaceInput\n    * findInputFocused false, seedSearchStringFromSelection true FocusReplaceInput\n    * findInputFocused false seedSearchStringFromSelection false FocusFindInput\n    */\n    const shouldFocus = (findInputFocused || seedSearchStringFromSelection) ?\n        2 /* FindStartFocusAction.FocusReplaceInput */ : 1 /* FindStartFocusAction.FocusFindInput */;\n    return controller.start({\n        forceRevealReplace: true,\n        seedSearchStringFromSelection: seedSearchStringFromSelection ? 'single' : 'none',\n        seedSearchStringFromNonEmptySelection: editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection === 'selection',\n        seedSearchStringFromGlobalClipboard: editor.getOption(37 /* EditorOption.find */).seedSearchStringFromSelection !== 'never',\n        shouldFocus: shouldFocus,\n        shouldAnimate: true,\n        updateSearchScope: false,\n        loop: editor.getOption(37 /* EditorOption.find */).loop\n    });\n});\nregisterEditorContribution(CommonFindController.ID, FindController);\nregisterEditorAction(StartFindWithArgsAction);\nregisterEditorAction(StartFindWithSelectionAction);\nregisterEditorAction(NextMatchFindAction);\nregisterEditorAction(PreviousMatchFindAction);\nregisterEditorAction(NextSelectionMatchFindAction);\nregisterEditorAction(PreviousSelectionMatchFindAction);\nconst FindCommand = EditorCommand.bindToContribution(CommonFindController.get);\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.CloseFindWidgetCommand,\n    precondition: CONTEXT_FIND_WIDGET_VISIBLE,\n    handler: x => x.closeFindWidget(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not('isComposing')),\n        primary: 9 /* KeyCode.Escape */,\n        secondary: [1024 /* KeyMod.Shift */ | 9 /* KeyCode.Escape */]\n    }\n}));\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.ToggleCaseSensitiveCommand,\n    precondition: undefined,\n    handler: x => x.toggleCaseSensitive(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: EditorContextKeys.focus,\n        primary: ToggleCaseSensitiveKeybinding.primary,\n        mac: ToggleCaseSensitiveKeybinding.mac,\n        win: ToggleCaseSensitiveKeybinding.win,\n        linux: ToggleCaseSensitiveKeybinding.linux\n    }\n}));\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.ToggleWholeWordCommand,\n    precondition: undefined,\n    handler: x => x.toggleWholeWords(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: EditorContextKeys.focus,\n        primary: ToggleWholeWordKeybinding.primary,\n        mac: ToggleWholeWordKeybinding.mac,\n        win: ToggleWholeWordKeybinding.win,\n        linux: ToggleWholeWordKeybinding.linux\n    }\n}));\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.ToggleRegexCommand,\n    precondition: undefined,\n    handler: x => x.toggleRegex(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: EditorContextKeys.focus,\n        primary: ToggleRegexKeybinding.primary,\n        mac: ToggleRegexKeybinding.mac,\n        win: ToggleRegexKeybinding.win,\n        linux: ToggleRegexKeybinding.linux\n    }\n}));\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.ToggleSearchScopeCommand,\n    precondition: undefined,\n    handler: x => x.toggleSearchScope(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: EditorContextKeys.focus,\n        primary: ToggleSearchScopeKeybinding.primary,\n        mac: ToggleSearchScopeKeybinding.mac,\n        win: ToggleSearchScopeKeybinding.win,\n        linux: ToggleSearchScopeKeybinding.linux\n    }\n}));\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.TogglePreserveCaseCommand,\n    precondition: undefined,\n    handler: x => x.togglePreserveCase(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: EditorContextKeys.focus,\n        primary: TogglePreserveCaseKeybinding.primary,\n        mac: TogglePreserveCaseKeybinding.mac,\n        win: TogglePreserveCaseKeybinding.win,\n        linux: TogglePreserveCaseKeybinding.linux\n    }\n}));\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.ReplaceOneAction,\n    precondition: CONTEXT_FIND_WIDGET_VISIBLE,\n    handler: x => x.replace(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: EditorContextKeys.focus,\n        primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 22 /* KeyCode.Digit1 */\n    }\n}));\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.ReplaceOneAction,\n    precondition: CONTEXT_FIND_WIDGET_VISIBLE,\n    handler: x => x.replace(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),\n        primary: 3 /* KeyCode.Enter */\n    }\n}));\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.ReplaceAllAction,\n    precondition: CONTEXT_FIND_WIDGET_VISIBLE,\n    handler: x => x.replaceAll(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: EditorContextKeys.focus,\n        primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 3 /* KeyCode.Enter */\n    }\n}));\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.ReplaceAllAction,\n    precondition: CONTEXT_FIND_WIDGET_VISIBLE,\n    handler: x => x.replaceAll(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),\n        primary: undefined,\n        mac: {\n            primary: 2048 /* KeyMod.CtrlCmd */ | 3 /* KeyCode.Enter */,\n        }\n    }\n}));\nregisterEditorCommand(new FindCommand({\n    id: FIND_IDS.SelectAllMatchesAction,\n    precondition: CONTEXT_FIND_WIDGET_VISIBLE,\n    handler: x => x.selectAllMatches(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 5,\n        kbExpr: EditorContextKeys.focus,\n        primary: 512 /* KeyMod.Alt */ | 3 /* KeyCode.Enter */\n    }\n}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { createCancelablePromise, Delayer, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { KeyChord } from '../../../../base/common/keyCodes.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { escapeRegExpCharacters } from '../../../../base/common/strings.js';\nimport * as types from '../../../../base/common/types.js';\nimport './folding.css';\nimport { StableEditorScrollState } from '../../../browser/stableEditorScroll.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution, registerInstantiatedEditorAction } from '../../../browser/editorExtensions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { FoldingRangeKind } from '../../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { FoldingModel, getNextFoldLine, getParentFoldLine as getParentFoldLine, getPreviousFoldLine, setCollapseStateAtLevel, setCollapseStateForMatchingLines, setCollapseStateForRest, setCollapseStateForType, setCollapseStateLevelsDown, setCollapseStateLevelsUp, setCollapseStateUp, toggleCollapseState } from './foldingModel.js';\nimport { HiddenRangeModel } from './hiddenRangeModel.js';\nimport { IndentRangeProvider } from './indentRangeProvider.js';\nimport * as nls from '../../../../nls.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { editorSelectionBackground, iconForeground, registerColor, transparent } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant, ThemeIcon } from '../../../../platform/theme/common/themeService.js';\nimport { foldingCollapsedIcon, FoldingDecorationProvider, foldingExpandedIcon, foldingManualCollapsedIcon, foldingManualExpandedIcon } from './foldingDecorations.js';\nimport { FoldingRegions } from './foldingRanges.js';\nimport { SyntaxRangeProvider } from './syntaxRangeProvider.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nimport Severity from '../../../../base/common/severity.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nconst CONTEXT_FOLDING_ENABLED = new RawContextKey('foldingEnabled', false);\nlet FoldingController = class FoldingController extends Disposable {\n    constructor(editor, contextKeyService, languageConfigurationService, notificationService, languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this.contextKeyService = contextKeyService;\n        this.languageConfigurationService = languageConfigurationService;\n        this.languageFeaturesService = languageFeaturesService;\n        this._tooManyRegionsNotified = false;\n        this.localToDispose = this._register(new DisposableStore());\n        this.editor = editor;\n        const options = this.editor.getOptions();\n        this._isEnabled = options.get(39 /* EditorOption.folding */);\n        this._useFoldingProviders = options.get(40 /* EditorOption.foldingStrategy */) !== 'indentation';\n        this._unfoldOnClickAfterEndOfLine = options.get(44 /* EditorOption.unfoldOnClickAfterEndOfLine */);\n        this._restoringViewState = false;\n        this._currentModelHasFoldedImports = false;\n        this._foldingImportsByDefault = options.get(42 /* EditorOption.foldingImportsByDefault */);\n        this._maxFoldingRegions = options.get(43 /* EditorOption.foldingMaximumRegions */);\n        this.updateDebounceInfo = languageFeatureDebounceService.for(languageFeaturesService.foldingRangeProvider, 'Folding', { min: 200 });\n        this.foldingModel = null;\n        this.hiddenRangeModel = null;\n        this.rangeProvider = null;\n        this.foldingRegionPromise = null;\n        this.foldingModelPromise = null;\n        this.updateScheduler = null;\n        this.cursorChangedScheduler = null;\n        this.mouseDownInfo = null;\n        this.foldingDecorationProvider = new FoldingDecorationProvider(editor);\n        this.foldingDecorationProvider.showFoldingControls = options.get(101 /* EditorOption.showFoldingControls */);\n        this.foldingDecorationProvider.showFoldingHighlights = options.get(41 /* EditorOption.foldingHighlight */);\n        this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);\n        this.foldingEnabled.set(this._isEnabled);\n        this._notifyTooManyRegions = (maxFoldingRegions) => {\n            // Message will display once per time vscode runs. Once per file would be tricky.\n            if (!this._tooManyRegionsNotified) {\n                notificationService.notify({\n                    severity: Severity.Warning,\n                    sticky: true,\n                    message: nls.localize('maximum fold ranges', \"The number of foldable regions is limited to a maximum of {0}. Increase configuration option ['Folding Maximum Regions'](command:workbench.action.openSettings?[\\\"editor.foldingMaximumRegions\\\"]) to enable more.\", maxFoldingRegions)\n                });\n                this._tooManyRegionsNotified = true;\n            }\n        };\n        this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));\n        this._register(this.editor.onDidChangeConfiguration((e) => {\n            if (e.hasChanged(39 /* EditorOption.folding */)) {\n                this._isEnabled = this.editor.getOptions().get(39 /* EditorOption.folding */);\n                this.foldingEnabled.set(this._isEnabled);\n                this.onModelChanged();\n            }\n            if (e.hasChanged(43 /* EditorOption.foldingMaximumRegions */)) {\n                this._maxFoldingRegions = this.editor.getOptions().get(43 /* EditorOption.foldingMaximumRegions */);\n                this._tooManyRegionsNotified = false;\n                this.onModelChanged();\n            }\n            if (e.hasChanged(101 /* EditorOption.showFoldingControls */) || e.hasChanged(41 /* EditorOption.foldingHighlight */)) {\n                const options = this.editor.getOptions();\n                this.foldingDecorationProvider.showFoldingControls = options.get(101 /* EditorOption.showFoldingControls */);\n                this.foldingDecorationProvider.showFoldingHighlights = options.get(41 /* EditorOption.foldingHighlight */);\n                this.triggerFoldingModelChanged();\n            }\n            if (e.hasChanged(40 /* EditorOption.foldingStrategy */)) {\n                this._useFoldingProviders = this.editor.getOptions().get(40 /* EditorOption.foldingStrategy */) !== 'indentation';\n                this.onFoldingStrategyChanged();\n            }\n            if (e.hasChanged(44 /* EditorOption.unfoldOnClickAfterEndOfLine */)) {\n                this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(44 /* EditorOption.unfoldOnClickAfterEndOfLine */);\n            }\n            if (e.hasChanged(42 /* EditorOption.foldingImportsByDefault */)) {\n                this._foldingImportsByDefault = this.editor.getOptions().get(42 /* EditorOption.foldingImportsByDefault */);\n            }\n        }));\n        this.onModelChanged();\n    }\n    static get(editor) {\n        return editor.getContribution(FoldingController.ID);\n    }\n    /**\n     * Store view state.\n     */\n    saveViewState() {\n        const model = this.editor.getModel();\n        if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {\n            return {};\n        }\n        if (this.foldingModel) { // disposed ?\n            const collapsedRegions = this.foldingModel.getMemento();\n            const provider = this.rangeProvider ? this.rangeProvider.id : undefined;\n            return { collapsedRegions, lineCount: model.getLineCount(), provider, foldedImports: this._currentModelHasFoldedImports };\n        }\n        return undefined;\n    }\n    /**\n     * Restore view state.\n     */\n    restoreViewState(state) {\n        const model = this.editor.getModel();\n        if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {\n            return;\n        }\n        if (!state || state.lineCount !== model.getLineCount()) {\n            return;\n        }\n        this._currentModelHasFoldedImports = !!state.foldedImports;\n        if (state.collapsedRegions && state.collapsedRegions.length > 0 && this.foldingModel) {\n            this._restoringViewState = true;\n            try {\n                this.foldingModel.applyMemento(state.collapsedRegions);\n            }\n            finally {\n                this._restoringViewState = false;\n            }\n        }\n    }\n    onModelChanged() {\n        this.localToDispose.clear();\n        const model = this.editor.getModel();\n        if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {\n            // huge files get no view model, so they cannot support hidden areas\n            return;\n        }\n        this._currentModelHasFoldedImports = false;\n        this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);\n        this.localToDispose.add(this.foldingModel);\n        this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);\n        this.localToDispose.add(this.hiddenRangeModel);\n        this.localToDispose.add(this.hiddenRangeModel.onDidChange(hr => this.onHiddenRangesChanges(hr)));\n        this.updateScheduler = new Delayer(this.updateDebounceInfo.get(model));\n        this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);\n        this.localToDispose.add(this.cursorChangedScheduler);\n        this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged()));\n        this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged())); // covers model language changes as well\n        this.localToDispose.add(this.editor.onDidChangeModelContent(e => this.onDidChangeModelContent(e)));\n        this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));\n        this.localToDispose.add(this.editor.onMouseDown(e => this.onEditorMouseDown(e)));\n        this.localToDispose.add(this.editor.onMouseUp(e => this.onEditorMouseUp(e)));\n        this.localToDispose.add({\n            dispose: () => {\n                if (this.foldingRegionPromise) {\n                    this.foldingRegionPromise.cancel();\n                    this.foldingRegionPromise = null;\n                }\n                if (this.updateScheduler) {\n                    this.updateScheduler.cancel();\n                }\n                this.updateScheduler = null;\n                this.foldingModel = null;\n                this.foldingModelPromise = null;\n                this.hiddenRangeModel = null;\n                this.cursorChangedScheduler = null;\n                if (this.rangeProvider) {\n                    this.rangeProvider.dispose();\n                }\n                this.rangeProvider = null;\n            }\n        });\n        this.triggerFoldingModelChanged();\n    }\n    onFoldingStrategyChanged() {\n        if (this.rangeProvider) {\n            this.rangeProvider.dispose();\n        }\n        this.rangeProvider = null;\n        this.triggerFoldingModelChanged();\n    }\n    getRangeProvider(editorModel) {\n        if (this.rangeProvider) {\n            return this.rangeProvider;\n        }\n        this.rangeProvider = new IndentRangeProvider(editorModel, this.languageConfigurationService, this._maxFoldingRegions); // fallback\n        if (this._useFoldingProviders && this.foldingModel) {\n            const foldingProviders = this.languageFeaturesService.foldingRangeProvider.ordered(this.foldingModel.textModel);\n            if (foldingProviders.length > 0) {\n                this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, () => this.triggerFoldingModelChanged(), this._maxFoldingRegions);\n            }\n        }\n        return this.rangeProvider;\n    }\n    getFoldingModel() {\n        return this.foldingModelPromise;\n    }\n    onDidChangeModelContent(e) {\n        var _a;\n        (_a = this.hiddenRangeModel) === null || _a === void 0 ? void 0 : _a.notifyChangeModelContent(e);\n        this.triggerFoldingModelChanged();\n    }\n    triggerFoldingModelChanged() {\n        if (this.updateScheduler) {\n            if (this.foldingRegionPromise) {\n                this.foldingRegionPromise.cancel();\n                this.foldingRegionPromise = null;\n            }\n            this.foldingModelPromise = this.updateScheduler.trigger(() => {\n                const foldingModel = this.foldingModel;\n                if (!foldingModel) { // null if editor has been disposed, or folding turned off\n                    return null;\n                }\n                const sw = new StopWatch(true);\n                const provider = this.getRangeProvider(foldingModel.textModel);\n                const foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise(token => provider.compute(token, this._notifyTooManyRegions));\n                return foldingRegionPromise.then(foldingRanges => {\n                    if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) { // new request or cancelled in the meantime?\n                        let scrollState;\n                        if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {\n                            const hasChanges = foldingRanges.setCollapsedAllOfType(FoldingRangeKind.Imports.value, true);\n                            if (hasChanges) {\n                                scrollState = StableEditorScrollState.capture(this.editor);\n                                this._currentModelHasFoldedImports = hasChanges;\n                            }\n                        }\n                        // some cursors might have moved into hidden regions, make sure they are in expanded regions\n                        const selections = this.editor.getSelections();\n                        const selectionLineNumbers = selections ? selections.map(s => s.startLineNumber) : [];\n                        foldingModel.update(foldingRanges, selectionLineNumbers);\n                        scrollState === null || scrollState === void 0 ? void 0 : scrollState.restore(this.editor);\n                        // update debounce info\n                        const newValue = this.updateDebounceInfo.update(foldingModel.textModel, sw.elapsed());\n                        if (this.updateScheduler) {\n                            this.updateScheduler.defaultDelay = newValue;\n                        }\n                    }\n                    return foldingModel;\n                });\n            }).then(undefined, (err) => {\n                onUnexpectedError(err);\n                return null;\n            });\n        }\n    }\n    onHiddenRangesChanges(hiddenRanges) {\n        if (this.hiddenRangeModel && hiddenRanges.length && !this._restoringViewState) {\n            const selections = this.editor.getSelections();\n            if (selections) {\n                if (this.hiddenRangeModel.adjustSelections(selections)) {\n                    this.editor.setSelections(selections);\n                }\n            }\n        }\n        this.editor.setHiddenAreas(hiddenRanges);\n    }\n    onCursorPositionChanged() {\n        if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {\n            this.cursorChangedScheduler.schedule();\n        }\n    }\n    revealCursor() {\n        const foldingModel = this.getFoldingModel();\n        if (!foldingModel) {\n            return;\n        }\n        foldingModel.then(foldingModel => {\n            if (foldingModel) {\n                const selections = this.editor.getSelections();\n                if (selections && selections.length > 0) {\n                    const toToggle = [];\n                    for (const selection of selections) {\n                        const lineNumber = selection.selectionStartLineNumber;\n                        if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {\n                            toToggle.push(...foldingModel.getAllRegionsAtLine(lineNumber, r => r.isCollapsed && lineNumber > r.startLineNumber));\n                        }\n                    }\n                    if (toToggle.length) {\n                        foldingModel.toggleCollapseState(toToggle);\n                        this.reveal(selections[0].getPosition());\n                    }\n                }\n            }\n        }).then(undefined, onUnexpectedError);\n    }\n    onEditorMouseDown(e) {\n        this.mouseDownInfo = null;\n        if (!this.hiddenRangeModel || !e.target || !e.target.range) {\n            return;\n        }\n        if (!e.event.leftButton && !e.event.middleButton) {\n            return;\n        }\n        const range = e.target.range;\n        let iconClicked = false;\n        switch (e.target.type) {\n            case 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */: {\n                const data = e.target.detail;\n                const offsetLeftInGutter = e.target.element.offsetLeft;\n                const gutterOffsetX = data.offsetX - offsetLeftInGutter;\n                // const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;\n                // TODO@joao TODO@alex TODO@martin this is such that we don't collide with dirty diff\n                if (gutterOffsetX < 5) { // the whitespace between the border and the real folding icon border is 5px\n                    return;\n                }\n                iconClicked = true;\n                break;\n            }\n            case 7 /* MouseTargetType.CONTENT_EMPTY */: {\n                if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {\n                    const data = e.target.detail;\n                    if (!data.isAfterLines) {\n                        break;\n                    }\n                }\n                return;\n            }\n            case 6 /* MouseTargetType.CONTENT_TEXT */: {\n                if (this.hiddenRangeModel.hasRanges()) {\n                    const model = this.editor.getModel();\n                    if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {\n                        break;\n                    }\n                }\n                return;\n            }\n            default:\n                return;\n        }\n        this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked };\n    }\n    onEditorMouseUp(e) {\n        const foldingModel = this.foldingModel;\n        if (!foldingModel || !this.mouseDownInfo || !e.target) {\n            return;\n        }\n        const lineNumber = this.mouseDownInfo.lineNumber;\n        const iconClicked = this.mouseDownInfo.iconClicked;\n        const range = e.target.range;\n        if (!range || range.startLineNumber !== lineNumber) {\n            return;\n        }\n        if (iconClicked) {\n            if (e.target.type !== 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */) {\n                return;\n            }\n        }\n        else {\n            const model = this.editor.getModel();\n            if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {\n                return;\n            }\n        }\n        const region = foldingModel.getRegionAtLine(lineNumber);\n        if (region && region.startLineNumber === lineNumber) {\n            const isCollapsed = region.isCollapsed;\n            if (iconClicked || isCollapsed) {\n                const surrounding = e.event.altKey;\n                let toToggle = [];\n                if (surrounding) {\n                    const filter = (otherRegion) => !otherRegion.containedBy(region) && !region.containedBy(otherRegion);\n                    const toMaybeToggle = foldingModel.getRegionsInside(null, filter);\n                    for (const r of toMaybeToggle) {\n                        if (r.isCollapsed) {\n                            toToggle.push(r);\n                        }\n                    }\n                    // if any surrounding regions are folded, unfold those. Otherwise, fold all surrounding\n                    if (toToggle.length === 0) {\n                        toToggle = toMaybeToggle;\n                    }\n                }\n                else {\n                    const recursive = e.event.middleButton || e.event.shiftKey;\n                    if (recursive) {\n                        for (const r of foldingModel.getRegionsInside(region)) {\n                            if (r.isCollapsed === isCollapsed) {\n                                toToggle.push(r);\n                            }\n                        }\n                    }\n                    // when recursive, first only collapse all children. If all are already folded or there are no children, also fold parent.\n                    if (isCollapsed || !recursive || toToggle.length === 0) {\n                        toToggle.push(region);\n                    }\n                }\n                foldingModel.toggleCollapseState(toToggle);\n                this.reveal({ lineNumber, column: 1 });\n            }\n        }\n    }\n    reveal(position) {\n        this.editor.revealPositionInCenterIfOutsideViewport(position, 0 /* ScrollType.Smooth */);\n    }\n};\nFoldingController.ID = 'editor.contrib.folding';\nFoldingController = __decorate([\n    __param(1, IContextKeyService),\n    __param(2, ILanguageConfigurationService),\n    __param(3, INotificationService),\n    __param(4, ILanguageFeatureDebounceService),\n    __param(5, ILanguageFeaturesService)\n], FoldingController);\nexport { FoldingController };\nclass FoldingAction extends EditorAction {\n    runEditorCommand(accessor, editor, args) {\n        const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n        const foldingController = FoldingController.get(editor);\n        if (!foldingController) {\n            return;\n        }\n        const foldingModelPromise = foldingController.getFoldingModel();\n        if (foldingModelPromise) {\n            this.reportTelemetry(accessor, editor);\n            return foldingModelPromise.then(foldingModel => {\n                if (foldingModel) {\n                    this.invoke(foldingController, foldingModel, editor, args, languageConfigurationService);\n                    const selection = editor.getSelection();\n                    if (selection) {\n                        foldingController.reveal(selection.getStartPosition());\n                    }\n                }\n            });\n        }\n    }\n    getSelectedLines(editor) {\n        const selections = editor.getSelections();\n        return selections ? selections.map(s => s.startLineNumber) : [];\n    }\n    getLineNumbers(args, editor) {\n        if (args && args.selectionLines) {\n            return args.selectionLines.map(l => l + 1); // to 0-bases line numbers\n        }\n        return this.getSelectedLines(editor);\n    }\n    run(_accessor, _editor) {\n    }\n}\nfunction foldingArgumentsConstraint(args) {\n    if (!types.isUndefined(args)) {\n        if (!types.isObject(args)) {\n            return false;\n        }\n        const foldingArgs = args;\n        if (!types.isUndefined(foldingArgs.levels) && !types.isNumber(foldingArgs.levels)) {\n            return false;\n        }\n        if (!types.isUndefined(foldingArgs.direction) && !types.isString(foldingArgs.direction)) {\n            return false;\n        }\n        if (!types.isUndefined(foldingArgs.selectionLines) && (!types.isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(types.isNumber))) {\n            return false;\n        }\n    }\n    return true;\n}\nclass UnfoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfold',\n            label: nls.localize('unfoldAction.label', \"Unfold\"),\n            alias: 'Unfold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 89 /* KeyCode.BracketRight */,\n                mac: {\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 89 /* KeyCode.BracketRight */\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            description: {\n                description: 'Unfold the content in the editor',\n                args: [\n                    {\n                        name: 'Unfold editor argument',\n                        description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t* 'levels': Number of levels to unfold. If not set, defaults to 1.\n\t\t\t\t\t\t* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.\n\t\t\t\t\t\t* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t`,\n                        constraint: foldingArgumentsConstraint,\n                        schema: {\n                            'type': 'object',\n                            'properties': {\n                                'levels': {\n                                    'type': 'number',\n                                    'default': 1\n                                },\n                                'direction': {\n                                    'type': 'string',\n                                    'enum': ['up', 'down'],\n                                    'default': 'down'\n                                },\n                                'selectionLines': {\n                                    'type': 'array',\n                                    'items': {\n                                        'type': 'number'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args) {\n        const levels = args && args.levels || 1;\n        const lineNumbers = this.getLineNumbers(args, editor);\n        if (args && args.direction === 'up') {\n            setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);\n        }\n        else {\n            setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);\n        }\n    }\n}\nclass UnFoldRecursivelyAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldRecursively',\n            label: nls.localize('unFoldRecursivelyAction.label', \"Unfold Recursively\"),\n            alias: 'Unfold Recursively',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 89 /* KeyCode.BracketRight */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, _args) {\n        setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor));\n    }\n}\nclass FoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.fold',\n            label: nls.localize('foldAction.label', \"Fold\"),\n            alias: 'Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 87 /* KeyCode.BracketLeft */,\n                mac: {\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 87 /* KeyCode.BracketLeft */\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            description: {\n                description: 'Fold the content in the editor',\n                args: [\n                    {\n                        name: 'Fold editor argument',\n                        description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'levels': Number of levels to fold.\n\t\t\t\t\t\t\t* 'direction': If 'up', folds given number of levels up otherwise folds down.\n\t\t\t\t\t\t\t* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t\tIf no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.\n\t\t\t\t\t\t`,\n                        constraint: foldingArgumentsConstraint,\n                        schema: {\n                            'type': 'object',\n                            'properties': {\n                                'levels': {\n                                    'type': 'number',\n                                },\n                                'direction': {\n                                    'type': 'string',\n                                    'enum': ['up', 'down'],\n                                },\n                                'selectionLines': {\n                                    'type': 'array',\n                                    'items': {\n                                        'type': 'number'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args) {\n        const lineNumbers = this.getLineNumbers(args, editor);\n        const levels = args && args.levels;\n        const direction = args && args.direction;\n        if (typeof levels !== 'number' && typeof direction !== 'string') {\n            // fold the region at the location or if already collapsed, the first uncollapsed parent instead.\n            setCollapseStateUp(foldingModel, true, lineNumbers);\n        }\n        else {\n            if (direction === 'up') {\n                setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);\n            }\n            else {\n                setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);\n            }\n        }\n    }\n}\nclass ToggleFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.toggleFold',\n            label: nls.localize('toggleFoldAction.label', \"Toggle Fold\"),\n            alias: 'Toggle Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 42 /* KeyCode.KeyL */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        toggleCollapseState(foldingModel, 1, selectedLines);\n    }\n}\nclass FoldRecursivelyAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldRecursively',\n            label: nls.localize('foldRecursivelyAction.label', \"Fold Recursively\"),\n            alias: 'Fold Recursively',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 87 /* KeyCode.BracketLeft */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);\n    }\n}\nclass FoldAllBlockCommentsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllBlockComments',\n            label: nls.localize('foldAllBlockComments.label', \"Fold All Block Comments\"),\n            alias: 'Fold All Block Comments',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 85 /* KeyCode.Slash */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const comments = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).comments;\n            if (comments && comments.blockCommentStartToken) {\n                const regExp = new RegExp('^\\\\s*' + escapeRegExpCharacters(comments.blockCommentStartToken));\n                setCollapseStateForMatchingLines(foldingModel, regExp, true);\n            }\n        }\n    }\n}\nclass FoldAllRegionsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllMarkerRegions',\n            label: nls.localize('foldAllMarkerRegions.label', \"Fold All Regions\"),\n            alias: 'Fold All Regions',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 29 /* KeyCode.Digit8 */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;\n            if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n                const regExp = new RegExp(foldingRules.markers.start);\n                setCollapseStateForMatchingLines(foldingModel, regExp, true);\n            }\n        }\n    }\n}\nclass UnfoldAllRegionsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAllMarkerRegions',\n            label: nls.localize('unfoldAllMarkerRegions.label', \"Unfold All Regions\"),\n            alias: 'Unfold All Regions',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 30 /* KeyCode.Digit9 */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;\n            if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n                const regExp = new RegExp(foldingRules.markers.start);\n                setCollapseStateForMatchingLines(foldingModel, regExp, false);\n            }\n        }\n    }\n}\nclass FoldAllRegionsExceptAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllExcept',\n            label: nls.localize('foldAllExcept.label', \"Fold All Regions Except Selected\"),\n            alias: 'Fold All Regions Except Selected',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 83 /* KeyCode.Minus */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        setCollapseStateForRest(foldingModel, true, selectedLines);\n    }\n}\nclass UnfoldAllRegionsExceptAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAllExcept',\n            label: nls.localize('unfoldAllExcept.label', \"Unfold All Regions Except Selected\"),\n            alias: 'Unfold All Regions Except Selected',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 81 /* KeyCode.Equal */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        setCollapseStateForRest(foldingModel, false, selectedLines);\n    }\n}\nclass FoldAllAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAll',\n            label: nls.localize('foldAllAction.label', \"Fold All\"),\n            alias: 'Fold All',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 21 /* KeyCode.Digit0 */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, _editor) {\n        setCollapseStateLevelsDown(foldingModel, true);\n    }\n}\nclass UnfoldAllAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAll',\n            label: nls.localize('unfoldAllAction.label', \"Unfold All\"),\n            alias: 'Unfold All',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 40 /* KeyCode.KeyJ */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, _editor) {\n        setCollapseStateLevelsDown(foldingModel, false);\n    }\n}\nclass FoldLevelAction extends FoldingAction {\n    getFoldingLevel() {\n        return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor));\n    }\n}\nFoldLevelAction.ID_PREFIX = 'editor.foldLevel';\nFoldLevelAction.ID = (level) => FoldLevelAction.ID_PREFIX + level;\n/** Action to go to the parent fold of current line */\nclass GotoParentFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoParentFold',\n            label: nls.localize('gotoParentFold.label', \"Go to Parent Fold\"),\n            alias: 'Go to Parent Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            const startLineNumber = getParentFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\n/** Action to go to the previous fold of current line */\nclass GotoPreviousFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoPreviousFold',\n            label: nls.localize('gotoPreviousFold.label', \"Go to Previous Folding Range\"),\n            alias: 'Go to Previous Folding Range',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            const startLineNumber = getPreviousFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\n/** Action to go to the next fold of current line */\nclass GotoNextFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoNextFold',\n            label: nls.localize('gotoNextFold.label', \"Go to Next Folding Range\"),\n            alias: 'Go to Next Folding Range',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            const startLineNumber = getNextFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\nclass FoldRangeFromSelectionAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.createFoldingRangeFromSelection',\n            label: nls.localize('createManualFoldRange.label', \"Create Manual Folding Range from Selection\"),\n            alias: 'Create Folding Range from Selection',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 82 /* KeyCode.Comma */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        var _a;\n        const collapseRanges = [];\n        const selections = editor.getSelections();\n        if (selections) {\n            for (const selection of selections) {\n                let endLineNumber = selection.endLineNumber;\n                if (selection.endColumn === 1) {\n                    --endLineNumber;\n                }\n                if (endLineNumber > selection.startLineNumber) {\n                    collapseRanges.push({\n                        startLineNumber: selection.startLineNumber,\n                        endLineNumber: endLineNumber,\n                        type: undefined,\n                        isCollapsed: true,\n                        source: 1 /* FoldSource.userDefined */\n                    });\n                    editor.setSelection({\n                        startLineNumber: selection.startLineNumber,\n                        startColumn: 1,\n                        endLineNumber: selection.startLineNumber,\n                        endColumn: 1\n                    });\n                }\n            }\n            if (collapseRanges.length > 0) {\n                collapseRanges.sort((a, b) => {\n                    return a.startLineNumber - b.startLineNumber;\n                });\n                const newRanges = FoldingRegions.sanitizeAndMerge(foldingModel.regions, collapseRanges, (_a = editor.getModel()) === null || _a === void 0 ? void 0 : _a.getLineCount());\n                foldingModel.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n            }\n        }\n    }\n}\nclass RemoveFoldRangeFromSelectionAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.removeManualFoldingRanges',\n            label: nls.localize('removeManualFoldingRanges.label', \"Remove Manual Folding Ranges\"),\n            alias: 'Remove Manual Folding Ranges',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 84 /* KeyCode.Period */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(foldingController, foldingModel, editor) {\n        const selections = editor.getSelections();\n        if (selections) {\n            const ranges = [];\n            for (const selection of selections) {\n                const { startLineNumber, endLineNumber } = selection;\n                ranges.push(endLineNumber >= startLineNumber ? { startLineNumber, endLineNumber } : { endLineNumber, startLineNumber });\n            }\n            foldingModel.removeManualRanges(ranges);\n            foldingController.triggerFoldingModelChanged();\n        }\n    }\n}\nregisterEditorContribution(FoldingController.ID, FoldingController);\nregisterEditorAction(UnfoldAction);\nregisterEditorAction(UnFoldRecursivelyAction);\nregisterEditorAction(FoldAction);\nregisterEditorAction(FoldRecursivelyAction);\nregisterEditorAction(FoldAllAction);\nregisterEditorAction(UnfoldAllAction);\nregisterEditorAction(FoldAllBlockCommentsAction);\nregisterEditorAction(FoldAllRegionsAction);\nregisterEditorAction(UnfoldAllRegionsAction);\nregisterEditorAction(FoldAllRegionsExceptAction);\nregisterEditorAction(UnfoldAllRegionsExceptAction);\nregisterEditorAction(ToggleFoldAction);\nregisterEditorAction(GotoParentFoldAction);\nregisterEditorAction(GotoPreviousFoldAction);\nregisterEditorAction(GotoNextFoldAction);\nregisterEditorAction(FoldRangeFromSelectionAction);\nregisterEditorAction(RemoveFoldRangeFromSelectionAction);\nfor (let i = 1; i <= 7; i++) {\n    registerInstantiatedEditorAction(new FoldLevelAction({\n        id: FoldLevelAction.ID(i),\n        label: nls.localize('foldLevelAction.label', \"Fold Level {0}\", i),\n        alias: `Fold Level ${i}`,\n        precondition: CONTEXT_FOLDING_ENABLED,\n        kbOpts: {\n            kbExpr: EditorContextKeys.editorTextFocus,\n            primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | (21 /* KeyCode.Digit0 */ + i)),\n            weight: 100 /* KeybindingWeight.EditorContrib */\n        }\n    }));\n}\nexport const foldBackgroundBackground = registerColor('editor.foldBackground', { light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hcDark: null, hcLight: null }, nls.localize('foldBackgroundBackground', \"Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorFoldForeground = registerColor('editorGutter.foldingControlForeground', { dark: iconForeground, light: iconForeground, hcDark: iconForeground, hcLight: iconForeground }, nls.localize('editorGutter.foldingControlForeground', 'Color of the folding control in the editor gutter.'));\nregisterThemingParticipant((theme, collector) => {\n    const foldBackground = theme.getColor(foldBackgroundBackground);\n    if (foldBackground) {\n        collector.addRule(`.monaco-editor .folded-background { background-color: ${foldBackground}; }`);\n    }\n    const editorFoldColor = theme.getColor(editorFoldForeground);\n    if (editorFoldColor) {\n        collector.addRule(`\n\t\t.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingExpandedIcon)},\n\t\t.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingCollapsedIcon)},\n\t\t.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingManualExpandedIcon)},\n\t\t.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingManualCollapsedIcon)} {\n\t\t\tcolor: ${editorFoldColor} !important;\n\t\t}\n\t\t`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorAction, registerEditorAction } from '../../../browser/editorExtensions.js';\nimport { EditorZoom } from '../../../common/config/editorZoom.js';\nimport * as nls from '../../../../nls.js';\nclass EditorFontZoomIn extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.fontZoomIn',\n            label: nls.localize('EditorFontZoomIn.label', \"Editor Font Zoom In\"),\n            alias: 'Editor Font Zoom In',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor) {\n        EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() + 1);\n    }\n}\nclass EditorFontZoomOut extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.fontZoomOut',\n            label: nls.localize('EditorFontZoomOut.label', \"Editor Font Zoom Out\"),\n            alias: 'Editor Font Zoom Out',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor) {\n        EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() - 1);\n    }\n}\nclass EditorFontZoomReset extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.fontZoomReset',\n            label: nls.localize('EditorFontZoomReset.label', \"Editor Font Zoom Reset\"),\n            alias: 'Editor Font Zoom Reset',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor) {\n        EditorZoom.setZoomLevel(0);\n    }\n}\nregisterEditorAction(EditorFontZoomIn);\nregisterEditorAction(EditorFontZoomOut);\nregisterEditorAction(EditorFontZoomReset);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/core/range.js';\nexport function createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nexport function applyEdits(text, edits) {\n    const transformer = new PositionOffsetTransformer(text);\n    const offsetEdits = edits.map(e => {\n        const range = Range.lift(e.range);\n        return ({\n            startOffset: transformer.getOffset(range.getStartPosition()),\n            endOffset: transformer.getOffset(range.getEndPosition()),\n            text: e.text\n        });\n    });\n    offsetEdits.sort((a, b) => b.startOffset - a.startOffset);\n    for (const edit of offsetEdits) {\n        text = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset);\n    }\n    return text;\n}\nclass PositionOffsetTransformer {\n    constructor(text) {\n        this.lineStartOffsetByLineIdx = [];\n        this.lineStartOffsetByLineIdx.push(0);\n        for (let i = 0; i < text.length; i++) {\n            if (text.charAt(i) === '\\n') {\n                this.lineStartOffsetByLineIdx.push(i + 1);\n            }\n        }\n    }\n    getOffset(position) {\n        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n    }\n}\nconst array = [];\nexport function getReadonlyEmptyArray() {\n    return array;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { applyEdits } from './utils.js';\nexport class GhostText {\n    constructor(lineNumber, parts, additionalReservedLineCount = 0) {\n        this.lineNumber = lineNumber;\n        this.parts = parts;\n        this.additionalReservedLineCount = additionalReservedLineCount;\n    }\n    renderForScreenReader(lineText) {\n        if (this.parts.length === 0) {\n            return '';\n        }\n        const lastPart = this.parts[this.parts.length - 1];\n        const cappedLineText = lineText.substr(0, lastPart.column - 1);\n        const text = applyEdits(cappedLineText, this.parts.map(p => ({\n            range: { startLineNumber: 1, endLineNumber: 1, startColumn: p.column, endColumn: p.column },\n            text: p.lines.join('\\n')\n        })));\n        return text.substring(this.parts[0].column - 1);\n    }\n    isEmpty() {\n        return this.parts.every(p => p.lines.length === 0);\n    }\n}\nexport class GhostTextPart {\n    constructor(column, lines, \n    /**\n     * Indicates if this part is a preview of an inline suggestion when a suggestion is previewed.\n    */\n    preview) {\n        this.column = column;\n        this.lines = lines;\n        this.preview = preview;\n    }\n}\nexport class GhostTextReplacement {\n    constructor(lineNumber, columnStart, length, newLines, additionalReservedLineCount = 0) {\n        this.lineNumber = lineNumber;\n        this.columnStart = columnStart;\n        this.length = length;\n        this.newLines = newLines;\n        this.additionalReservedLineCount = additionalReservedLineCount;\n        this.parts = [\n            new GhostTextPart(this.columnStart + this.length, this.newLines, false),\n        ];\n    }\n    renderForScreenReader(_lineText) {\n        return this.newLines.join('\\n');\n    }\n}\nexport class BaseGhostTextWidgetModel extends Disposable {\n    constructor(editor) {\n        super();\n        this.editor = editor;\n        this._expanded = undefined;\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this._register(editor.onDidChangeConfiguration((e) => {\n            if (e.hasChanged(108 /* EditorOption.suggest */) && this._expanded === undefined) {\n                this.onDidChangeEmitter.fire();\n            }\n        }));\n    }\n    setExpanded(expanded) {\n        this._expanded = true;\n        this.onDidChangeEmitter.fire();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { createCancelablePromise, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { CoreEditingCommands } from '../../../browser/coreCommands.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nimport { InlineCompletionTriggerKind } from '../../../common/languages.js';\nimport { BaseGhostTextWidgetModel, GhostTextReplacement } from './ghostText.js';\nimport { ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { inlineSuggestCommitId } from './consts.js';\nimport { inlineCompletionToGhostText } from './inlineCompletionToGhostText.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\nimport { SnippetController2 } from '../../snippet/browser/snippetController2.js';\nimport { assertNever } from '../../../../base/common/types.js';\nimport { matchesSubString } from '../../../../base/common/filters.js';\nimport { getReadonlyEmptyArray } from './utils.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nlet InlineCompletionsModel = class InlineCompletionsModel extends Disposable {\n    constructor(editor, cache, commandService, languageConfigurationService, languageFeaturesService, debounceService, configurationService) {\n        super();\n        this.editor = editor;\n        this.cache = cache;\n        this.commandService = commandService;\n        this.languageConfigurationService = languageConfigurationService;\n        this.languageFeaturesService = languageFeaturesService;\n        this.debounceService = debounceService;\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.completionSession = this._register(new MutableDisposable());\n        this.active = false;\n        this.disposed = false;\n        this.debounceValue = this.debounceService.for(this.languageFeaturesService.inlineCompletionsProvider, 'InlineCompletionsDebounce', { min: 50, max: 50 });\n        this._register(commandService.onDidExecuteCommand((e) => {\n            // These commands don't trigger onDidType.\n            const commands = new Set([\n                CoreEditingCommands.Tab.id,\n                CoreEditingCommands.DeleteLeft.id,\n                CoreEditingCommands.DeleteRight.id,\n                inlineSuggestCommitId,\n                'acceptSelectedSuggestion',\n            ]);\n            if (commands.has(e.commandId) && editor.hasTextFocus()) {\n                this.handleUserInput();\n            }\n        }));\n        this._register(this.editor.onDidType((e) => {\n            this.handleUserInput();\n        }));\n        this._register(this.editor.onDidChangeCursorPosition((e) => {\n            if (e.reason === 3 /* CursorChangeReason.Explicit */ ||\n                this.session && !this.session.isValid) {\n                this.hide();\n            }\n        }));\n        this._register(toDisposable(() => {\n            this.disposed = true;\n        }));\n        this._register(this.editor.onDidBlurEditorWidget(() => {\n            // This is a hidden setting very useful for debugging\n            if (configurationService.getValue('editor.inlineSuggest.hideOnBlur')) {\n                return;\n            }\n            this.hide();\n        }));\n    }\n    handleUserInput() {\n        if (this.session && !this.session.isValid) {\n            this.hide();\n        }\n        setTimeout(() => {\n            if (this.disposed) {\n                return;\n            }\n            // Wait for the cursor update that happens in the same iteration loop iteration\n            this.startSessionIfTriggered();\n        }, 0);\n    }\n    get session() {\n        return this.completionSession.value;\n    }\n    get ghostText() {\n        var _a;\n        return (_a = this.session) === null || _a === void 0 ? void 0 : _a.ghostText;\n    }\n    get minReservedLineCount() {\n        return this.session ? this.session.minReservedLineCount : 0;\n    }\n    setExpanded(expanded) {\n        var _a;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.setExpanded(expanded);\n    }\n    setActive(active) {\n        var _a;\n        this.active = active;\n        if (active) {\n            (_a = this.session) === null || _a === void 0 ? void 0 : _a.scheduleAutomaticUpdate();\n        }\n    }\n    startSessionIfTriggered() {\n        const suggestOptions = this.editor.getOption(57 /* EditorOption.inlineSuggest */);\n        if (!suggestOptions.enabled) {\n            return;\n        }\n        if (this.session && this.session.isValid) {\n            return;\n        }\n        this.trigger(InlineCompletionTriggerKind.Automatic);\n    }\n    trigger(triggerKind) {\n        if (this.completionSession.value) {\n            if (triggerKind === InlineCompletionTriggerKind.Explicit) {\n                void this.completionSession.value.ensureUpdateWithExplicitContext();\n            }\n            return;\n        }\n        this.completionSession.value = new InlineCompletionsSession(this.editor, this.editor.getPosition(), () => this.active, this.commandService, this.cache, triggerKind, this.languageConfigurationService, this.languageFeaturesService.inlineCompletionsProvider, this.debounceValue);\n        this.completionSession.value.takeOwnership(this.completionSession.value.onDidChange(() => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    hide() {\n        this.completionSession.clear();\n        this.onDidChangeEmitter.fire();\n    }\n    commitCurrentSuggestion() {\n        var _a;\n        // Don't dispose the session, so that after committing, more suggestions are shown.\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.commitCurrentCompletion();\n    }\n    showNext() {\n        var _a;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.showNextInlineCompletion();\n    }\n    showPrevious() {\n        var _a;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.showPreviousInlineCompletion();\n    }\n    hasMultipleInlineCompletions() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield ((_a = this.session) === null || _a === void 0 ? void 0 : _a.hasMultipleInlineCompletions());\n            return result !== undefined ? result : false;\n        });\n    }\n};\nInlineCompletionsModel = __decorate([\n    __param(2, ICommandService),\n    __param(3, ILanguageConfigurationService),\n    __param(4, ILanguageFeaturesService),\n    __param(5, ILanguageFeatureDebounceService),\n    __param(6, IConfigurationService)\n], InlineCompletionsModel);\nexport { InlineCompletionsModel };\nexport class InlineCompletionsSession extends BaseGhostTextWidgetModel {\n    constructor(editor, triggerPosition, shouldUpdate, commandService, cache, initialTriggerKind, languageConfigurationService, registry, debounce) {\n        super(editor);\n        this.triggerPosition = triggerPosition;\n        this.shouldUpdate = shouldUpdate;\n        this.commandService = commandService;\n        this.cache = cache;\n        this.initialTriggerKind = initialTriggerKind;\n        this.languageConfigurationService = languageConfigurationService;\n        this.registry = registry;\n        this.debounce = debounce;\n        this.minReservedLineCount = 0;\n        this.updateOperation = this._register(new MutableDisposable());\n        this.updateSoon = this._register(new RunOnceScheduler(() => {\n            const triggerKind = this.initialTriggerKind;\n            // All subsequent triggers are automatic.\n            this.initialTriggerKind = InlineCompletionTriggerKind.Automatic;\n            return this.update(triggerKind);\n        }, 50));\n        this.filteredCompletions = [];\n        //#region Selection\n        // We use a semantic id to track the selection even if the cache changes.\n        this.currentlySelectedCompletionId = undefined;\n        let lastCompletionItem = undefined;\n        this._register(this.onDidChange(() => {\n            var _a;\n            const currentCompletion = this.currentCompletion;\n            if (currentCompletion && currentCompletion.sourceInlineCompletion !== lastCompletionItem) {\n                lastCompletionItem = currentCompletion.sourceInlineCompletion;\n                const provider = currentCompletion.sourceProvider;\n                (_a = provider.handleItemDidShow) === null || _a === void 0 ? void 0 : _a.call(provider, currentCompletion.sourceInlineCompletions, lastCompletionItem);\n            }\n        }));\n        this._register(toDisposable(() => {\n            this.cache.clear();\n        }));\n        this._register(this.editor.onDidChangeCursorPosition((e) => {\n            var _a;\n            if (e.reason === 3 /* CursorChangeReason.Explicit */) {\n                return;\n            }\n            // Ghost text depends on the cursor position\n            (_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.updateRanges();\n            if (this.cache.value) {\n                this.updateFilteredInlineCompletions();\n                this.onDidChangeEmitter.fire();\n            }\n        }));\n        this._register(this.editor.onDidChangeModelContent((e) => {\n            var _a;\n            // Call this in case `onDidChangeModelContent` calls us first.\n            (_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.updateRanges();\n            this.updateFilteredInlineCompletions();\n            this.scheduleAutomaticUpdate();\n        }));\n        this._register(this.registry.onDidChange(() => {\n            this.updateSoon.schedule(this.debounce.get(this.editor.getModel()));\n        }));\n        this.scheduleAutomaticUpdate();\n    }\n    updateFilteredInlineCompletions() {\n        if (!this.cache.value) {\n            this.filteredCompletions = [];\n            return;\n        }\n        const model = this.editor.getModel();\n        const cursorPosition = model.validatePosition(this.editor.getPosition());\n        this.filteredCompletions = this.cache.value.completions.filter(c => {\n            const originalValue = model.getValueInRange(c.synchronizedRange).toLowerCase();\n            const filterText = c.inlineCompletion.filterText.toLowerCase();\n            const indent = model.getLineIndentColumn(c.synchronizedRange.startLineNumber);\n            const cursorPosIndex = Math.max(0, cursorPosition.column - c.synchronizedRange.startColumn);\n            let filterTextBefore = filterText.substring(0, cursorPosIndex);\n            let filterTextAfter = filterText.substring(cursorPosIndex);\n            let originalValueBefore = originalValue.substring(0, cursorPosIndex);\n            let originalValueAfter = originalValue.substring(cursorPosIndex);\n            if (c.synchronizedRange.startColumn <= indent) {\n                // Remove indentation\n                originalValueBefore = originalValueBefore.trimStart();\n                if (originalValueBefore.length === 0) {\n                    originalValueAfter = originalValueAfter.trimStart();\n                }\n                filterTextBefore = filterTextBefore.trimStart();\n                if (filterTextBefore.length === 0) {\n                    filterTextAfter = filterTextAfter.trimStart();\n                }\n            }\n            return filterTextBefore.startsWith(originalValueBefore)\n                && matchesSubString(originalValueAfter, filterTextAfter);\n        });\n    }\n    fixAndGetIndexOfCurrentSelection() {\n        if (!this.currentlySelectedCompletionId || !this.cache.value) {\n            return 0;\n        }\n        if (this.cache.value.completions.length === 0) {\n            // don't reset the selection in this case\n            return 0;\n        }\n        const idx = this.filteredCompletions.findIndex(v => v.semanticId === this.currentlySelectedCompletionId);\n        if (idx === -1) {\n            // Reset the selection so that the selection does not jump back when it appears again\n            this.currentlySelectedCompletionId = undefined;\n            return 0;\n        }\n        return idx;\n    }\n    get currentCachedCompletion() {\n        if (!this.cache.value) {\n            return undefined;\n        }\n        return this.filteredCompletions[this.fixAndGetIndexOfCurrentSelection()];\n    }\n    showNextInlineCompletion() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.ensureUpdateWithExplicitContext();\n            const completions = this.filteredCompletions || [];\n            if (completions.length > 0) {\n                const newIdx = (this.fixAndGetIndexOfCurrentSelection() + 1) % completions.length;\n                this.currentlySelectedCompletionId = completions[newIdx].semanticId;\n            }\n            else {\n                this.currentlySelectedCompletionId = undefined;\n            }\n            this.onDidChangeEmitter.fire();\n        });\n    }\n    showPreviousInlineCompletion() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.ensureUpdateWithExplicitContext();\n            const completions = this.filteredCompletions || [];\n            if (completions.length > 0) {\n                const newIdx = (this.fixAndGetIndexOfCurrentSelection() + completions.length - 1) % completions.length;\n                this.currentlySelectedCompletionId = completions[newIdx].semanticId;\n            }\n            else {\n                this.currentlySelectedCompletionId = undefined;\n            }\n            this.onDidChangeEmitter.fire();\n        });\n    }\n    ensureUpdateWithExplicitContext() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.updateOperation.value) {\n                // Restart or wait for current update operation\n                if (this.updateOperation.value.triggerKind === InlineCompletionTriggerKind.Explicit) {\n                    yield this.updateOperation.value.promise;\n                }\n                else {\n                    yield this.update(InlineCompletionTriggerKind.Explicit);\n                }\n            }\n            else if (((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.triggerKind) !== InlineCompletionTriggerKind.Explicit) {\n                // Refresh cache\n                yield this.update(InlineCompletionTriggerKind.Explicit);\n            }\n        });\n    }\n    hasMultipleInlineCompletions() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.ensureUpdateWithExplicitContext();\n            return (((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions.length) || 0) > 1;\n        });\n    }\n    //#endregion\n    get ghostText() {\n        const currentCompletion = this.currentCompletion;\n        if (!currentCompletion) {\n            return undefined;\n        }\n        const cursorPosition = this.editor.getPosition();\n        if (currentCompletion.range.getEndPosition().isBefore(cursorPosition)) {\n            return undefined;\n        }\n        const mode = this.editor.getOptions().get(57 /* EditorOption.inlineSuggest */).mode;\n        const ghostText = inlineCompletionToGhostText(currentCompletion, this.editor.getModel(), mode, cursorPosition);\n        if (ghostText) {\n            if (ghostText.isEmpty()) {\n                return undefined;\n            }\n            return ghostText;\n        }\n        return new GhostTextReplacement(currentCompletion.range.startLineNumber, currentCompletion.range.startColumn, currentCompletion.range.endColumn - currentCompletion.range.startColumn, currentCompletion.insertText.split('\\n'), 0);\n    }\n    get currentCompletion() {\n        const completion = this.currentCachedCompletion;\n        if (!completion) {\n            return undefined;\n        }\n        return completion.toLiveInlineCompletion();\n    }\n    get isValid() {\n        return this.editor.getPosition().lineNumber === this.triggerPosition.lineNumber;\n    }\n    scheduleAutomaticUpdate() {\n        // Since updateSoon debounces, starvation can happen.\n        // To prevent stale cache, we clear the current update operation.\n        this.updateOperation.clear();\n        this.updateSoon.schedule(this.debounce.get(this.editor.getModel()));\n    }\n    update(triggerKind) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.shouldUpdate()) {\n                return;\n            }\n            const position = this.editor.getPosition();\n            const startTime = new Date();\n            const promise = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {\n                let result;\n                try {\n                    result = yield provideInlineCompletions(this.registry, position, this.editor.getModel(), { triggerKind, selectedSuggestionInfo: undefined }, token, this.languageConfigurationService);\n                    const endTime = new Date();\n                    this.debounce.update(this.editor.getModel(), endTime.getTime() - startTime.getTime());\n                }\n                catch (e) {\n                    onUnexpectedError(e);\n                    return;\n                }\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                this.cache.setValue(this.editor, result, triggerKind);\n                this.updateFilteredInlineCompletions();\n                this.onDidChangeEmitter.fire();\n            }));\n            const operation = new UpdateOperation(promise, triggerKind);\n            this.updateOperation.value = operation;\n            yield promise;\n            if (this.updateOperation.value === operation) {\n                this.updateOperation.clear();\n            }\n        });\n    }\n    takeOwnership(disposable) {\n        this._register(disposable);\n    }\n    commitCurrentCompletion() {\n        const ghostText = this.ghostText;\n        if (!ghostText) {\n            // No ghost text was shown for this completion.\n            // Thus, we don't want to commit anything.\n            return;\n        }\n        const completion = this.currentCompletion;\n        if (completion) {\n            this.commit(completion);\n        }\n    }\n    commit(completion) {\n        var _a;\n        // Mark the cache as stale, but don't dispose it yet,\n        // otherwise command args might get disposed.\n        const cache = this.cache.clearAndLeak();\n        if (completion.snippetInfo) {\n            this.editor.executeEdits('inlineSuggestion.accept', [\n                EditOperation.replaceMove(completion.range, ''),\n                ...completion.additionalTextEdits\n            ]);\n            this.editor.setPosition(completion.snippetInfo.range.getStartPosition());\n            (_a = SnippetController2.get(this.editor)) === null || _a === void 0 ? void 0 : _a.insert(completion.snippetInfo.snippet);\n        }\n        else {\n            this.editor.executeEdits('inlineSuggestion.accept', [\n                EditOperation.replaceMove(completion.range, completion.insertText),\n                ...completion.additionalTextEdits\n            ]);\n        }\n        if (completion.command) {\n            this.commandService\n                .executeCommand(completion.command.id, ...(completion.command.arguments || []))\n                .finally(() => {\n                cache === null || cache === void 0 ? void 0 : cache.dispose();\n            })\n                .then(undefined, onUnexpectedExternalError);\n        }\n        else {\n            cache === null || cache === void 0 ? void 0 : cache.dispose();\n        }\n        this.onDidChangeEmitter.fire();\n    }\n    get commands() {\n        var _a;\n        const lists = new Set(((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions.map(c => c.inlineCompletion.sourceInlineCompletions)) || []);\n        return [...lists].flatMap(l => l.commands || []);\n    }\n}\nexport class UpdateOperation {\n    constructor(promise, triggerKind) {\n        this.promise = promise;\n        this.triggerKind = triggerKind;\n    }\n    dispose() {\n        this.promise.cancel();\n    }\n}\n/**\n * The cache keeps itself in sync with the editor.\n * It also owns the completions result and disposes it when the cache is diposed.\n*/\nexport class SynchronizedInlineCompletionsCache extends Disposable {\n    constructor(completionsSource, editor, onChange, triggerKind) {\n        super();\n        this.editor = editor;\n        this.onChange = onChange;\n        this.triggerKind = triggerKind;\n        this.isDisposing = false;\n        const decorationIds = editor.changeDecorations((changeAccessor) => {\n            return changeAccessor.deltaDecorations([], completionsSource.items.map(i => ({\n                range: i.range,\n                options: {\n                    description: 'inline-completion-tracking-range'\n                },\n            })));\n        });\n        this._register(toDisposable(() => {\n            this.isDisposing = true;\n            editor.removeDecorations(decorationIds);\n        }));\n        this.completions = completionsSource.items.map((c, idx) => new CachedInlineCompletion(c, decorationIds[idx]));\n        this._register(editor.onDidChangeModelContent(() => {\n            this.updateRanges();\n        }));\n        this._register(completionsSource);\n    }\n    updateRanges() {\n        if (this.isDisposing) {\n            return;\n        }\n        let hasChanged = false;\n        const model = this.editor.getModel();\n        for (const c of this.completions) {\n            const newRange = model.getDecorationRange(c.decorationId);\n            if (!newRange) {\n                onUnexpectedError(new Error('Decoration has no range'));\n                continue;\n            }\n            if (!c.synchronizedRange.equalsRange(newRange)) {\n                hasChanged = true;\n                c.synchronizedRange = newRange;\n            }\n        }\n        if (hasChanged) {\n            this.onChange();\n        }\n    }\n}\nclass CachedInlineCompletion {\n    constructor(inlineCompletion, decorationId) {\n        this.inlineCompletion = inlineCompletion;\n        this.decorationId = decorationId;\n        this.semanticId = JSON.stringify({\n            text: this.inlineCompletion.insertText,\n            abbreviation: this.inlineCompletion.filterText,\n            startLine: this.inlineCompletion.range.startLineNumber,\n            startColumn: this.inlineCompletion.range.startColumn,\n            command: this.inlineCompletion.command\n        });\n        this.synchronizedRange = inlineCompletion.range;\n    }\n    toLiveInlineCompletion() {\n        return {\n            insertText: this.inlineCompletion.insertText,\n            range: this.synchronizedRange,\n            command: this.inlineCompletion.command,\n            sourceProvider: this.inlineCompletion.sourceProvider,\n            sourceInlineCompletions: this.inlineCompletion.sourceInlineCompletions,\n            sourceInlineCompletion: this.inlineCompletion.sourceInlineCompletion,\n            snippetInfo: this.inlineCompletion.snippetInfo,\n            filterText: this.inlineCompletion.filterText,\n            additionalTextEdits: this.inlineCompletion.additionalTextEdits,\n        };\n    }\n}\nexport function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const defaultReplaceRange = getDefaultRange(position, model);\n        const providers = registry.all(model);\n        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {\n            const completions = yield Promise.resolve(provider.provideInlineCompletions(model, position, context, token)).catch(onUnexpectedExternalError);\n            return ({\n                completions,\n                provider,\n                dispose: () => {\n                    if (completions) {\n                        provider.freeInlineCompletions(completions);\n                    }\n                }\n            });\n        })));\n        const itemsByHash = new Map();\n        for (const result of results) {\n            const completions = result.completions;\n            if (!completions) {\n                continue;\n            }\n            for (const item of completions.items) {\n                let range = item.range ? Range.lift(item.range) : defaultReplaceRange;\n                if (range.startLineNumber !== range.endLineNumber) {\n                    // Ignore invalid ranges.\n                    continue;\n                }\n                let insertText;\n                let snippetInfo;\n                if (typeof item.insertText === 'string') {\n                    insertText = item.insertText;\n                    if (languageConfigurationService && item.completeBracketPairs) {\n                        insertText = closeBrackets(insertText, range.getStartPosition(), model, languageConfigurationService);\n                        // Modify range depending on if brackets are added or removed\n                        const diff = insertText.length - item.insertText.length;\n                        if (diff !== 0) {\n                            range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n                        }\n                    }\n                    snippetInfo = undefined;\n                }\n                else if ('snippet' in item.insertText) {\n                    const snippet = new SnippetParser().parse(item.insertText.snippet);\n                    insertText = snippet.toString();\n                    snippetInfo = {\n                        snippet: item.insertText.snippet,\n                        range: range\n                    };\n                }\n                else {\n                    assertNever(item.insertText);\n                }\n                const trackedItem = ({\n                    insertText,\n                    snippetInfo,\n                    range,\n                    command: item.command,\n                    sourceProvider: result.provider,\n                    sourceInlineCompletions: completions,\n                    sourceInlineCompletion: item,\n                    filterText: item.filterText || insertText,\n                    additionalTextEdits: item.additionalTextEdits || getReadonlyEmptyArray()\n                });\n                itemsByHash.set(JSON.stringify({ insertText, range: item.range }), trackedItem);\n            }\n        }\n        return {\n            items: [...itemsByHash.values()],\n            dispose: () => {\n                for (const result of results) {\n                    result.dispose();\n                }\n            },\n        };\n    });\n}\nfunction getDefaultRange(position, model) {\n    const word = model.getWordAtPosition(position);\n    const maxColumn = model.getLineMaxColumn(position.lineNumber);\n    // By default, always replace up until the end of the current line.\n    // This default might be subject to change!\n    return word\n        ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn)\n        : Range.fromPositions(position, position.with(undefined, maxColumn));\n}\nfunction closeBrackets(text, position, model, languageConfigurationService) {\n    const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);\n    const newLine = lineStart + text;\n    const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);\n    const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);\n    if (!slicedTokens) {\n        return text;\n    }\n    const newText = fixBracketsInLine(slicedTokens, languageConfigurationService);\n    return newText;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { localize } from '../../../../nls.js';\nimport { foreground, registerColor } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport const SYMBOL_ICON_ARRAY_FOREGROUND = registerColor('symbolIcon.arrayForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground,\n}, localize('symbolIcon.arrayForeground', 'The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_BOOLEAN_FOREGROUND = registerColor('symbolIcon.booleanForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground,\n}, localize('symbolIcon.booleanForeground', 'The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_CLASS_FOREGROUND = registerColor('symbolIcon.classForeground', {\n    dark: '#EE9D28',\n    light: '#D67E00',\n    hcDark: '#EE9D28',\n    hcLight: '#D67E00'\n}, localize('symbolIcon.classForeground', 'The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_COLOR_FOREGROUND = registerColor('symbolIcon.colorForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.colorForeground', 'The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_CONSTANT_FOREGROUND = registerColor('symbolIcon.constantForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.constantForeground', 'The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_CONSTRUCTOR_FOREGROUND = registerColor('symbolIcon.constructorForeground', {\n    dark: '#B180D7',\n    light: '#652D90',\n    hcDark: '#B180D7',\n    hcLight: '#652D90'\n}, localize('symbolIcon.constructorForeground', 'The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_ENUMERATOR_FOREGROUND = registerColor('symbolIcon.enumeratorForeground', {\n    dark: '#EE9D28',\n    light: '#D67E00',\n    hcDark: '#EE9D28',\n    hcLight: '#D67E00'\n}, localize('symbolIcon.enumeratorForeground', 'The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND = registerColor('symbolIcon.enumeratorMemberForeground', {\n    dark: '#75BEFF',\n    light: '#007ACC',\n    hcDark: '#75BEFF',\n    hcLight: '#007ACC'\n}, localize('symbolIcon.enumeratorMemberForeground', 'The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_EVENT_FOREGROUND = registerColor('symbolIcon.eventForeground', {\n    dark: '#EE9D28',\n    light: '#D67E00',\n    hcDark: '#EE9D28',\n    hcLight: '#D67E00'\n}, localize('symbolIcon.eventForeground', 'The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_FIELD_FOREGROUND = registerColor('symbolIcon.fieldForeground', {\n    dark: '#75BEFF',\n    light: '#007ACC',\n    hcDark: '#75BEFF',\n    hcLight: '#007ACC'\n}, localize('symbolIcon.fieldForeground', 'The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_FILE_FOREGROUND = registerColor('symbolIcon.fileForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.fileForeground', 'The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_FOLDER_FOREGROUND = registerColor('symbolIcon.folderForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.folderForeground', 'The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_FUNCTION_FOREGROUND = registerColor('symbolIcon.functionForeground', {\n    dark: '#B180D7',\n    light: '#652D90',\n    hcDark: '#B180D7',\n    hcLight: '#652D90'\n}, localize('symbolIcon.functionForeground', 'The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_INTERFACE_FOREGROUND = registerColor('symbolIcon.interfaceForeground', {\n    dark: '#75BEFF',\n    light: '#007ACC',\n    hcDark: '#75BEFF',\n    hcLight: '#007ACC'\n}, localize('symbolIcon.interfaceForeground', 'The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_KEY_FOREGROUND = registerColor('symbolIcon.keyForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.keyForeground', 'The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_KEYWORD_FOREGROUND = registerColor('symbolIcon.keywordForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.keywordForeground', 'The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_METHOD_FOREGROUND = registerColor('symbolIcon.methodForeground', {\n    dark: '#B180D7',\n    light: '#652D90',\n    hcDark: '#B180D7',\n    hcLight: '#652D90'\n}, localize('symbolIcon.methodForeground', 'The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_MODULE_FOREGROUND = registerColor('symbolIcon.moduleForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.moduleForeground', 'The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_NAMESPACE_FOREGROUND = registerColor('symbolIcon.namespaceForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.namespaceForeground', 'The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_NULL_FOREGROUND = registerColor('symbolIcon.nullForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.nullForeground', 'The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_NUMBER_FOREGROUND = registerColor('symbolIcon.numberForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.numberForeground', 'The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_OBJECT_FOREGROUND = registerColor('symbolIcon.objectForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.objectForeground', 'The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_OPERATOR_FOREGROUND = registerColor('symbolIcon.operatorForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.operatorForeground', 'The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_PACKAGE_FOREGROUND = registerColor('symbolIcon.packageForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.packageForeground', 'The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_PROPERTY_FOREGROUND = registerColor('symbolIcon.propertyForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.propertyForeground', 'The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_REFERENCE_FOREGROUND = registerColor('symbolIcon.referenceForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.referenceForeground', 'The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_SNIPPET_FOREGROUND = registerColor('symbolIcon.snippetForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.snippetForeground', 'The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_STRING_FOREGROUND = registerColor('symbolIcon.stringForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.stringForeground', 'The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_STRUCT_FOREGROUND = registerColor('symbolIcon.structForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground,\n}, localize('symbolIcon.structForeground', 'The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_TEXT_FOREGROUND = registerColor('symbolIcon.textForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.textForeground', 'The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_TYPEPARAMETER_FOREGROUND = registerColor('symbolIcon.typeParameterForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.typeParameterForeground', 'The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_UNIT_FOREGROUND = registerColor('symbolIcon.unitForeground', {\n    dark: foreground,\n    light: foreground,\n    hcDark: foreground,\n    hcLight: foreground\n}, localize('symbolIcon.unitForeground', 'The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nexport const SYMBOL_ICON_VARIABLE_FOREGROUND = registerColor('symbolIcon.variableForeground', {\n    dark: '#75BEFF',\n    light: '#007ACC',\n    hcDark: '#75BEFF',\n    hcLight: '#007ACC',\n}, localize('symbolIcon.variableForeground', 'The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget.'));\nregisterThemingParticipant((theme, collector) => {\n    const symbolIconArrayColor = theme.getColor(SYMBOL_ICON_ARRAY_FOREGROUND);\n    if (symbolIconArrayColor) {\n        collector.addRule(`${Codicon.symbolArray.cssSelector} { color: ${symbolIconArrayColor}; }`);\n    }\n    const symbolIconBooleanColor = theme.getColor(SYMBOL_ICON_BOOLEAN_FOREGROUND);\n    if (symbolIconBooleanColor) {\n        collector.addRule(`${Codicon.symbolBoolean.cssSelector} { color: ${symbolIconBooleanColor}; }`);\n    }\n    const symbolIconClassColor = theme.getColor(SYMBOL_ICON_CLASS_FOREGROUND);\n    if (symbolIconClassColor) {\n        collector.addRule(`${Codicon.symbolClass.cssSelector} { color: ${symbolIconClassColor}; }`);\n    }\n    const symbolIconMethodColor = theme.getColor(SYMBOL_ICON_METHOD_FOREGROUND);\n    if (symbolIconMethodColor) {\n        collector.addRule(`${Codicon.symbolMethod.cssSelector} { color: ${symbolIconMethodColor}; }`);\n    }\n    const symbolIconColorColor = theme.getColor(SYMBOL_ICON_COLOR_FOREGROUND);\n    if (symbolIconColorColor) {\n        collector.addRule(`${Codicon.symbolColor.cssSelector} { color: ${symbolIconColorColor}; }`);\n    }\n    const symbolIconConstantColor = theme.getColor(SYMBOL_ICON_CONSTANT_FOREGROUND);\n    if (symbolIconConstantColor) {\n        collector.addRule(`${Codicon.symbolConstant.cssSelector} { color: ${symbolIconConstantColor}; }`);\n    }\n    const symbolIconConstructorColor = theme.getColor(SYMBOL_ICON_CONSTRUCTOR_FOREGROUND);\n    if (symbolIconConstructorColor) {\n        collector.addRule(`${Codicon.symbolConstructor.cssSelector} { color: ${symbolIconConstructorColor}; }`);\n    }\n    const symbolIconEnumeratorColor = theme.getColor(SYMBOL_ICON_ENUMERATOR_FOREGROUND);\n    if (symbolIconEnumeratorColor) {\n        collector.addRule(`\n\t\t\t${Codicon.symbolValue.cssSelector},${Codicon.symbolEnum.cssSelector} { color: ${symbolIconEnumeratorColor}; }`);\n    }\n    const symbolIconEnumeratorMemberColor = theme.getColor(SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND);\n    if (symbolIconEnumeratorMemberColor) {\n        collector.addRule(`${Codicon.symbolEnumMember.cssSelector} { color: ${symbolIconEnumeratorMemberColor}; }`);\n    }\n    const symbolIconEventColor = theme.getColor(SYMBOL_ICON_EVENT_FOREGROUND);\n    if (symbolIconEventColor) {\n        collector.addRule(`${Codicon.symbolEvent.cssSelector} { color: ${symbolIconEventColor}; }`);\n    }\n    const symbolIconFieldColor = theme.getColor(SYMBOL_ICON_FIELD_FOREGROUND);\n    if (symbolIconFieldColor) {\n        collector.addRule(`${Codicon.symbolField.cssSelector} { color: ${symbolIconFieldColor}; }`);\n    }\n    const symbolIconFileColor = theme.getColor(SYMBOL_ICON_FILE_FOREGROUND);\n    if (symbolIconFileColor) {\n        collector.addRule(`${Codicon.symbolFile.cssSelector} { color: ${symbolIconFileColor}; }`);\n    }\n    const symbolIconFolderColor = theme.getColor(SYMBOL_ICON_FOLDER_FOREGROUND);\n    if (symbolIconFolderColor) {\n        collector.addRule(`${Codicon.symbolFolder.cssSelector} { color: ${symbolIconFolderColor}; }`);\n    }\n    const symbolIconFunctionColor = theme.getColor(SYMBOL_ICON_FUNCTION_FOREGROUND);\n    if (symbolIconFunctionColor) {\n        collector.addRule(`${Codicon.symbolFunction.cssSelector} { color: ${symbolIconFunctionColor}; }`);\n    }\n    const symbolIconInterfaceColor = theme.getColor(SYMBOL_ICON_INTERFACE_FOREGROUND);\n    if (symbolIconInterfaceColor) {\n        collector.addRule(`${Codicon.symbolInterface.cssSelector} { color: ${symbolIconInterfaceColor}; }`);\n    }\n    const symbolIconKeyColor = theme.getColor(SYMBOL_ICON_KEY_FOREGROUND);\n    if (symbolIconKeyColor) {\n        collector.addRule(`${Codicon.symbolKey.cssSelector} { color: ${symbolIconKeyColor}; }`);\n    }\n    const symbolIconKeywordColor = theme.getColor(SYMBOL_ICON_KEYWORD_FOREGROUND);\n    if (symbolIconKeywordColor) {\n        collector.addRule(`${Codicon.symbolKeyword.cssSelector} { color: ${symbolIconKeywordColor}; }`);\n    }\n    const symbolIconModuleColor = theme.getColor(SYMBOL_ICON_MODULE_FOREGROUND);\n    if (symbolIconModuleColor) {\n        collector.addRule(`${Codicon.symbolModule.cssSelector} { color: ${symbolIconModuleColor}; }`);\n    }\n    const outlineNamespaceColor = theme.getColor(SYMBOL_ICON_NAMESPACE_FOREGROUND);\n    if (outlineNamespaceColor) {\n        collector.addRule(`${Codicon.symbolNamespace.cssSelector} { color: ${outlineNamespaceColor}; }`);\n    }\n    const symbolIconNullColor = theme.getColor(SYMBOL_ICON_NULL_FOREGROUND);\n    if (symbolIconNullColor) {\n        collector.addRule(`${Codicon.symbolNull.cssSelector} { color: ${symbolIconNullColor}; }`);\n    }\n    const symbolIconNumberColor = theme.getColor(SYMBOL_ICON_NUMBER_FOREGROUND);\n    if (symbolIconNumberColor) {\n        collector.addRule(`${Codicon.symbolNumber.cssSelector} { color: ${symbolIconNumberColor}; }`);\n    }\n    const symbolIconObjectColor = theme.getColor(SYMBOL_ICON_OBJECT_FOREGROUND);\n    if (symbolIconObjectColor) {\n        collector.addRule(`${Codicon.symbolObject.cssSelector} { color: ${symbolIconObjectColor}; }`);\n    }\n    const symbolIconOperatorColor = theme.getColor(SYMBOL_ICON_OPERATOR_FOREGROUND);\n    if (symbolIconOperatorColor) {\n        collector.addRule(`${Codicon.symbolOperator.cssSelector} { color: ${symbolIconOperatorColor}; }`);\n    }\n    const symbolIconPackageColor = theme.getColor(SYMBOL_ICON_PACKAGE_FOREGROUND);\n    if (symbolIconPackageColor) {\n        collector.addRule(`${Codicon.symbolPackage.cssSelector} { color: ${symbolIconPackageColor}; }`);\n    }\n    const symbolIconPropertyColor = theme.getColor(SYMBOL_ICON_PROPERTY_FOREGROUND);\n    if (symbolIconPropertyColor) {\n        collector.addRule(`${Codicon.symbolProperty.cssSelector} { color: ${symbolIconPropertyColor}; }`);\n    }\n    const symbolIconReferenceColor = theme.getColor(SYMBOL_ICON_REFERENCE_FOREGROUND);\n    if (symbolIconReferenceColor) {\n        collector.addRule(`${Codicon.symbolReference.cssSelector} { color: ${symbolIconReferenceColor}; }`);\n    }\n    const symbolIconSnippetColor = theme.getColor(SYMBOL_ICON_SNIPPET_FOREGROUND);\n    if (symbolIconSnippetColor) {\n        collector.addRule(`${Codicon.symbolSnippet.cssSelector} { color: ${symbolIconSnippetColor}; }`);\n    }\n    const symbolIconStringColor = theme.getColor(SYMBOL_ICON_STRING_FOREGROUND);\n    if (symbolIconStringColor) {\n        collector.addRule(`${Codicon.symbolString.cssSelector} { color: ${symbolIconStringColor}; }`);\n    }\n    const symbolIconStructColor = theme.getColor(SYMBOL_ICON_STRUCT_FOREGROUND);\n    if (symbolIconStructColor) {\n        collector.addRule(`${Codicon.symbolStruct.cssSelector} { color: ${symbolIconStructColor}; }`);\n    }\n    const symbolIconTextColor = theme.getColor(SYMBOL_ICON_TEXT_FOREGROUND);\n    if (symbolIconTextColor) {\n        collector.addRule(`${Codicon.symbolText.cssSelector} { color: ${symbolIconTextColor}; }`);\n    }\n    const symbolIconTypeParameterColor = theme.getColor(SYMBOL_ICON_TYPEPARAMETER_FOREGROUND);\n    if (symbolIconTypeParameterColor) {\n        collector.addRule(`${Codicon.symbolTypeParameter.cssSelector} { color: ${symbolIconTypeParameterColor}; }`);\n    }\n    const symbolIconUnitColor = theme.getColor(SYMBOL_ICON_UNIT_FOREGROUND);\n    if (symbolIconUnitColor) {\n        collector.addRule(`${Codicon.symbolUnit.cssSelector} { color: ${symbolIconUnitColor}; }`);\n    }\n    const symbolIconVariableColor = theme.getColor(SYMBOL_ICON_VARIABLE_FOREGROUND);\n    if (symbolIconVariableColor) {\n        collector.addRule(`${Codicon.symbolVariable.cssSelector} { color: ${symbolIconVariableColor}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as dom from '../../../../base/browser/dom.js';\nimport { DomScrollableElement } from '../../../../base/browser/ui/scrollbar/scrollableElement.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { MarkdownString } from '../../../../base/common/htmlContent.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { MarkdownRenderer } from '../../markdownRenderer/browser/markdownRenderer.js';\nimport { ResizableHTMLElement } from '../../../../base/browser/ui/resizable/resizable.js';\nimport * as nls from '../../../../nls.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nexport function canExpandCompletionItem(item) {\n    return !!item && Boolean(item.completion.documentation || item.completion.detail && item.completion.detail !== item.completion.label);\n}\nlet SuggestDetailsWidget = class SuggestDetailsWidget {\n    constructor(_editor, instaService) {\n        this._editor = _editor;\n        this._onDidClose = new Emitter();\n        this.onDidClose = this._onDidClose.event;\n        this._onDidChangeContents = new Emitter();\n        this.onDidChangeContents = this._onDidChangeContents.event;\n        this._disposables = new DisposableStore();\n        this._renderDisposeable = new DisposableStore();\n        this._borderWidth = 1;\n        this._size = new dom.Dimension(330, 0);\n        this.domNode = dom.$('.suggest-details');\n        this.domNode.classList.add('no-docs');\n        this._markdownRenderer = instaService.createInstance(MarkdownRenderer, { editor: _editor });\n        this._body = dom.$('.body');\n        this._scrollbar = new DomScrollableElement(this._body, {\n            alwaysConsumeMouseWheel: true,\n        });\n        dom.append(this.domNode, this._scrollbar.getDomNode());\n        this._disposables.add(this._scrollbar);\n        this._header = dom.append(this._body, dom.$('.header'));\n        this._close = dom.append(this._header, dom.$('span' + Codicon.close.cssSelector));\n        this._close.title = nls.localize('details.close', \"Close\");\n        this._type = dom.append(this._header, dom.$('p.type'));\n        this._docs = dom.append(this._body, dom.$('p.docs'));\n        this._configureFont();\n        this._disposables.add(this._editor.onDidChangeConfiguration(e => {\n            if (e.hasChanged(46 /* EditorOption.fontInfo */)) {\n                this._configureFont();\n            }\n        }));\n    }\n    dispose() {\n        this._disposables.dispose();\n        this._renderDisposeable.dispose();\n    }\n    _configureFont() {\n        const options = this._editor.getOptions();\n        const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n        const fontFamily = fontInfo.getMassagedFontFamily();\n        const fontSize = options.get(109 /* EditorOption.suggestFontSize */) || fontInfo.fontSize;\n        const lineHeight = options.get(110 /* EditorOption.suggestLineHeight */) || fontInfo.lineHeight;\n        const fontWeight = fontInfo.fontWeight;\n        const fontSizePx = `${fontSize}px`;\n        const lineHeightPx = `${lineHeight}px`;\n        this.domNode.style.fontSize = fontSizePx;\n        this.domNode.style.lineHeight = `${lineHeight / fontSize}`;\n        this.domNode.style.fontWeight = fontWeight;\n        this.domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;\n        this._type.style.fontFamily = fontFamily;\n        this._close.style.height = lineHeightPx;\n        this._close.style.width = lineHeightPx;\n    }\n    getLayoutInfo() {\n        const lineHeight = this._editor.getOption(110 /* EditorOption.suggestLineHeight */) || this._editor.getOption(46 /* EditorOption.fontInfo */).lineHeight;\n        const borderWidth = this._borderWidth;\n        const borderHeight = borderWidth * 2;\n        return {\n            lineHeight,\n            borderWidth,\n            borderHeight,\n            verticalPadding: 22,\n            horizontalPadding: 14\n        };\n    }\n    renderLoading() {\n        this._type.textContent = nls.localize('loading', \"Loading...\");\n        this._docs.textContent = '';\n        this.domNode.classList.remove('no-docs', 'no-type');\n        this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2);\n        this._onDidChangeContents.fire(this);\n    }\n    renderItem(item, explainMode) {\n        var _a, _b;\n        this._renderDisposeable.clear();\n        let { detail, documentation } = item.completion;\n        if (explainMode) {\n            let md = '';\n            md += `score: ${item.score[0]}\\n`;\n            md += `prefix: ${(_a = item.word) !== null && _a !== void 0 ? _a : '(no prefix)'}\\n`;\n            md += `word: ${item.completion.filterText ? item.completion.filterText + ' (filterText)' : item.textLabel}\\n`;\n            md += `distance: ${item.distance} (localityBonus-setting)\\n`;\n            md += `index: ${item.idx}, based on ${item.completion.sortText && `sortText: \"${item.completion.sortText}\"` || 'label'}\\n`;\n            md += `commit_chars: ${(_b = item.completion.commitCharacters) === null || _b === void 0 ? void 0 : _b.join('')}\\n`;\n            documentation = new MarkdownString().appendCodeblock('empty', md);\n            detail = `Provider: ${item.provider._debugDisplayName}`;\n        }\n        if (!explainMode && !canExpandCompletionItem(item)) {\n            this.clearContents();\n            return;\n        }\n        this.domNode.classList.remove('no-docs', 'no-type');\n        // --- details\n        if (detail) {\n            const cappedDetail = detail.length > 100000 ? `${detail.substr(0, 100000)}…` : detail;\n            this._type.textContent = cappedDetail;\n            this._type.title = cappedDetail;\n            dom.show(this._type);\n            this._type.classList.toggle('auto-wrap', !/\\r?\\n^\\s+/gmi.test(cappedDetail));\n        }\n        else {\n            dom.clearNode(this._type);\n            this._type.title = '';\n            dom.hide(this._type);\n            this.domNode.classList.add('no-type');\n        }\n        // --- documentation\n        dom.clearNode(this._docs);\n        if (typeof documentation === 'string') {\n            this._docs.classList.remove('markdown-docs');\n            this._docs.textContent = documentation;\n        }\n        else if (documentation) {\n            this._docs.classList.add('markdown-docs');\n            dom.clearNode(this._docs);\n            const renderedContents = this._markdownRenderer.render(documentation);\n            this._docs.appendChild(renderedContents.element);\n            this._renderDisposeable.add(renderedContents);\n            this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {\n                this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);\n                this._onDidChangeContents.fire(this);\n            }));\n        }\n        this.domNode.style.userSelect = 'text';\n        this.domNode.tabIndex = -1;\n        this._close.onmousedown = e => {\n            e.preventDefault();\n            e.stopPropagation();\n        };\n        this._close.onclick = e => {\n            e.preventDefault();\n            e.stopPropagation();\n            this._onDidClose.fire();\n        };\n        this._body.scrollTop = 0;\n        this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);\n        this._onDidChangeContents.fire(this);\n    }\n    clearContents() {\n        this.domNode.classList.add('no-docs');\n        this._type.textContent = '';\n        this._docs.textContent = '';\n    }\n    get size() {\n        return this._size;\n    }\n    layout(width, height) {\n        const newSize = new dom.Dimension(width, height);\n        if (!dom.Dimension.equals(newSize, this._size)) {\n            this._size = newSize;\n            dom.size(this.domNode, width, height);\n        }\n        this._scrollbar.scanDomNode();\n    }\n    scrollDown(much = 8) {\n        this._body.scrollTop += much;\n    }\n    scrollUp(much = 8) {\n        this._body.scrollTop -= much;\n    }\n    scrollTop() {\n        this._body.scrollTop = 0;\n    }\n    scrollBottom() {\n        this._body.scrollTop = this._body.scrollHeight;\n    }\n    pageDown() {\n        this.scrollDown(80);\n    }\n    pageUp() {\n        this.scrollUp(80);\n    }\n    set borderWidth(width) {\n        this._borderWidth = width;\n    }\n    get borderWidth() {\n        return this._borderWidth;\n    }\n};\nSuggestDetailsWidget = __decorate([\n    __param(1, IInstantiationService)\n], SuggestDetailsWidget);\nexport { SuggestDetailsWidget };\nexport class SuggestDetailsOverlay {\n    constructor(widget, _editor) {\n        this.widget = widget;\n        this._editor = _editor;\n        this._disposables = new DisposableStore();\n        this._added = false;\n        this._preferAlignAtTop = true;\n        this._resizable = new ResizableHTMLElement();\n        this._resizable.domNode.classList.add('suggest-details-container');\n        this._resizable.domNode.appendChild(widget.domNode);\n        this._resizable.enableSashes(false, true, true, false);\n        let topLeftNow;\n        let sizeNow;\n        let deltaTop = 0;\n        let deltaLeft = 0;\n        this._disposables.add(this._resizable.onDidWillResize(() => {\n            topLeftNow = this._topLeft;\n            sizeNow = this._resizable.size;\n        }));\n        this._disposables.add(this._resizable.onDidResize(e => {\n            if (topLeftNow && sizeNow) {\n                this.widget.layout(e.dimension.width, e.dimension.height);\n                let updateTopLeft = false;\n                if (e.west) {\n                    deltaLeft = sizeNow.width - e.dimension.width;\n                    updateTopLeft = true;\n                }\n                if (e.north) {\n                    deltaTop = sizeNow.height - e.dimension.height;\n                    updateTopLeft = true;\n                }\n                if (updateTopLeft) {\n                    this._applyTopLeft({\n                        top: topLeftNow.top + deltaTop,\n                        left: topLeftNow.left + deltaLeft,\n                    });\n                }\n            }\n            if (e.done) {\n                topLeftNow = undefined;\n                sizeNow = undefined;\n                deltaTop = 0;\n                deltaLeft = 0;\n                this._userSize = e.dimension;\n            }\n        }));\n        this._disposables.add(this.widget.onDidChangeContents(() => {\n            var _a;\n            if (this._anchorBox) {\n                this._placeAtAnchor(this._anchorBox, (_a = this._userSize) !== null && _a !== void 0 ? _a : this.widget.size, this._preferAlignAtTop);\n            }\n        }));\n    }\n    dispose() {\n        this._resizable.dispose();\n        this._disposables.dispose();\n        this.hide();\n    }\n    getId() {\n        return 'suggest.details';\n    }\n    getDomNode() {\n        return this._resizable.domNode;\n    }\n    getPosition() {\n        return null;\n    }\n    show() {\n        if (!this._added) {\n            this._editor.addOverlayWidget(this);\n            this.getDomNode().style.position = 'fixed';\n            this._added = true;\n        }\n    }\n    hide(sessionEnded = false) {\n        this._resizable.clearSashHoverState();\n        if (this._added) {\n            this._editor.removeOverlayWidget(this);\n            this._added = false;\n            this._anchorBox = undefined;\n            this._topLeft = undefined;\n        }\n        if (sessionEnded) {\n            this._userSize = undefined;\n            this.widget.clearContents();\n        }\n    }\n    placeAtAnchor(anchor, preferAlignAtTop) {\n        var _a;\n        const anchorBox = anchor.getBoundingClientRect();\n        this._anchorBox = anchorBox;\n        this._preferAlignAtTop = preferAlignAtTop;\n        this._placeAtAnchor(this._anchorBox, (_a = this._userSize) !== null && _a !== void 0 ? _a : this.widget.size, preferAlignAtTop);\n    }\n    _placeAtAnchor(anchorBox, size, preferAlignAtTop) {\n        var _a;\n        const bodyBox = dom.getClientArea(document.body);\n        const info = this.widget.getLayoutInfo();\n        const defaultMinSize = new dom.Dimension(220, 2 * info.lineHeight);\n        const defaultTop = anchorBox.top;\n        // EAST\n        const eastPlacement = (function () {\n            const width = bodyBox.width - (anchorBox.left + anchorBox.width + info.borderWidth + info.horizontalPadding);\n            const left = -info.borderWidth + anchorBox.left + anchorBox.width;\n            const maxSizeTop = new dom.Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);\n            const maxSizeBottom = maxSizeTop.with(undefined, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);\n            return { top: defaultTop, left, fit: width - size.width, maxSizeTop, maxSizeBottom, minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width)) };\n        })();\n        // WEST\n        const westPlacement = (function () {\n            const width = anchorBox.left - info.borderWidth - info.horizontalPadding;\n            const left = Math.max(info.horizontalPadding, anchorBox.left - size.width - info.borderWidth);\n            const maxSizeTop = new dom.Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);\n            const maxSizeBottom = maxSizeTop.with(undefined, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);\n            return { top: defaultTop, left, fit: width - size.width, maxSizeTop, maxSizeBottom, minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width)) };\n        })();\n        // SOUTH\n        const southPacement = (function () {\n            const left = anchorBox.left;\n            const top = -info.borderWidth + anchorBox.top + anchorBox.height;\n            const maxSizeBottom = new dom.Dimension(anchorBox.width - info.borderHeight, bodyBox.height - anchorBox.top - anchorBox.height - info.verticalPadding);\n            return { top, left, fit: maxSizeBottom.height - size.height, maxSizeBottom, maxSizeTop: maxSizeBottom, minSize: defaultMinSize.with(maxSizeBottom.width) };\n        })();\n        // take first placement that fits or the first with \"least bad\" fit\n        const placements = [eastPlacement, westPlacement, southPacement];\n        const placement = (_a = placements.find(p => p.fit >= 0)) !== null && _a !== void 0 ? _a : placements.sort((a, b) => b.fit - a.fit)[0];\n        // top/bottom placement\n        const bottom = anchorBox.top + anchorBox.height - info.borderHeight;\n        let alignAtTop;\n        let height = size.height;\n        const maxHeight = Math.max(placement.maxSizeTop.height, placement.maxSizeBottom.height);\n        if (height > maxHeight) {\n            height = maxHeight;\n        }\n        let maxSize;\n        if (preferAlignAtTop) {\n            if (height <= placement.maxSizeTop.height) {\n                alignAtTop = true;\n                maxSize = placement.maxSizeTop;\n            }\n            else {\n                alignAtTop = false;\n                maxSize = placement.maxSizeBottom;\n            }\n        }\n        else {\n            if (height <= placement.maxSizeBottom.height) {\n                alignAtTop = false;\n                maxSize = placement.maxSizeBottom;\n            }\n            else {\n                alignAtTop = true;\n                maxSize = placement.maxSizeTop;\n            }\n        }\n        this._applyTopLeft({ left: placement.left, top: alignAtTop ? placement.top : bottom - height });\n        this.getDomNode().style.position = 'fixed';\n        this._resizable.enableSashes(!alignAtTop, placement === eastPlacement, alignAtTop, placement !== eastPlacement);\n        this._resizable.minSize = placement.minSize;\n        this._resizable.maxSize = maxSize;\n        this._resizable.layout(height, Math.min(maxSize.width, size.width));\n        this.widget.layout(this._resizable.size.width, this._resizable.size.height);\n    }\n    _applyTopLeft(topLeft) {\n        this._topLeft = topLeft;\n        this.getDomNode().style.left = `${this._topLeft.left}px`;\n        this.getDomNode().style.top = `${this._topLeft.top}px`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nexport class CopyLinesCommand {\n    constructor(selection, isCopyingDown, noop) {\n        this._selection = selection;\n        this._isCopyingDown = isCopyingDown;\n        this._noop = noop || false;\n        this._selectionDirection = 0 /* SelectionDirection.LTR */;\n        this._selectionId = null;\n        this._startLineNumberDelta = 0;\n        this._endLineNumberDelta = 0;\n    }\n    getEditOperations(model, builder) {\n        let s = this._selection;\n        this._startLineNumberDelta = 0;\n        this._endLineNumberDelta = 0;\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._endLineNumberDelta = 1;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const sourceLines = [];\n        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n            sourceLines.push(model.getLineContent(i));\n        }\n        const sourceText = sourceLines.join('\\n');\n        if (sourceText === '') {\n            // Duplicating empty line\n            if (this._isCopyingDown) {\n                this._startLineNumberDelta++;\n                this._endLineNumberDelta++;\n            }\n        }\n        if (this._noop) {\n            builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber + 1, 1), s.endLineNumber === model.getLineCount() ? '' : '\\n');\n        }\n        else {\n            if (!this._isCopyingDown) {\n                builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + sourceText);\n            }\n            else {\n                builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + '\\n');\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n        this._selectionDirection = this._selection.getDirection();\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {\n            let startLineNumber = result.startLineNumber;\n            let startColumn = result.startColumn;\n            let endLineNumber = result.endLineNumber;\n            let endColumn = result.endColumn;\n            if (this._startLineNumberDelta !== 0) {\n                startLineNumber = startLineNumber + this._startLineNumberDelta;\n                startColumn = 1;\n            }\n            if (this._endLineNumberDelta !== 0) {\n                endLineNumber = endLineNumber + this._endLineNumberDelta;\n                endColumn = 1;\n            }\n            result = Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IndentAction } from '../../../common/languages/languageConfiguration.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as indentUtils from '../../indentation/browser/indentUtils.js';\nimport { getGoodIndentForLine, getIndentMetadata } from '../../../common/languages/autoIndent.js';\nimport { getEnterAction } from '../../../common/languages/enterAction.js';\nlet MoveLinesCommand = class MoveLinesCommand {\n    constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {\n        this._languageConfigurationService = _languageConfigurationService;\n        this._selection = selection;\n        this._isMovingDown = isMovingDown;\n        this._autoIndent = autoIndent;\n        this._selectionId = null;\n        this._moveEndLineSelectionShrink = false;\n    }\n    getEditOperations(model, builder) {\n        const modelLineCount = model.getLineCount();\n        if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        this._moveEndPositionDown = false;\n        let s = this._selection;\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const { tabSize, indentSize, insertSpaces } = model.getOptions();\n        const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n        const virtualModel = {\n            tokenization: {\n                getLineTokens: (lineNumber) => {\n                    return model.tokenization.getLineTokens(lineNumber);\n                },\n                getLanguageId: () => {\n                    return model.getLanguageId();\n                },\n                getLanguageIdAtPosition: (lineNumber, column) => {\n                    return model.getLanguageIdAtPosition(lineNumber, column);\n                },\n            },\n            getLineContent: null,\n        };\n        if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n            // Current line is empty\n            const lineNumber = s.startLineNumber;\n            const otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);\n            if (model.getLineMaxColumn(otherLineNumber) === 1) {\n                // Other line number is empty too, so no editing is needed\n                // Add a no-op to force running by the model\n                builder.addEditOperation(new Range(1, 1, 1, 1), null);\n            }\n            else {\n                // Type content from other line number on line number\n                builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n                // Remove content from other line number\n                builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n            }\n            // Track selection at the other line number\n            s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n        }\n        else {\n            let movingLineNumber;\n            let movingLineText;\n            if (this._isMovingDown) {\n                movingLineNumber = s.endLineNumber + 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n                let insertingText = movingLineText;\n                if (this.shouldAutoIndent(model, s)) {\n                    const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n                    // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n                    if (movingLineMatchResult !== null) {\n                        const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                        const newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                        const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                        insertingText = newIndentation + this.trimLeft(movingLineText);\n                    }\n                    else {\n                        // no enter rule matches, let's check indentatin rules then.\n                        virtualModel.getLineContent = (lineNumber) => {\n                            if (lineNumber === s.startLineNumber) {\n                                return model.getLineContent(movingLineNumber);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        };\n                        const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);\n                        if (indentOfMovingLine !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                                insertingText = newIndentation + this.trimLeft(movingLineText);\n                            }\n                        }\n                    }\n                    // add edit operations for moving line first to make sure it's executed after we make indentation change\n                    // to s.startLineNumber\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                    const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\n                    // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match onEnter rules, let's check indentation rules then.\n                        virtualModel.getLineContent = (lineNumber) => {\n                            if (lineNumber === s.startLineNumber) {\n                                return insertingText;\n                            }\n                            else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                                return model.getLineContent(lineNumber - 1);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        };\n                        const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);\n                        if (newIndentatOfMovingBlock !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Insert line that needs to be moved before\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                }\n            }\n            else {\n                movingLineNumber = s.startLineNumber - 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n                // Insert line that needs to be moved after\n                builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n                if (this.shouldAutoIndent(model, s)) {\n                    virtualModel.getLineContent = (lineNumber) => {\n                        if (lineNumber === movingLineNumber) {\n                            return model.getLineContent(s.startLineNumber);\n                        }\n                        else {\n                            return model.getLineContent(lineNumber);\n                        }\n                    };\n                    const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n                    // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match any onEnter rule, let's check indentation rules then.\n                        const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);\n                        if (indentOfFirstLine !== null) {\n                            // adjust the indentation of the moving block\n                            const oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    buildIndentConverter(tabSize, indentSize, insertSpaces) {\n        return {\n            shiftIndent: (indentation) => {\n                return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            },\n            unshiftIndent: (indentation) => {\n                return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            }\n        };\n    }\n    parseEnterResult(model, indentConverter, tabSize, line, enter) {\n        if (enter) {\n            let enterPrefix = enter.indentation;\n            if (enter.indentAction === IndentAction.None) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.Indent) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.IndentOutdent) {\n                enterPrefix = enter.indentation;\n            }\n            else if (enter.indentAction === IndentAction.Outdent) {\n                enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n            }\n            const movingLineText = model.getLineContent(line);\n            if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {\n                const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n                let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n                const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);\n                if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* IndentConsts.DECREASE_MASK */) {\n                    newIndentation = indentConverter.unshiftIndent(newIndentation);\n                }\n                const newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n                const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                return newSpaceCnt - oldSpaceCnt;\n            }\n        }\n        return null;\n    }\n    /**\n     *\n     * @param model\n     * @param indentConverter\n     * @param tabSize\n     * @param line the line moving down\n     * @param futureAboveLineNumber the line which will be at the `line` position\n     * @param futureAboveLineText\n     */\n    matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n        if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n            // break\n            const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n            const enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n        else {\n            // go upwards, starting from `line - 1`\n            let validPrecedingLine = line - 1;\n            while (validPrecedingLine >= 1) {\n                const lineContent = model.getLineContent(validPrecedingLine);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n                validPrecedingLine--;\n            }\n            if (validPrecedingLine < 1 || line > model.getLineCount()) {\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n            const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n    }\n    matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n        let validPrecedingLine = oneLineAbove;\n        while (validPrecedingLine >= 1) {\n            // ship empty lines as empty lines just inherit indentation\n            let lineContent;\n            if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n                lineContent = previousLineText;\n            }\n            else {\n                lineContent = model.getLineContent(validPrecedingLine);\n            }\n            const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n            if (nonWhitespaceIdx >= 0) {\n                break;\n            }\n            validPrecedingLine--;\n        }\n        if (validPrecedingLine < 1 || line > model.getLineCount()) {\n            return null;\n        }\n        const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n        const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n        return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n    trimLeft(str) {\n        return str.replace(/^\\s+/, '');\n    }\n    shouldAutoIndent(model, selection) {\n        if (this._autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        // if it's not easy to tokenize, we stop auto indent.\n        if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n            return false;\n        }\n        const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n        const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n        if (languageAtSelectionStart !== languageAtSelectionEnd) {\n            return false;\n        }\n        if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {\n            return false;\n        }\n        return true;\n    }\n    getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n            const lineContent = model.getLineContent(i);\n            const originalIndent = strings.getLeadingWhitespace(lineContent);\n            const originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n            const newSpacesCnt = originalSpacesCnt + offset;\n            const newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n            if (newIndent !== originalIndent) {\n                builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n                if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n                    // as users select part of the original indent white spaces\n                    // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n                    this._moveEndLineSelectionShrink = true;\n                }\n            }\n        }\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n            result = result.setEndPosition(result.endLineNumber, 2);\n        }\n        return result;\n    }\n};\nMoveLinesCommand = __decorate([\n    __param(3, ILanguageConfigurationService)\n], MoveLinesCommand);\nexport { MoveLinesCommand };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nexport class SortLinesCommand {\n    constructor(selection, descending) {\n        this.selection = selection;\n        this.descending = descending;\n        this.selectionId = null;\n    }\n    static getCollator() {\n        if (!SortLinesCommand._COLLATOR) {\n            SortLinesCommand._COLLATOR = new Intl.Collator();\n        }\n        return SortLinesCommand._COLLATOR;\n    }\n    getEditOperations(model, builder) {\n        const op = sortLines(model, this.selection, this.descending);\n        if (op) {\n            builder.addEditOperation(op.range, op.text);\n        }\n        this.selectionId = builder.trackSelection(this.selection);\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this.selectionId);\n    }\n    static canRun(model, selection, descending) {\n        if (model === null) {\n            return false;\n        }\n        const data = getSortData(model, selection, descending);\n        if (!data) {\n            return false;\n        }\n        for (let i = 0, len = data.before.length; i < len; i++) {\n            if (data.before[i] !== data.after[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nSortLinesCommand._COLLATOR = null;\nfunction getSortData(model, selection, descending) {\n    const startLineNumber = selection.startLineNumber;\n    let endLineNumber = selection.endLineNumber;\n    if (selection.endColumn === 1) {\n        endLineNumber--;\n    }\n    // Nothing to sort if user didn't select anything.\n    if (startLineNumber >= endLineNumber) {\n        return null;\n    }\n    const linesToSort = [];\n    // Get the contents of the selection to be sorted.\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        linesToSort.push(model.getLineContent(lineNumber));\n    }\n    let sorted = linesToSort.slice(0);\n    sorted.sort(SortLinesCommand.getCollator().compare);\n    // If descending, reverse the order.\n    if (descending === true) {\n        sorted = sorted.reverse();\n    }\n    return {\n        startLineNumber: startLineNumber,\n        endLineNumber: endLineNumber,\n        before: linesToSort,\n        after: sorted\n    };\n}\n/**\n * Generate commands for sorting lines on a model.\n */\nfunction sortLines(model, selection, descending) {\n    const data = getSortData(model, selection, descending);\n    if (!data) {\n        return null;\n    }\n    return EditOperation.replace(new Range(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join('\\n'));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { KeyChord } from '../../../../base/common/keyCodes.js';\nimport { CoreEditingCommands } from '../../../browser/coreCommands.js';\nimport { EditorAction, registerEditorAction } from '../../../browser/editorExtensions.js';\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection, ReplaceCommandThatSelectsText } from '../../../common/commands/replaceCommand.js';\nimport { TrimTrailingWhitespaceCommand } from '../../../common/commands/trimTrailingWhitespaceCommand.js';\nimport { TypeOperations } from '../../../common/cursor/cursorTypeOperations.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { CopyLinesCommand } from './copyLinesCommand.js';\nimport { MoveLinesCommand } from './moveLinesCommand.js';\nimport { SortLinesCommand } from './sortLinesCommand.js';\nimport * as nls from '../../../../nls.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\n// copy lines\nclass AbstractCopyLinesAction extends EditorAction {\n    constructor(down, opts) {\n        super(opts);\n        this.down = down;\n    }\n    run(_accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const selections = editor.getSelections().map((selection, index) => ({ selection, index, ignore: false }));\n        selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n        // Remove selections that would result in copying the same line\n        let prev = selections[0];\n        for (let i = 1; i < selections.length; i++) {\n            const curr = selections[i];\n            if (prev.selection.endLineNumber === curr.selection.startLineNumber) {\n                // these two selections would copy the same line\n                if (prev.index < curr.index) {\n                    // prev wins\n                    curr.ignore = true;\n                }\n                else {\n                    // curr wins\n                    prev.ignore = true;\n                    prev = curr;\n                }\n            }\n        }\n        const commands = [];\n        for (const selection of selections) {\n            commands.push(new CopyLinesCommand(selection.selection, this.down, selection.ignore));\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, commands);\n        editor.pushUndoStop();\n    }\n}\nclass CopyLinesUpAction extends AbstractCopyLinesAction {\n    constructor() {\n        super(false, {\n            id: 'editor.action.copyLinesUpAction',\n            label: nls.localize('lines.copyUp', \"Copy Line Up\"),\n            alias: 'Copy Line Up',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */,\n                linux: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '2_line',\n                title: nls.localize({ key: 'miCopyLinesUp', comment: ['&& denotes a mnemonic'] }, \"&&Copy Line Up\"),\n                order: 1\n            }\n        });\n    }\n}\nclass CopyLinesDownAction extends AbstractCopyLinesAction {\n    constructor() {\n        super(true, {\n            id: 'editor.action.copyLinesDownAction',\n            label: nls.localize('lines.copyDown', \"Copy Line Down\"),\n            alias: 'Copy Line Down',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */,\n                linux: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '2_line',\n                title: nls.localize({ key: 'miCopyLinesDown', comment: ['&& denotes a mnemonic'] }, \"Co&&py Line Down\"),\n                order: 2\n            }\n        });\n    }\n}\nexport class DuplicateSelectionAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.duplicateSelection',\n            label: nls.localize('duplicateSelection', \"Duplicate Selection\"),\n            alias: 'Duplicate Selection',\n            precondition: EditorContextKeys.writable,\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '2_line',\n                title: nls.localize({ key: 'miDuplicateSelection', comment: ['&& denotes a mnemonic'] }, \"&&Duplicate Selection\"),\n                order: 5\n            }\n        });\n    }\n    run(accessor, editor, args) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const commands = [];\n        const selections = editor.getSelections();\n        const model = editor.getModel();\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                commands.push(new CopyLinesCommand(selection, true));\n            }\n            else {\n                const insertSelection = new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn);\n                commands.push(new ReplaceCommandThatSelectsText(insertSelection, model.getValueInRange(selection)));\n            }\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, commands);\n        editor.pushUndoStop();\n    }\n}\n// move lines\nclass AbstractMoveLinesAction extends EditorAction {\n    constructor(down, opts) {\n        super(opts);\n        this.down = down;\n    }\n    run(accessor, editor) {\n        const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n        const commands = [];\n        const selections = editor.getSelections() || [];\n        const autoIndent = editor.getOption(9 /* EditorOption.autoIndent */);\n        for (const selection of selections) {\n            commands.push(new MoveLinesCommand(selection, this.down, autoIndent, languageConfigurationService));\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, commands);\n        editor.pushUndoStop();\n    }\n}\nclass MoveLinesUpAction extends AbstractMoveLinesAction {\n    constructor() {\n        super(false, {\n            id: 'editor.action.moveLinesUpAction',\n            label: nls.localize('lines.moveUp', \"Move Line Up\"),\n            alias: 'Move Line Up',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */,\n                linux: { primary: 512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '2_line',\n                title: nls.localize({ key: 'miMoveLinesUp', comment: ['&& denotes a mnemonic'] }, \"Mo&&ve Line Up\"),\n                order: 3\n            }\n        });\n    }\n}\nclass MoveLinesDownAction extends AbstractMoveLinesAction {\n    constructor() {\n        super(true, {\n            id: 'editor.action.moveLinesDownAction',\n            label: nls.localize('lines.moveDown', \"Move Line Down\"),\n            alias: 'Move Line Down',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */,\n                linux: { primary: 512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '2_line',\n                title: nls.localize({ key: 'miMoveLinesDown', comment: ['&& denotes a mnemonic'] }, \"Move &&Line Down\"),\n                order: 4\n            }\n        });\n    }\n}\nexport class AbstractSortLinesAction extends EditorAction {\n    constructor(descending, opts) {\n        super(opts);\n        this.descending = descending;\n    }\n    run(_accessor, editor) {\n        const selections = editor.getSelections() || [];\n        for (const selection of selections) {\n            if (!SortLinesCommand.canRun(editor.getModel(), selection, this.descending)) {\n                return;\n            }\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new SortLinesCommand(selections[i], this.descending);\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, commands);\n        editor.pushUndoStop();\n    }\n}\nexport class SortLinesAscendingAction extends AbstractSortLinesAction {\n    constructor() {\n        super(false, {\n            id: 'editor.action.sortLinesAscending',\n            label: nls.localize('lines.sortAscending', \"Sort Lines Ascending\"),\n            alias: 'Sort Lines Ascending',\n            precondition: EditorContextKeys.writable\n        });\n    }\n}\nexport class SortLinesDescendingAction extends AbstractSortLinesAction {\n    constructor() {\n        super(true, {\n            id: 'editor.action.sortLinesDescending',\n            label: nls.localize('lines.sortDescending', \"Sort Lines Descending\"),\n            alias: 'Sort Lines Descending',\n            precondition: EditorContextKeys.writable\n        });\n    }\n}\nexport class DeleteDuplicateLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.removeDuplicateLines',\n            label: nls.localize('lines.deleteDuplicates', \"Delete Duplicate Lines\"),\n            alias: 'Delete Duplicate Lines',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    run(_accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const model = editor.getModel();\n        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n            return;\n        }\n        const edits = [];\n        const endCursorState = [];\n        let linesDeleted = 0;\n        for (const selection of editor.getSelections()) {\n            const uniqueLines = new Set();\n            const lines = [];\n            for (let i = selection.startLineNumber; i <= selection.endLineNumber; i++) {\n                const line = model.getLineContent(i);\n                if (uniqueLines.has(line)) {\n                    continue;\n                }\n                lines.push(line);\n                uniqueLines.add(line);\n            }\n            const selectionToReplace = new Selection(selection.startLineNumber, 1, selection.endLineNumber, model.getLineMaxColumn(selection.endLineNumber));\n            const adjustedSelectionStart = selection.startLineNumber - linesDeleted;\n            const finalSelection = new Selection(adjustedSelectionStart, 1, adjustedSelectionStart + lines.length - 1, lines[lines.length - 1].length);\n            edits.push(EditOperation.replace(selectionToReplace, lines.join('\\n')));\n            endCursorState.push(finalSelection);\n            linesDeleted += (selection.endLineNumber - selection.startLineNumber + 1) - lines.length;\n        }\n        editor.pushUndoStop();\n        editor.executeEdits(this.id, edits, endCursorState);\n        editor.pushUndoStop();\n    }\n}\nexport class TrimTrailingWhitespaceAction extends EditorAction {\n    constructor() {\n        super({\n            id: TrimTrailingWhitespaceAction.ID,\n            label: nls.localize('lines.trimTrailingWhitespace', \"Trim Trailing Whitespace\"),\n            alias: 'Trim Trailing Whitespace',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 54 /* KeyCode.KeyX */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor, args) {\n        let cursors = [];\n        if (args.reason === 'auto-save') {\n            // See https://github.com/editorconfig/editorconfig-vscode/issues/47\n            // It is very convenient for the editor config extension to invoke this action.\n            // So, if we get a reason:'auto-save' passed in, let's preserve cursor positions.\n            cursors = (editor.getSelections() || []).map(s => new Position(s.positionLineNumber, s.positionColumn));\n        }\n        const selection = editor.getSelection();\n        if (selection === null) {\n            return;\n        }\n        const command = new TrimTrailingWhitespaceCommand(selection, cursors);\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, [command]);\n        editor.pushUndoStop();\n    }\n}\nTrimTrailingWhitespaceAction.ID = 'editor.action.trimTrailingWhitespace';\nexport class DeleteLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.deleteLines',\n            label: nls.localize('lines.delete', \"Delete Line\"),\n            alias: 'Delete Line',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.textInputFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 41 /* KeyCode.KeyK */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const ops = this._getLinesToRemove(editor);\n        const model = editor.getModel();\n        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n            // Model is empty\n            return;\n        }\n        let linesDeleted = 0;\n        const edits = [];\n        const cursorState = [];\n        for (let i = 0, len = ops.length; i < len; i++) {\n            const op = ops[i];\n            let startLineNumber = op.startLineNumber;\n            let endLineNumber = op.endLineNumber;\n            let startColumn = 1;\n            let endColumn = model.getLineMaxColumn(endLineNumber);\n            if (endLineNumber < model.getLineCount()) {\n                endLineNumber += 1;\n                endColumn = 1;\n            }\n            else if (startLineNumber > 1) {\n                startLineNumber -= 1;\n                startColumn = model.getLineMaxColumn(startLineNumber);\n            }\n            edits.push(EditOperation.replace(new Selection(startLineNumber, startColumn, endLineNumber, endColumn), ''));\n            cursorState.push(new Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));\n            linesDeleted += (op.endLineNumber - op.startLineNumber + 1);\n        }\n        editor.pushUndoStop();\n        editor.executeEdits(this.id, edits, cursorState);\n        editor.pushUndoStop();\n    }\n    _getLinesToRemove(editor) {\n        // Construct delete operations\n        const operations = editor.getSelections().map((s) => {\n            let endLineNumber = s.endLineNumber;\n            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n                endLineNumber -= 1;\n            }\n            return {\n                startLineNumber: s.startLineNumber,\n                selectionStartColumn: s.selectionStartColumn,\n                endLineNumber: endLineNumber,\n                positionColumn: s.positionColumn\n            };\n        });\n        // Sort delete operations\n        operations.sort((a, b) => {\n            if (a.startLineNumber === b.startLineNumber) {\n                return a.endLineNumber - b.endLineNumber;\n            }\n            return a.startLineNumber - b.startLineNumber;\n        });\n        // Merge delete operations which are adjacent or overlapping\n        const mergedOperations = [];\n        let previousOperation = operations[0];\n        for (let i = 1; i < operations.length; i++) {\n            if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) {\n                // Merge current operations into the previous one\n                previousOperation.endLineNumber = operations[i].endLineNumber;\n            }\n            else {\n                // Push previous operation\n                mergedOperations.push(previousOperation);\n                previousOperation = operations[i];\n            }\n        }\n        // Push the last operation\n        mergedOperations.push(previousOperation);\n        return mergedOperations;\n    }\n}\nexport class IndentLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.indentLines',\n            label: nls.localize('lines.indent', \"Indent Line\"),\n            alias: 'Indent Line',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 89 /* KeyCode.BracketRight */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        const viewModel = editor._getViewModel();\n        if (!viewModel) {\n            return;\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, TypeOperations.indent(viewModel.cursorConfig, editor.getModel(), editor.getSelections()));\n        editor.pushUndoStop();\n    }\n}\nclass OutdentLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.outdentLines',\n            label: nls.localize('lines.outdent', \"Outdent Line\"),\n            alias: 'Outdent Line',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 87 /* KeyCode.BracketLeft */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor, null);\n    }\n}\nexport class InsertLineBeforeAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.insertLineBefore',\n            label: nls.localize('lines.insertBefore', \"Insert Line Above\"),\n            alias: 'Insert Line Above',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 3 /* KeyCode.Enter */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        const viewModel = editor._getViewModel();\n        if (!viewModel) {\n            return;\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, TypeOperations.lineInsertBefore(viewModel.cursorConfig, editor.getModel(), editor.getSelections()));\n    }\n}\nexport class InsertLineAfterAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.insertLineAfter',\n            label: nls.localize('lines.insertAfter', \"Insert Line Below\"),\n            alias: 'Insert Line Below',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 3 /* KeyCode.Enter */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        const viewModel = editor._getViewModel();\n        if (!viewModel) {\n            return;\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, TypeOperations.lineInsertAfter(viewModel.cursorConfig, editor.getModel(), editor.getSelections()));\n    }\n}\nexport class AbstractDeleteAllToBoundaryAction extends EditorAction {\n    run(_accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const primaryCursor = editor.getSelection();\n        const rangesToDelete = this._getRangesToDelete(editor);\n        // merge overlapping selections\n        const effectiveRanges = [];\n        for (let i = 0, count = rangesToDelete.length - 1; i < count; i++) {\n            const range = rangesToDelete[i];\n            const nextRange = rangesToDelete[i + 1];\n            if (Range.intersectRanges(range, nextRange) === null) {\n                effectiveRanges.push(range);\n            }\n            else {\n                rangesToDelete[i + 1] = Range.plusRange(range, nextRange);\n            }\n        }\n        effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);\n        const endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);\n        const edits = effectiveRanges.map(range => {\n            return EditOperation.replace(range, '');\n        });\n        editor.pushUndoStop();\n        editor.executeEdits(this.id, edits, endCursorState);\n        editor.pushUndoStop();\n    }\n}\nexport class DeleteAllLeftAction extends AbstractDeleteAllToBoundaryAction {\n    constructor() {\n        super({\n            id: 'deleteAllLeft',\n            label: nls.localize('lines.deleteAllLeft', \"Delete All Left\"),\n            alias: 'Delete All Left',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.textInputFocus,\n                primary: 0,\n                mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 1 /* KeyCode.Backspace */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    _getEndCursorState(primaryCursor, rangesToDelete) {\n        let endPrimaryCursor = null;\n        const endCursorState = [];\n        let deletedLines = 0;\n        rangesToDelete.forEach(range => {\n            let endCursor;\n            if (range.endColumn === 1 && deletedLines > 0) {\n                const newStartLine = range.startLineNumber - deletedLines;\n                endCursor = new Selection(newStartLine, range.startColumn, newStartLine, range.startColumn);\n            }\n            else {\n                endCursor = new Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n            }\n            deletedLines += range.endLineNumber - range.startLineNumber;\n            if (range.intersectRanges(primaryCursor)) {\n                endPrimaryCursor = endCursor;\n            }\n            else {\n                endCursorState.push(endCursor);\n            }\n        });\n        if (endPrimaryCursor) {\n            endCursorState.unshift(endPrimaryCursor);\n        }\n        return endCursorState;\n    }\n    _getRangesToDelete(editor) {\n        const selections = editor.getSelections();\n        if (selections === null) {\n            return [];\n        }\n        let rangesToDelete = selections;\n        const model = editor.getModel();\n        if (model === null) {\n            return [];\n        }\n        rangesToDelete.sort(Range.compareRangesUsingStarts);\n        rangesToDelete = rangesToDelete.map(selection => {\n            if (selection.isEmpty()) {\n                if (selection.startColumn === 1) {\n                    const deleteFromLine = Math.max(1, selection.startLineNumber - 1);\n                    const deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineContent(deleteFromLine).length + 1;\n                    return new Range(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);\n                }\n                else {\n                    return new Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);\n                }\n            }\n            else {\n                return new Range(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n            }\n        });\n        return rangesToDelete;\n    }\n}\nexport class DeleteAllRightAction extends AbstractDeleteAllToBoundaryAction {\n    constructor() {\n        super({\n            id: 'deleteAllRight',\n            label: nls.localize('lines.deleteAllRight', \"Delete All Right\"),\n            alias: 'Delete All Right',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.textInputFocus,\n                primary: 0,\n                mac: { primary: 256 /* KeyMod.WinCtrl */ | 41 /* KeyCode.KeyK */, secondary: [2048 /* KeyMod.CtrlCmd */ | 20 /* KeyCode.Delete */] },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    _getEndCursorState(primaryCursor, rangesToDelete) {\n        let endPrimaryCursor = null;\n        const endCursorState = [];\n        for (let i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {\n            const range = rangesToDelete[i];\n            const endCursor = new Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);\n            if (range.intersectRanges(primaryCursor)) {\n                endPrimaryCursor = endCursor;\n            }\n            else {\n                endCursorState.push(endCursor);\n            }\n        }\n        if (endPrimaryCursor) {\n            endCursorState.unshift(endPrimaryCursor);\n        }\n        return endCursorState;\n    }\n    _getRangesToDelete(editor) {\n        const model = editor.getModel();\n        if (model === null) {\n            return [];\n        }\n        const selections = editor.getSelections();\n        if (selections === null) {\n            return [];\n        }\n        const rangesToDelete = selections.map((sel) => {\n            if (sel.isEmpty()) {\n                const maxColumn = model.getLineMaxColumn(sel.startLineNumber);\n                if (sel.startColumn === maxColumn) {\n                    return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);\n                }\n                else {\n                    return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);\n                }\n            }\n            return sel;\n        });\n        rangesToDelete.sort(Range.compareRangesUsingStarts);\n        return rangesToDelete;\n    }\n}\nexport class JoinLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.joinLines',\n            label: nls.localize('lines.joinLines', \"Join Lines\"),\n            alias: 'Join Lines',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 0,\n                mac: { primary: 256 /* KeyMod.WinCtrl */ | 40 /* KeyCode.KeyJ */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        const selections = editor.getSelections();\n        if (selections === null) {\n            return;\n        }\n        let primaryCursor = editor.getSelection();\n        if (primaryCursor === null) {\n            return;\n        }\n        selections.sort(Range.compareRangesUsingStarts);\n        const reducedSelections = [];\n        const lastSelection = selections.reduce((previousValue, currentValue) => {\n            if (previousValue.isEmpty()) {\n                if (previousValue.endLineNumber === currentValue.startLineNumber) {\n                    if (primaryCursor.equalsSelection(previousValue)) {\n                        primaryCursor = currentValue;\n                    }\n                    return currentValue;\n                }\n                if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {\n                    reducedSelections.push(previousValue);\n                    return currentValue;\n                }\n                else {\n                    return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);\n                }\n            }\n            else {\n                if (currentValue.startLineNumber > previousValue.endLineNumber) {\n                    reducedSelections.push(previousValue);\n                    return currentValue;\n                }\n                else {\n                    return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);\n                }\n            }\n        });\n        reducedSelections.push(lastSelection);\n        const model = editor.getModel();\n        if (model === null) {\n            return;\n        }\n        const edits = [];\n        const endCursorState = [];\n        let endPrimaryCursor = primaryCursor;\n        let lineOffset = 0;\n        for (let i = 0, len = reducedSelections.length; i < len; i++) {\n            const selection = reducedSelections[i];\n            const startLineNumber = selection.startLineNumber;\n            const startColumn = 1;\n            let columnDeltaOffset = 0;\n            let endLineNumber, endColumn;\n            const selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;\n            if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {\n                const position = selection.getStartPosition();\n                if (position.lineNumber < model.getLineCount()) {\n                    endLineNumber = startLineNumber + 1;\n                    endColumn = model.getLineMaxColumn(endLineNumber);\n                }\n                else {\n                    endLineNumber = position.lineNumber;\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            else {\n                endLineNumber = selection.endLineNumber;\n                endColumn = model.getLineMaxColumn(endLineNumber);\n            }\n            let trimmedLinesContent = model.getLineContent(startLineNumber);\n            for (let i = startLineNumber + 1; i <= endLineNumber; i++) {\n                const lineText = model.getLineContent(i);\n                const firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i);\n                if (firstNonWhitespaceIdx >= 1) {\n                    let insertSpace = true;\n                    if (trimmedLinesContent === '') {\n                        insertSpace = false;\n                    }\n                    if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === ' ' ||\n                        trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === '\\t')) {\n                        insertSpace = false;\n                        trimmedLinesContent = trimmedLinesContent.replace(/[\\s\\uFEFF\\xA0]+$/g, ' ');\n                    }\n                    const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);\n                    trimmedLinesContent += (insertSpace ? ' ' : '') + lineTextWithoutIndent;\n                    if (insertSpace) {\n                        columnDeltaOffset = lineTextWithoutIndent.length + 1;\n                    }\n                    else {\n                        columnDeltaOffset = lineTextWithoutIndent.length;\n                    }\n                }\n                else {\n                    columnDeltaOffset = 0;\n                }\n            }\n            const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            if (!deleteSelection.isEmpty()) {\n                let resultSelection;\n                if (selection.isEmpty()) {\n                    edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));\n                    resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);\n                }\n                else {\n                    if (selection.startLineNumber === selection.endLineNumber) {\n                        edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));\n                        resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);\n                    }\n                    else {\n                        edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));\n                        resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);\n                    }\n                }\n                if (Range.intersectRanges(deleteSelection, primaryCursor) !== null) {\n                    endPrimaryCursor = resultSelection;\n                }\n                else {\n                    endCursorState.push(resultSelection);\n                }\n            }\n            lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;\n        }\n        endCursorState.unshift(endPrimaryCursor);\n        editor.pushUndoStop();\n        editor.executeEdits(this.id, edits, endCursorState);\n        editor.pushUndoStop();\n    }\n}\nexport class TransposeAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.transpose',\n            label: nls.localize('editor.transpose', \"Transpose characters around the cursor\"),\n            alias: 'Transpose characters around the cursor',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    run(_accessor, editor) {\n        const selections = editor.getSelections();\n        if (selections === null) {\n            return;\n        }\n        const model = editor.getModel();\n        if (model === null) {\n            return;\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                continue;\n            }\n            const cursor = selection.getStartPosition();\n            const maxColumn = model.getLineMaxColumn(cursor.lineNumber);\n            if (cursor.column >= maxColumn) {\n                if (cursor.lineNumber === model.getLineCount()) {\n                    continue;\n                }\n                // The cursor is at the end of current line and current line is not empty\n                // then we transpose the character before the cursor and the line break if there is any following line.\n                const deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);\n                const chars = model.getValueInRange(deleteSelection).split('').reverse().join('');\n                commands.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));\n            }\n            else {\n                const deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);\n                const chars = model.getValueInRange(deleteSelection).split('').reverse().join('');\n                commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));\n            }\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, commands);\n        editor.pushUndoStop();\n    }\n}\nexport class AbstractCaseAction extends EditorAction {\n    run(_accessor, editor) {\n        const selections = editor.getSelections();\n        if (selections === null) {\n            return;\n        }\n        const model = editor.getModel();\n        if (model === null) {\n            return;\n        }\n        const wordSeparators = editor.getOption(119 /* EditorOption.wordSeparators */);\n        const textEdits = [];\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                const cursor = selection.getStartPosition();\n                const word = editor.getConfiguredWordAtPosition(cursor);\n                if (!word) {\n                    continue;\n                }\n                const wordRange = new Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);\n                const text = model.getValueInRange(wordRange);\n                textEdits.push(EditOperation.replace(wordRange, this._modifyText(text, wordSeparators)));\n            }\n            else {\n                const text = model.getValueInRange(selection);\n                textEdits.push(EditOperation.replace(selection, this._modifyText(text, wordSeparators)));\n            }\n        }\n        editor.pushUndoStop();\n        editor.executeEdits(this.id, textEdits);\n        editor.pushUndoStop();\n    }\n}\nexport class UpperCaseAction extends AbstractCaseAction {\n    constructor() {\n        super({\n            id: 'editor.action.transformToUppercase',\n            label: nls.localize('editor.transformToUppercase', \"Transform to Uppercase\"),\n            alias: 'Transform to Uppercase',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, wordSeparators) {\n        return text.toLocaleUpperCase();\n    }\n}\nexport class LowerCaseAction extends AbstractCaseAction {\n    constructor() {\n        super({\n            id: 'editor.action.transformToLowercase',\n            label: nls.localize('editor.transformToLowercase', \"Transform to Lowercase\"),\n            alias: 'Transform to Lowercase',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, wordSeparators) {\n        return text.toLocaleLowerCase();\n    }\n}\nclass BackwardsCompatibleRegExp {\n    constructor(_pattern, _flags) {\n        this._pattern = _pattern;\n        this._flags = _flags;\n        this._actual = null;\n        this._evaluated = false;\n    }\n    get() {\n        if (!this._evaluated) {\n            this._evaluated = true;\n            try {\n                this._actual = new RegExp(this._pattern, this._flags);\n            }\n            catch (err) {\n                // this browser does not support this regular expression\n            }\n        }\n        return this._actual;\n    }\n    isSupported() {\n        return (this.get() !== null);\n    }\n}\nexport class TitleCaseAction extends AbstractCaseAction {\n    constructor() {\n        super({\n            id: 'editor.action.transformToTitlecase',\n            label: nls.localize('editor.transformToTitlecase', \"Transform to Title Case\"),\n            alias: 'Transform to Title Case',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, wordSeparators) {\n        const titleBoundary = TitleCaseAction.titleBoundary.get();\n        if (!titleBoundary) {\n            // cannot support this\n            return text;\n        }\n        return text\n            .toLocaleLowerCase()\n            .replace(titleBoundary, (b) => b.toLocaleUpperCase());\n    }\n}\nTitleCaseAction.titleBoundary = new BackwardsCompatibleRegExp('(^|[^\\\\p{L}\\\\p{N}\\']|((^|\\\\P{L})\\'))\\\\p{L}', 'gmu');\nexport class SnakeCaseAction extends AbstractCaseAction {\n    constructor() {\n        super({\n            id: 'editor.action.transformToSnakecase',\n            label: nls.localize('editor.transformToSnakecase', \"Transform to Snake Case\"),\n            alias: 'Transform to Snake Case',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, wordSeparators) {\n        const caseBoundary = SnakeCaseAction.caseBoundary.get();\n        const singleLetters = SnakeCaseAction.singleLetters.get();\n        if (!caseBoundary || !singleLetters) {\n            // cannot support this\n            return text;\n        }\n        return (text\n            .replace(caseBoundary, '$1_$2')\n            .replace(singleLetters, '$1_$2$3')\n            .toLocaleLowerCase());\n    }\n}\nSnakeCaseAction.caseBoundary = new BackwardsCompatibleRegExp('(\\\\p{Ll})(\\\\p{Lu})', 'gmu');\nSnakeCaseAction.singleLetters = new BackwardsCompatibleRegExp('(\\\\p{Lu}|\\\\p{N})(\\\\p{Lu})(\\\\p{Ll})', 'gmu');\nexport class KebabCaseAction extends AbstractCaseAction {\n    constructor() {\n        super({\n            id: 'editor.action.transformToKebabcase',\n            label: nls.localize('editor.transformToKebabcase', 'Transform to Kebab Case'),\n            alias: 'Transform to Kebab Case',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    static isSupported() {\n        const areAllRegexpsSupported = [\n            this.caseBoundary,\n            this.singleLetters,\n            this.underscoreBoundary,\n        ].every((regexp) => regexp.isSupported());\n        return areAllRegexpsSupported;\n    }\n    _modifyText(text, _) {\n        const caseBoundary = KebabCaseAction.caseBoundary.get();\n        const singleLetters = KebabCaseAction.singleLetters.get();\n        const underscoreBoundary = KebabCaseAction.underscoreBoundary.get();\n        if (!caseBoundary || !singleLetters || !underscoreBoundary) {\n            // one or more regexps aren't supported\n            return text;\n        }\n        return text\n            .replace(underscoreBoundary, '$1-$3')\n            .replace(caseBoundary, '$1-$2')\n            .replace(singleLetters, '$1-$2')\n            .toLocaleLowerCase();\n    }\n}\nKebabCaseAction.caseBoundary = new BackwardsCompatibleRegExp('(\\\\p{Ll})(\\\\p{Lu})', 'gmu');\nKebabCaseAction.singleLetters = new BackwardsCompatibleRegExp('(\\\\p{Lu}|\\\\p{N})(\\\\p{Lu}\\\\p{Ll})', 'gmu');\nKebabCaseAction.underscoreBoundary = new BackwardsCompatibleRegExp('(\\\\S)(_)(\\\\S)', 'gm');\nregisterEditorAction(CopyLinesUpAction);\nregisterEditorAction(CopyLinesDownAction);\nregisterEditorAction(DuplicateSelectionAction);\nregisterEditorAction(MoveLinesUpAction);\nregisterEditorAction(MoveLinesDownAction);\nregisterEditorAction(SortLinesAscendingAction);\nregisterEditorAction(SortLinesDescendingAction);\nregisterEditorAction(DeleteDuplicateLinesAction);\nregisterEditorAction(TrimTrailingWhitespaceAction);\nregisterEditorAction(DeleteLinesAction);\nregisterEditorAction(IndentLinesAction);\nregisterEditorAction(OutdentLinesAction);\nregisterEditorAction(InsertLineBeforeAction);\nregisterEditorAction(InsertLineAfterAction);\nregisterEditorAction(DeleteAllLeftAction);\nregisterEditorAction(DeleteAllRightAction);\nregisterEditorAction(JoinLinesAction);\nregisterEditorAction(TransposeAction);\nregisterEditorAction(UpperCaseAction);\nregisterEditorAction(LowerCaseAction);\nif (SnakeCaseAction.caseBoundary.isSupported() && SnakeCaseAction.singleLetters.isSupported()) {\n    registerEditorAction(SnakeCaseAction);\n}\nif (TitleCaseAction.titleBoundary.isSupported()) {\n    registerEditorAction(TitleCaseAction);\n}\nif (KebabCaseAction.isSupported()) {\n    registerEditorAction(KebabCaseAction);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { createCancelablePromise, Delayer, first } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { isCancellationError, onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorAction, EditorCommand, registerEditorAction, registerEditorCommand, registerEditorContribution, registerModelAndPositionCommand } from '../../../browser/editorExtensions.js';\nimport { ICodeEditorService } from '../../../browser/services/codeEditorService.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as nls from '../../../../nls.js';\nimport { ContextKeyExpr, IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { registerColor } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nexport const CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE = new RawContextKey('LinkedEditingInputVisible', false);\nconst DECORATION_CLASS_NAME = 'linked-editing-decoration';\nlet LinkedEditingContribution = class LinkedEditingContribution extends Disposable {\n    constructor(editor, contextKeyService, languageFeaturesService, languageConfigurationService, languageFeatureDebounceService) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._syncRangesToken = 0;\n        this._localToDispose = this._register(new DisposableStore());\n        this._editor = editor;\n        this._providers = languageFeaturesService.linkedEditingRangeProvider;\n        this._enabled = false;\n        this._visibleContextKey = CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);\n        this._debounceInformation = languageFeatureDebounceService.for(this._providers, 'Linked Editing', { min: 200 });\n        this._currentDecorations = this._editor.createDecorationsCollection();\n        this._languageWordPattern = null;\n        this._currentWordPattern = null;\n        this._ignoreChangeEvent = false;\n        this._localToDispose = this._register(new DisposableStore());\n        this._rangeUpdateTriggerPromise = null;\n        this._rangeSyncTriggerPromise = null;\n        this._currentRequest = null;\n        this._currentRequestPosition = null;\n        this._currentRequestModelVersion = null;\n        this._register(this._editor.onDidChangeModel(() => this.reinitialize(true)));\n        this._register(this._editor.onDidChangeConfiguration(e => {\n            if (e.hasChanged(64 /* EditorOption.linkedEditing */) || e.hasChanged(84 /* EditorOption.renameOnType */)) {\n                this.reinitialize(false);\n            }\n        }));\n        this._register(this._providers.onDidChange(() => this.reinitialize(false)));\n        this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(true)));\n        this.reinitialize(true);\n    }\n    static get(editor) {\n        return editor.getContribution(LinkedEditingContribution.ID);\n    }\n    reinitialize(forceRefresh) {\n        const model = this._editor.getModel();\n        const isEnabled = model !== null && (this._editor.getOption(64 /* EditorOption.linkedEditing */) || this._editor.getOption(84 /* EditorOption.renameOnType */)) && this._providers.has(model);\n        if (isEnabled === this._enabled && !forceRefresh) {\n            return;\n        }\n        this._enabled = isEnabled;\n        this.clearRanges();\n        this._localToDispose.clear();\n        if (!isEnabled || model === null) {\n            return;\n        }\n        this._localToDispose.add(Event.runAndSubscribe(model.onDidChangeLanguageConfiguration, () => {\n            this._languageWordPattern = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();\n        }));\n        const rangeUpdateScheduler = new Delayer(this._debounceInformation.get(model));\n        const triggerRangeUpdate = () => {\n            var _a;\n            this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), (_a = this._debounceDuration) !== null && _a !== void 0 ? _a : this._debounceInformation.get(model));\n        };\n        const rangeSyncScheduler = new Delayer(0);\n        const triggerRangeSync = (token) => {\n            this._rangeSyncTriggerPromise = rangeSyncScheduler.trigger(() => this._syncRanges(token));\n        };\n        this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {\n            triggerRangeUpdate();\n        }));\n        this._localToDispose.add(this._editor.onDidChangeModelContent((e) => {\n            if (!this._ignoreChangeEvent) {\n                if (this._currentDecorations.length > 0) {\n                    const referenceRange = this._currentDecorations.getRange(0);\n                    if (referenceRange && e.changes.every(c => referenceRange.intersectRanges(c.range))) {\n                        triggerRangeSync(this._syncRangesToken);\n                        return;\n                    }\n                }\n            }\n            triggerRangeUpdate();\n        }));\n        this._localToDispose.add({\n            dispose: () => {\n                rangeUpdateScheduler.dispose();\n                rangeSyncScheduler.dispose();\n            }\n        });\n        this.updateRanges();\n    }\n    _syncRanges(token) {\n        // dalayed invocation, make sure we're still on\n        if (!this._editor.hasModel() || token !== this._syncRangesToken || this._currentDecorations.length === 0) {\n            // nothing to do\n            return;\n        }\n        const model = this._editor.getModel();\n        const referenceRange = this._currentDecorations.getRange(0);\n        if (!referenceRange || referenceRange.startLineNumber !== referenceRange.endLineNumber) {\n            return this.clearRanges();\n        }\n        const referenceValue = model.getValueInRange(referenceRange);\n        if (this._currentWordPattern) {\n            const match = referenceValue.match(this._currentWordPattern);\n            const matchLength = match ? match[0].length : 0;\n            if (matchLength !== referenceValue.length) {\n                return this.clearRanges();\n            }\n        }\n        const edits = [];\n        for (let i = 1, len = this._currentDecorations.length; i < len; i++) {\n            const mirrorRange = this._currentDecorations.getRange(i);\n            if (!mirrorRange) {\n                continue;\n            }\n            if (mirrorRange.startLineNumber !== mirrorRange.endLineNumber) {\n                edits.push({\n                    range: mirrorRange,\n                    text: referenceValue\n                });\n            }\n            else {\n                let oldValue = model.getValueInRange(mirrorRange);\n                let newValue = referenceValue;\n                let rangeStartColumn = mirrorRange.startColumn;\n                let rangeEndColumn = mirrorRange.endColumn;\n                const commonPrefixLength = strings.commonPrefixLength(oldValue, newValue);\n                rangeStartColumn += commonPrefixLength;\n                oldValue = oldValue.substr(commonPrefixLength);\n                newValue = newValue.substr(commonPrefixLength);\n                const commonSuffixLength = strings.commonSuffixLength(oldValue, newValue);\n                rangeEndColumn -= commonSuffixLength;\n                oldValue = oldValue.substr(0, oldValue.length - commonSuffixLength);\n                newValue = newValue.substr(0, newValue.length - commonSuffixLength);\n                if (rangeStartColumn !== rangeEndColumn || newValue.length !== 0) {\n                    edits.push({\n                        range: new Range(mirrorRange.startLineNumber, rangeStartColumn, mirrorRange.endLineNumber, rangeEndColumn),\n                        text: newValue\n                    });\n                }\n            }\n        }\n        if (edits.length === 0) {\n            return;\n        }\n        try {\n            this._editor.popUndoStop();\n            this._ignoreChangeEvent = true;\n            const prevEditOperationType = this._editor._getViewModel().getPrevEditOperationType();\n            this._editor.executeEdits('linkedEditing', edits);\n            this._editor._getViewModel().setPrevEditOperationType(prevEditOperationType);\n        }\n        finally {\n            this._ignoreChangeEvent = false;\n        }\n    }\n    dispose() {\n        this.clearRanges();\n        super.dispose();\n    }\n    clearRanges() {\n        this._visibleContextKey.set(false);\n        this._currentDecorations.clear();\n        if (this._currentRequest) {\n            this._currentRequest.cancel();\n            this._currentRequest = null;\n            this._currentRequestPosition = null;\n        }\n    }\n    updateRanges(force = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._editor.hasModel()) {\n                this.clearRanges();\n                return;\n            }\n            const position = this._editor.getPosition();\n            if (!this._enabled && !force || this._editor.getSelections().length > 1) {\n                // disabled or multicursor\n                this.clearRanges();\n                return;\n            }\n            const model = this._editor.getModel();\n            const modelVersionId = model.getVersionId();\n            if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {\n                if (position.equals(this._currentRequestPosition)) {\n                    return; // same position\n                }\n                if (this._currentDecorations.length > 0) {\n                    const range = this._currentDecorations.getRange(0);\n                    if (range && range.containsPosition(position)) {\n                        return; // just moving inside the existing primary range\n                    }\n                }\n            }\n            this._currentRequestPosition = position;\n            this._currentRequestModelVersion = modelVersionId;\n            const request = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const sw = new StopWatch(false);\n                    const response = yield getLinkedEditingRanges(this._providers, model, position, token);\n                    this._debounceInformation.update(model, sw.elapsed());\n                    if (request !== this._currentRequest) {\n                        return;\n                    }\n                    this._currentRequest = null;\n                    if (modelVersionId !== model.getVersionId()) {\n                        return;\n                    }\n                    let ranges = [];\n                    if (response === null || response === void 0 ? void 0 : response.ranges) {\n                        ranges = response.ranges;\n                    }\n                    this._currentWordPattern = (response === null || response === void 0 ? void 0 : response.wordPattern) || this._languageWordPattern;\n                    let foundReferenceRange = false;\n                    for (let i = 0, len = ranges.length; i < len; i++) {\n                        if (Range.containsPosition(ranges[i], position)) {\n                            foundReferenceRange = true;\n                            if (i !== 0) {\n                                const referenceRange = ranges[i];\n                                ranges.splice(i, 1);\n                                ranges.unshift(referenceRange);\n                            }\n                            break;\n                        }\n                    }\n                    if (!foundReferenceRange) {\n                        // Cannot do linked editing if the ranges are not where the cursor is...\n                        this.clearRanges();\n                        return;\n                    }\n                    const decorations = ranges.map(range => ({ range: range, options: LinkedEditingContribution.DECORATION }));\n                    this._visibleContextKey.set(true);\n                    this._currentDecorations.set(decorations);\n                    this._syncRangesToken++; // cancel any pending syncRanges call\n                }\n                catch (err) {\n                    if (!isCancellationError(err)) {\n                        onUnexpectedError(err);\n                    }\n                    if (this._currentRequest === request || !this._currentRequest) {\n                        // stop if we are still the latest request\n                        this.clearRanges();\n                    }\n                }\n            }));\n            this._currentRequest = request;\n            return request;\n        });\n    }\n};\nLinkedEditingContribution.ID = 'editor.contrib.linkedEditing';\nLinkedEditingContribution.DECORATION = ModelDecorationOptions.register({\n    description: 'linked-editing',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    className: DECORATION_CLASS_NAME\n});\nLinkedEditingContribution = __decorate([\n    __param(1, IContextKeyService),\n    __param(2, ILanguageFeaturesService),\n    __param(3, ILanguageConfigurationService),\n    __param(4, ILanguageFeatureDebounceService)\n], LinkedEditingContribution);\nexport { LinkedEditingContribution };\nexport class LinkedEditingAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.linkedEditing',\n            label: nls.localize('linkedEditing.label', \"Start Linked Editing\"),\n            alias: 'Start Linked Editing',\n            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 60 /* KeyCode.F2 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    runCommand(accessor, args) {\n        const editorService = accessor.get(ICodeEditorService);\n        const [uri, pos] = Array.isArray(args) && args || [undefined, undefined];\n        if (URI.isUri(uri) && Position.isIPosition(pos)) {\n            return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then(editor => {\n                if (!editor) {\n                    return;\n                }\n                editor.setPosition(pos);\n                editor.invokeWithinContext(accessor => {\n                    this.reportTelemetry(accessor, editor);\n                    return this.run(accessor, editor);\n                });\n            }, onUnexpectedError);\n        }\n        return super.runCommand(accessor, args);\n    }\n    run(_accessor, editor) {\n        const controller = LinkedEditingContribution.get(editor);\n        if (controller) {\n            return Promise.resolve(controller.updateRanges(true));\n        }\n        return Promise.resolve();\n    }\n}\nconst LinkedEditingCommand = EditorCommand.bindToContribution(LinkedEditingContribution.get);\nregisterEditorCommand(new LinkedEditingCommand({\n    id: 'cancelLinkedEditingInput',\n    precondition: CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE,\n    handler: x => x.clearRanges(),\n    kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 99,\n        primary: 9 /* KeyCode.Escape */,\n        secondary: [1024 /* KeyMod.Shift */ | 9 /* KeyCode.Escape */]\n    }\n}));\nfunction getLinkedEditingRanges(providers, model, position, token) {\n    const orderedByScore = providers.ordered(model);\n    // in order of score ask the linked editing range provider\n    // until someone response with a good result\n    // (good = not null)\n    return first(orderedByScore.map(provider => () => __awaiter(this, void 0, void 0, function* () {\n        try {\n            return yield provider.provideLinkedEditingRanges(model, position, token);\n        }\n        catch (e) {\n            onUnexpectedExternalError(e);\n            return undefined;\n        }\n    })), result => !!result && arrays.isNonEmptyArray(result === null || result === void 0 ? void 0 : result.ranges));\n}\nexport const editorLinkedEditingBackground = registerColor('editor.linkedEditingBackground', { dark: Color.fromHex('#f00').transparent(0.3), light: Color.fromHex('#f00').transparent(0.3), hcDark: Color.fromHex('#f00').transparent(0.3), hcLight: Color.white }, nls.localize('editorLinkedEditingBackground', 'Background color when the editor auto renames on type.'));\nregisterThemingParticipant((theme, collector) => {\n    const editorLinkedEditingBackgroundColor = theme.getColor(editorLinkedEditingBackground);\n    if (editorLinkedEditingBackgroundColor) {\n        collector.addRule(`.monaco-editor .${DECORATION_CLASS_NAME} { background: ${editorLinkedEditingBackgroundColor}; border-left-color: ${editorLinkedEditingBackgroundColor}; }`);\n    }\n});\nregisterModelAndPositionCommand('_executeLinkedEditingProvider', (_accessor, model, position) => {\n    const { linkedEditingRangeProvider } = _accessor.get(ILanguageFeaturesService);\n    return getLinkedEditingRanges(linkedEditingRangeProvider, model, position, CancellationToken.None);\n});\nregisterEditorContribution(LinkedEditingContribution.ID, LinkedEditingContribution);\nregisterEditorAction(LinkedEditingAction);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { status } from '../../../../base/browser/ui/aria/aria.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { KeyChord } from '../../../../base/common/keyCodes.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution } from '../../../browser/editorExtensions.js';\nimport { CursorMoveCommands } from '../../../common/cursor/cursorMoveCommands.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { OverviewRulerLane, MinimapPosition } from '../../../common/model.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { CommonFindController } from '../../find/browser/findController.js';\nimport * as nls from '../../../../nls.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';\nimport { overviewRulerSelectionHighlightForeground, minimapSelectionOccurrenceHighlight } from '../../../../platform/theme/common/colorRegistry.js';\nimport { themeColorFromId } from '../../../../platform/theme/common/themeService.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nfunction announceCursorChange(previousCursorState, cursorState) {\n    const cursorDiff = cursorState.filter(cs => !previousCursorState.find(pcs => pcs.equals(cs)));\n    if (cursorDiff.length >= 1) {\n        const cursorPositions = cursorDiff.map(cs => `line ${cs.viewState.position.lineNumber} column ${cs.viewState.position.column}`).join(', ');\n        const msg = cursorDiff.length === 1 ? nls.localize('cursorAdded', \"Cursor added: {0}\", cursorPositions) : nls.localize('cursorsAdded', \"Cursors added: {0}\", cursorPositions);\n        status(msg);\n    }\n}\nexport class InsertCursorAbove extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.insertCursorAbove',\n            label: nls.localize('mutlicursor.insertAbove', \"Add Cursor Above\"),\n            alias: 'Add Cursor Above',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */,\n                linux: {\n                    primary: 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */,\n                    secondary: [2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */]\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miInsertCursorAbove', comment: ['&& denotes a mnemonic'] }, \"&&Add Cursor Above\"),\n                order: 2\n            }\n        });\n    }\n    run(accessor, editor, args) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        let useLogicalLine = true;\n        if (args && args.logicalLine === false) {\n            useLogicalLine = false;\n        }\n        const viewModel = editor._getViewModel();\n        if (viewModel.cursorConfig.readOnly) {\n            return;\n        }\n        viewModel.model.pushStackElement();\n        const previousCursorState = viewModel.getCursorStates();\n        viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, CursorMoveCommands.addCursorUp(viewModel, previousCursorState, useLogicalLine));\n        viewModel.revealTopMostCursor(args.source);\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nexport class InsertCursorBelow extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.insertCursorBelow',\n            label: nls.localize('mutlicursor.insertBelow', \"Add Cursor Below\"),\n            alias: 'Add Cursor Below',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */,\n                linux: {\n                    primary: 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */,\n                    secondary: [2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */]\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miInsertCursorBelow', comment: ['&& denotes a mnemonic'] }, \"A&&dd Cursor Below\"),\n                order: 3\n            }\n        });\n    }\n    run(accessor, editor, args) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        let useLogicalLine = true;\n        if (args && args.logicalLine === false) {\n            useLogicalLine = false;\n        }\n        const viewModel = editor._getViewModel();\n        if (viewModel.cursorConfig.readOnly) {\n            return;\n        }\n        viewModel.model.pushStackElement();\n        const previousCursorState = viewModel.getCursorStates();\n        viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, CursorMoveCommands.addCursorDown(viewModel, previousCursorState, useLogicalLine));\n        viewModel.revealBottomMostCursor(args.source);\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nclass InsertCursorAtEndOfEachLineSelected extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.insertCursorAtEndOfEachLineSelected',\n            label: nls.localize('mutlicursor.insertAtEndOfEachLineSelected', \"Add Cursors to Line Ends\"),\n            alias: 'Add Cursors to Line Ends',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 39 /* KeyCode.KeyI */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miInsertCursorAtEndOfEachLineSelected', comment: ['&& denotes a mnemonic'] }, \"Add C&&ursors to Line Ends\"),\n                order: 4\n            }\n        });\n    }\n    getCursorsForSelection(selection, model, result) {\n        if (selection.isEmpty()) {\n            return;\n        }\n        for (let i = selection.startLineNumber; i < selection.endLineNumber; i++) {\n            const currentLineMaxColumn = model.getLineMaxColumn(i);\n            result.push(new Selection(i, currentLineMaxColumn, i, currentLineMaxColumn));\n        }\n        if (selection.endColumn > 1) {\n            result.push(new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));\n        }\n    }\n    run(accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const model = editor.getModel();\n        const selections = editor.getSelections();\n        const viewModel = editor._getViewModel();\n        const previousCursorState = viewModel.getCursorStates();\n        const newSelections = [];\n        selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));\n        if (newSelections.length > 0) {\n            editor.setSelections(newSelections);\n        }\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nclass InsertCursorAtEndOfLineSelected extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.addCursorsToBottom',\n            label: nls.localize('mutlicursor.addCursorsToBottom', \"Add Cursors To Bottom\"),\n            alias: 'Add Cursors To Bottom',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const selections = editor.getSelections();\n        const lineCount = editor.getModel().getLineCount();\n        const newSelections = [];\n        for (let i = selections[0].startLineNumber; i <= lineCount; i++) {\n            newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));\n        }\n        const viewModel = editor._getViewModel();\n        const previousCursorState = viewModel.getCursorStates();\n        if (newSelections.length > 0) {\n            editor.setSelections(newSelections);\n        }\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nclass InsertCursorAtTopOfLineSelected extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.addCursorsToTop',\n            label: nls.localize('mutlicursor.addCursorsToTop', \"Add Cursors To Top\"),\n            alias: 'Add Cursors To Top',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const selections = editor.getSelections();\n        const newSelections = [];\n        for (let i = selections[0].startLineNumber; i >= 1; i--) {\n            newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));\n        }\n        const viewModel = editor._getViewModel();\n        const previousCursorState = viewModel.getCursorStates();\n        if (newSelections.length > 0) {\n            editor.setSelections(newSelections);\n        }\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nexport class MultiCursorSessionResult {\n    constructor(selections, revealRange, revealScrollType) {\n        this.selections = selections;\n        this.revealRange = revealRange;\n        this.revealScrollType = revealScrollType;\n    }\n}\nexport class MultiCursorSession {\n    constructor(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {\n        this._editor = _editor;\n        this.findController = findController;\n        this.isDisconnectedFromFindController = isDisconnectedFromFindController;\n        this.searchText = searchText;\n        this.wholeWord = wholeWord;\n        this.matchCase = matchCase;\n        this.currentMatch = currentMatch;\n    }\n    static create(editor, findController) {\n        if (!editor.hasModel()) {\n            return null;\n        }\n        const findState = findController.getState();\n        // Find widget owns entirely what we search for if:\n        //  - focus is not in the editor (i.e. it is in the find widget)\n        //  - and the search widget is visible\n        //  - and the search string is non-empty\n        if (!editor.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) {\n            // Find widget owns what is searched for\n            return new MultiCursorSession(editor, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);\n        }\n        // Otherwise, the selection gives the search text, and the find widget gives the search settings\n        // The exception is the find state disassociation case: when beginning with a single, collapsed selection\n        let isDisconnectedFromFindController = false;\n        let wholeWord;\n        let matchCase;\n        const selections = editor.getSelections();\n        if (selections.length === 1 && selections[0].isEmpty()) {\n            isDisconnectedFromFindController = true;\n            wholeWord = true;\n            matchCase = true;\n        }\n        else {\n            wholeWord = findState.wholeWord;\n            matchCase = findState.matchCase;\n        }\n        // Selection owns what is searched for\n        const s = editor.getSelection();\n        let searchText;\n        let currentMatch = null;\n        if (s.isEmpty()) {\n            // selection is empty => expand to current word\n            const word = editor.getConfiguredWordAtPosition(s.getStartPosition());\n            if (!word) {\n                return null;\n            }\n            searchText = word.word;\n            currentMatch = new Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);\n        }\n        else {\n            searchText = editor.getModel().getValueInRange(s).replace(/\\r\\n/g, '\\n');\n        }\n        return new MultiCursorSession(editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);\n    }\n    addSelectionToNextFindMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        const nextMatch = this._getNextMatch();\n        if (!nextMatch) {\n            return null;\n        }\n        const allSelections = this._editor.getSelections();\n        return new MultiCursorSessionResult(allSelections.concat(nextMatch), nextMatch, 0 /* ScrollType.Smooth */);\n    }\n    moveSelectionToNextFindMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        const nextMatch = this._getNextMatch();\n        if (!nextMatch) {\n            return null;\n        }\n        const allSelections = this._editor.getSelections();\n        return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(nextMatch), nextMatch, 0 /* ScrollType.Smooth */);\n    }\n    _getNextMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        if (this.currentMatch) {\n            const result = this.currentMatch;\n            this.currentMatch = null;\n            return result;\n        }\n        this.findController.highlightFindOptions();\n        const allSelections = this._editor.getSelections();\n        const lastAddedSelection = allSelections[allSelections.length - 1];\n        const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, false);\n        if (!nextMatch) {\n            return null;\n        }\n        return new Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);\n    }\n    addSelectionToPreviousFindMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        const previousMatch = this._getPreviousMatch();\n        if (!previousMatch) {\n            return null;\n        }\n        const allSelections = this._editor.getSelections();\n        return new MultiCursorSessionResult(allSelections.concat(previousMatch), previousMatch, 0 /* ScrollType.Smooth */);\n    }\n    moveSelectionToPreviousFindMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        const previousMatch = this._getPreviousMatch();\n        if (!previousMatch) {\n            return null;\n        }\n        const allSelections = this._editor.getSelections();\n        return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(previousMatch), previousMatch, 0 /* ScrollType.Smooth */);\n    }\n    _getPreviousMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        if (this.currentMatch) {\n            const result = this.currentMatch;\n            this.currentMatch = null;\n            return result;\n        }\n        this.findController.highlightFindOptions();\n        const allSelections = this._editor.getSelections();\n        const lastAddedSelection = allSelections[allSelections.length - 1];\n        const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, false);\n        if (!previousMatch) {\n            return null;\n        }\n        return new Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);\n    }\n    selectAll(searchScope) {\n        if (!this._editor.hasModel()) {\n            return [];\n        }\n        this.findController.highlightFindOptions();\n        const editorModel = this._editor.getModel();\n        if (searchScope) {\n            return editorModel.findMatches(this.searchText, searchScope, false, this.matchCase, this.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        }\n        return editorModel.findMatches(this.searchText, true, false, this.matchCase, this.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n    }\n}\nexport class MultiCursorSelectionController extends Disposable {\n    constructor(editor) {\n        super();\n        this._sessionDispose = this._register(new DisposableStore());\n        this._editor = editor;\n        this._ignoreSelectionChange = false;\n        this._session = null;\n    }\n    static get(editor) {\n        return editor.getContribution(MultiCursorSelectionController.ID);\n    }\n    dispose() {\n        this._endSession();\n        super.dispose();\n    }\n    _beginSessionIfNeeded(findController) {\n        if (!this._session) {\n            // Create a new session\n            const session = MultiCursorSession.create(this._editor, findController);\n            if (!session) {\n                return;\n            }\n            this._session = session;\n            const newState = { searchString: this._session.searchText };\n            if (this._session.isDisconnectedFromFindController) {\n                newState.wholeWordOverride = 1 /* FindOptionOverride.True */;\n                newState.matchCaseOverride = 1 /* FindOptionOverride.True */;\n                newState.isRegexOverride = 2 /* FindOptionOverride.False */;\n            }\n            findController.getState().change(newState, false);\n            this._sessionDispose.add(this._editor.onDidChangeCursorSelection((e) => {\n                if (this._ignoreSelectionChange) {\n                    return;\n                }\n                this._endSession();\n            }));\n            this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {\n                this._endSession();\n            }));\n            this._sessionDispose.add(findController.getState().onFindReplaceStateChange((e) => {\n                if (e.matchCase || e.wholeWord) {\n                    this._endSession();\n                }\n            }));\n        }\n    }\n    _endSession() {\n        this._sessionDispose.clear();\n        if (this._session && this._session.isDisconnectedFromFindController) {\n            const newState = {\n                wholeWordOverride: 0 /* FindOptionOverride.NotSet */,\n                matchCaseOverride: 0 /* FindOptionOverride.NotSet */,\n                isRegexOverride: 0 /* FindOptionOverride.NotSet */,\n            };\n            this._session.findController.getState().change(newState, false);\n        }\n        this._session = null;\n    }\n    _setSelections(selections) {\n        this._ignoreSelectionChange = true;\n        this._editor.setSelections(selections);\n        this._ignoreSelectionChange = false;\n    }\n    _expandEmptyToWord(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const word = this._editor.getConfiguredWordAtPosition(selection.getStartPosition());\n        if (!word) {\n            return selection;\n        }\n        return new Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);\n    }\n    _applySessionResult(result) {\n        if (!result) {\n            return;\n        }\n        this._setSelections(result.selections);\n        if (result.revealRange) {\n            this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);\n        }\n    }\n    getSession(findController) {\n        return this._session;\n    }\n    addSelectionToNextFindMatch(findController) {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        if (!this._session) {\n            // If there are multiple cursors, handle the case where they do not all select the same text.\n            const allSelections = this._editor.getSelections();\n            if (allSelections.length > 1) {\n                const findState = findController.getState();\n                const matchCase = findState.matchCase;\n                const selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);\n                if (!selectionsContainSameText) {\n                    const model = this._editor.getModel();\n                    const resultingSelections = [];\n                    for (let i = 0, len = allSelections.length; i < len; i++) {\n                        resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);\n                    }\n                    this._editor.setSelections(resultingSelections);\n                    return;\n                }\n            }\n        }\n        this._beginSessionIfNeeded(findController);\n        if (this._session) {\n            this._applySessionResult(this._session.addSelectionToNextFindMatch());\n        }\n    }\n    addSelectionToPreviousFindMatch(findController) {\n        this._beginSessionIfNeeded(findController);\n        if (this._session) {\n            this._applySessionResult(this._session.addSelectionToPreviousFindMatch());\n        }\n    }\n    moveSelectionToNextFindMatch(findController) {\n        this._beginSessionIfNeeded(findController);\n        if (this._session) {\n            this._applySessionResult(this._session.moveSelectionToNextFindMatch());\n        }\n    }\n    moveSelectionToPreviousFindMatch(findController) {\n        this._beginSessionIfNeeded(findController);\n        if (this._session) {\n            this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());\n        }\n    }\n    selectAll(findController) {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        let matches = null;\n        const findState = findController.getState();\n        // Special case: find widget owns entirely what we search for if:\n        // - focus is not in the editor (i.e. it is in the find widget)\n        // - and the search widget is visible\n        // - and the search string is non-empty\n        // - and we're searching for a regex\n        if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {\n            const editorModel = this._editor.getModel();\n            if (findState.searchScope) {\n                matches = editorModel.findMatches(findState.searchString, findState.searchScope, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n            }\n            else {\n                matches = editorModel.findMatches(findState.searchString, true, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getOption(119 /* EditorOption.wordSeparators */) : null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n            }\n        }\n        else {\n            this._beginSessionIfNeeded(findController);\n            if (!this._session) {\n                return;\n            }\n            matches = this._session.selectAll(findState.searchScope);\n        }\n        if (matches.length > 0) {\n            const editorSelection = this._editor.getSelection();\n            // Have the primary cursor remain the one where the action was invoked\n            for (let i = 0, len = matches.length; i < len; i++) {\n                const match = matches[i];\n                const intersection = match.range.intersectRanges(editorSelection);\n                if (intersection) {\n                    // bingo!\n                    matches[i] = matches[0];\n                    matches[0] = match;\n                    break;\n                }\n            }\n            this._setSelections(matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));\n        }\n    }\n}\nMultiCursorSelectionController.ID = 'editor.contrib.multiCursorController';\nexport class MultiCursorSelectionControllerAction extends EditorAction {\n    run(accessor, editor) {\n        const multiCursorController = MultiCursorSelectionController.get(editor);\n        if (!multiCursorController) {\n            return;\n        }\n        const findController = CommonFindController.get(editor);\n        if (!findController) {\n            return;\n        }\n        const viewModel = editor._getViewModel();\n        if (viewModel) {\n            const previousCursorState = viewModel.getCursorStates();\n            this._run(multiCursorController, findController);\n            announceCursorChange(previousCursorState, viewModel.getCursorStates());\n        }\n    }\n}\nexport class AddSelectionToNextFindMatchAction extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.addSelectionToNextFindMatch',\n            label: nls.localize('addSelectionToNextFindMatch', \"Add Selection To Next Find Match\"),\n            alias: 'Add Selection To Next Find Match',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.focus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 34 /* KeyCode.KeyD */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miAddSelectionToNextFindMatch', comment: ['&& denotes a mnemonic'] }, \"Add &&Next Occurrence\"),\n                order: 5\n            }\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.addSelectionToNextFindMatch(findController);\n    }\n}\nexport class AddSelectionToPreviousFindMatchAction extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.addSelectionToPreviousFindMatch',\n            label: nls.localize('addSelectionToPreviousFindMatch', \"Add Selection To Previous Find Match\"),\n            alias: 'Add Selection To Previous Find Match',\n            precondition: undefined,\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miAddSelectionToPreviousFindMatch', comment: ['&& denotes a mnemonic'] }, \"Add P&&revious Occurrence\"),\n                order: 6\n            }\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.addSelectionToPreviousFindMatch(findController);\n    }\n}\nexport class MoveSelectionToNextFindMatchAction extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.moveSelectionToNextFindMatch',\n            label: nls.localize('moveSelectionToNextFindMatch', \"Move Last Selection To Next Find Match\"),\n            alias: 'Move Last Selection To Next Find Match',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.focus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 34 /* KeyCode.KeyD */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.moveSelectionToNextFindMatch(findController);\n    }\n}\nexport class MoveSelectionToPreviousFindMatchAction extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.moveSelectionToPreviousFindMatch',\n            label: nls.localize('moveSelectionToPreviousFindMatch', \"Move Last Selection To Previous Find Match\"),\n            alias: 'Move Last Selection To Previous Find Match',\n            precondition: undefined\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.moveSelectionToPreviousFindMatch(findController);\n    }\n}\nexport class SelectHighlightsAction extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.selectHighlights',\n            label: nls.localize('selectAllOccurrencesOfFindMatch', \"Select All Occurrences of Find Match\"),\n            alias: 'Select All Occurrences of Find Match',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.focus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 42 /* KeyCode.KeyL */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miSelectHighlights', comment: ['&& denotes a mnemonic'] }, \"Select All &&Occurrences\"),\n                order: 7\n            }\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.selectAll(findController);\n    }\n}\nexport class CompatChangeAll extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.changeAll',\n            label: nls.localize('changeAll.label', \"Change All Occurrences\"),\n            alias: 'Change All Occurrences',\n            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 60 /* KeyCode.F2 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            contextMenuOpts: {\n                group: '1_modification',\n                order: 1.2\n            }\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.selectAll(findController);\n    }\n}\nclass SelectionHighlighterState {\n    constructor(_model, _searchText, _matchCase, _wordSeparators, prevState) {\n        this._model = _model;\n        this._searchText = _searchText;\n        this._matchCase = _matchCase;\n        this._wordSeparators = _wordSeparators;\n        this._modelVersionId = this._model.getVersionId();\n        this._cachedFindMatches = null;\n        if (prevState\n            && this._model === prevState._model\n            && this._searchText === prevState._searchText\n            && this._matchCase === prevState._matchCase\n            && this._wordSeparators === prevState._wordSeparators\n            && this._modelVersionId === prevState._modelVersionId) {\n            this._cachedFindMatches = prevState._cachedFindMatches;\n        }\n    }\n    findMatches() {\n        if (this._cachedFindMatches === null) {\n            this._cachedFindMatches = this._model.findMatches(this._searchText, true, false, this._matchCase, this._wordSeparators, false).map(m => m.range);\n            this._cachedFindMatches.sort(Range.compareRangesUsingStarts);\n        }\n        return this._cachedFindMatches;\n    }\n}\nlet SelectionHighlighter = class SelectionHighlighter extends Disposable {\n    constructor(editor, _languageFeaturesService) {\n        super();\n        this._languageFeaturesService = _languageFeaturesService;\n        this.editor = editor;\n        this._isEnabled = editor.getOption(99 /* EditorOption.selectionHighlight */);\n        this._decorations = editor.createDecorationsCollection();\n        this.updateSoon = this._register(new RunOnceScheduler(() => this._update(), 300));\n        this.state = null;\n        this._register(editor.onDidChangeConfiguration((e) => {\n            this._isEnabled = editor.getOption(99 /* EditorOption.selectionHighlight */);\n        }));\n        this._register(editor.onDidChangeCursorSelection((e) => {\n            if (!this._isEnabled) {\n                // Early exit if nothing needs to be done!\n                // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n                return;\n            }\n            if (e.selection.isEmpty()) {\n                if (e.reason === 3 /* CursorChangeReason.Explicit */) {\n                    if (this.state) {\n                        // no longer valid\n                        this._setState(null);\n                    }\n                    this.updateSoon.schedule();\n                }\n                else {\n                    this._setState(null);\n                }\n            }\n            else {\n                this._update();\n            }\n        }));\n        this._register(editor.onDidChangeModel((e) => {\n            this._setState(null);\n        }));\n        this._register(editor.onDidChangeModelContent((e) => {\n            if (this._isEnabled) {\n                this.updateSoon.schedule();\n            }\n        }));\n        const findController = CommonFindController.get(editor);\n        if (findController) {\n            this._register(findController.getState().onFindReplaceStateChange((e) => {\n                this._update();\n            }));\n        }\n    }\n    _update() {\n        this._setState(SelectionHighlighter._createState(this.state, this._isEnabled, this.editor));\n    }\n    static _createState(oldState, isEnabled, editor) {\n        if (!isEnabled) {\n            return null;\n        }\n        if (!editor.hasModel()) {\n            return null;\n        }\n        const s = editor.getSelection();\n        if (s.startLineNumber !== s.endLineNumber) {\n            // multiline forbidden for perf reasons\n            return null;\n        }\n        const multiCursorController = MultiCursorSelectionController.get(editor);\n        if (!multiCursorController) {\n            return null;\n        }\n        const findController = CommonFindController.get(editor);\n        if (!findController) {\n            return null;\n        }\n        let r = multiCursorController.getSession(findController);\n        if (!r) {\n            const allSelections = editor.getSelections();\n            if (allSelections.length > 1) {\n                const findState = findController.getState();\n                const matchCase = findState.matchCase;\n                const selectionsContainSameText = modelRangesContainSameText(editor.getModel(), allSelections, matchCase);\n                if (!selectionsContainSameText) {\n                    return null;\n                }\n            }\n            r = MultiCursorSession.create(editor, findController);\n        }\n        if (!r) {\n            return null;\n        }\n        if (r.currentMatch) {\n            // This is an empty selection\n            // Do not interfere with semantic word highlighting in the no selection case\n            return null;\n        }\n        if (/^[ \\t]+$/.test(r.searchText)) {\n            // whitespace only selection\n            return null;\n        }\n        if (r.searchText.length > 200) {\n            // very long selection\n            return null;\n        }\n        // TODO: better handling of this case\n        const findState = findController.getState();\n        const caseSensitive = findState.matchCase;\n        // Return early if the find widget shows the exact same matches\n        if (findState.isRevealed) {\n            let findStateSearchString = findState.searchString;\n            if (!caseSensitive) {\n                findStateSearchString = findStateSearchString.toLowerCase();\n            }\n            let mySearchString = r.searchText;\n            if (!caseSensitive) {\n                mySearchString = mySearchString.toLowerCase();\n            }\n            if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {\n                return null;\n            }\n        }\n        return new SelectionHighlighterState(editor.getModel(), r.searchText, r.matchCase, r.wholeWord ? editor.getOption(119 /* EditorOption.wordSeparators */) : null, oldState);\n    }\n    _setState(newState) {\n        this.state = newState;\n        if (!this.state) {\n            this._decorations.clear();\n            return;\n        }\n        if (!this.editor.hasModel()) {\n            return;\n        }\n        const model = this.editor.getModel();\n        if (model.isTooLargeForTokenization()) {\n            // the file is too large, so searching word under cursor in the whole document would be blocking the UI.\n            return;\n        }\n        const allMatches = this.state.findMatches();\n        const selections = this.editor.getSelections();\n        selections.sort(Range.compareRangesUsingStarts);\n        // do not overlap with selection (issue #64 and #512)\n        const matches = [];\n        for (let i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len;) {\n            const match = allMatches[i];\n            if (j >= lenJ) {\n                // finished all editor selections\n                matches.push(match);\n                i++;\n            }\n            else {\n                const cmp = Range.compareRangesUsingStarts(match, selections[j]);\n                if (cmp < 0) {\n                    // match is before sel\n                    if (selections[j].isEmpty() || !Range.areIntersecting(match, selections[j])) {\n                        matches.push(match);\n                    }\n                    i++;\n                }\n                else if (cmp > 0) {\n                    // sel is before match\n                    j++;\n                }\n                else {\n                    // sel is equal to match\n                    i++;\n                    j++;\n                }\n            }\n        }\n        const hasFindOccurrences = this._languageFeaturesService.documentHighlightProvider.has(model) && this.editor.getOption(74 /* EditorOption.occurrencesHighlight */);\n        const decorations = matches.map(r => {\n            return {\n                range: r,\n                // Show in overviewRuler only if model has no semantic highlighting\n                options: (hasFindOccurrences ? SelectionHighlighter._SELECTION_HIGHLIGHT : SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW)\n            };\n        });\n        this._decorations.set(decorations);\n    }\n    dispose() {\n        this._setState(null);\n        super.dispose();\n    }\n};\nSelectionHighlighter.ID = 'editor.contrib.selectionHighlighter';\nSelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW = ModelDecorationOptions.register({\n    description: 'selection-highlight-overview',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n    className: 'selectionHighlight',\n    minimap: {\n        color: themeColorFromId(minimapSelectionOccurrenceHighlight),\n        position: MinimapPosition.Inline\n    },\n    overviewRuler: {\n        color: themeColorFromId(overviewRulerSelectionHighlightForeground),\n        position: OverviewRulerLane.Center\n    }\n});\nSelectionHighlighter._SELECTION_HIGHLIGHT = ModelDecorationOptions.register({\n    description: 'selection-highlight',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n    className: 'selectionHighlight',\n});\nSelectionHighlighter = __decorate([\n    __param(1, ILanguageFeaturesService)\n], SelectionHighlighter);\nexport { SelectionHighlighter };\nfunction modelRangesContainSameText(model, ranges, matchCase) {\n    const selectedText = getValueInRange(model, ranges[0], !matchCase);\n    for (let i = 1, len = ranges.length; i < len; i++) {\n        const range = ranges[i];\n        if (range.isEmpty()) {\n            return false;\n        }\n        const thisSelectedText = getValueInRange(model, range, !matchCase);\n        if (selectedText !== thisSelectedText) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getValueInRange(model, range, toLowerCase) {\n    const text = model.getValueInRange(range);\n    return (toLowerCase ? text.toLowerCase() : text);\n}\nexport class FocusNextCursor extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.focusNextCursor',\n            label: nls.localize('mutlicursor.focusNextCursor', \"Focus Next Cursor\"),\n            description: {\n                description: nls.localize('mutlicursor.focusNextCursor.description', \"Focuses the next cursor\"),\n                args: [],\n            },\n            alias: 'Focus Next Cursor',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor, args) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const viewModel = editor._getViewModel();\n        if (viewModel.cursorConfig.readOnly) {\n            return;\n        }\n        viewModel.model.pushStackElement();\n        const previousCursorState = Array.from(viewModel.getCursorStates());\n        const firstCursor = previousCursorState.shift();\n        if (!firstCursor) {\n            return;\n        }\n        previousCursorState.push(firstCursor);\n        viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, previousCursorState);\n        viewModel.revealPrimaryCursor(args.source, true);\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nexport class FocusPreviousCursor extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.focusPreviousCursor',\n            label: nls.localize('mutlicursor.focusPreviousCursor', \"Focus Previous Cursor\"),\n            description: {\n                description: nls.localize('mutlicursor.focusPreviousCursor.description', \"Focuses the previous cursor\"),\n                args: [],\n            },\n            alias: 'Focus Previous Cursor',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor, args) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const viewModel = editor._getViewModel();\n        if (viewModel.cursorConfig.readOnly) {\n            return;\n        }\n        viewModel.model.pushStackElement();\n        const previousCursorState = Array.from(viewModel.getCursorStates());\n        const firstCursor = previousCursorState.pop();\n        if (!firstCursor) {\n            return;\n        }\n        previousCursorState.unshift(firstCursor);\n        viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, previousCursorState);\n        viewModel.revealPrimaryCursor(args.source, true);\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nregisterEditorContribution(MultiCursorSelectionController.ID, MultiCursorSelectionController);\nregisterEditorContribution(SelectionHighlighter.ID, SelectionHighlighter);\nregisterEditorAction(InsertCursorAbove);\nregisterEditorAction(InsertCursorBelow);\nregisterEditorAction(InsertCursorAtEndOfEachLineSelected);\nregisterEditorAction(AddSelectionToNextFindMatchAction);\nregisterEditorAction(AddSelectionToPreviousFindMatchAction);\nregisterEditorAction(MoveSelectionToNextFindMatchAction);\nregisterEditorAction(MoveSelectionToPreviousFindMatchAction);\nregisterEditorAction(SelectHighlightsAction);\nregisterEditorAction(CompatChangeAll);\nregisterEditorAction(InsertCursorAtEndOfLineSelected);\nregisterEditorAction(InsertCursorAtTopOfLineSelected);\nregisterEditorAction(FocusNextCursor);\nregisterEditorAction(FocusPreviousCursor);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport { IdleValue, raceCancellation } from '../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { EditorAction, EditorCommand, registerEditorAction, registerEditorCommand, registerEditorContribution, registerModelAndPositionCommand } from '../../../browser/editorExtensions.js';\nimport { IBulkEditService, ResourceEdit } from '../../../browser/services/bulkEditService.js';\nimport { ICodeEditorService } from '../../../browser/services/codeEditorService.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { ITextResourceConfigurationService } from '../../../common/services/textResourceConfiguration.js';\nimport { MessageController } from '../../message/browser/messageController.js';\nimport * as nls from '../../../../nls.js';\nimport { Extensions } from '../../../../platform/configuration/common/configurationRegistry.js';\nimport { ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nimport { IEditorProgressService } from '../../../../platform/progress/common/progress.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { CONTEXT_RENAME_INPUT_VISIBLE, RenameInputField } from './renameInputField.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nclass RenameSkeleton {\n    constructor(model, position, registry) {\n        this.model = model;\n        this.position = position;\n        this._providerRenameIdx = 0;\n        this._providers = registry.ordered(model);\n    }\n    hasProvider() {\n        return this._providers.length > 0;\n    }\n    resolveRenameLocation(token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const rejects = [];\n            for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {\n                const provider = this._providers[this._providerRenameIdx];\n                if (!provider.resolveRenameLocation) {\n                    break;\n                }\n                const res = yield provider.resolveRenameLocation(this.model, this.position, token);\n                if (!res) {\n                    continue;\n                }\n                if (res.rejectReason) {\n                    rejects.push(res.rejectReason);\n                    continue;\n                }\n                return res;\n            }\n            const word = this.model.getWordAtPosition(this.position);\n            if (!word) {\n                return {\n                    range: Range.fromPositions(this.position),\n                    text: '',\n                    rejectReason: rejects.length > 0 ? rejects.join('\\n') : undefined\n                };\n            }\n            return {\n                range: new Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),\n                text: word.word,\n                rejectReason: rejects.length > 0 ? rejects.join('\\n') : undefined\n            };\n        });\n    }\n    provideRenameEdits(newName, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);\n        });\n    }\n    _provideRenameEdits(newName, i, rejects, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this._providers[i];\n            if (!provider) {\n                return {\n                    edits: [],\n                    rejectReason: rejects.join('\\n')\n                };\n            }\n            const result = yield provider.provideRenameEdits(this.model, this.position, newName, token);\n            if (!result) {\n                return this._provideRenameEdits(newName, i + 1, rejects.concat(nls.localize('no result', \"No result.\")), token);\n            }\n            else if (result.rejectReason) {\n                return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);\n            }\n            return result;\n        });\n    }\n}\nexport function rename(registry, model, position, newName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const skeleton = new RenameSkeleton(model, position, registry);\n        const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);\n        if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {\n            return { edits: [], rejectReason: loc.rejectReason };\n        }\n        return skeleton.provideRenameEdits(newName, CancellationToken.None);\n    });\n}\n// ---  register actions and commands\nlet RenameController = class RenameController {\n    constructor(editor, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService, _languageFeaturesService) {\n        this.editor = editor;\n        this._instaService = _instaService;\n        this._notificationService = _notificationService;\n        this._bulkEditService = _bulkEditService;\n        this._progressService = _progressService;\n        this._logService = _logService;\n        this._configService = _configService;\n        this._languageFeaturesService = _languageFeaturesService;\n        this._disposableStore = new DisposableStore();\n        this._cts = new CancellationTokenSource();\n        this._renameInputField = this._disposableStore.add(new IdleValue(() => this._disposableStore.add(this._instaService.createInstance(RenameInputField, this.editor, ['acceptRenameInput', 'acceptRenameInputWithPreview']))));\n    }\n    static get(editor) {\n        return editor.getContribution(RenameController.ID);\n    }\n    dispose() {\n        this._disposableStore.dispose();\n        this._cts.dispose(true);\n    }\n    run() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            this._cts.dispose(true);\n            if (!this.editor.hasModel()) {\n                return undefined;\n            }\n            const position = this.editor.getPosition();\n            const skeleton = new RenameSkeleton(this.editor.getModel(), position, this._languageFeaturesService.renameProvider);\n            if (!skeleton.hasProvider()) {\n                return undefined;\n            }\n            this._cts = new EditorStateCancellationTokenSource(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */);\n            // resolve rename location\n            let loc;\n            try {\n                const resolveLocationOperation = skeleton.resolveRenameLocation(this._cts.token);\n                this._progressService.showWhile(resolveLocationOperation, 250);\n                loc = yield resolveLocationOperation;\n            }\n            catch (e) {\n                (_a = MessageController.get(this.editor)) === null || _a === void 0 ? void 0 : _a.showMessage(e || nls.localize('resolveRenameLocationFailed', \"An unknown error occurred while resolving rename location\"), position);\n                return undefined;\n            }\n            if (!loc) {\n                return undefined;\n            }\n            if (loc.rejectReason) {\n                (_b = MessageController.get(this.editor)) === null || _b === void 0 ? void 0 : _b.showMessage(loc.rejectReason, position);\n                return undefined;\n            }\n            if (this._cts.token.isCancellationRequested) {\n                return undefined;\n            }\n            this._cts.dispose();\n            this._cts = new EditorStateCancellationTokenSource(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */, loc.range);\n            // do rename at location\n            const selection = this.editor.getSelection();\n            let selectionStart = 0;\n            let selectionEnd = loc.text.length;\n            if (!Range.isEmpty(selection) && !Range.spansMultipleLines(selection) && Range.containsRange(loc.range, selection)) {\n                selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);\n                selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;\n            }\n            const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, 'editor.rename.enablePreview');\n            const inputFieldResult = yield this._renameInputField.value.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, this._cts.token);\n            // no result, only hint to focus the editor or not\n            if (typeof inputFieldResult === 'boolean') {\n                if (inputFieldResult) {\n                    this.editor.focus();\n                }\n                return undefined;\n            }\n            this.editor.focus();\n            const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, this._cts.token), this._cts.token).then((renameResult) => __awaiter(this, void 0, void 0, function* () {\n                if (!renameResult || !this.editor.hasModel()) {\n                    return;\n                }\n                if (renameResult.rejectReason) {\n                    this._notificationService.info(renameResult.rejectReason);\n                    return;\n                }\n                // collapse selection to active end\n                this.editor.setSelection(Range.fromPositions(this.editor.getSelection().getPosition()));\n                this._bulkEditService.apply(ResourceEdit.convert(renameResult), {\n                    editor: this.editor,\n                    showPreview: inputFieldResult.wantsPreview,\n                    label: nls.localize('label', \"Renaming '{0}' to '{1}'\", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),\n                    code: 'undoredo.rename',\n                    quotableLabel: nls.localize('quotableLabel', \"Renaming {0} to {1}\", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),\n                    respectAutoSaveConfig: true\n                }).then(result => {\n                    if (result.ariaSummary) {\n                        alert(nls.localize('aria', \"Successfully renamed '{0}' to '{1}'. Summary: {2}\", loc.text, inputFieldResult.newName, result.ariaSummary));\n                    }\n                }).catch(err => {\n                    this._notificationService.error(nls.localize('rename.failedApply', \"Rename failed to apply edits\"));\n                    this._logService.error(err);\n                });\n            }), err => {\n                this._notificationService.error(nls.localize('rename.failed', \"Rename failed to compute edits\"));\n                this._logService.error(err);\n            });\n            this._progressService.showWhile(renameOperation, 250);\n            return renameOperation;\n        });\n    }\n    acceptRenameInput(wantsPreview) {\n        this._renameInputField.value.acceptInput(wantsPreview);\n    }\n    cancelRenameInput() {\n        this._renameInputField.value.cancelInput(true);\n    }\n};\nRenameController.ID = 'editor.contrib.renameController';\nRenameController = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, INotificationService),\n    __param(3, IBulkEditService),\n    __param(4, IEditorProgressService),\n    __param(5, ILogService),\n    __param(6, ITextResourceConfigurationService),\n    __param(7, ILanguageFeaturesService)\n], RenameController);\n// ---- action implementation\nexport class RenameAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.rename',\n            label: nls.localize('rename.label', \"Rename Symbol\"),\n            alias: 'Rename Symbol',\n            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 60 /* KeyCode.F2 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            contextMenuOpts: {\n                group: '1_modification',\n                order: 1.1\n            }\n        });\n    }\n    runCommand(accessor, args) {\n        const editorService = accessor.get(ICodeEditorService);\n        const [uri, pos] = Array.isArray(args) && args || [undefined, undefined];\n        if (URI.isUri(uri) && Position.isIPosition(pos)) {\n            return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then(editor => {\n                if (!editor) {\n                    return;\n                }\n                editor.setPosition(pos);\n                editor.invokeWithinContext(accessor => {\n                    this.reportTelemetry(accessor, editor);\n                    return this.run(accessor, editor);\n                });\n            }, onUnexpectedError);\n        }\n        return super.runCommand(accessor, args);\n    }\n    run(accessor, editor) {\n        const controller = RenameController.get(editor);\n        if (controller) {\n            return controller.run();\n        }\n        return Promise.resolve();\n    }\n}\nregisterEditorContribution(RenameController.ID, RenameController);\nregisterEditorAction(RenameAction);\nconst RenameCommand = EditorCommand.bindToContribution(RenameController.get);\nregisterEditorCommand(new RenameCommand({\n    id: 'acceptRenameInput',\n    precondition: CONTEXT_RENAME_INPUT_VISIBLE,\n    handler: x => x.acceptRenameInput(false),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 99,\n        kbExpr: EditorContextKeys.focus,\n        primary: 3 /* KeyCode.Enter */\n    }\n}));\nregisterEditorCommand(new RenameCommand({\n    id: 'acceptRenameInputWithPreview',\n    precondition: ContextKeyExpr.and(CONTEXT_RENAME_INPUT_VISIBLE, ContextKeyExpr.has('config.editor.rename.enablePreview')),\n    handler: x => x.acceptRenameInput(true),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 99,\n        kbExpr: EditorContextKeys.focus,\n        primary: 1024 /* KeyMod.Shift */ + 3 /* KeyCode.Enter */\n    }\n}));\nregisterEditorCommand(new RenameCommand({\n    id: 'cancelRenameInput',\n    precondition: CONTEXT_RENAME_INPUT_VISIBLE,\n    handler: x => x.cancelRenameInput(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 99,\n        kbExpr: EditorContextKeys.focus,\n        primary: 9 /* KeyCode.Escape */,\n        secondary: [1024 /* KeyMod.Shift */ | 9 /* KeyCode.Escape */]\n    }\n}));\n// ---- api bridge command\nregisterModelAndPositionCommand('_executeDocumentRenameProvider', function (accessor, model, position, ...args) {\n    const [newName] = args;\n    assertType(typeof newName === 'string');\n    const { renameProvider } = accessor.get(ILanguageFeaturesService);\n    return rename(renameProvider, model, position, newName);\n});\nregisterModelAndPositionCommand('_executePrepareRename', function (accessor, model, position) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { renameProvider } = accessor.get(ILanguageFeaturesService);\n        const skeleton = new RenameSkeleton(model, position, renameProvider);\n        const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);\n        if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {\n            throw new Error(loc.rejectReason);\n        }\n        return loc;\n    });\n});\n//todo@jrieken use editor options world\nRegistry.as(Extensions.Configuration).registerConfiguration({\n    id: 'editor',\n    properties: {\n        'editor.rename.enablePreview': {\n            scope: 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */,\n            description: nls.localize('enablePreview', \"Enable/disable the ability to preview changes before renaming\"),\n            default: true,\n            type: 'boolean'\n        }\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport './accessibilityHelp.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { renderFormattedText } from '../../../../base/browser/formattedTextRenderer.js';\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport { Widget } from '../../../../base/browser/ui/widget.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorAction, EditorCommand, registerEditorAction, registerEditorCommand, registerEditorContribution } from '../../../browser/editorExtensions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { ToggleTabFocusModeAction } from '../../../contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';\nimport { IOpenerService } from '../../../../platform/opener/common/opener.js';\nimport { contrastBorder, editorWidgetBackground, widgetShadow, editorWidgetForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { AccessibilityHelpNLS } from '../../../common/standaloneStrings.js';\nconst CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE = new RawContextKey('accessibilityHelpWidgetVisible', false);\nlet AccessibilityHelpController = class AccessibilityHelpController extends Disposable {\n    constructor(editor, instantiationService) {\n        super();\n        this._editor = editor;\n        this._widget = this._register(instantiationService.createInstance(AccessibilityHelpWidget, this._editor));\n    }\n    static get(editor) {\n        return editor.getContribution(AccessibilityHelpController.ID);\n    }\n    show() {\n        this._widget.show();\n    }\n    hide() {\n        this._widget.hide();\n    }\n};\nAccessibilityHelpController.ID = 'editor.contrib.accessibilityHelpController';\nAccessibilityHelpController = __decorate([\n    __param(1, IInstantiationService)\n], AccessibilityHelpController);\nfunction getSelectionLabel(selections, charactersSelected) {\n    if (!selections || selections.length === 0) {\n        return AccessibilityHelpNLS.noSelection;\n    }\n    if (selections.length === 1) {\n        if (charactersSelected) {\n            return strings.format(AccessibilityHelpNLS.singleSelectionRange, selections[0].positionLineNumber, selections[0].positionColumn, charactersSelected);\n        }\n        return strings.format(AccessibilityHelpNLS.singleSelection, selections[0].positionLineNumber, selections[0].positionColumn);\n    }\n    if (charactersSelected) {\n        return strings.format(AccessibilityHelpNLS.multiSelectionRange, selections.length, charactersSelected);\n    }\n    if (selections.length > 0) {\n        return strings.format(AccessibilityHelpNLS.multiSelection, selections.length);\n    }\n    return '';\n}\nlet AccessibilityHelpWidget = class AccessibilityHelpWidget extends Widget {\n    constructor(editor, _contextKeyService, _keybindingService, _openerService) {\n        super();\n        this._contextKeyService = _contextKeyService;\n        this._keybindingService = _keybindingService;\n        this._openerService = _openerService;\n        this._editor = editor;\n        this._isVisibleKey = CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE.bindTo(this._contextKeyService);\n        this._domNode = createFastDomNode(document.createElement('div'));\n        this._domNode.setClassName('accessibilityHelpWidget');\n        this._domNode.setDisplay('none');\n        this._domNode.setAttribute('role', 'dialog');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._contentDomNode = createFastDomNode(document.createElement('div'));\n        this._contentDomNode.setAttribute('role', 'document');\n        this._domNode.appendChild(this._contentDomNode);\n        this._isVisible = false;\n        this._register(this._editor.onDidLayoutChange(() => {\n            if (this._isVisible) {\n                this._layout();\n            }\n        }));\n        // Intentionally not configurable!\n        this._register(dom.addStandardDisposableListener(this._contentDomNode.domNode, 'keydown', (e) => {\n            if (!this._isVisible) {\n                return;\n            }\n            if (e.equals(2048 /* KeyMod.CtrlCmd */ | 35 /* KeyCode.KeyE */)) {\n                alert(AccessibilityHelpNLS.emergencyConfOn);\n                this._editor.updateOptions({\n                    accessibilitySupport: 'on'\n                });\n                dom.clearNode(this._contentDomNode.domNode);\n                this._buildContent();\n                this._contentDomNode.domNode.focus();\n                e.preventDefault();\n                e.stopPropagation();\n            }\n            if (e.equals(2048 /* KeyMod.CtrlCmd */ | 38 /* KeyCode.KeyH */)) {\n                alert(AccessibilityHelpNLS.openingDocs);\n                let url = this._editor.getRawOptions().accessibilityHelpUrl;\n                if (typeof url === 'undefined') {\n                    url = 'https://go.microsoft.com/fwlink/?linkid=852450';\n                }\n                this._openerService.open(URI.parse(url));\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }));\n        this.onblur(this._contentDomNode.domNode, () => {\n            this.hide();\n        });\n        this._editor.addOverlayWidget(this);\n    }\n    dispose() {\n        this._editor.removeOverlayWidget(this);\n        super.dispose();\n    }\n    getId() {\n        return AccessibilityHelpWidget.ID;\n    }\n    getDomNode() {\n        return this._domNode.domNode;\n    }\n    getPosition() {\n        return {\n            preference: null\n        };\n    }\n    show() {\n        if (this._isVisible) {\n            return;\n        }\n        this._isVisible = true;\n        this._isVisibleKey.set(true);\n        this._layout();\n        this._domNode.setDisplay('block');\n        this._domNode.setAttribute('aria-hidden', 'false');\n        this._contentDomNode.domNode.tabIndex = 0;\n        this._buildContent();\n        this._contentDomNode.domNode.focus();\n    }\n    _descriptionForCommand(commandId, msg, noKbMsg) {\n        const kb = this._keybindingService.lookupKeybinding(commandId);\n        if (kb) {\n            return strings.format(msg, kb.getAriaLabel());\n        }\n        return strings.format(noKbMsg, commandId);\n    }\n    _buildContent() {\n        const options = this._editor.getOptions();\n        const selections = this._editor.getSelections();\n        let charactersSelected = 0;\n        if (selections) {\n            const model = this._editor.getModel();\n            if (model) {\n                selections.forEach((selection) => {\n                    charactersSelected += model.getValueLengthInRange(selection);\n                });\n            }\n        }\n        let text = getSelectionLabel(selections, charactersSelected);\n        if (options.get(56 /* EditorOption.inDiffEditor */)) {\n            if (options.get(83 /* EditorOption.readOnly */)) {\n                text += AccessibilityHelpNLS.readonlyDiffEditor;\n            }\n            else {\n                text += AccessibilityHelpNLS.editableDiffEditor;\n            }\n        }\n        else {\n            if (options.get(83 /* EditorOption.readOnly */)) {\n                text += AccessibilityHelpNLS.readonlyEditor;\n            }\n            else {\n                text += AccessibilityHelpNLS.editableEditor;\n            }\n        }\n        const turnOnMessage = (platform.isMacintosh\n            ? AccessibilityHelpNLS.changeConfigToOnMac\n            : AccessibilityHelpNLS.changeConfigToOnWinLinux);\n        switch (options.get(2 /* EditorOption.accessibilitySupport */)) {\n            case 0 /* AccessibilitySupport.Unknown */:\n                text += '\\n\\n - ' + turnOnMessage;\n                break;\n            case 2 /* AccessibilitySupport.Enabled */:\n                text += '\\n\\n - ' + AccessibilityHelpNLS.auto_on;\n                break;\n            case 1 /* AccessibilitySupport.Disabled */:\n                text += '\\n\\n - ' + AccessibilityHelpNLS.auto_off;\n                text += ' ' + turnOnMessage;\n                break;\n        }\n        if (options.get(132 /* EditorOption.tabFocusMode */)) {\n            text += '\\n\\n - ' + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOnMsg, AccessibilityHelpNLS.tabFocusModeOnMsgNoKb);\n        }\n        else {\n            text += '\\n\\n - ' + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOffMsg, AccessibilityHelpNLS.tabFocusModeOffMsgNoKb);\n        }\n        const openDocMessage = (platform.isMacintosh\n            ? AccessibilityHelpNLS.openDocMac\n            : AccessibilityHelpNLS.openDocWinLinux);\n        text += '\\n\\n - ' + openDocMessage;\n        text += '\\n\\n' + AccessibilityHelpNLS.outroMsg;\n        this._contentDomNode.domNode.appendChild(renderFormattedText(text));\n        // Per https://www.w3.org/TR/wai-aria/roles#document, Authors SHOULD provide a title or label for documents\n        this._contentDomNode.domNode.setAttribute('aria-label', text);\n    }\n    hide() {\n        if (!this._isVisible) {\n            return;\n        }\n        this._isVisible = false;\n        this._isVisibleKey.reset();\n        this._domNode.setDisplay('none');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._contentDomNode.domNode.tabIndex = -1;\n        dom.clearNode(this._contentDomNode.domNode);\n        this._editor.focus();\n    }\n    _layout() {\n        const editorLayout = this._editor.getLayoutInfo();\n        const w = Math.max(5, Math.min(AccessibilityHelpWidget.WIDTH, editorLayout.width - 40));\n        const h = Math.max(5, Math.min(AccessibilityHelpWidget.HEIGHT, editorLayout.height - 40));\n        this._domNode.setWidth(w);\n        this._domNode.setHeight(h);\n        const top = Math.round((editorLayout.height - h) / 2);\n        this._domNode.setTop(top);\n        const left = Math.round((editorLayout.width - w) / 2);\n        this._domNode.setLeft(left);\n    }\n};\nAccessibilityHelpWidget.ID = 'editor.contrib.accessibilityHelpWidget';\nAccessibilityHelpWidget.WIDTH = 500;\nAccessibilityHelpWidget.HEIGHT = 300;\nAccessibilityHelpWidget = __decorate([\n    __param(1, IContextKeyService),\n    __param(2, IKeybindingService),\n    __param(3, IOpenerService)\n], AccessibilityHelpWidget);\nclass ShowAccessibilityHelpAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.showAccessibilityHelp',\n            label: AccessibilityHelpNLS.showAccessibilityHelpAction,\n            alias: 'Show Accessibility Help',\n            precondition: undefined,\n            kbOpts: {\n                primary: 512 /* KeyMod.Alt */ | 59 /* KeyCode.F1 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */,\n                linux: {\n                    primary: 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 59 /* KeyCode.F1 */,\n                    secondary: [512 /* KeyMod.Alt */ | 59 /* KeyCode.F1 */]\n                }\n            }\n        });\n    }\n    run(accessor, editor) {\n        const controller = AccessibilityHelpController.get(editor);\n        if (controller) {\n            controller.show();\n        }\n    }\n}\nregisterEditorContribution(AccessibilityHelpController.ID, AccessibilityHelpController);\nregisterEditorAction(ShowAccessibilityHelpAction);\nconst AccessibilityHelpCommand = EditorCommand.bindToContribution(AccessibilityHelpController.get);\nregisterEditorCommand(new AccessibilityHelpCommand({\n    id: 'closeAccessibilityHelp',\n    precondition: CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE,\n    handler: x => x.hide(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 100,\n        kbExpr: EditorContextKeys.focus,\n        primary: 9 /* KeyCode.Escape */,\n        secondary: [1024 /* KeyMod.Shift */ | 9 /* KeyCode.Escape */]\n    }\n}));\nregisterThemingParticipant((theme, collector) => {\n    const widgetBackground = theme.getColor(editorWidgetBackground);\n    if (widgetBackground) {\n        collector.addRule(`.monaco-editor .accessibilityHelpWidget { background-color: ${widgetBackground}; }`);\n    }\n    const widgetForeground = theme.getColor(editorWidgetForeground);\n    if (widgetForeground) {\n        collector.addRule(`.monaco-editor .accessibilityHelpWidget { color: ${widgetForeground}; }`);\n    }\n    const widgetShadowColor = theme.getColor(widgetShadow);\n    if (widgetShadowColor) {\n        collector.addRule(`.monaco-editor .accessibilityHelpWidget { box-shadow: 0 2px 8px ${widgetShadowColor}; }`);\n    }\n    const hcBorder = theme.getColor(contrastBorder);\n    if (hcBorder) {\n        collector.addRule(`.monaco-editor .accessibilityHelpWidget { border: 2px solid ${hcBorder}; }`);\n    }\n});\n"],"file":"assets/index.0d915e4d.js"}